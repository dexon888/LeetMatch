[
    {
        "problem_name": "01-matrix",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n# dp solution\nclass Solution(object):\n    def updateMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[i])):\n                if not matrix[i][j]:\n                    continue\n                matrix[i][j] = float(\"inf\")\n                if i > 0:\n                    matrix[i][j] = min(matrix[i][j], matrix[i-1][j]+1)\n                if j > 0:\n                    matrix[i][j] = min(matrix[i][j], matrix[i][j-1]+1)\n        for i in reversed(xrange(len(matrix))):\n            for j in reversed(xrange(len(matrix[i]))):\n                if not matrix[i][j]:\n                    continue\n                if i < len(matrix)-1:\n                    matrix[i][j] = min(matrix[i][j], matrix[i+1][j]+1)\n                if j < len(matrix[i])-1:\n                    matrix[i][j] = min(matrix[i][j], matrix[i][j+1]+1)\n        return matrix\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\n# dp solution\nclass Solution2(object):\n    def updateMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        dp = [[float(\"inf\")]*len(matrix[0]) for _ in xrange(len(matrix))]\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[i])):\n                if matrix[i][j] == 0:\n                    dp[i][j] = 0\n                else:\n                    if i > 0:\n                        dp[i][j] = min(dp[i][j], dp[i-1][j]+1)\n                    if j > 0:\n                        dp[i][j] = min(dp[i][j], dp[i][j-1]+1)\n        for i in reversed(xrange(len(matrix))):\n            for j in reversed(xrange(len(matrix[i]))):\n                if matrix[i][j] == 0:\n                    dp[i][j] = 0\n                else:\n                    if i < len(matrix)-1:\n                        dp[i][j] = min(dp[i][j], dp[i+1][j]+1)\n                    if j < len(matrix[i])-1:\n                        dp[i][j] = min(dp[i][j], dp[i][j+1]+1)\n        return dp\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\nimport collections\n\n\nclass Solution3(object):\n    def updateMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        queue = collections.deque()\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    queue.append((i, j))\n                else:\n                    matrix[i][j] = float(\"inf\")\n\n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        while queue:\n            cell = queue.popleft()\n            for dir in dirs:\n                i, j = cell[0]+dir[0], cell[1]+dir[1]\n                if not (0 <= i < len(matrix) and\n                        0 <= j < len(matrix[0]) and\n                        matrix[i][j] > matrix[cell[0]][cell[1]]+1):\n                    continue\n                queue.append((i, j))\n                matrix[i][j] = matrix[cell[0]][cell[1]]+1\n\n        return matrix\n"
    },
    {
        "problem_name": "1-bit-and-2-bit-characters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n\nclass Solution(object):\n    def isOneBitCharacter(self, bits):\n        \"\"\"\n        :type bits: List[int]\n        :rtype: bool\n        \"\"\"\n        parity = 0\n        for i in reversed(xrange(len(bits)-1)):\n            if bits[i] == 0:\n                break\n            parity ^= bits[i]\n        return parity == 0\n\n"
    },
    {
        "problem_name": "132-pattern",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def find132pattern(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        ak = float(\"-inf\")\n        stk = []\n        for i in reversed(xrange(len(nums))):\n            if nums[i] < ak:\n                return True\n            while stk and stk[-1] < nums[i]:\n                ak = stk.pop()\n            stk.append(nums[i])\n        return False\n\n\n# Time:  O(n^2)\n# Space: O(1)\nclass Solution_TLE(object):\n    def find132pattern(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for k in xrange(len(nums)):\n            valid = False\n            for j in xrange(k):\n                if nums[j] < nums[k]:\n                    valid = True\n                elif nums[j] > nums[k]:\n                    if valid:\n                        return True\n        return False\n"
    },
    {
        "problem_name": "2-keys-keyboard",
        "solution": "# Time:  O(sqrt(n))\n# Space: O(1)\n\nclass Solution(object):\n    def minSteps(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        p = 2\n        # the answer is the sum of prime factors\n        while p**2 <= n:\n            while n % p == 0:\n                result += p\n                n //= p\n            p += 1\n        if n > 1:\n            result += n\n        return result\n\n"
    },
    {
        "problem_name": "24-game",
        "solution": "# Time:  O(n^3 * 4^n) = O(1), n = 4\n# Space: O(n^2) = O(1)\n\nfrom operator import add, sub, mul, truediv\nfrom fractions import Fraction\n\n\nclass Solution(object):\n    def judgePoint24(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) == 1:\n            return abs(nums[0]-24) < 1e-6\n        ops = [add, sub, mul, truediv]\n        for i in xrange(len(nums)):\n            for j in xrange(len(nums)):\n                if i == j:\n                    continue\n                next_nums = [nums[k] for k in xrange(len(nums)) if i != k != j]\n                for op in ops:\n                    if ((op is add or op is mul) and j > i) or \\\n                       (op == truediv and nums[j] == 0):\n                        continue\n                    next_nums.append(op(nums[i], nums[j]))\n                    if self.judgePoint24(next_nums):\n                        return True\n                    next_nums.pop()\n        return False\n\n\n# Time:  O(n^3 * 4^n) = O(1), n = 4\n# Space: O(n^2) = O(1)\nclass Solution2(object):\n    def judgePoint24(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def dfs(nums):\n            if len(nums) == 1:\n                return nums[0] == 24\n            ops = [add, sub, mul, truediv]\n            for i in xrange(len(nums)):\n                for j in xrange(len(nums)):\n                    if i == j:\n                        continue\n                    next_nums = [nums[k] for k in xrange(len(nums))\n                                 if i != k != j]\n                    for op in ops:\n                        if ((op is add or op is mul) and j > i) or \\\n                           (op == truediv and nums[j] == 0):\n                            continue\n                        next_nums.append(op(nums[i], nums[j]))\n                        if dfs(next_nums):\n                            return True\n                        next_nums.pop()\n            return False\n\n        return dfs(map(Fraction, nums))\n\n"
    },
    {
        "problem_name": "3sum-closest",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        result, min_diff = 0, float(\"inf\")\n        nums.sort()\n        for i in reversed(xrange(2, len(nums))):\n            if i+1 < len(nums) and nums[i] == nums[i+1]:\n                continue\n            left, right = 0, i-1\n            while left < right:\n                total = nums[left]+nums[right]+nums[i]\n                if total < target:\n                    left += 1\n                elif total > target:\n                    right -= 1\n                else:\n                    return target\n                if abs(total-target) < min_diff:\n                    min_diff = abs(total-target)\n                    result = total\n        return result\n\n"
    },
    {
        "problem_name": "3sum-smaller",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def threeSumSmaller(self, nums, target):\n        nums.sort()\n        n = len(nums)\n\n        count, k = 0, 2\n        while k < n:\n            i, j = 0, k - 1\n            while i < j:  # Two Pointers, linear time.\n                if nums[i] + nums[j] + nums[k] >= target:\n                    j -= 1\n                else:\n                    count += j - i\n                    i += 1\n            k += 1\n\n        return count\n\n"
    },
    {
        "problem_name": "3sum-with-multiplicity",
        "solution": "# Time:  O(n^2), n is the number of disctinct A[i]\n# Space: O(n)\n\nimport collections\nimport itertools\n\n\nclass Solution(object):\n    def threeSumMulti(self, A, target):\n        \"\"\"\n        :type A: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        count = collections.Counter(A)\n        result = 0\n        for i, j in itertools.combinations_with_replacement(count, 2):\n            k = target - i - j\n            if i == j == k:\n                result += count[i] * (count[i]-1) * (count[i]-2) // 6\n            elif i == j != k:\n                result += count[i] * (count[i]-1) // 2 * count[k]\n            elif max(i, j) < k:\n                result += count[i] * count[j] * count[k]\n        return result % (10**9 + 7)\n"
    },
    {
        "problem_name": "3sum",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        nums.sort()\n        for i in reversed(xrange(2, len(nums))):\n            if i+1 < len(nums) and nums[i] == nums[i+1]:\n                continue\n            target = -nums[i]\n            left, right = 0, i-1\n            while left < right:\n                if nums[left]+nums[right] < target:\n                    left += 1\n                elif nums[left]+nums[right] > target:\n                    right -= 1\n                else:\n                    result.append([nums[left], nums[right], nums[i]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(1)\nclass Solution2(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, i = sorted(nums), [], 0\n        while i < len(nums) - 2:\n            if i == 0 or nums[i] != nums[i - 1]:\n                j, k = i + 1, len(nums) - 1\n                while j < k:\n                    if nums[i] + nums[j] + nums[k] < 0:\n                        j += 1\n                    elif nums[i] + nums[j] + nums[k] > 0:\n                        k -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[k]])\n                        j, k = j + 1, k - 1\n                        while j < k and nums[j] == nums[j - 1]:\n                            j += 1\n                        while j < k and nums[k] == nums[k + 1]:\n                            k -= 1\n            i += 1\n        return result\n\n"
    },
    {
        "problem_name": "4-keys-keyboard",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n\nclass Solution(object):\n    def maxA(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        if N < 7:\n            return N\n        if N == 10:\n            return 20  # the following rule doesn't hold when N = 10\n\n        n = N // 5 + 1  # n3 + n4 increases one every 5 keys\n        # (1) n     =     n3 +     n4\n        # (2) N + 1 = 4 * n3 + 5 * n4\n        #     5 x (1) - (2) => 5*n - N - 1 = n3\n        n3 = 5*n - N - 1\n        n4 = n - n3\n        return 3**n3 * 4**n4\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def maxA(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        if N < 7:\n            return N\n        dp = range(N+1)\n        for i in xrange(7, N+1):\n            dp[i % 6] = max(dp[(i-4) % 6]*3, dp[(i-5) % 6]*4)\n        return dp[N % 6]\n\n"
    },
    {
        "problem_name": "4sum-ii",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nimport collections\n\n\nclass Solution(object):\n    def fourSumCount(self, A, B, C, D):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :type C: List[int]\n        :type D: List[int]\n        :rtype: int\n        \"\"\"\n        A_B_sum = collections.Counter(a+b for a in A for b in B)\n        return sum(A_B_sum[-c-d] for c in C for d in D)\n\n"
    },
    {
        "problem_name": "4sum",
        "solution": "# Time:  O(n^3)\n# Space: O(1)\n\nimport collections\n\n\n# Two pointer solution. (1356ms)\nclass Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = []\n        for i in xrange(len(nums) - 3):\n            if i and nums[i] == nums[i - 1]:\n                continue\n            for j in xrange(i + 1, len(nums) - 2):\n                if j != i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                total = target - nums[i] - nums[j]\n                left, right = j + 1, len(nums) - 1\n                while left < right:\n                    if nums[left] + nums[right] == total:\n                        result.append([nums[i], nums[j], nums[left], nums[right]])\n                        right -= 1\n                        left += 1\n                        while left < right and nums[left] == nums[left - 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right + 1]:\n                            right -= 1\n                    elif nums[left] + nums[right] > total:\n                        right -= 1\n                    else:\n                        left += 1\n        return result\n\n\n# Time:  O(n^2 * p)\n# Space: O(n^2 * p)\n# Hash solution. (224ms)\nclass Solution2(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, lookup = sorted(nums), [], collections.defaultdict(list)\n        for i in xrange(0, len(nums) - 1):\n            for j in xrange(i + 1, len(nums)):\n                is_duplicated = False\n                for [x, y] in lookup[nums[i] + nums[j]]:\n                    if nums[x] == nums[i]:\n                        is_duplicated = True\n                        break\n                if not is_duplicated:\n                    lookup[nums[i] + nums[j]].append([i, j])\n        ans = {}\n        for c in xrange(2, len(nums)):\n            for d in xrange(c+1, len(nums)):\n                if target - nums[c] - nums[d] in lookup:\n                    for [a, b] in lookup[target - nums[c] - nums[d]]:\n                        if b < c:\n                            quad = [nums[a], nums[b], nums[c], nums[d]]\n                            quad_hash = \" \".join(str(quad))\n                            if quad_hash not in ans:\n                                ans[quad_hash] = True\n                                result.append(quad)\n        return result\n\n\n# Time:  O(n^2 * p) ~ O(n^4)\n# Space: O(n^2)\nclass Solution3(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums, result, lookup = sorted(nums), [], collections.defaultdict(list)\n        for i in xrange(0, len(nums) - 1):\n            for j in xrange(i + 1, len(nums)):\n                lookup[nums[i] + nums[j]].append([i, j])\n\n        for i in lookup.keys():\n            if target - i in lookup:\n                for x in lookup[i]:\n                    for y in lookup[target - i]:\n                        [a, b], [c, d] = x, y\n                        if a is not c and a is not d and \\\n                           b is not c and b is not d:\n                            quad = sorted([nums[a], nums[b], nums[c], nums[d]])\n                            if quad not in result:\n                                result.append(quad)\n        return sorted(result)\n\n"
    },
    {
        "problem_name": "a-number-after-a-double-reversal",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def isSameAfterReversals(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        return num == 0 or num%10\n"
    },
    {
        "problem_name": "abbreviating-the-product-of-a-range",
        "solution": "# Time:  O(r - l)\n# Space: O(1)\n\nimport math\n\n\nclass Solution(object):\n    def abbreviateProduct(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: str\n        \"\"\"\n        PREFIX_LEN = SUFFIX_LEN = 5\n        MOD = 10**(PREFIX_LEN+SUFFIX_LEN)\n        curr, zeros = 1, 0\n        abbr = False\n        for i in xrange(left, right+1):\n            curr *= i\n            while not curr%10:\n                curr //= 10\n                zeros += 1\n            q, curr = divmod(curr, MOD)\n            if q:\n                abbr = True\n        if not abbr:\n            return \"%se%s\" % (curr, zeros)\n        decimal = reduce(lambda x, y: (x+y)%1, (math.log10(i) for i in xrange(left, right+1)))\n        prefix = str(int(10**(decimal+(PREFIX_LEN-1))))\n        suffix = str(curr % 10**SUFFIX_LEN).zfill(SUFFIX_LEN)\n        return \"%s...%se%s\" % (prefix, suffix, zeros)\n"
    },
    {
        "problem_name": "account-balance-after-rounded-purchase",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def accountBalanceAfterPurchase(self, purchaseAmount):\n        \"\"\"\n        :type purchaseAmount: int\n        :rtype: int\n        \"\"\"\n        return 100-(purchaseAmount+5)//10*10\n"
    },
    {
        "problem_name": "accounts-merge",
        "solution": "# Time:  O(nlogn), n is the number of total emails,\n#                  and the max length ofemail is 320, p.s. {64}@{255}\n# Space: O(n)\n\nimport collections\n\n\nclass UnionFind(object):\n    def __init__(self):\n        self.set = []\n\n    def get_id(self):\n        self.set.append(len(self.set))\n        return len(self.set)-1\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n\n\nclass Solution(object):\n    def accountsMerge(self, accounts):\n        \"\"\"\n        :type accounts: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n        union_find = UnionFind()\n        email_to_name = {}\n        email_to_id = {}\n        for account in accounts:\n            name = account[0]\n            for i in xrange(1, len(account)):\n                if account[i] not in email_to_id:\n                    email_to_name[account[i]] = name\n                    email_to_id[account[i]] = union_find.get_id()\n                union_find.union_set(email_to_id[account[1]],\n                                     email_to_id[account[i]])\n\n        result = collections.defaultdict(list)\n        for email in email_to_name.keys():\n            result[union_find.find_set(email_to_id[email])].append(email)\n        for emails in result.values():\n            emails.sort()\n        return [[email_to_name[emails[0]]] + emails\n                for emails in result.values()]\n\n"
    },
    {
        "problem_name": "add-and-search-word-data-structure-design",
        "solution": "# Time:  O(min(n, h)), per operation\n# Space: O(min(n, h))\n\nclass TrieNode(object):\n    # Initialize your data structure here.\n    def __init__(self):\n        self.is_string = False\n        self.leaves = {}\n\n\nclass WordDictionary(object):\n    def __init__(self):\n        self.root = TrieNode()\n\n    # @param {string} word\n    # @return {void}\n    # Adds a word into the data structure.\n    def addWord(self, word):\n        curr = self.root\n        for c in word:\n            if c not in curr.leaves:\n                curr.leaves[c] = TrieNode()\n            curr = curr.leaves[c]\n        curr.is_string = True\n\n    # @param {string} word\n    # @return {boolean}\n    # Returns if the word is in the data structure. A word could\n    # contain the dot character '.' to represent any one letter.\n    def search(self, word):\n        return self.searchHelper(word, 0, self.root)\n\n    def searchHelper(self, word, start, curr):\n        if start == len(word):\n            return curr.is_string\n        if word[start] in curr.leaves:\n            return self.searchHelper(word, start+1, curr.leaves[word[start]])\n        elif word[start] == '.':\n            for c in curr.leaves:\n                if self.searchHelper(word, start+1, curr.leaves[c]):\n                    return True\n\n        return False\n\n\n"
    },
    {
        "problem_name": "add-binary",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param a, a string\n    # @param b, a string\n    # @return a string\n    def addBinary(self, a, b):\n        result, carry, val = \"\", 0, 0\n        for i in xrange(max(len(a), len(b))):\n            val = carry\n            if i < len(a):\n                val += int(a[-(i + 1)])\n            if i < len(b):\n                val += int(b[-(i + 1)])\n            carry, val = divmod(val, 2)\n            result += str(val)\n        if carry:\n            result += str(carry)\n        return result[::-1]\n\n\n# Time:  O(n)\n# Space: O(1)\nfrom itertools import izip_longest\n\n\nclass Solution2(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        result = \"\"\n        carry = 0\n        for x, y in izip_longest(reversed(a), reversed(b), fillvalue=\"0\"):\n            carry, remainder = divmod(int(x)+int(y)+carry, 2)\n            result += str(remainder)\n        \n        if carry:\n            result += str(carry)\n        \n        return result[::-1]\n"
    },
    {
        "problem_name": "add-bold-tag-in-string",
        "solution": "# Time:  O(n * d * l), l is the average string length\n# Space: O(n)\n\nimport collections\nimport functools\n\n\n# 59ms\nclass Solution(object):\n    def addBoldTag(self, s, dict):\n        \"\"\"\n        :type s: str\n        :type dict: List[str]\n        :rtype: str\n        \"\"\"\n        lookup = [0] * len(s)\n        for d in dict:\n            pos = s.find(d)\n            while pos != -1:\n                lookup[pos:pos+len(d)] = [1] * len(d)\n                pos = s.find(d, pos + 1)\n\n        result = []\n        for i in xrange(len(s)):\n            if lookup[i] and (i == 0 or not lookup[i-1]):\n                result.append(\"<b>\")\n            result.append(s[i])\n            if lookup[i] and (i == len(s)-1 or not lookup[i+1]):\n                result.append(\"</b>\")\n        return \"\".join(result)\n\n\n# Time:  O(n * l), l is the average string length\n# Space: O(t)    , t is the size of trie\n# trie solution, 439ms\nclass Solution2(object):\n    def addBoldTag(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        for i, word in enumerate(words):\n            functools.reduce(dict.__getitem__, word, trie).setdefault(\"_end\")\n\n        lookup = [False] * len(s)\n        for i in xrange(len(s)):\n            curr = trie\n            k = -1\n            for j in xrange(i, len(s)):\n                if s[j] not in curr:\n                    break\n                curr = curr[s[j]]\n                if \"_end\" in curr:\n                    k = j\n            for j in xrange(i, k+1):\n                lookup[j] = True\n\n        result = []\n        for i in xrange(len(s)):\n            if lookup[i] and (i == 0 or not lookup[i-1]):\n                result.append(\"<b>\")\n            result.append(s[i])\n            if lookup[i] and (i == len(s)-1 or not lookup[i+1]):\n                result.append(\"</b>\")\n        return \"\".join(result)\n\n"
    },
    {
        "problem_name": "add-digits",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    \"\"\"\n    :type num: int\n    :rtype: int\n    \"\"\"\n    def addDigits(self, num):\n        return (num - 1) % 9 + 1 if num > 0 else 0\n\n"
    },
    {
        "problem_name": "add-edges-to-make-degrees-of-all-nodes-even",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# graph\nclass Solution(object):\n    def isPossible(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        adj = [set() for _ in xrange(n)]\n        for u, v in edges:\n            adj[u-1].add(v-1)\n            adj[v-1].add(u-1)\n        odds = [u for u in xrange(n) if len(adj[u])%2]\n        if len(odds) == 0:\n            return True\n        if len(odds) == 2:\n            return any(odds[0] not in adj[u] and odds[1] not in adj[u] for u in range(n))\n        if len(odds) == 4:\n            return ((odds[0] not in adj[odds[1]] and odds[2] not in adj[odds[3]]) or\n                    (odds[0] not in adj[odds[2]] and odds[1] not in adj[odds[3]]) or\n                    (odds[0] not in adj[odds[3]] and odds[1] not in adj[odds[2]]))\n        return False\n"
    },
    {
        "problem_name": "add-minimum-number-of-rungs",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def addRungs(self, rungs, dist):\n        \"\"\"\n        :type rungs: List[int]\n        :type dist: int\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+(b-1))//b\n\n        result = prev = 0\n        for curr in rungs:\n            result += ceil_divide(curr-prev, dist)-1\n            prev = curr\n        return result\n"
    },
    {
        "problem_name": "add-one-row-to-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def addOneRow(self, root, v, d):\n        \"\"\"\n        :type root: TreeNode\n        :type v: int\n        :type d: int\n        :rtype: TreeNode\n        \"\"\"\n        if d in (0, 1):\n            node = TreeNode(v)\n            if d == 1:\n                node.left = root\n            else:\n                node.right = root\n            return node\n        if root and d >= 2:\n            root.left = self.addOneRow(root.left,  v, d-1 if d > 2 else 1)\n            root.right = self.addOneRow(root.right, v, d-1 if d > 2 else 0)\n        return root\n\n"
    },
    {
        "problem_name": "add-strings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        result = []\n        i, j, carry = len(num1) - 1, len(num2) - 1, 0\n\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += ord(num1[i]) - ord('0')\n                i -= 1\n            if j >= 0:\n                carry += ord(num2[j]) - ord('0')\n                j -= 1\n            result.append(str(carry % 10))\n            carry /= 10\n        result.reverse()\n\n        return \"\".join(result)\n\n    def addStrings2(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        length = max(len(num1), len(num2))\n        num1 = num1.zfill(length)[::-1]\n        num2 = num2.zfill(length)[::-1]\n        res, plus = '', 0\n        for index, num in enumerate(num1):\n            tmp = str(int(num) + int(num2[index]) + plus)\n            res += tmp[-1]\n            if int(tmp) > 9:\n                plus = 1\n            else:\n                plus = 0\n        if plus:\n            res += '1'\n        return res[::-1]\n\n"
    },
    {
        "problem_name": "add-to-array-form-of-integer",
        "solution": "# Time:  O(n + logk)\n# Space: O(1)\n\nclass Solution(object):\n    def addToArrayForm(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: List[int]\n        \"\"\"\n        A.reverse()\n        carry, i = K, 0\n        A[i] += carry\n        carry, A[i] = divmod(A[i], 10)\n        while carry:\n            i += 1\n            if i < len(A):\n                A[i] += carry\n            else:\n                A.append(carry)\n            carry, A[i] = divmod(A[i], 10)\n        A.reverse()\n        return A\n"
    },
    {
        "problem_name": "add-two-integers",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def sum(self, num1, num2):\n        \"\"\"\n        :type num1: int\n        :type num2: int\n        :rtype: int\n        \"\"\"\n        return num1+num2\n"
    },
    {
        "problem_name": "add-two-numbers-ii",
        "solution": "# Time:  O(m + n)\n# Space: O(m + n)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        stk1, stk2 = [], []\n        while l1:\n            stk1.append(l1.val)\n            l1 = l1.next\n        while l2:\n            stk2.append(l2.val)\n            l2 = l2.next\n\n        prev, head = None, None\n        sum = 0\n        while stk1 or stk2:\n            sum /= 10\n            if stk1:\n                sum += stk1.pop()\n            if stk2:\n                sum += stk2.pop()\n\n            head = ListNode(sum % 10)\n            head.next = prev\n            prev = head\n\n        if sum >= 10:\n            head = ListNode(sum / 10)\n            head.next = prev\n\n        return head\n\n"
    },
    {
        "problem_name": "add-two-numbers",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        current, carry = dummy, 0\n\n        while l1 or l2:\n            val = carry\n            if l1:\n                val += l1.val\n                l1 = l1.next\n            if l2:\n                val += l2.val\n                l2 = l2.next\n            carry, val = divmod(val, 10)\n            current.next = ListNode(val)\n            current = current.next\n\n        if carry == 1:\n            current.next = ListNode(1)\n\n        return dummy.next\n\n"
    },
    {
        "problem_name": "add-two-polynomials-represented-as-linked-lists",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nclass PolyNode:\n    def __init__(self, x=0, y=0, next=None):\n        pass\n\n\nclass Solution:\n    def addPoly(self, poly1, poly2):\n        \"\"\"\n        :type poly1: PolyNode\n        :type poly2: PolyNode\n        :rtype: PolyNode\n        \"\"\"\n        curr = dummy = PolyNode()\n        while poly1 and poly2:\n            if poly1.power > poly2.power:\n                curr.next = poly1\n                curr = curr.next\n                poly1 = poly1.next\n            elif poly1.power < poly2.power:\n                curr.next = poly2\n                curr = curr.next\n                poly2 = poly2.next\n            else:\n                coef = poly1.coefficient+poly2.coefficient\n                if coef:\n                    curr.next = PolyNode(coef, poly1.power)\n                    curr = curr.next\n                poly1, poly2 = poly1.next, poly2.next\n        curr.next = poly1 or poly2\n        return dummy.next\n"
    },
    {
        "problem_name": "adding-spaces-to-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# inplace solution\nclass Solution(object):\n    def addSpaces(self, s, spaces):\n        \"\"\"\n        :type s: str\n        :type spaces: List[int]\n        :rtype: str\n        \"\"\"\n        prev = len(s)\n        s = list(s)\n        s.extend([None]*len(spaces))\n        for i in reversed(xrange(len(spaces))):\n            for j in reversed(xrange(spaces[i], prev)):\n                s[j+1+i] = s[j]\n            s[spaces[i]+i] = ' '\n            prev = spaces[i]\n        return \"\".join(s)\n"
    },
    {
        "problem_name": "adding-two-negabinary-numbers",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def addNegabinary(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        carry = 0\n        while arr1 or arr2 or carry:\n            if arr1:\n                carry += arr1.pop()\n            if arr2:\n                carry += arr2.pop()\n            result.append(carry & 1)\n            carry = -(carry >> 1)\n        while len(result) > 1 and result[-1] == 0:\n            result.pop()\n        result.reverse()\n        return result\n"
    },
    {
        "problem_name": "additive-number",
        "solution": "# Time:  O(n^3)\n# Space: O(n)\n\n\nclass Solution(object):\n    def isAdditiveNumber(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: bool\n        \"\"\"\n        def add(a, b):\n            res, carry, val = \"\", 0, 0\n            for i in xrange(max(len(a), len(b))):\n                val = carry\n                if i < len(a):\n                    val += int(a[-(i + 1)])\n                if i < len(b):\n                    val += int(b[-(i + 1)])\n                carry, val = val / 10, val % 10\n                res += str(val)\n            if carry:\n                res += str(carry)\n            return res[::-1]\n\n        for i in xrange(1, len(num)):\n            for j in xrange(i + 1, len(num)):\n                s1, s2 = num[0:i], num[i:j]\n                if (len(s1) > 1 and s1[0] == '0') or \\\n                   (len(s2) > 1 and s2[0] == '0'):\n                    continue\n\n                expected = add(s1, s2)\n                cur = s1 + s2 + expected\n                while len(cur) < len(num):\n                    s1, s2, expected = s2, expected, add(s2, expected)\n                    cur += expected\n                if cur == num:\n                    return True\n        return False\n\n"
    },
    {
        "problem_name": "advantage-shuffle",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def advantageCount(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: List[int]\n        \"\"\"\n        sortedA = sorted(A)\n        sortedB = sorted(B)\n\n        candidates = {b: [] for b in B}\n        others = []\n        j = 0\n        for a in sortedA:\n            if a > sortedB[j]:\n                candidates[sortedB[j]].append(a)\n                j += 1\n            else:\n                others.append(a)\n        return [candidates[b].pop() if candidates[b] else others.pop()\n                for b in B]\n\n"
    },
    {
        "problem_name": "airplane-seat-assignment-probability",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def nthPersonGetsNthSeat(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: float\n        \"\"\"\n        # p(k) = 1 * (prob that 1th passenger takes his own seat) +\n        #        0 * (prob that 1th passenger takes kth one's seat) +\n        #        1 * (prob that 1th passenger takes the others' seat) * \n        #            (prob that the first k-1 passengers get a seat\n        #             which is not kth one's seat)\n        #      = 1/k + p(k-1)*(k-2)/k\n        #\n        # p(1) = 1\n        # p(2) = 1/2 + p(1) * (2-2)/2 = 1/2\n        # p(3) = 1/3 + p(2) * (3-2)/3 = 1/3 + 1/2 * (3-2)/3 = 1/2\n        # ...\n        # p(n) = 1/n + 1/2 * (n-2)/n = (2+n-2)/(2n) = 1/2\n        return 0.5 if n != 1 else 1.0\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def nthPersonGetsNthSeat(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: float\n        \"\"\"\n        dp = [0.0]*2\n        dp[0] = 1.0  # zero-indexed\n        for i in xrange(2, n+1):\n            dp[(i-1)%2] = 1.0/i+dp[(i-2)%2]*(i-2)/i\n        return dp[(n-1)%2]\n"
    },
    {
        "problem_name": "alert-using-same-key-card-three-or-more-times-in-a-one-hour-period",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\nimport itertools\n\n\nclass Solution(object):\n    def alertNames(self, keyName, keyTime):\n        \"\"\"\n        :type keyName: List[str]\n        :type keyTime: List[str]\n        :rtype: List[str]\n        \"\"\"\n        THRESHOLD = 3\n        name_to_times = collections.defaultdict(list)\n        for name, hour_minute in itertools.izip(keyName, keyTime):\n            hour, minute = map(int, hour_minute.split(':'))\n            name_to_times[name].append(hour*60 + minute)\n        names = []    \n        for name, times in name_to_times.iteritems():\n            times.sort()\n            left = 0\n            for right, time in enumerate(times):\n                while time-times[left] > 60:\n                    left += 1\n                if right-left+1 >= THRESHOLD:\n                    names.append(name)\n                    break\n        names.sort()\n        return names\n"
    },
    {
        "problem_name": "alice-and-bob-playing-flower-game",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# combinatorics\nclass Solution(object):\n    def flowerGame(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        return (n*m)//2\n"
    },
    {
        "problem_name": "alien-dictionary",
        "solution": "# Time:  O(n)\n# Space: O(|V|+|E|) = O(26 + 26^2) = O(1)\n\nimport collections\n\n\n# BFS solution.\nclass Solution(object):\n    def alienOrder(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        result, in_degree, out_degree = [], {}, {}\n        zero_in_degree_queue = collections.deque()\n        nodes = set()\n        for word in words:\n            for c in word:\n                nodes.add(c)\n\n        for i in xrange(1, len(words)):\n            if (len(words[i-1]) > len(words[i]) and\n                    words[i-1][:len(words[i])] == words[i]):\n                return \"\"\n            self.findEdges(words[i - 1], words[i], in_degree, out_degree)\n\n        for node in nodes:\n            if node not in in_degree:\n                zero_in_degree_queue.append(node)\n\n        while zero_in_degree_queue:\n            precedence = zero_in_degree_queue.popleft()\n            result.append(precedence)\n\n            if precedence in out_degree:\n                for c in out_degree[precedence]:\n                    in_degree[c].discard(precedence)\n                    if not in_degree[c]:\n                        zero_in_degree_queue.append(c)\n\n                del out_degree[precedence]\n\n        if out_degree:\n            return \"\"\n\n        return \"\".join(result)\n\n    # Construct the graph.\n    def findEdges(self, word1, word2, in_degree, out_degree):\n        str_len = min(len(word1), len(word2))\n        for i in xrange(str_len):\n            if word1[i] != word2[i]:\n                if word2[i] not in in_degree:\n                    in_degree[word2[i]] = set()\n                if word1[i] not in out_degree:\n                    out_degree[word1[i]] = set()\n                in_degree[word2[i]].add(word1[i])\n                out_degree[word1[i]].add(word2[i])\n                break\n\n\n# DFS solution.\nclass Solution2(object):\n    def alienOrder(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        # Find ancestors of each node by DFS.\n        nodes, ancestors = set(), {}\n        for i in xrange(len(words)):\n            for c in words[i]:\n                nodes.add(c)\n        for node in nodes:\n            ancestors[node] = []\n        for i in xrange(1, len(words)):\n            if (len(words[i-1]) > len(words[i]) and\n                    words[i-1][:len(words[i])] == words[i]):\n                return \"\"\n            self.findEdges(words[i - 1], words[i], ancestors)\n\n        # Output topological order by DFS.\n        result = []\n        visited = {}\n        for node in nodes:\n            if self.topSortDFS(node, node, ancestors, visited, result):\n                return \"\"\n\n        return \"\".join(result)\n\n    # Construct the graph.\n    def findEdges(self, word1, word2, ancestors):\n        min_len = min(len(word1), len(word2))\n        for i in xrange(min_len):\n            if word1[i] != word2[i]:\n                ancestors[word2[i]].append(word1[i])\n                break\n\n    # Topological sort, return whether there is a cycle.\n    def topSortDFS(self, root, node, ancestors, visited, result):\n        if node not in visited:\n            visited[node] = root\n            for ancestor in ancestors[node]:\n                if self.topSortDFS(root, ancestor, ancestors, visited, result):\n                    return True\n            result.append(node)\n        elif visited[node] == root:\n            # Visited from the same root in the DFS path.\n            # So it is cyclic.\n            return True\n        return False\n\n"
    },
    {
        "problem_name": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "solution": "# Time:  O(|V| * |E|)\n# Space: O(|V| + |E|)\n\n# dfs\nclass Solution(object):\n    def getAncestors(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def iter_dfs(adj, i, result):\n            lookup = [False]*len(adj)\n            stk = [i]\n            while stk:\n                u = stk.pop()\n                for v in reversed(adj[u]):\n                    if lookup[v]:\n                        continue\n                    lookup[v] = True\n                    stk.append(v)\n                    result[v].append(i)\n                    \n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n        result = [[] for _ in xrange(n)]\n        for u in xrange(n):\n            iter_dfs(adj, u, result)\n        return result\n\n\n# Time:  O(|V| * |E| * log(|V| * |E|))\n# Space: O(|V| + |E|)\n# bfs\nclass Solution2(object):\n    def getAncestors(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def bfs(adj, i, result):\n            lookup = [False]*len(adj)\n            q = [i]\n            lookup[i] = True\n            while q:\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if lookup[v]:\n                            continue\n                        lookup[v] = True\n                        new_q.append(v)\n                        result[i].append(v)\n                q = new_q\n            result[i].sort()\n\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[v].append(u)\n        result = [[] for _ in xrange(n)]\n        for u in xrange(n):\n            bfs(adj, u, result) \n        return result\n\n\n# Time:  O(|V| * |E| * log(|V| * |E|))\n# Space: O(|V| + |E|)\n# topological sort\nclass Solution3(object):\n    def getAncestors(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = [set() for _ in xrange(n)]\n        in_degree = [0]*n\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            in_degree[v] += 1\n            result[v].add(u)\n        q = [u for u, d in enumerate(in_degree) if not d]\n        while q:\n            new_q = []\n            for u in q:\n                for v in adj[u]:\n                    result[v].update(result[u])\n                    in_degree[v] -= 1\n                    if not in_degree[v]:\n                        new_q.append(v)\n            q = new_q\n        return [sorted(s) for s in result]\n"
    },
    {
        "problem_name": "all-divisions-with-the-highest-score-of-a-binary-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# prefix sum\nclass Solution(object):\n    def maxScoreIndices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        mx = zeros = 0\n        total = sum(nums)\n        for i in xrange(len(nums)+1):\n            zeros += ((nums[i-1] if i else 0) == 0)\n            if zeros+(total-(i-zeros)) > mx:\n                mx = zeros+(total-(i-zeros))\n                result = []\n            if zeros+(total-(i-zeros)) == mx:\n                result.append(i)\n        return result\n"
    },
    {
        "problem_name": "all-elements-in-two-binary-search-trees",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def getAllElements(self, root1, root2):\n        \"\"\"\n        :type root1: TreeNode\n        :type root2: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        def inorder_gen(root):\n            result, stack = [], [(root, False)]\n            while stack:\n                root, is_visited = stack.pop()\n                if root is None:\n                    continue\n                if is_visited:\n                    yield root.val\n                else:\n                    stack.append((root.right, False))\n                    stack.append((root, True))\n                    stack.append((root.left, False))\n            yield None\n        \n        result = []\n        left_gen, right_gen = inorder_gen(root1), inorder_gen(root2)\n        left, right = next(left_gen), next(right_gen)\n        while left is not None or right is not None:\n            if right is None or (left is not None and left < right):\n                result.append(left)\n                left = next(left_gen)\n            else:\n                result.append(right)\n                right = next(right_gen)\n        return result\n  \n"
    },
    {
        "problem_name": "all-nodes-distance-k-in-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def distanceK(self, root, target, K):\n        \"\"\"\n        :type root: TreeNode\n        :type target: TreeNode\n        :type K: int\n        :rtype: List[int]\n        \"\"\"\n        def dfs(parent, child, neighbors):\n            if not child:\n                return\n            if parent:\n                neighbors[parent.val].append(child.val)\n                neighbors[child.val].append(parent.val)\n            dfs(child, child.left, neighbors)\n            dfs(child, child.right, neighbors)\n\n        neighbors = collections.defaultdict(list)\n        dfs(None, root, neighbors)\n        bfs = [target.val]\n        lookup = set(bfs)\n        for _ in xrange(K):\n            bfs = [nei for node in bfs\n                   for nei in neighbors[node]\n                   if nei not in lookup]\n            lookup |= set(bfs)\n        return bfs\n\n"
    },
    {
        "problem_name": "all-oone-data-structure",
        "solution": "# Time:  O(1), per operation\n# Space: O(k)\n\nclass Node(object):\n    \"\"\"\n    double linked list node\n    \"\"\"\n    def __init__(self, value, keys):\n        self.value = value\n        self.keys = keys\n        self.prev = None\n        self.next = None\n\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head, self.tail = Node(0, set()), Node(0, set())\n        self.head.next, self.tail.prev = self.tail, self.head\n\n    def insert(self, pos, node):\n        node.prev, node.next = pos.prev, pos\n        pos.prev.next, pos.prev = node, node\n        return node\n\n    def erase(self, node):\n        node.prev.next, node.next.prev = node.next, node.prev\n        del node\n\n    def empty(self):\n        return self.head.next is self.tail\n\n    def begin(self):\n        return self.head.next\n\n    def end(self):\n        return self.tail\n\n    def front(self):\n        return self.head.next\n\n    def back(self):\n        return self.tail.prev\n\n\nclass AllOne(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.bucket_of_key = {}\n        self.buckets = LinkedList()\n\n    def inc(self, key):\n        \"\"\"\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n        :type key: str\n        :rtype: void\n        \"\"\"\n        if key not in self.bucket_of_key:\n            self.bucket_of_key[key] = self.buckets.insert(self.buckets.begin(), Node(0, set([key])))\n\n        bucket, next_bucket = self.bucket_of_key[key], self.bucket_of_key[key].next\n        if next_bucket is self.buckets.end() or next_bucket.value > bucket.value+1:\n            next_bucket = self.buckets.insert(next_bucket, Node(bucket.value+1, set()))\n        next_bucket.keys.add(key)\n        self.bucket_of_key[key] = next_bucket\n\n        bucket.keys.remove(key)\n        if not bucket.keys:\n            self.buckets.erase(bucket)\n\n    def dec(self, key):\n        \"\"\"\n        Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\n        :type key: str\n        :rtype: void\n        \"\"\"\n        if key not in self.bucket_of_key:\n            return\n\n        bucket, prev_bucket = self.bucket_of_key[key], self.bucket_of_key[key].prev\n        self.bucket_of_key.pop(key, None)\n        if bucket.value > 1:\n            if bucket is self.buckets.begin() or prev_bucket.value < bucket.value-1:\n                prev_bucket = self.buckets.insert(bucket, Node(bucket.value-1, set()))\n            prev_bucket.keys.add(key)\n            self.bucket_of_key[key] = prev_bucket\n\n        bucket.keys.remove(key)\n        if not bucket.keys:\n            self.buckets.erase(bucket)\n\n    def getMaxKey(self):\n        \"\"\"\n        Returns one of the keys with maximal value.\n        :rtype: str\n        \"\"\"\n        if self.buckets.empty():\n            return \"\"\n        return iter(self.buckets.back().keys).next()\n\n    def getMinKey(self):\n        \"\"\"\n        Returns one of the keys with Minimal value.\n        :rtype: str\n        \"\"\"\n        if self.buckets.empty():\n            return \"\"\n        return iter(self.buckets.front().keys).next()\n\n"
    },
    {
        "problem_name": "all-paths-from-source-lead-to-destination",
        "solution": "# Time:  O(n + e)\n# Space: O(n + e)\n\nimport collections\n\n\nclass Solution(object):\n    def leadsToDestination(self, n, edges, source, destination):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type source: int\n        :type destination: int\n        :rtype: bool\n        \"\"\"\n        UNVISITED, VISITING, DONE = range(3)\n        def dfs(children, node, destination, status):\n            if status[node] == DONE:\n                return True\n            if status[node] == VISITING:\n                return False\n            status[node] = VISITING\n            if node not in children and node != destination:\n                return False\n            if node in children:\n                for child in children[node]:\n                    if not dfs(children, child, destination, status):\n                        return False\n            status[node] = DONE\n            return True\n        \n        children = collections.defaultdict(list)\n        for parent, child in edges:\n            children[parent].append(child)\n        return dfs(children, source, destination, [0]*n)\n"
    },
    {
        "problem_name": "all-paths-from-source-to-target",
        "solution": "# Time:  O(p + r * n), p is the count of all the possible paths in graph,\n#                      r is the count of the result.\n# Space: O(n)\n\nclass Solution(object):\n    def allPathsSourceTarget(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def dfs(graph, curr, path, result):\n            if curr == len(graph)-1:\n                result.append(path[:])\n                return\n            for node in graph[curr]:\n                path.append(node)\n                dfs(graph, node, path, result)\n                path.pop()\n\n        result = []\n        dfs(graph, 0, [0], result)\n        return result\n\n"
    },
    {
        "problem_name": "all-possible-full-binary-trees",
        "solution": "# Time:  O(n * 4^n / n^(3/2)) ~= sum of Catalan numbers from 1 .. N\n# Space: O(n * 4^n / n^(3/2)) ~= sum of Catalan numbers from 1 .. N\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def __init__(self):\n        self.__memo = {1: [TreeNode(0)]}\n    \n    def allPossibleFBT(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: List[TreeNode]\n        \"\"\"\n        if N % 2 == 0:\n            return []\n\n        if N not in self.__memo:\n            result = []\n            for i in xrange(N):\n                for left in self.allPossibleFBT(i):\n                    for right in self.allPossibleFBT(N-1-i):\n                        node = TreeNode(0)\n                        node.left = left\n                        node.right = right\n                        result.append(node)\n            self.__memo[N] = result\n\n        return self.__memo[N]\n \n\n"
    },
    {
        "problem_name": "allocate-mailboxes",
        "solution": "# Time:  O(m * n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def minDistance(self, houses, k):\n        \"\"\"\n        :type houses: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def cost(prefix, i, j):\n            return (prefix[j+1]-prefix[(i+j+1)//2])-(prefix[(i+j)//2+1]-prefix[i])\n\n        houses.sort()\n        prefix = [0]*(len(houses)+1)\n        for i, h in enumerate(houses):\n            prefix[i+1] = prefix[i]+h\n        dp = [cost(prefix, 0, j) for j in xrange(len(houses))]\n        for m in xrange(1, k):\n            for j in reversed(xrange(m, len(houses))):\n                for i in xrange(m, j+1):\n                    dp[j] = min(dp[j], dp[i-1]+cost(prefix, i, j))\n        return dp[-1]\n"
    },
    {
        "problem_name": "alphabet-board-path",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def alphabetBoardPath(self, target):\n        \"\"\"\n        :type target: str\n        :rtype: str\n        \"\"\"\n        x, y = 0, 0\n        result = []\n        for c in target:\n            y1, x1 = divmod(ord(c)-ord('a'), 5)\n            result.append('U' * max(y-y1, 0))\n            result.append('L' * max(x-x1, 0))\n            result.append('R' * max(x1-x, 0))\n            result.append('D' * max(y1-y, 0))\n            result.append('!')\n            x, y = x1, y1\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "alternating-digit-sum",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def alternateDigitSum(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        sign = 1\n        while n:\n            sign *= -1\n            result += sign*(n%10)\n            n //= 10\n        return sign*result\n"
    },
    {
        "problem_name": "ambiguous-coordinates",
        "solution": "# Time:  O(n^4)\n# Space: O(n)\n\nimport itertools\n\n\nclass Solution(object):\n    def ambiguousCoordinates(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        def make(S, i, n):\n            for d in xrange(1, n+1):\n                left = S[i:i+d]\n                right = S[i+d:i+n]\n                if ((not left.startswith('0') or left == '0')\n                        and (not right.endswith('0'))):\n                    yield \"\".join([left, '.' if right else '', right])\n\n        return [\"({}, {})\".format(*cand)\n                for i in xrange(1, len(S)-2)\n                for cand in itertools.product(make(S, 1, i),\n                                              make(S, i+1, len(S)-2-i))]\n\n"
    },
    {
        "problem_name": "amount-of-new-area-painted-each-day",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\nimport heapq\n\n\n# line sweep, heap\nclass Solution(object):\n    def amountPainted(self, paint):\n        \"\"\"\n        :type paint: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        points = collections.defaultdict(list)\n        for i, (s, e) in enumerate(paint):\n            points[s].append((True, i))\n            points[e].append((False, i))\n        min_heap = []\n        lookup = [False]*len(paint)\n        result = [0]*len(paint)\n        prev = -1\n        for pos in sorted(points.iterkeys()):\n            while min_heap and lookup[min_heap[0]]:\n                heapq.heappop(min_heap)\n            if min_heap:\n                result[min_heap[0]] += pos-prev\n            prev = pos\n            for t, i in points[pos]:\n                if t:\n                    heapq.heappush(min_heap, i)\n                else:\n                    lookup[i] = True\n        return result\n                    \n            \n# Time:  O(nlogn)\n# Space: O(n)\nfrom sortedcontainers import SortedList\n\n\n# line sweep, sorted list\nclass Solution2(object):\n    def amountPainted(self, paint):\n        \"\"\"\n        :type paint: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        points = collections.defaultdict(list)\n        for i, (s, e) in enumerate(paint):\n            points[s].append((True, i))\n            points[e].append((False, i))\n        sl = SortedList()\n        result = [0]*len(paint)\n        prev = -1\n        for pos in sorted(points.iterkeys()):\n            if sl:\n                result[sl[0]] += pos-prev\n            prev = pos\n            for t, i in points[pos]:\n                if t:\n                    sl.add(i)\n                else:\n                    sl.remove(i)\n        return result\n\n\nclass SegmentTree(object):\n    def __init__(self, N,\n                 build_fn=lambda x: 0,\n                 query_fn=lambda x, y: y if x is None else x+y,\n                 update_fn=lambda x, y: y):\n        self.tree = [None]*(2*N)\n        self.lazy = [None]*len(self.tree)\n        self.base = len(self.tree)//2\n        self.H = (self.base-1).bit_length()\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        for i in xrange(self.base, self.base+N):\n            self.tree[i] = build_fn(i-self.base)\n        for i in reversed(xrange(1, self.base)):\n            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n        self.count = [1]*(2*N)\n        for i in reversed(xrange(1, N)):\n            self.count[i] = self.count[2*i] + self.count[2*i+1]\n\n    def __apply(self, x, val):\n        self.tree[x] = self.update_fn(self.tree[x], val*self.count[x])\n        if x < self.base:\n            self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n    def __push(self, x):\n        n = 2**self.H\n        while n != 1:\n            y = x // n\n            if self.lazy[y] is not None:\n                self.__apply(y*2, self.lazy[y])\n                self.__apply(y*2 + 1, self.lazy[y])\n                self.lazy[y] = None\n            n //= 2\n\n    def update(self, L, R, h):\n        def pull(x):\n            while x > 1:\n                x //= 2\n                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n                if self.lazy[x] is not None:\n                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x])\n\n        if L > R:\n            return\n        L += self.base\n        R += self.base\n        self.__push(L)  # key point\n        self.__push(R)  # key point\n        L0, R0 = L, R\n        while L <= R:\n            if L & 1:\n                self.__apply(L, h)\n                L += 1\n            if R & 1 == 0:\n                self.__apply(R, h)\n                R -= 1\n            L //= 2\n            R //= 2\n        pull(L0)\n        pull(R0)\n\n    def query(self, L, R):\n        result = None\n        if L > R:\n            return result\n\n        L += self.base\n        R += self.base\n        self.__push(L)\n        self.__push(R)\n        while L <= R:\n            if L & 1:\n                result = self.query_fn(result, self.tree[L])\n                L += 1\n            if R & 1 == 0:\n                result = self.query_fn(result, self.tree[R])\n                R -= 1\n            L //= 2\n            R //= 2\n        return result\n\n\n# Time:  O(nlogr), r is the max position\n# Space: O(r)\n# segment tree\nclass SolutionTLE(object):\n    def amountPainted(self, paint):\n        \"\"\"\n        :type paint: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        st = SegmentTree(max(e for _, e in paint))\n        for s, e in paint:\n            cnt = st.query(s, e-1)\n            st.update(s, e-1, 1)\n            result.append(st.query(s, e-1)-cnt)\n        return result\n"
    },
    {
        "problem_name": "amount-of-time-for-binary-tree-to-be-infected",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\n# iterative dfs, tree dp\nclass Solution(object):\n    def amountOfTime(self, root, start):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type start: int\n        :rtype: int\n        \"\"\"\n        def iter_dfs(root, start):\n            result = -1\n            stk = [(1, (root, [-1]*2))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    curr, ret = args\n                    if curr is None:\n                        continue\n                    left, right = [-1]*2, [-1]*2\n                    stk.append((2, (curr, left, right, ret)))\n                    stk.append((1, (curr.right, right)))\n                    stk.append((1, (curr.left, left)))\n                elif step == 2:\n                    curr, left, right, ret = args\n                    d = -1\n                    if curr.val == start:\n                        d = 0\n                        result = max(left[0], right[0])+1\n                    elif left[1] >= 0:\n                        d = left[1]+1\n                        result = max(result, right[0]+1+d)\n                    elif right[1] >= 0:\n                        d = right[1]+1\n                        result = max(result, left[0]+1+d)\n                    ret[:] = [max(left[0], right[0])+1, d]  # [height, dist_to_start]\n            return result\n\n        return iter_dfs(root, start)\n\n\n# Time:  O(n)\n# Space: O(h)\n# dfs, tree dp\nclass Solution2(object):\n    def amountOfTime(self, root, start):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type start: int\n        :rtype: int\n        \"\"\"\n        def dfs(curr, start, result):\n            if curr is None:\n                return [-1, -1]\n            left = dfs(curr.left, start, result)\n            right = dfs(curr.right, start, result)\n            d = -1\n            if curr.val == start:\n                d = 0\n                result[0] = max(left[0], right[0])+1\n            elif left[1] >= 0:\n                d = left[1]+1\n                result[0] = max(result[0], right[0]+1+d)\n            elif right[1] >= 0:\n                d = right[1]+1\n                result[0] = max(result[0], left[0]+1+d)\n            return [max(left[0], right[0])+1, d]  # [height, dist_to_start]\n\n        result = [-1]\n        dfs(root, start, result)\n        return result[0]\n\n\n# Time:  O(n)\n# Space: O(n)\n# bfs\nclass Solution3(object):\n    def amountOfTime(self, root, start):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type start: int\n        :rtype: int\n        \"\"\"\n        def bfs(root):\n            adj = collections.defaultdict(list)\n            q = [root]\n            while q:\n                new_q = []\n                for u in q:\n                    for v in (u.left, u.right):\n                        if v is None:\n                            continue\n                        adj[u.val].append(v.val)\n                        adj[v.val].append(u.val)\n                        new_q.append(v)\n                q = new_q\n            return adj\n\n        def bfs2(adj, start):\n            result = -1\n            q = [start]\n            lookup = {start}\n            while q:\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if v in lookup:\n                            continue\n                        lookup.add(v)\n                        new_q.append(v)\n                q = new_q\n                result += 1\n            return result\n\n        adj = bfs(root)\n        return bfs2(adj, start)\n"
    },
    {
        "problem_name": "analyze-user-website-visit-pattern",
        "solution": "# Time:  O(n^3)\n# Space: O(n^3)\n\nimport collections\nimport itertools\n\n\nclass Solution(object):\n    def mostVisitedPattern(self, username, timestamp, website):\n        \"\"\"\n        :type username: List[str]\n        :type timestamp: List[int]\n        :type website: List[str]\n        :rtype: List[str]\n        \"\"\"\n        lookup = collections.defaultdict(list)\n        A = zip(timestamp, username, website)\n        A.sort()\n        for t, u, w in A:\n            lookup[u].append(w)\n        count = sum([collections.Counter(set(itertools.combinations(lookup[u], 3))) for u in lookup], collections.Counter())\n        return list(min(count, key=lambda x: (-count[x], x)))\n"
    },
    {
        "problem_name": "android-unlock-patterns",
        "solution": "# Time:  O(9^2 * 2^9)\n# Space: O(9 * 2^9)\n\n\n# DP solution.\nclass Solution(object):\n    def numberOfPatterns(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def merge(used, i):\n            return used | (1 << i)\n\n        def number_of_keys(i):\n            number = 0\n            while i > 0:\n                i &= i - 1\n                number += 1\n            return number\n\n        def contain(used, i):\n            return bool(used & (1 << i))\n\n        def convert(i, j):\n            return 3 * i + j\n\n        # dp[i][j]: i is the set of the numbers in binary representation,\n        #           dp[i][j] is the number of ways ending with the number j.\n        dp = [[0] * 9 for _ in xrange(1 << 9)]\n        for i in xrange(9):\n            dp[merge(0, i)][i] = 1\n\n        res = 0\n        for used in xrange(len(dp)):\n            number = number_of_keys(used)\n            if number > n:\n                continue\n\n            for i in xrange(9):\n                if not contain(used, i):\n                    continue\n\n                if m <= number <= n:\n                    res += dp[used][i]\n\n                x1, y1 = divmod(i, 3)\n                for j in xrange(9):\n                    if contain(used, j):\n                        continue\n\n                    x2, y2 = divmod(j, 3)\n                    if ((x1 == x2 and abs(y1 - y2) == 2) or\n                        (y1 == y2 and abs(x1 - x2) == 2) or\n                        (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)) and \\\n                       not contain(used,\n                                   convert((x1 + x2) // 2, (y1 + y2) // 2)):\n                            continue\n\n                    dp[merge(used, j)][j] += dp[used][i]\n\n        return res\n\n\n# Time:  O(9^2 * 2^9)\n# Space: O(9 * 2^9)\n# DP solution.\nclass Solution2(object):\n    def numberOfPatterns(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def merge(used, i):\n            return used | (1 << i)\n\n        def number_of_keys(i):\n            number = 0\n            while i > 0:\n                i &= i - 1\n                number += 1\n            return number\n\n        def exclude(used, i):\n            return used & ~(1 << i)\n\n        def contain(used, i):\n            return bool(used & (1 << i))\n\n        def convert(i, j):\n            return 3 * i + j\n\n        # dp[i][j]: i is the set of the numbers in binary representation,\n        #            d[i][j] is the number of ways ending with the number j.\n        dp = [[0] * 9 for _ in xrange(1 << 9)]\n        for i in xrange(9):\n            dp[merge(0, i)][i] = 1\n\n        res = 0\n        for used in xrange(len(dp)):\n            number = number_of_keys(used)\n            if number > n:\n                continue\n\n            for i in xrange(9):\n                if not contain(used, i):\n                    continue\n\n                x1, y1 = divmod(i, 3)\n                for j in xrange(9):\n                    if i == j or not contain(used, j):\n                        continue\n\n                    x2, y2 = divmod(j, 3)\n                    if ((x1 == x2 and abs(y1 - y2) == 2) or\n                        (y1 == y2 and abs(x1 - x2) == 2) or\n                        (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)) and \\\n                       not contain(used,\n                                   convert((x1 + x2) // 2, (y1 + y2) // 2)):\n                            continue\n\n                    dp[used][i] += dp[exclude(used, i)][j]\n\n                if m <= number <= n:\n                    res += dp[used][i]\n\n        return res\n\n\n# Time:  O(9!)\n# Space: O(9)\n# Backtracking solution. (TLE)\nclass Solution_TLE(object):\n    def numberOfPatterns(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def merge(used, i):\n            return used | (1 << i)\n\n        def contain(used, i):\n            return bool(used & (1 << i))\n\n        def convert(i, j):\n            return 3 * i + j\n\n        def numberOfPatternsHelper(m, n, level, used, i):\n            number = 0\n            if level > n:\n                return number\n\n            if m <= level <= n:\n                number += 1\n\n            x1, y1 = divmod(i, 3)\n            for j in xrange(9):\n                if contain(used, j):\n                    continue\n\n                x2, y2 = divmod(j, 3)\n                if ((x1 == x2 and abs(y1 - y2) == 2) or\n                    (y1 == y2 and abs(x1 - x2) == 2) or\n                    (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)) and \\\n                   not contain(used,\n                               convert((x1 + x2) // 2, (y1 + y2) // 2)):\n                        continue\n\n                number += numberOfPatternsHelper(m, n, level + 1, merge(used, j), j)\n\n            return number\n\n        number = 0\n        # 1, 3, 7, 9\n        number += 4 * numberOfPatternsHelper(m, n, 1, merge(0, 0), 0)\n        # 2, 4, 6, 8\n        number += 4 * numberOfPatternsHelper(m, n, 1, merge(0, 1), 1)\n        # 5\n        number += numberOfPatternsHelper(m, n, 1, merge(0, 4), 4)\n        return number\n\n"
    },
    {
        "problem_name": "angle-between-hands-of-a-clock",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def angleClock(self, hour, minutes):\n        \"\"\"\n        :type hour: int\n        :type minutes: int\n        :rtype: float\n        \"\"\"\n        angle1 = (hour % 12 * 60.0 + minutes) / 720.0\n        angle2 = minutes / 60.0\n        diff = abs(angle1-angle2)\n        return min(diff, 1.0-diff) * 360.0\n"
    },
    {
        "problem_name": "ant-on-the-boundary",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# prefix sum\nclass Solution(object):\n    def returnToBoundaryCount(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = curr = 0\n        for x in nums:\n            curr += x\n            if curr == 0:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "append-characters-to-string-to-make-subsequence",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers, greedy\nclass Solution(object):\n    def appendCharacters(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        i = -1\n        for j, c in enumerate(t):\n            for i in xrange(i+1, len(s)):\n                if s[i] == c:\n                    break\n            else:\n                return len(t)-j\n        return 0\n"
    },
    {
        "problem_name": "append-k-integers-with-minimal-sum",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# greedy\nclass Solution(object):\n    def minimalKSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = k*(k+1)//2\n        curr = k+1\n        for x in sorted(set(nums)):\n            if x < curr:\n                result += curr-x\n                curr += 1\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# greedy\nclass Solution2(object):\n    def minimalKSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = prev = 0\n        nums.append(float(\"inf\"))\n        for x in sorted(set(nums)):\n            if not k:\n                break\n            cnt = min((x-1)-prev, k)\n            k -= cnt\n            result += ((prev+1)+(prev+cnt))*cnt//2\n            prev = x\n        return result\n"
    },
    {
        "problem_name": "apple-redistribution-into-boxes",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, greedy\nclass Solution(object):\n    def minimumBoxes(self, apple, capacity):\n        \"\"\"\n        :type apple: List[int]\n        :type capacity: List[int]\n        :rtype: int\n        \"\"\"\n        capacity.sort(reverse=True)\n        total = sum(apple)\n        for i in xrange(len(capacity)):\n            total -= capacity[i]\n            if total <= 0:\n                return i+1\n        return -1\n"
    },
    {
        "problem_name": "apply-bitwise-operations-to-make-strings-equal",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# constructive algorithms\nclass Solution(object):\n    def makeStringsEqual(self, s, target):\n        \"\"\"\n        :type s: str\n        :type target: str\n        :rtype: bool\n        \"\"\"\n        return ('1' in s) == ('1' in target)\n"
    },
    {
        "problem_name": "apply-discount-every-n-orders",
        "solution": "# Time:  ctor:    O(m), m is the number of all products\n#        getBill: O(p), p is the number of products to bill\n# Space: O(m)\n\nclass Cashier(object):\n\n    def __init__(self, n, discount, products, prices):\n        \"\"\"\n        :type n: int\n        :type discount: int\n        :type products: List[int]\n        :type prices: List[int]\n        \"\"\"\n        self.__n = n\n        self.__discount = discount\n        self.__curr = 0\n        self.__lookup = {p : prices[i] for i, p in enumerate(products)}\n\n    def getBill(self, product, amount):\n        \"\"\"\n        :type product: List[int]\n        :type amount: List[int]\n        :rtype: float\n        \"\"\"\n        self.__curr = (self.__curr+1) % self.__n\n        result = 0.0\n        for i, p in enumerate(product):\n            result += self.__lookup[p]*amount[i]\n        return result * (1.0 - self.__discount/100.0 if self.__curr == 0 else 1.0)    \n"
    },
    {
        "problem_name": "apply-discount-to-prices",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def discountPrices(self, sentence, discount):\n        \"\"\"\n        :type sentence: str\n        :type discount: int\n        :rtype: str\n        \"\"\"\n        result = []\n        i = 0\n        while i < len(sentence):\n            j = sentence.find(' ', i)\n            if j == -1: j = len(sentence)\n            if sentence[i] == '$' and j-(i+1) > 0 and all(sentence[k].isdigit() for k in xrange(i+1, j)):\n                cnt = reduce(lambda x, y: x*10+int(y), (sentence[k] for k in xrange(i+1, j)), 0)\n                result.append(\"${:d}.{:02d}\".format(*divmod(cnt*(100-discount), 100)))\n            else:\n                for k in xrange(i, j):\n                    result.append(sentence[k])\n            if j != len(sentence):\n                result.append(' ')\n            i = j+1\n        return \"\".join(result)\n\n    \n# Time:  O(n)\n# Space: O(n)\n# string\nclass Solution2(object):\n    def discountPrices(self, sentence, discount):\n        \"\"\"\n        :type sentence: str\n        :type discount: int\n        :rtype: str\n        \"\"\"\n        def format(discount, x):\n            return \"${:d}.{:02d}\".format(*divmod(int(x[1:])*(100-discount), 100)) if x[0] == '$' and x[1:].isdigit() else x\n\n        return \" \".join(format(discount, x) for x in sentence.split())\n"
    },
    {
        "problem_name": "apply-operations-on-array-to-maximize-sum-of-squares",
        "solution": "# Time:  O(nlogr), r = max(nums)\n# Space: O(logr)\n\n# bit manipulation, greedy, freq table\nclass Solution(object):\n    def maxSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        l = max(nums).bit_length()\n        cnt = [0]*l\n        for i in xrange(l):\n            for x in nums:\n                if x&(1<<i):\n                    cnt[i] += 1\n        return reduce(lambda x, y: (x+y)%MOD, (sum(1<<i for i in xrange(l) if cnt[i] >= j)**2 for j in xrange(1, k+1)))\n"
    },
    {
        "problem_name": "apply-operations-to-an-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# inplace, array\nclass Solution(object):\n    def applyOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in xrange(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                nums[i], nums[i+1] = 2*nums[i], 0\n        i = 0\n        for x in nums:\n            if not x:\n                continue\n            nums[i] = x\n            i += 1\n        for i in xrange(i, len(nums)):\n            nums[i] = 0\n        return nums\n"
    },
    {
        "problem_name": "apply-operations-to-make-all-array-elements-equal-to-zero",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy, sliding window\nclass Solution(object):\n    def checkArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        curr = 0\n        for i, x in enumerate(nums):\n            if x-curr < 0:\n                return False\n            nums[i] -= curr\n            curr += nums[i]\n            if i-(k-1) >= 0:\n                curr -= nums[i-(k-1)]\n        return curr == 0\n"
    },
    {
        "problem_name": "apply-operations-to-make-string-empty",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# freq table\nclass Solution(object):\n    def lastNonEmptyString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        cnt = [0]*26\n        for x in s:\n            cnt[ord(x)-ord('a')] += 1\n        mx = max(cnt)\n        result = []\n        for x in reversed(s):\n            if cnt[ord(x)-ord('a')] != mx:\n                continue\n            cnt[ord(x)-ord('a')] -= 1\n            result.append(x)\n        return \"\".join(reversed(result))\n"
    },
    {
        "problem_name": "apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def minOperations(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # reference: https://stackoverflow.com/questions/15390807/integer-square-root-in-python\n        def isqrt(n):\n            a, b = n, (n+1)//2\n            while b < a:\n                a, b = b, (b+n//b)//2\n            return a\n\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n    \n        x = isqrt(k)\n        return (x-1)+(ceil_divide(k, x)-1)\n"
    },
    {
        "problem_name": "apply-operations-to-make-two-strings-equal",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def minOperations(self, s1, s2, x):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type x: int\n        :rtype: int\n        \"\"\"\n        parity = curr = prev = 0\n        j = -1\n        for i in xrange(len(s1)):\n            if s1[i] == s2[i]:\n                continue\n            curr, prev = min(curr+x, prev+(i-j)*2 if j != -1 else float(\"inf\")), curr\n            j = i\n            parity ^= 1\n        return curr//2 if parity == 0 else -1\n"
    },
    {
        "problem_name": "apply-operations-to-maximize-frequency-score",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, two pointers, sliding window\nclass Solution(object):\n    def maxFrequencyScore(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        result = left = curr = 0\n        for right in xrange(len(nums)):\n            # \"-+  \" => \"-0+ \"\n            # \"-0+ \" => \"--++\"\n            curr += nums[right]-nums[(left+right)//2]\n            if not curr <= k:\n                # \"--++\" => \" -0+\"\n                # \" -0+\" => \"  -+\"\n                curr -= nums[((left+1)+right)//2]-nums[left]\n                left += 1\n        return right-left+1\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# sort, two pointers, sliding window\nclass Solution2(object):\n    def maxFrequencyScore(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        result = left = curr = 0\n        for right in xrange(len(nums)):\n            # \"-+  \" => \"-0+ \"\n            # \"-0+ \" => \"--++\"\n            curr += nums[right]-nums[(left+right)//2]\n            while not curr <= k:\n                # \"--++\" => \" -0+\"\n                # \" -0+\" => \"  -+\"\n                curr -= nums[((left+1)+right)//2]-nums[left]\n                left += 1\n            result = max(result, right-left+1)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# sort, prefix sum, binary search\nclass Solution3(object):\n    def maxFrequencyScore(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(l):\n            # \"-+ \" or \"-0+\"\n            return any((prefix[i+l]-prefix[i+(l+1)//2])-(prefix[i+l//2]-prefix[i]) <= k for i in xrange(len(nums)-l+1))\n\n        nums.sort()\n        prefix = [0]*(len(nums)+1)\n        for i, x in enumerate(nums):\n            prefix[i+1] = prefix[i]+x\n        left, right = 1, len(nums)\n        while left <= right:\n            mid = left+(right-left)//2\n            if not check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "apply-operations-to-maximize-score",
        "solution": "# Time:  O(sqrt(r) + n * (logr + pi(sqrt(r))) + klogn) = O(sqrt(r) + n * (logr + sqrt(r)/log(sqrt(r))) + klogn), m is max(k for _, k in queries), pi(n) = number of primes in a range [1, n] = O(n/logn) by prime number theorem, see https://en.wikipedia.org/wiki/Prime_number_theorem\n# Space: O(sqrt(r) + n)\n\nimport heapq\n\n\n# number theory, mono stack, greedy, sort, heap\nclass Solution(object):\n    def maximumScore(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)\n            primes = []\n            spf = [-1]*(n+1)  # the smallest prime factor\n            for i in xrange(2, n+1):\n                if spf[i] == -1:\n                    spf[i] = i\n                    primes.append(i)\n                for p in primes:\n                    if i*p > n or p > spf[i]:\n                        break\n                    spf[i*p] = p\n            return primes  # len(primes) = O(n/(logn-1)), reference: https://math.stackexchange.com/questions/264544/how-to-find-number-of-prime-numbers-up-to-to-n\n\n\n        lookup = {}\n        def count_of_distinct_prime_factors(x):\n            y = x\n            if y not in lookup:\n                cnt = 0\n                for p in primes:\n                    if p*p > x:\n                        break\n                    if x%p != 0:\n                        continue\n                    cnt += 1\n                    while x%p == 0:\n                        x //= p\n                if x != 1:\n                    cnt += 1\n                lookup[y] = cnt\n            return lookup[y]\n\n        primes = linear_sieve_of_eratosthenes(int(max(nums)**0.5))\n        scores = [count_of_distinct_prime_factors(x) for x in nums]\n\n        left = [-1]*len(scores)\n        stk = [-1]\n        for i in xrange(len(scores)):\n            while stk[-1] != -1 and scores[stk[-1]] < scores[i]:  # if multiple such elements exist, choose the one with the smallest index\n                stk.pop()\n            left[i] = stk[-1]\n            stk.append(i)\n        right = [-1]*len(scores)\n        stk = [len(scores)]\n        for i in reversed(xrange(len(scores))):\n            while stk[-1] != len(scores) and scores[stk[-1]] <= scores[i]:\n                stk.pop()\n            right[i] = stk[-1]\n            stk.append(i)\n        \n        result = 1\n        max_heap = [(-x, i) for i, x in enumerate(nums)]\n        heapq.heapify(max_heap)\n        while max_heap:\n            _, i = heapq.heappop(max_heap)\n            c = min((i-left[i])*(right[i]-i), k)\n            result = (result*pow(nums[i], c, MOD))%MOD\n            k -= c\n            if not k:\n                break\n        return result\n\n"
    },
    {
        "problem_name": "arithmetic-slices-ii-subsequence",
        "solution": "# Time:  O(n^2)\n# Space: O(n * d)\n\nimport collections\n\n\nclass Solution(object):\n    def numberOfArithmeticSlices(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        dp = [collections.defaultdict(int) for i in xrange(len(A))]\n        for i in xrange(1, len(A)):\n            for j in xrange(i):\n                diff = A[i]-A[j]\n                dp[i][diff] += 1\n                if diff in dp[j]:\n                    dp[i][diff] += dp[j][diff]\n                    result += dp[j][diff]\n        return result\n\n"
    },
    {
        "problem_name": "arithmetic-slices",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfArithmeticSlices(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        res, i = 0, 0\n        while i+2 < len(A):\n            start = i\n            while i+2 < len(A) and A[i+2] + A[i] == 2*A[i+1]:\n                res += i - start + 1\n                i += 1\n            i += 1\n\n        return res\n\n"
    },
    {
        "problem_name": "arithmetic-subarrays",
        "solution": "# Time:  O(n * q)\n# Space: O(n)\n\nimport itertools\n\n\nclass Solution(object):\n    def checkArithmeticSubarrays(self, nums, l, r):\n        \"\"\"\n        :type nums: List[int]\n        :type l: List[int]\n        :type r: List[int]\n        :rtype: List[bool]\n        \"\"\"\n        def is_arith(n):\n            mx, mn, lookup = max(n), min(n), set(n)\n            if mx == mn:\n                return True\n            d, r = divmod(mx-mn, len(n)-1)\n            if r:\n                return False\n            return all(i in lookup for i in xrange(mn, mx, d))\n    \n        result = []\n        for left, right in itertools.izip(l, r):\n            result.append(is_arith(nums[left:right+1]))\n        return result\n"
    },
    {
        "problem_name": "armstrong-number",
        "solution": "# Time:  O(klogk)\n# Space: O(k)\n\nclass Solution(object):\n    def isArmstrong(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: bool\n        \"\"\"\n        n_str = str(N)\n        return sum(int(i)**len(n_str) for i in n_str) == N\n"
    },
    {
        "problem_name": "arranging-coins",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport math\n\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return int((math.sqrt(8*n+1)-1) / 2)  # sqrt is O(logn) time.\n\n\n# Time:  O(logn)\n# Space: O(1)\nclass Solution2(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def check(mid, n):\n            return mid*(mid+1) <= 2*n\n\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(mid, n):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "array-nesting",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def arrayNesting(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for num in nums:\n            if num is not None:\n                start, count = num, 0\n                while nums[start] is not None:\n                    temp = start\n                    start = nums[start]\n                    nums[temp] = None\n                    count += 1\n                result = max(result, count)\n        return result\n\n"
    },
    {
        "problem_name": "array-of-doubled-pairs",
        "solution": "# Time:  O(n + klogk)\n# Space: O(k)\n\nimport collections\n\n\nclass Solution(object):\n    def canReorderDoubled(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: bool\n        \"\"\"\n        count = collections.Counter(A)\n        for x in sorted(count, key=abs):\n            if count[x] > count[2*x]:\n                return False\n            count[2*x] -= count[x]\n        return True\n"
    },
    {
        "problem_name": "array-partition-i",
        "solution": "# Time:  O(r), r is the range size of the integers\n# Space: O(r)\n\n\nclass Solution(object):\n    def arrayPairSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        LEFT, RIGHT = -10000, 10000\n        lookup = [0] * (RIGHT-LEFT+1)\n        for num in nums:\n            lookup[num-LEFT] += 1\n        r, result = 0, 0\n        for i in xrange(LEFT, RIGHT+1):\n            result += (lookup[i-LEFT] + 1 - r) / 2 * i\n            r = (lookup[i-LEFT] + r) % 2\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(1)\nclass Solution2(object):\n    def arrayPairSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        result = 0\n        for i in xrange(0, len(nums), 2):\n            result += nums[i]\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nclass Solution3(object):\n    def arrayPairSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums = sorted(nums)\n        return sum([nums[i] for i in range(0, len(nums), 2)])\n\n"
    },
    {
        "problem_name": "array-transformation",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def transformArray(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def is_changable(arr):\n            return any(arr[i-1] > arr[i] < arr[i+1] or \n                       arr[i-1] < arr[i] > arr[i+1]\n                       for i in xrange(1, len(arr)-1))\n        \n        while is_changable(arr):\n            new_arr = arr[:]\n            for i in xrange(1, len(arr)-1):\n                new_arr[i] += arr[i-1] > arr[i] < arr[i+1]\n                new_arr[i] -= arr[i-1] < arr[i] > arr[i+1]\n            arr = new_arr\n        return arr\n"
    },
    {
        "problem_name": "array-with-elements-not-equal-to-average-of-neighbors",
        "solution": "# Time:  O(n) ~ O(n^2), O(n) on average\n# Space: O(1)\n\n# Tri Partition (aka Dutch National Flag Problem) with virtual index solution\nclass Solution(object):\n    def rearrangeArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        def reversedTriPartitionWithVI(nums, val):\n            def idx(i, N):\n                return (1 + 2 * (i)) % N\n\n            N = len(nums)//2 * 2 + 1\n            i, j, n = 0, 0, len(nums) - 1\n            while j <= n:\n                if nums[idx(j, N)] > val:\n                    nums[idx(i, N)], nums[idx(j, N)] = nums[idx(j, N)], nums[idx(i, N)]\n                    i += 1\n                    j += 1\n                elif nums[idx(j, N)] < val:\n                    nums[idx(j, N)], nums[idx(n, N)] = nums[idx(n, N)], nums[idx(j, N)]\n                    n -= 1\n                else:\n                    j += 1\n\n        mid = (len(nums)-1)//2\n        nth_element(nums, mid)\n        reversedTriPartitionWithVI(nums, nums[mid])\n        return nums\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# Sorting and reorder solution\nclass Solution2(object):\n    def rearrangeArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        mid = (len(nums)-1)//2\n        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]\n        return nums\n"
    },
    {
        "problem_name": "as-far-from-land-as-possible",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nimport collections\n\n\nclass Solution(object):\n    def maxDistance(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        q = collections.deque([(i, j) for i in xrange(len(grid))\n                                      for j in xrange(len(grid[0])) if grid[i][j] == 1])    \n        if len(q) == len(grid)*len(grid[0]):\n            return -1\n        level = -1\n        while q:\n            next_q = collections.deque()\n            while q:\n                x, y = q.popleft()\n                for dx, dy in directions:\n                    nx, ny = x+dx, y+dy\n                    if not (0 <= nx < len(grid) and \n                            0 <= ny < len(grid[0]) and \n                            grid[nx][ny] == 0):\n                        continue\n                    next_q.append((nx, ny))\n                    grid[nx][ny] = 1\n            q = next_q\n            level += 1\n        return level\n"
    },
    {
        "problem_name": "assign-cookies",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n\nclass Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        g.sort()\n        s.sort()\n\n        result, i = 0, 0\n        for j in xrange(len(s)):\n            if i == len(g):\n                break\n            if s[j] >= g[i]:\n                result += 1\n                i += 1\n        return result\n\n"
    },
    {
        "problem_name": "asteroid-collision",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def asteroidCollision(self, asteroids):\n        \"\"\"\n        :type asteroids: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for x in asteroids:\n            if x > 0:\n                result.append(x)\n                continue\n            while result and 0 < result[-1] < -x:\n                result.pop()\n            if result and 0 < result[-1]:\n                if result[-1] == -x:\n                    result.pop()\n                continue\n            result.append(x)\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def asteroidCollision(self, asteroids):\n        \"\"\"\n        :type asteroids: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for x in asteroids:\n            while result and x < 0 < result[-1]:\n                if result[-1] < -x:\n                    result.pop()\n                    continue\n                elif result[-1] == -x:\n                    result.pop()\n                break\n            else:\n                result.append(x)\n        return result\n"
    },
    {
        "problem_name": "available-captures-for-rook",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def numRookCaptures(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        r, c = None, None\n        for i in xrange(8):\n            if r is not None:\n                break\n            for j in xrange(8):\n                if board[i][j] == 'R':\n                    r, c = i, j\n                    break\n\n        result = 0\n        for d in directions:\n            nr, nc = r+d[0], c+d[1]\n            while 0 <= nr < 8 and 0 <= nc < 8:\n                if board[nr][nc] == 'p':\n                    result += 1\n                if board[nr][nc] != '.':\n                    break\n                nr, nc= nr+d[0], nc+d[1]\n        return result\n"
    },
    {
        "problem_name": "average-height-of-buildings-in-each-segment",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def averageHeightOfBuildings(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        points = []\n        for x, y, h in buildings:\n            points.append((x, 1, h))\n            points.append((y, -1, h))\n        points.sort()\n        result = []\n        total = cnt = 0\n        prev = -1\n        for curr, c, h in points:\n            if cnt and curr != prev:\n                if result and result[-1][1] == prev and result[-1][2] == total//cnt:\n                    result[-1][1] = curr\n                else:\n                    result.append([prev, curr, total//cnt])\n            total += h*c\n            cnt += c\n            prev = curr\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport collections\n\n\nclass Solution2(object):\n    def averageHeightOfBuildings(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        count = collections.defaultdict(lambda: (0, 0))\n        for x, y, h in buildings:\n            count[x] = (count[x][0]+1, count[x][1]+h)\n            count[y] = (count[y][0]-1, count[y][1]-h)\n        result = []\n        total = cnt = 0\n        prev = -1\n        for curr, (c, h) in sorted(count.iteritems()):\n            if cnt:\n                if result and result[-1][1] == prev and result[-1][2] == total//cnt:\n                    result[-1][1] = curr\n                else:\n                    result.append([prev, curr, total//cnt])\n            total += h\n            cnt += c\n            prev = curr\n        return result\n"
    },
    {
        "problem_name": "average-of-levels-in-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n\nclass Solution(object):\n    def averageOfLevels(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[float]\n        \"\"\"\n        result = []\n        q = [root]\n        while q:\n            total, count = 0, 0\n            next_q = []\n            for n in q:\n                total += n.val\n                count += 1\n                if n.left:\n                    next_q.append(n.left)\n                if n.right:\n                    next_q.append(n.right)\n            q = next_q\n            result.append(float(total) / count)\n        return result\n\n"
    },
    {
        "problem_name": "average-salary-excluding-the-minimum-and-maximum-salary",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# one pass solution\nclass Solution(object):\n    def average(self, salary):\n        \"\"\"\n        :type salary: List[int]\n        :rtype: float\n        \"\"\"\n        total, mi, ma = 0, float(\"inf\"), float(\"-inf\")\n        for s in salary:\n            total += s\n            mi, ma = min(mi, s), max(ma, s)\n        return 1.0*(total-mi-ma)/(len(salary)-2)\n\n\n# Time:  O(n)\n# Space: O(1)\n# one-liner solution\nclass Solution2(object):\n    def average(self, salary):\n        \"\"\"\n        :type salary: List[int]\n        :rtype: float\n        \"\"\"\n        return 1.0*(sum(salary)-min(salary)-max(salary))/(len(salary)-2)\n"
    },
    {
        "problem_name": "average-value-of-even-numbers-that-are-divisible-by-three",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def averageValue(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        total = cnt = 0\n        for x in nums:\n            if x%6:\n                continue\n            total += x\n            cnt += 1\n        return total//cnt if cnt else 0\n"
    },
    {
        "problem_name": "average-waiting-time",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def averageWaitingTime(self, customers):\n        \"\"\"\n        :type customers: List[List[int]]\n        :rtype: float\n        \"\"\"\n        avai = wait = 0.0\n        for a, t in customers:\n            avai = max(avai, a)+t\n            wait += avai-a\n        return wait/len(customers)\n"
    },
    {
        "problem_name": "avoid-flood-in-the-city",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\nimport heapq\n\n\nclass Solution(object):\n    def avoidFlood(self, rains):\n        \"\"\"\n        :type rains: List[int]\n        :rtype: List[int]\n        \"\"\"\n        lookup = collections.defaultdict(list)\n        i = len(rains)-1\n        for lake in reversed(rains):\n            lookup[lake].append(i)\n            i -= 1\n        result, min_heap = [], []\n        for i, lake in enumerate(rains):\n            if lake:\n                if len(lookup[lake]) >= 2:\n                    lookup[lake].pop()\n                    heapq.heappush(min_heap, lookup[lake][-1])\n                result.append(-1)\n            elif min_heap:\n                j = heapq.heappop(min_heap)\n                if j < i:\n                    return []\n                result.append(rains[j])\n            else:\n                result.append(1)\n        return result if not min_heap else []\n"
    },
    {
        "problem_name": "backspace-string-compare",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def backspaceCompare(self, S, T):\n        \"\"\"\n        :type S: str\n        :type T: str\n        :rtype: bool\n        \"\"\"\n        def findNextChar(S):\n            skip = 0\n            for i in reversed(xrange(len(S))):\n                if S[i] == '#':\n                    skip += 1\n                elif skip:\n                    skip -= 1\n                else:\n                    yield S[i]\n\n        return all(x == y for x, y in\n                   itertools.izip_longest(findNextChar(S), findNextChar(T)))\n\n"
    },
    {
        "problem_name": "bag-of-tokens",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def bagOfTokensScore(self, tokens, P):\n        \"\"\"\n        :type tokens: List[int]\n        :type P: int\n        :rtype: int\n        \"\"\"\n        tokens.sort()\n        result, points = 0, 0\n        left, right = 0, len(tokens)-1\n        while left <= right:\n            if P >= tokens[left]:\n                P -= tokens[left]\n                left += 1\n                points += 1\n                result = max(result, points)\n            elif points > 0:\n                points -= 1\n                P += tokens[right]\n                right -= 1\n            else:\n                break\n        return result\n"
    },
    {
        "problem_name": "balance-a-binary-search-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n# dfs solution with stack\nclass Solution(object):\n    def balanceBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        def inorderTraversal(root):\n            result, stk = [], [(root, False)]\n            while stk:\n                node, is_visited = stk.pop()\n                if node is None:\n                    continue\n                if is_visited:\n                    result.append(node.val)\n                else:\n                    stk.append((node.right, False))\n                    stk.append((node, True))\n                    stk.append((node.left, False))\n            return result\n    \n        def sortedArrayToBst(arr):\n            ROOT, LEFT, RIGHT = range(3)\n            result = [None]\n            stk = [(0, len(arr), ROOT, result)]\n            while stk:\n                i, j, update, ret = stk.pop()\n                if i >= j:\n                    continue\n                mid = i + (j-i)//2\n                node = TreeNode(arr[mid])\n                if update == ROOT:\n                    ret[0] = node\n                elif update == LEFT:\n                    ret[0].left = node\n                else:\n                    ret[0].right = node\n                stk.append((mid+1, j, RIGHT, [node]))\n                stk.append((i, mid, LEFT, [node]))\n            return result[0]\n        \n        return sortedArrayToBst(inorderTraversal(root))\n\n\n# Time:  O(n)\n# Space: O(h)\n# dfs solution with recursion\nclass Solution2(object):\n    def balanceBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        def inorderTraversalHelper(node, arr):\n            if not node:\n                return\n            inorderTraversalHelper(node.left, arr)\n            arr.append(node.val)\n            inorderTraversalHelper(node.right, arr)\n        \n        def sortedArrayToBstHelper(arr, i, j):\n            if i >= j:\n                return None\n            mid = i + (j-i)//2\n            node = TreeNode(arr[mid])\n            node.left = sortedArrayToBstHelper(arr, i, mid)\n            node.right = sortedArrayToBstHelper(arr, mid+1, j)\n            return node\n        \n        arr = []\n        inorderTraversalHelper(root, arr)\n        return sortedArrayToBstHelper(arr, 0, len(arr))\n"
    },
    {
        "problem_name": "balanced-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h), h is height of binary tree\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a boolean\n    def isBalanced(self, root):\n        def getHeight(root):\n            if root is None:\n                return 0\n            left_height, right_height = \\\n                getHeight(root.left), getHeight(root.right)\n            if left_height < 0 or right_height < 0 or \\\n               abs(left_height - right_height) > 1:\n                return -1\n            return max(left_height, right_height) + 1\n        return (getHeight(root) >= 0)\n\n"
    },
    {
        "problem_name": "base-7",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def convertToBase7(self, num):\n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        result = ''\n        while num:\n            result = str(num % 7) + result\n            num //= 7\n        return result if result else '0'\n\n\nclass Solution2(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        if num < 7:\n            return str(num)\n        return self.convertToBase7(num // 7) + str(num % 7)\n\n"
    },
    {
        "problem_name": "baseball-game",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def calPoints(self, ops):\n        \"\"\"\n        :type ops: List[str]\n        :rtype: int\n        \"\"\"\n        history = []\n        for op in ops:\n            if op == '+':\n                history.append(history[-1] + history[-2])\n            elif op == 'D':\n                history.append(history[-1] * 2)\n            elif op == 'C':\n                history.pop()\n            else:\n                history.append(int(op))\n        return sum(history)\n\n"
    },
    {
        "problem_name": "basic-calculator-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport operator\n\n\nclass Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(ops[operators.pop()](left, right))\n\n        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n        precedence = {'+':0, '-':0, '*':1, '/':1}\n        operands, operators, operand = [], [], 0\n        for i in xrange(len(s)):\n            if s[i].isdigit():\n                operand = operand*10 + int(s[i])\n                if i == len(s)-1 or not s[i+1].isdigit():\n                    operands.append(operand)\n                    operand = 0\n            elif s[i] == '(':\n                operators.append(s[i])\n            elif s[i] == ')':\n                while operators[-1] != '(':\n                    compute(operands, operators)\n                operators.pop()\n            elif s[i] in precedence:\n                while operators and operators[-1] in precedence and \\\n                      precedence[operators[-1]] >= precedence[s[i]]:\n                    compute(operands, operators)\n                operators.append(s[i])\n        while operators:\n            compute(operands, operators)\n        return operands[-1]\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    # @param {string} s\n    # @return {integer}\n    def calculate(self, s):\n        operands, operators = [], []\n        operand = \"\"\n        for i in reversed(xrange(len(s))):\n            if s[i].isdigit():\n                operand += s[i]\n                if i == 0 or not s[i-1].isdigit():\n                    operands.append(int(operand[::-1]))\n                    operand = \"\"\n            elif s[i] == ')' or s[i] == '*' or s[i] == '/':\n                operators.append(s[i])\n            elif s[i] == '+' or s[i] == '-':\n                while operators and \\\n                      (operators[-1] == '*' or operators[-1] == '/'):\n                    self.compute(operands, operators)\n                operators.append(s[i])\n            elif s[i] == '(':\n                while operators[-1] != ')':\n                    self.compute(operands, operators)\n                operators.pop()\n\n        while operators:\n            self.compute(operands, operators)\n\n        return operands[-1]\n\n    def compute(self, operands, operators):\n        left, right = operands.pop(), operands.pop()\n        op = operators.pop()\n        if op == '+':\n            operands.append(left + right)\n        elif op == '-':\n            operands.append(left - right)\n        elif op == '*':\n            operands.append(left * right)\n        elif op == '/':\n            operands.append(left / right)\n\n"
    },
    {
        "problem_name": "basic-calculator-iii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport operator\n\n\nclass Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(ops[operators.pop()](left, right))\n\n        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n        precedence = {'+':0, '-':0, '*':1, '/':1}\n        operands, operators, operand = [], [], 0\n        for i in xrange(len(s)):\n            if s[i].isdigit():\n                operand = operand*10 + int(s[i])\n                if i == len(s)-1 or not s[i+1].isdigit():\n                    operands.append(operand)\n                    operand = 0\n            elif s[i] == '(':\n                operators.append(s[i])\n            elif s[i] == ')':\n                while operators[-1] != '(':\n                    compute(operands, operators)\n                operators.pop()\n            elif s[i] in precedence:\n                while operators and operators[-1] in precedence and \\\n                      precedence[operators[-1]] >= precedence[s[i]]:\n                    compute(operands, operators)\n                operators.append(s[i])\n        while operators:\n            compute(operands, operators)\n        return operands[-1]\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        operands, operators = [], []\n        operand = \"\"\n        for i in reversed(xrange(len(s))):\n            if s[i].isdigit():\n                operand += s[i]\n                if i == 0 or not s[i-1].isdigit():\n                    operands.append(int(operand[::-1]))\n                    operand = \"\"\n            elif s[i] == ')' or s[i] == '*' or s[i] == '/':\n                operators.append(s[i])\n            elif s[i] == '+' or s[i] == '-':\n                while operators and \\\n                      (operators[-1] == '*' or operators[-1] == '/'):\n                    self.compute(operands, operators)\n                operators.append(s[i])\n            elif s[i] == '(':\n                while operators[-1] != ')':\n                    self.compute(operands, operators)\n                operators.pop()\n\n        while operators:\n            self.compute(operands, operators)\n\n        return operands[-1]\n\n    def compute(self, operands, operators):\n        left, right = operands.pop(), operands.pop()\n        op = operators.pop()\n        if op == '+':\n            operands.append(left + right)\n        elif op == '-':\n            operands.append(left - right)\n        elif op == '*':\n            operands.append(left * right)\n        elif op == '/':\n            operands.append(left / right)\n\n"
    },
    {
        "problem_name": "basic-calculator-iv",
        "solution": "# Time:  +:        O(d * t), t is the number of terms,\n#                            d is the average degree of terms\n#        -:        O(d * t)\n#        *:        O(d * t^2)\n#        eval:     O(d * t)\n#        to_list:  O(d * tlogt)\n# Space: O(e + d * t), e is the number of evalvars\n\nimport collections\nimport itertools\nimport operator\n\n\ndef clear(result):\n    to_remove = [k for k, v in result.iteritems() if v == 0]\n    for k in to_remove:\n        result.pop(k)\n\n\nclass Poly(collections.Counter):\n    def __init__(self, expr=None):\n        if expr is None:\n            return\n        if expr.isdigit():\n            if int(expr):\n                self.update({(): int(expr)})\n        else:\n            self[(expr,)] += 1\n\n    def __add__(self, other):\n        result = Poly()\n        result.update(self)\n        result.update(other)\n        clear(result)\n        return result\n\n    def __sub__(self, other):\n        result = Poly()\n        result.update(self)\n        result.update({k: -v for k, v in other.iteritems()})\n        clear(result)\n        return result\n\n    def __mul__(self, other):\n        def merge(k1, k2):\n            result = []\n            i, j = 0, 0\n            while i != len(k1) or j != len(k2):\n                if j == len(k2) or (i != len(k1) and k1[i] < k2[j]):\n                    result.append(k1[i])\n                    i += 1\n                else:\n                    result.append(k2[j])\n                    j += 1\n            return result\n\n        result = Poly()\n        for k1, v1 in self.iteritems():\n            for k2, v2 in other.iteritems():\n                result.update({tuple(merge(k1, k2)): v1*v2})\n        clear(result)\n        return result\n\n    def eval(self, lookup):\n        result = Poly()\n        for polies, c in self.iteritems():\n            key = []\n            for var in polies:\n                if var in lookup:\n                    c *= lookup[var]\n                else:\n                    key.append(var)\n            result[tuple(key)] += c\n        clear(result)\n        return result\n\n    def to_list(self):\n        return [\"*\".join((str(v),) + k)\n                for k, v in sorted(self.iteritems(),\n                                   key=lambda x: (-len(x[0]), x[0]))]\n\n\nclass Solution(object):\n    def basicCalculatorIV(self, expression, evalvars, evalints):\n        \"\"\"\n        :type expression: str\n        :type evalvars: List[str]\n        :type evalints: List[int]\n        :rtype: List[str]\n        \"\"\"\n        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul}\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(ops[operators.pop()](left, right))\n\n        def parse(s):\n            precedence = {'+':0, '-':0, '*':1}\n            operands, operators, operand = [], [], []\n            for i in xrange(len(s)):\n                if s[i].isalnum():\n                    operand.append(s[i])\n                    if i == len(s)-1 or not s[i+1].isalnum():\n                        operands.append(Poly(\"\".join(operand)))\n                        operand = []\n                elif s[i] == '(':\n                    operators.append(s[i])\n                elif s[i] == ')':\n                    while operators[-1] != '(':\n                        compute(operands, operators)\n                    operators.pop()\n                elif s[i] in precedence:\n                    while operators and operators[-1] in precedence and \\\n                          precedence[operators[-1]] >= precedence[s[i]]:\n                        compute(operands, operators)\n                    operators.append(s[i])\n            while operators:\n                compute(operands, operators)\n            return operands[-1]\n\n        lookup = dict(itertools.izip(evalvars, evalints))\n        return parse(expression).eval(lookup).to_list()\n\n\nclass Solution2(object):\n    def basicCalculatorIV(self, expression, evalvars, evalints):\n        \"\"\"\n        :type expression: str\n        :type evalvars: List[str]\n        :type evalints: List[int]\n        :rtype: List[str]\n        \"\"\"\n        def compute(operands, operators):\n            left, right = operands.pop(), operands.pop()\n            op = operators.pop()\n            if op == '+':\n                operands.append(left + right)\n            elif op == '-':\n                operands.append(left - right)\n            elif op == '*':\n                operands.append(left * right)\n\n        def parse(s):\n            if not s:\n                return Poly()\n            operands, operators = [], []\n            operand = \"\"\n            for i in reversed(xrange(len(s))):\n                if s[i].isalnum():\n                    operand += s[i]\n                    if i == 0 or not s[i-1].isalnum():\n                        operands.append(Poly(operand[::-1]))\n                        operand = \"\"\n                elif s[i] == ')' or s[i] == '*':\n                    operators.append(s[i])\n                elif s[i] == '+' or s[i] == '-':\n                    while operators and operators[-1] == '*':\n                        compute(operands, operators)\n                    operators.append(s[i])\n                elif s[i] == '(':\n                    while operators[-1] != ')':\n                        compute(operands, operators)\n                    operators.pop()\n            while operators:\n                compute(operands, operators)\n            return operands[-1]\n\n        lookup = dict(itertools.izip(evalvars, evalints))\n        return parse(expression).eval(lookup).to_list()\n\n"
    },
    {
        "problem_name": "basic-calculator",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport operator\n\n\nclass Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(ops[operators.pop()](left, right))\n\n        ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n        precedence = {'+':0, '-':0, '*':1, '/':1}\n        operands, operators, operand = [], [], 0\n        for i in xrange(len(s)):\n            if s[i].isdigit():\n                operand = operand*10 + int(s[i])\n                if i == len(s)-1 or not s[i+1].isdigit():\n                    operands.append(operand)\n                    operand = 0\n            elif s[i] == '(':\n                operators.append(s[i])\n            elif s[i] == ')':\n                while operators[-1] != '(':\n                    compute(operands, operators)\n                operators.pop()\n            elif s[i] in precedence:\n                while operators and operators[-1] in precedence and \\\n                      precedence[operators[-1]] >= precedence[s[i]]:\n                    compute(operands, operators)\n                operators.append(s[i])\n        while operators:\n            compute(operands, operators)\n        return operands[-1]\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    # @param {string} s\n    # @return {integer}\n    def calculate(self, s):\n        operands, operators = [], []\n        operand = \"\"\n        for i in reversed(xrange(len(s))):\n            if s[i].isdigit():\n                operand += s[i]\n                if i == 0 or not s[i-1].isdigit():\n                    operands.append(int(operand[::-1]))\n                    operand = \"\"\n            elif s[i] == ')' or s[i] == '+' or s[i] == '-':\n                operators.append(s[i])\n            elif s[i] == '(':\n                while operators[-1] != ')':\n                    self.compute(operands, operators)\n                operators.pop()\n\n        while operators:\n            self.compute(operands, operators)\n\n        return operands[-1]\n\n    def compute(self, operands, operators):\n        left, right = operands.pop(), operands.pop()\n        op = operators.pop()\n        if op == '+':\n            operands.append(left + right)\n        elif op == '-':\n            operands.append(left - right)\n\n"
    },
    {
        "problem_name": "battleships-in-a-board",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n\nclass Solution(object):\n    def countBattleships(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: int\n        \"\"\"\n        if not board or not board[0]:\n            return 0\n\n        cnt = 0\n        for i in xrange(len(board)):\n            for j in xrange(len(board[0])):\n                cnt += int(board[i][j] == 'X' and\n                           (i == 0 or board[i - 1][j] != 'X') and\n                           (j == 0 or board[i][j - 1] != 'X'))\n        return cnt\n\n"
    },
    {
        "problem_name": "beautiful-arrangement-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def constructArray(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        left, right = 1, n\n        while left <= right:\n            if k % 2:\n                result.append(left)\n                left += 1\n            else:\n                result.append(right)\n                right -= 1\n            if k > 1:\n                k -= 1\n        return result\n\n"
    },
    {
        "problem_name": "beautiful-arrangement",
        "solution": "# Time:  O(n!)\n# Space: O(n)\n\n\nclass Solution(object):\n    def countArrangement(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        def countArrangementHelper(n, arr):\n            if n <= 0:\n                return 1\n            count = 0\n            for i in xrange(n):\n                if arr[i] % n == 0 or n % arr[i] == 0:\n                    arr[i], arr[n-1] = arr[n-1], arr[i]\n                    count += countArrangementHelper(n - 1, arr)\n                    arr[i], arr[n-1] = arr[n-1], arr[i]\n            return count\n\n        return countArrangementHelper(N, range(1, N+1))\n\n"
    },
    {
        "problem_name": "beautiful-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def beautifulArray(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: List[int]\n        \"\"\"\n        result = [1]\n        while len(result) < N:\n            result = [i*2 - 1 for i in result] + [i*2 for i in result]\n        return [i for i in result if i <= N]\n"
    },
    {
        "problem_name": "beautiful-pairs",
        "solution": "# Time:  O(n) on average\n# Space: O(n)\n\nimport random\nimport itertools\nimport math\n\n\n# random algorithms, variant of closest pair\n# reference: https://github.com/jilljenn/tryalgo/blob/master/tryalgo/closest_points.py\nrandom.seed(0)\nclass Solution(object):\n    def beautifulPair(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        INF = float(\"inf\")\n        def dist(a, b):\n            if a[2] > b[2]:\n                a, b = b, a\n            return [abs(a[0]-b[0])+abs(a[1]-b[1]), a[2], b[2]]\n\n        def cell(point, size):\n            x, y, _ = point\n            return math.floor(x/size), math.floor(y/size)\n\n        def improve():\n            lookup = {}\n            for p in points:\n                i, j = map(int, cell(p, result[0]/2.0))\n                for ni in xrange(i-2, (i+2)+1):\n                    for nj in xrange(j-2, (j+2)+1):\n                        if (ni, nj) not in lookup:\n                            continue\n                        d = dist(p, lookup[ni, nj])\n                        if d < result:\n                            result[:] = d\n                            return True\n                lookup[i, j] = p\n            return False\n\n        points = [(i, j, idx) for idx, (i, j) in enumerate(itertools.izip(nums1, nums2))]\n        result = [INF]*3\n        lookup = {}\n        for i in reversed(xrange(len(points))):\n            if points[i][:2] in lookup:\n                result = [0, i, lookup[points[i][:2]]]\n            lookup[points[i][:2]] = i\n        if result[0] == 0:\n            return result[1:]\n        random.shuffle(points)\n        result = dist(points[0], points[1])\n        while improve():\n            pass\n        return result[1:]\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\n\n\n# divide and conquer, merge sort, variant of closest pair\n# reference: https://www.baeldung.com/cs/minimal-manhattan-distance\nclass Solution2(object):\n    def beautifulPair(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        INF = float(\"inf\")\n        MAX_NEIGHBOR_COUNT = (8+2)//2\n        def dist(a, b):\n            if a > b:\n                a, b = b, a\n            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]\n\n        def merge_sort(left, right):\n            def update(arr, i):  # added\n                for j in reversed(xrange(len(arr))):\n                    if points[i][1]-points[arr[j]][1] > result[0]:\n                        break\n                    result[:] = min(result, dist(i, arr[j]))\n                else:\n                    j = -1\n                assert((len(arr)-1)-j <= MAX_NEIGHBOR_COUNT)\n\n            if left == right:\n                return\n            mid = left+(right-left)//2\n            x = points[order[mid]][0]  # added\n            merge_sort(left, mid)\n            merge_sort(mid+1, right)\n            tmp, tmp_l, tmp_r = [], [], []\n            l, r = left, mid+1\n            while l <= mid or r <= right:\n                if r == right+1 or (l <= mid and points[order[l]][1] <= points[order[r]][1]):  # modified\n                    update(tmp_r, order[l])\n                    if x-points[order[l]][0] <= result[0]:  # added\n                        tmp_l.append(order[l])\n                    tmp.append(order[l])\n                    l += 1\n                else:\n                    update(tmp_l, order[r])\n                    if points[order[r]][0]-x <= result[0]:  # added\n                        tmp_r.append(order[r])\n                    tmp.append(order[r])\n                    r += 1\n            order[left:right+1] = tmp\n\n        points = [(i, j) for i, j in itertools.izip(nums1, nums2)]\n        result = [INF]*3\n        lookup = {}\n        for i in reversed(xrange(len(points))):\n            if points[i] in lookup:\n                result = [0, (i, lookup[points[i]])]\n            lookup[points[i]] = i\n        if result[0] == 0:\n            return result[1]\n        order = range(len(points))\n        order.sort(key=lambda x: points[x][0])\n        merge_sort(0, len(points)-1)\n        return result[1:]\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\n\n\n# divide and conquer, merge sort, variant of closest pair\n# reference: https://www.baeldung.com/cs/minimal-manhattan-distance\nclass Solution3(object):\n    def beautifulPair(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        INF = float(\"inf\")\n        MAX_NEIGHBOR_COUNT = 8\n        def dist(a, b):\n            if a > b:\n                a, b = b, a\n            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]\n\n        def merge_sort(left, right):\n            if left == right:\n                return\n            mid = left + (right-left)//2\n            x = points[order[mid]][0]  # added\n            merge_sort(left, mid)\n            merge_sort(mid+1, right)\n            r = mid+1\n            tmp = []\n            for l in xrange(left, mid+1):\n                while r <= right and points[order[r]][1] < points[order[l]][1]:  # modified\n                    tmp.append(order[r])\n                    r += 1\n                tmp.append(order[l])\n            order[left:left+len(tmp)] = tmp\n\n            # added below\n            stripe = [order[i] for i in xrange(left, right+1) if abs(points[order[i]][0]-x) <= result[0]]\n            for i in xrange(len(stripe)-1):\n                for j in xrange(i+1, len(stripe)):\n                    x, y = stripe[i], stripe[j]\n                    if points[y][1]-points[x][1] > result[0]:\n                        break\n                    result[:] = min(result, dist(x, y))\n                else:\n                    j = len(stripe)\n                assert(j-(i+1) <= MAX_NEIGHBOR_COUNT)\n\n        points = [(i, j) for i, j in itertools.izip(nums1, nums2)]\n        result = [INF]*3\n        lookup = {}\n        for i in reversed(xrange(len(points))):\n            if points[i] in lookup:\n                result = [0, (i, lookup[points[i]])]\n            lookup[points[i]] = i\n        if result[0] == 0:\n            return result[1]\n        order = range(len(points))\n        order.sort(key=lambda x: points[x][0])\n        merge_sort(0, len(points)-1)\n        return result[1:]\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\n\n\n# segment tree\nclass Solution4(object):\n    def beautifulPair(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        INF = float(\"inf\")\n        # Range Maximum Query\n        class SegmentTree(object):\n            def __init__(self, N,\n                         build_fn=lambda _: [-INF, -INF],  # modified\n                         query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),\n                         update_fn=lambda x: x):\n                self.tree = [None]*(2*2**((N-1).bit_length()))\n                self.base = len(self.tree)//2\n                self.query_fn = query_fn\n                self.update_fn = update_fn\n                for i in xrange(self.base, self.base+N):\n                    self.tree[i] = build_fn(i-self.base)\n                for i in reversed(xrange(1, self.base)):\n                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n\n            def update(self, i, h):\n                x = self.base+i\n                self.tree[x] = self.update_fn(h)\n                while x > 1:\n                    x //= 2\n                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n\n            def query(self, L, R):\n                if L > R:\n                    return [-INF, -INF]  # modified\n                L += self.base\n                R += self.base\n                left = right = None\n                while L <= R:\n                    if L & 1:\n                        left = self.query_fn(left, self.tree[L])\n                        L += 1\n                    if R & 1 == 0:\n                        right = self.query_fn(self.tree[R], right)\n                        R -= 1\n                    L //= 2\n                    R //= 2\n                return self.query_fn(left, right)\n\n        def dist(a, b):\n            if a > b:\n                a, b = b, a\n            return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b]\n\n        points = [(i, j) for i, j in itertools.izip(nums1, nums2)]\n        result = [INF]*3\n        lookup = {}\n        for i in reversed(xrange(len(points))):\n            if points[i] in lookup:\n                result = [0, (i, lookup[points[i]])]\n            lookup[points[i]] = i\n        if result[0] == 0:\n            return result[1]\n        order = range(len(points))\n        order.sort(key=lambda x: points[x][0])\n        y_set = set(y for _, y in points)\n        y_to_idx = {y:i for i, y in enumerate(sorted(y_set))}\n        st1, st2 = SegmentTree(len(y_to_idx)), SegmentTree(len(y_to_idx))\n        for i in order:\n            j = -st1.query(0, y_to_idx[points[i][1]]-1)[1]  # min((xi-xj)+(yi-yj) for j in range(y_to_idx[points[i][1])) = (xi+yi)-max((xj+yj) for j in range(y_to_idx[points[i][1]))\n            if j != INF:\n                assert(points[j][1] < points[i][1])\n                result = min(result, dist(i, j))\n            st1.update(y_to_idx[points[i][1]], [points[i][0]+points[i][1], -i])\n            j = -st2.query(y_to_idx[points[i][1]], len(y_to_idx)-1)[1]  # min((xi-xj)+(yj-yi) for j in range(y_to_idx[points[i][1], len(y_to_idx))) = (xi-yi)-max((xj-yj) for j in range(y_to_idx[points[i][1], len(y_to_idx))\n            if j != INF:\n                assert(points[j][1] >= points[i][1])\n                result = min(result, dist(i, j))\n            st2.update(y_to_idx[points[i][1]], [points[i][0]-points[i][1], -i])\n        return result[1:]\n"
    },
    {
        "problem_name": "beautiful-towers-i",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# mono stack\nclass Solution(object):\n    def maximumSumOfHeights(self, maxHeights):\n        \"\"\"\n        :type maxHeights: List[int]\n        :rtype: int\n        \"\"\"\n        left = [0]*len(maxHeights)\n        stk = [-1]\n        curr = 0\n        for i in xrange(len(maxHeights)):\n            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:\n                j = stk.pop()\n                curr -= (j-stk[-1])*maxHeights[j]\n            curr += (i-stk[-1])*maxHeights[i]\n            stk.append(i)\n            left[i] = curr\n        stk = [len(maxHeights)]\n        result = right = curr = 0\n        for i in reversed(xrange(len(maxHeights))):\n            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:\n                j = stk.pop()\n                curr -= (stk[-1]-j)*maxHeights[j]\n            curr += (stk[-1]-i)*maxHeights[i]\n            stk.append(i)\n            right = curr\n            result = max(result, left[i]+right-maxHeights[i])\n        return result\n"
    },
    {
        "problem_name": "beautiful-towers-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# mono stack\nclass Solution(object):\n    def maximumSumOfHeights(self, maxHeights):\n        \"\"\"\n        :type maxHeights: List[int]\n        :rtype: int\n        \"\"\"\n        left = [0]*len(maxHeights)\n        stk = [-1]\n        curr = 0\n        for i in xrange(len(maxHeights)):\n            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:\n                j = stk.pop()\n                curr -= (j-stk[-1])*maxHeights[j]\n            curr += (i-stk[-1])*maxHeights[i]\n            stk.append(i)\n            left[i] = curr\n        stk = [len(maxHeights)]\n        result = right = curr = 0\n        for i in reversed(xrange(len(maxHeights))):\n            while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]:\n                j = stk.pop()\n                curr -= (stk[-1]-j)*maxHeights[j]\n            curr += (stk[-1]-i)*maxHeights[i]\n            stk.append(i)\n            right = curr\n            result = max(result, left[i]+right-maxHeights[i])\n        return result\n"
    },
    {
        "problem_name": "before-and-after-puzzle",
        "solution": "# Time:  O(l * rlogr)  , l is the max length of phrases\n#                      , r is the number of result, could be up to O(n^2)\n# Space: O(l * (n + r)), n is the number of phrases\n\nimport collections\n\n\nclass Solution(object):\n    def beforeAndAfterPuzzles(self, phrases):\n        \"\"\"\n        :type phrases: List[str]\n        :rtype: List[str]\n        \"\"\"\n        lookup = collections.defaultdict(list)\n        for i, phrase in enumerate(phrases):\n            right = phrase.rfind(' ')\n            word = phrase if right == -1 else phrase[right+1:]\n            lookup[word].append(i)\n\n        result_set = set()\n        for i, phrase in enumerate(phrases):\n            left = phrase.find(' ')\n            word = phrase if left == -1 else phrase[:left]\n            if word not in lookup:\n                continue\n            for j in lookup[word]:\n                if j == i:\n                    continue\n                result_set.add(phrases[j] + phrase[len(word):])\n        return sorted(result_set)\n"
    },
    {
        "problem_name": "best-meeting-point",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nfrom random import randint\n\n\nclass Solution(object):\n    def minTotalDistance(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        x = [i for i, row in enumerate(grid) for v in row if v == 1]\n        y = [j for row in grid for j, v in enumerate(row) if v == 1]\n        mid_x = self.findKthLargest(x, len(x) / 2 + 1)\n        mid_y = self.findKthLargest(y, len(y) / 2 + 1)\n\n        return sum([abs(mid_x-i) + abs(mid_y-j)\n                   for i, row in enumerate(grid)\n                   for j, v in enumerate(row) if v == 1])\n\n    def findKthLargest(self, nums, k):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = self.PartitionAroundPivot(left, right,\n                                                      pivot_idx, nums)\n            if new_pivot_idx == k - 1:\n                return nums[new_pivot_idx]\n            elif new_pivot_idx > k - 1:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k - 1.\n                left = new_pivot_idx + 1\n\n    def PartitionAroundPivot(self, left, right, pivot_idx, nums):\n        pivot_value = nums[pivot_idx]\n        new_pivot_idx = left\n        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n        for i in xrange(left, right):\n            if nums[i] > pivot_value:\n                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                new_pivot_idx += 1\n\n        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n        return new_pivot_idx\n\n"
    },
    {
        "problem_name": "best-poker-hand",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# freq table\nclass Solution(object):\n    def bestHand(self, ranks, suits):\n        \"\"\"\n        :type ranks: List[int]\n        :type suits: List[str]\n        :rtype: str\n        \"\"\"\n        LOOKUP = [\"\", \"High Card\", \"Pair\", \"Three of a Kind\", \"Three of a Kind\", \"Three of a Kind\"]\n        if all(suits[i] == suits[0] for i in xrange(1, len(suits))):\n            return \"Flush\"\n        cnt = [0]*13\n        for x in ranks:\n            cnt[x-1] += 1\n        return LOOKUP[max(cnt)]\n"
    },
    {
        "problem_name": "best-position-for-a-service-centre",
        "solution": "# Time:  O(n * iter), iter is the number of iterations\n# Space: O(1)\n\n# see reference:\n# - https://en.wikipedia.org/wiki/Geometric_median\n# - https://wikimedia.org/api/rest_v1/media/math/render/svg/b3fb215363358f12687100710caff0e86cd9d26b\n# Weiszfeld's algorithm\nclass Solution(object):\n    def getMinDistSum(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: float\n        \"\"\"\n        EPS = 1e-6\n        def norm(p1, p2):\n            return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)**0.5\n        \n        def geometry_median(positions, median):\n            numerator, denominator = [0.0, 0.0], 0.0\n            for p in positions:\n                l = norm(median, p)\n                if not l:\n                    continue                       \n                numerator[0] += p[0]/l\n                numerator[1] += p[1]/l\n                denominator += 1/l\n            if denominator == 0.0:\n                return True, None\n            return False, [numerator[0]/denominator, numerator[1]/denominator]\n\n        median = [float(sum(p[0] for p in positions))/len(positions),\n                  float(sum(p[1] for p in positions))/len(positions)]\n        prev_median = [float(\"-inf\"), float(\"-inf\")]\n        while norm(median, prev_median)*len(positions) > EPS:\n            stopped, new_median = geometry_median(positions, median)\n            if stopped:\n                break\n            median, prev_median = new_median, median\n        return sum(norm(median, p) for p in positions)\n\n\n# Time:  O(n * iter), iter is the number of iterations\n# Space: O(1)\nclass Solution2(object):\n    def getMinDistSum(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: float\n        \"\"\"\n        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        EPS = 1e-6\n        def dist(positions, p):\n            return sum(((p[0]-x)**2 + (p[1]-y)**2)**0.5 for x, y in positions)\n        \n        median = [0.0, 0.0]\n        median[0] = float(sum(x for x, _ in positions))/len(positions)\n        median[1] = float(sum(y for _, y in positions))/len(positions)\n        result = dist(positions, median)\n        delta = float(max(max(positions, key=lambda x: x[0])[0],\n                          max(positions, key=lambda x: x[1])[1])) - \\\n                float(min(min(positions, key=lambda x: x[0])[0],\n                          min(positions, key=lambda x: x[1])[1]))\n        while delta > EPS:\n            for dx, dy in DIRECTIONS:\n                new_median = [median[0] + delta*dx, median[1] + delta*dy]\n                nd = dist(positions, new_median)\n                if nd < result: \n                    result = nd \n                    median = new_median\n                    break \n            else:\n                delta /= 2.0\n        return result \n"
    },
    {
        "problem_name": "best-sightseeing-pair",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxScoreSightseeingPair(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = 0, 0\n        for x in A:\n            result = max(result, curr+x)\n            curr = max(curr, x)-1\n        return result\n"
    },
    {
        "problem_name": "best-team-with-no-conflicts",
        "solution": "# Time:  O(nloga)\n# Space: O(n)\n\n# Range Maximum Query\nclass SegmentTree(object):  # 0-based index\n    def __init__(self, N,\n                 build_fn=lambda x, y: [y]*(2*x),\n                 query_fn=lambda x, y: y if x is None else max(x, y),  # (lambda x, y: y if x is None else min(x, y))\n                 update_fn=lambda x, y: y,\n                 default_val=0):\n        self.N = N\n        self.H = (N-1).bit_length()\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        self.default_val = default_val\n        self.tree = build_fn(N, default_val)\n        self.lazy = [None]*N\n\n    def __apply(self, x, val):\n        self.tree[x] = self.update_fn(self.tree[x], val)\n        if x < self.N:\n            self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n    def update(self, L, R, h):  # Time: O(logN), Space: O(N)\n        def pull(x):\n            while x > 1:\n                x //= 2\n                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n                if self.lazy[x] is not None:\n                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\n\n        L += self.N\n        R += self.N\n        L0, R0 = L, R\n        while L <= R:\n            if L & 1:  # is right child\n                self.__apply(L, h) \n                L += 1\n            if R & 1 == 0:  # is left child\n                self.__apply(R, h)\n                R -= 1\n            L //= 2\n            R //= 2\n        pull(L0)\n        pull(R0)\n\n    def query(self, L, R):  # Time: O(logN), Space: O(N)\n        def push(x):\n            n = 2**self.H\n            while n != 1:\n                y = x // n\n                if self.lazy[y] is not None:\n                    self.__apply(y*2, self.lazy[y])\n                    self.__apply(y*2 + 1, self.lazy[y])\n                    self.lazy[y] = None\n                n //= 2\n\n        result = None\n        if L > R:\n            return result\n\n        L += self.N\n        R += self.N\n        push(L)\n        push(R)\n        while L <= R:\n            if L & 1:  # is right child\n                result = self.query_fn(result, self.tree[L])\n                L += 1\n            if R & 1 == 0:  # is left child\n                result = self.query_fn(result, self.tree[R])\n                R -= 1\n            L //= 2\n            R //= 2\n        return result\n    \n    def __str__(self):\n        showList = []\n        for i in xrange(self.N):\n            showList.append(self.query(i, i))\n        return \",\".join(map(str, showList))\n\n\n# optimized from Solution3\nclass Solution(object):\n    def bestTeamScore(self, scores, ages):\n        \"\"\"\n        :type scores: List[int]\n        :type ages: List[int]\n        :rtype: int\n        \"\"\"\n        players = sorted(zip(scores, ages))\n        sorted_ages = sorted(set(ages))\n        lookup = {age:i for i, age in enumerate(sorted_ages)}  # coordinate compression\n        segment_tree = SegmentTree(len(lookup))\n        result = 0\n        for score, age in players:\n            segment_tree.update(lookup[age], lookup[age], segment_tree.query(0, lookup[age])+score)\n        return segment_tree.query(0, len(lookup)-1)\n\n\n# Time:  O(nlogs)\n# Space: O(n)\n# optimized from Solution4\nclass Solution2(object):\n    def bestTeamScore(self, scores, ages):\n        \"\"\"\n        :type scores: List[int]\n        :type ages: List[int]\n        :rtype: int\n        \"\"\"\n        players = sorted(zip(ages, scores))\n        sorted_scores = sorted(set(scores))\n        lookup = {score:i for i, score in enumerate(sorted_scores)}  # coordinate compression\n        segment_tree = SegmentTree(len(lookup))\n        result = 0\n        for age, score in players:\n            segment_tree.update(lookup[score], lookup[score], segment_tree.query(0, lookup[score])+score)\n        return segment_tree.query(0, len(lookup)-1)\n \n\n# Time:  O(n * a)\n# Space: O(n)\nimport collections\n\n\n# optimized from Solution5\nclass Solution3(object):\n    def bestTeamScore(self, scores, ages):\n        \"\"\"\n        :type scores: List[int]\n        :type ages: List[int]\n        :rtype: int\n        \"\"\"\n        players = sorted(zip(scores, ages))\n        sorted_ages = sorted(set(ages))\n        dp = collections.defaultdict(int)\n        result = 0\n        for score, age in players:\n            dp[age] = max(dp[a] for a in sorted_ages if a <= age) + score\n        return max(dp.itervalues())\n\n\n# Time:  O(n * s)\n# Space: O(n)\nimport collections\n\n\n# optimized from Solution6\nclass Solution4(object):\n    def bestTeamScore(self, scores, ages):\n        \"\"\"\n        :type scores: List[int]\n        :type ages: List[int]\n        :rtype: int\n        \"\"\"\n        players = sorted(zip(ages, scores))\n        sorted_scores = sorted(set(scores))\n        dp = collections.defaultdict(int)\n        result = 0\n        for age, score in players:\n            dp[score] = max(dp[s] for s in sorted_scores if s <= score) + score\n        return max(dp.itervalues())\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# longest_increasing_subsequence like dp solution\nclass Solution5(object):\n    def bestTeamScore(self, scores, ages):\n        \"\"\"\n        :type scores: List[int]\n        :type ages: List[int]\n        :rtype: int\n        \"\"\"\n        players = sorted(zip(scores, ages))\n        dp = [0]*len(players)\n        result = 0\n        for i in xrange(len(players)):\n            dp[i] = players[i][0]\n            for j in xrange(i):\n                if players[j][1] <= players[i][1]:\n                    dp[i] = max(dp[i], dp[j] + players[i][0])\n            result = max(result, dp[i])\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# longest_increasing_subsequence like dp solution\nclass Solution6(object):\n    def bestTeamScore(self, scores, ages):\n        \"\"\"\n        :type scores: List[int]\n        :type ages: List[int]\n        :rtype: int\n        \"\"\"\n        players = sorted(zip(ages, scores))\n        dp = [0]*len(players)\n        result = 0\n        for i in xrange(len(players)):\n            dp[i] = players[i][1]\n            for j in xrange(i):\n                if players[j][1] <= players[i][1]:\n                    dp[i] = max(dp[i], dp[j] + players[i][1])\n            result = max(result, dp[i])\n        return result\n"
    },
    {
        "problem_name": "best-time-to-buy-and-sell-stock-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n\nclass Solution(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        profit = 0\n        for i in xrange(len(prices) - 1):\n            profit += max(0, prices[i + 1] - prices[i])\n        return profit\n\n    def maxProfit2(self, prices):\n        return sum(map(lambda x: max(prices[x + 1] - prices[x], 0),\n                       xrange(len(prices[:-1]))))\n\n"
    },
    {
        "problem_name": "best-time-to-buy-and-sell-stock-iii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        hold1, hold2 = float(\"-inf\"), float(\"-inf\")\n        release1, release2 = 0, 0\n        for i in prices:\n            release1 = max(release1, hold1 + i)\n            hold1 = max(hold1, -i)\n            release2 = max(release2, hold2 + i)\n            hold2 = max(hold2, release1 - i)\n        return release2\n\n\n# Time:  O(k * n)\n# Space: O(k)\nclass Solution2(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        def maxAtMostKPairsProfit(prices, k):\n            max_buy = [float(\"-inf\") for _ in xrange(k + 1)]\n            max_sell = [0 for _ in xrange(k + 1)]\n            for i in xrange(len(prices)):\n                for j in xrange(1, k + 1):\n                    max_buy[j] = max(max_buy[j], max_sell[j-1] - prices[i])\n                    max_sell[j] = max(max_sell[j], max_buy[j] + prices[i])\n            return max_sell[k]\n\n        return maxAtMostKPairsProfit(prices, 2)\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution3(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        min_price, max_profit_from_left, max_profits_from_left = \\\n            float(\"inf\"), 0, []\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit_from_left = max(max_profit_from_left, price - min_price)\n            max_profits_from_left.append(max_profit_from_left)\n\n        max_price, max_profit_from_right, max_profits_from_right = 0, 0, []\n        for i in reversed(range(len(prices))):\n            max_price = max(max_price, prices[i])\n            max_profit_from_right = max(max_profit_from_right,\n                                        max_price - prices[i])\n            max_profits_from_right.insert(0, max_profit_from_right)\n\n        max_profit = 0\n        for i in range(len(prices)):\n            max_profit = max(max_profit,\n                             max_profits_from_left[i] +\n                             max_profits_from_right[i])\n\n        return max_profit\n\n"
    },
    {
        "problem_name": "best-time-to-buy-and-sell-stock-iv",
        "solution": "# Time:  O(n) on average, using Median of Medians could achieve O(n) (Intro Select)\n# Space: O(n)\n\nimport random\n\n\nclass Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        profits = []\n        v_p_stk = []  # mono stack, where v is increasing and p is strictly decreasing\n        v, p = -1, -1\n        while p+1 < len(prices): # at most O(n) peaks, so v_p_stk and profits are both at most O(n) space\n            for v in xrange(p+1, len(prices)-1):\n                if prices[v] < prices[v+1]:\n                    break\n            else:\n                v = len(prices)-1\n            for p in xrange(v, len(prices)-1):\n                if prices[p] > prices[p+1]:\n                    break \n            else:\n                p = len(prices)-1\n            while v_p_stk and prices[v_p_stk[-1][0]] > prices[v]:  # not overlapped\n                last_v, last_p = v_p_stk.pop()\n                profits.append(prices[last_p]-prices[last_v])  # count [prices[last_v], prices[last_p]] interval\n            while v_p_stk and prices[v_p_stk[-1][1]] <= prices[p]:  # overlapped\n                # prices[last_v] <= prices[v] <= prices[last_p] <= prices[p],\n                # treat overlapped as [prices[v], prices[last_p]], [prices[last_v], prices[p]] intervals due to invariant max profit\n                last_v, last_p = v_p_stk.pop()\n                profits.append(prices[last_p]-prices[v])  # count [prices[v], prices[last_p]] interval\n                v = last_v\n            v_p_stk.append((v, p))  # keep [prices[last_v], prices[p]] interval to check overlapped      \n        while v_p_stk:\n            last_v, last_p = v_p_stk.pop()\n            profits.append(prices[last_p]-prices[last_v])  # count [prices[last_v], prices[last_p]] interval\n        if k > len(profits):\n            k = len(profits)\n        else:\n            nth_element(profits, k-1, compare=lambda a, b: a > b)\n        return sum(profits[i] for i in xrange(k))  # top k profits of nonoverlapped intervals\n\n\n# Time:  O(k * n)\n# Space: O(k)\nclass Solution2(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        def maxAtMostNPairsProfit(sprices):\n            profit = 0\n            for i in xrange(len(prices) - 1):\n                profit += max(0, prices[i + 1] - prices[i])\n            return profit\n\n        def maxAtMostKPairsProfit(prices, k):\n            max_buy = [float(\"-inf\") for _ in xrange(k + 1)]\n            max_sell = [0 for _ in xrange(k + 1)]\n            for i in xrange(len(prices)):\n                for j in xrange(1, k + 1):\n                    max_buy[j] = max(max_buy[j], max_sell[j-1] - prices[i])\n                    max_sell[j] = max(max_sell[j], max_buy[j] + prices[i])\n            return max_sell[k]\n\n        if k >= len(prices) // 2:\n            return maxAtMostNPairsProfit(prices)\n\n        return maxAtMostKPairsProfit(prices, k)\n"
    },
    {
        "problem_name": "best-time-to-buy-and-sell-stock-with-cooldown",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n\nclass Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        buy, sell, coolDown = [0] * 2, [0] * 2, [0] * 2\n        buy[0] = -prices[0]\n        for i in xrange(1, len(prices)):\n            # Bought before or buy today.\n            buy[i % 2] = max(buy[(i - 1) % 2],\n                             coolDown[(i - 1) % 2] - prices[i])\n            # Sell today.\n            sell[i % 2] = buy[(i - 1) % 2] + prices[i]\n            # Sold before yesterday or sold yesterday.\n            coolDown[i % 2] = max(coolDown[(i - 1) % 2], sell[(i - 1) % 2])\n        return max(coolDown[(len(prices) - 1) % 2],\n                   sell[(len(prices) - 1) % 2])\n\n"
    },
    {
        "problem_name": "best-time-to-buy-and-sell-stock-with-transaction-fee",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n\nclass Solution(object):\n    def maxProfit(self, prices, fee):\n        \"\"\"\n        :type prices: List[int]\n        :type fee: int\n        :rtype: int\n        \"\"\"\n        cash, hold = 0, -prices[0]\n        for i in xrange(1, len(prices)):\n            cash = max(cash, hold+prices[i]-fee)\n            hold = max(hold, cash-prices[i])\n        return cash\n\n"
    },
    {
        "problem_name": "best-time-to-buy-and-sell-stock",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param prices, a list of integer\n    # @return an integer\n    def maxProfit(self, prices):\n        max_profit, min_price = 0, float(\"inf\")\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit\n\n"
    },
    {
        "problem_name": "binary-gap",
        "solution": "# Time:  O(logn) = O(1) due to n is a 32-bit number\n# Space: O(1)\n\nclass Solution(object):\n    def binaryGap(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        last = None\n        for i in xrange(32):\n            if (N >> i) & 1:\n                if last is not None:\n                    result = max(result, i-last)\n                last = i\n        return result\n\n"
    },
    {
        "problem_name": "binary-number-with-alternating-bits",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def hasAlternatingBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        n, curr = divmod(n, 2)\n        while n > 0:\n            if curr == n % 2:\n                return False\n            n, curr = divmod(n, 2)\n        return True\n\n"
    },
    {
        "problem_name": "binary-prefix-divisible-by-5",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def prefixesDivBy5(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[bool]\n        \"\"\"\n        for i in xrange(1, len(A)):\n            A[i] += A[i-1] * 2 % 5\n        return [x % 5 == 0 for x in A]\n"
    },
    {
        "problem_name": "binary-search-tree-iterator-ii",
        "solution": "# Time:  O(1), amortized\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass BSTIterator(object):\n\n    def __init__(self, root):\n        \"\"\"\n        :type root: TreeNode\n        \"\"\"\n        self.__stk = []\n        self.__traversalLeft(root)\n        self.__vals = []\n        self.__pos = -1\n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return self.__pos+1 != len(self.__vals) or self.__stk\n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.__pos += 1\n        if self.__pos == len(self.__vals):\n            node = self.__stk.pop()\n            self.__traversalLeft(node.right)\n            self.__vals.append(node.val)\n        return self.__vals[self.__pos]\n        \n    def hasPrev(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return self.__pos-1 >= 0\n\n    def prev(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.__pos -= 1\n        return self.__vals[self.__pos]\n    \n    def __traversalLeft(self, node):\n        while node is not None:\n            self.__stk.append(node)\n            node = node.left\n\n"
    },
    {
        "problem_name": "binary-search-tree-iterator",
        "solution": "# Time:  O(1)\n# Space: O(h), h is height of binary tree\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass BSTIterator(object):\n    # @param root, a binary search tree's root node\n    def __init__(self, root):\n        self.__stk = []\n        self.__traversalLeft(root)\n\n    # @return a boolean, whether we have a next smallest number\n    def hasNext(self):\n        return self.__stk\n\n    # @return an integer, the next smallest number\n    def next(self):\n        node = self.__stk.pop()\n        self.__traversalLeft(node.right)\n        return node.val\n    \n    def __traversalLeft(self, node):\n        while node is not None:\n            self.__stk.append(node)\n            node = node.left\n\n"
    },
    {
        "problem_name": "binary-search-tree-to-greater-sum-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def bstToGst(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        def bstToGstHelper(root, prev):\n            if not root:\n                return root\n            bstToGstHelper(root.right, prev)\n            root.val += prev[0]\n            prev[0] = root.val\n            bstToGstHelper(root.left, prev)\n            return root\n        \n        prev = [0]\n        return bstToGstHelper(root, prev)\n"
    },
    {
        "problem_name": "binary-search",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if nums[mid] > target:\n                right = mid-1\n            elif nums[mid] < target:\n                left = mid+1\n            else:\n                return mid\n        return -1\n\n"
    },
    {
        "problem_name": "binary-searchable-numbers-in-an-unsorted-array",
        "solution": "\n# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def binarySearchableNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        right = [float(\"inf\")]*(len(nums)+1)\n        for i in reversed(xrange(1, len(nums)+1)):\n            right[i-1] = min(right[i], nums[i-1])\n        result, left = set(), float(\"-inf\")\n        for i in xrange(len(nums)):\n            if left <= nums[i] <= right[i+1]:\n                result.add(nums[i])\n            left = max(left, nums[i])\n        return len(result)\n"
    },
    {
        "problem_name": "binary-string-with-substrings-representing-1-to-n",
        "solution": "# Time:  O(n^2), n is the length of S\n# Space: O(1)\n\nclass Solution(object):\n    def queryString(self, S, N):\n        \"\"\"\n        :type S: str\n        :type N: int\n        :rtype: bool\n        \"\"\"\n        # since S with length n has at most different n-k+1 k-digit numbers\n        # => given S with length n, valid N is at most 2(n-k+1)\n        # => valid N <= 2(n-k+1) < 2n = 2 * S.length\n        return all(bin(i)[2:] in S for i in reversed(xrange(N//2, N+1)))\n"
    },
    {
        "problem_name": "binary-subarrays-with-sum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Two pointers solution\nclass Solution(object):\n    def numSubarraysWithSum(self, A, S):\n        \"\"\"\n        :type A: List[int]\n        :type S: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        left, right, sum_left, sum_right = 0, 0, 0, 0\n        for i, a in enumerate(A):\n            sum_left += a\n            while left < i and sum_left > S:\n                sum_left -= A[left]\n                left += 1\n            sum_right += a\n            while right < i and \\\n                  (sum_right > S or (sum_right == S and not A[right])):\n                sum_right -= A[right]\n                right += 1\n            if sum_left == S:\n                result += right-left+1\n        return result\n"
    },
    {
        "problem_name": "binary-tree-cameras",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def minCameraCover(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        UNCOVERED, COVERED, CAMERA = range(3)\n        def dfs(root, result):\n            left = dfs(root.left, result) if root.left else COVERED\n            right = dfs(root.right, result) if root.right else COVERED\n            if left == UNCOVERED or right == UNCOVERED:\n                result[0] += 1\n                return CAMERA\n            if left == CAMERA or right == CAMERA:\n                return COVERED\n            return UNCOVERED\n        \n        result = [0]\n        if dfs(root, result) == UNCOVERED:\n            result[0] += 1\n        return result[0]\n"
    },
    {
        "problem_name": "binary-tree-coloring-game",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def btreeGameWinningMove(self, root, n, x):\n        \"\"\"\n        :type root: TreeNode\n        :type n: int\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        def count(node, x, left_right):\n            if not node:\n                return 0\n            left, right = count(node.left, x, left_right), count(node.right, x, left_right)\n            if node.val == x:\n                left_right[0], left_right[1] = left, right\n            return left + right + 1\n\n        left_right = [0, 0]\n        count(root, x, left_right)\n        blue = max(max(left_right), n-(sum(left_right)+1))\n        return blue > n-blue\n"
    },
    {
        "problem_name": "binary-tree-inorder-traversal",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n# Morris Traversal Solution\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result, curr = [], root\n        while curr:\n            if curr.left is None:\n                result.append(curr.val)\n                curr = curr.right\n            else:\n                node = curr.left\n                while node.right and node.right != curr:\n                    node = node.right\n\n                if node.right is None:\n                    node.right = curr\n                    curr = curr.left\n                else:\n                    result.append(curr.val)\n                    node.right = None\n                    curr = curr.right\n\n        return result\n\n\n# Time:  O(n)\n# Space: O(h)\n# Stack Solution\nclass Solution2(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result, stack = [], [(root, False)]\n        while stack:\n            root, is_visited = stack.pop()\n            if root is None:\n                continue\n            if is_visited:\n                result.append(root.val)\n            else:\n                stack.append((root.right, False))\n                stack.append((root, True))\n                stack.append((root.left, False))\n        return result\n\n"
    },
    {
        "problem_name": "binary-tree-level-order-traversal-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if root is None:\n            return []\n\n        result, current = [], [root]\n        while current:\n            next_level, vals = [], []\n            for node in current:\n                vals.append(node.val)\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)\n            current = next_level\n            result.append(vals)\n\n        return result[::-1]\n\n"
    },
    {
        "problem_name": "binary-tree-level-order-traversal",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a list of lists of integers\n    def levelOrder(self, root):\n        if root is None:\n            return []\n        result, current = [], [root]\n        while current:\n            next_level, vals = [], []\n            for node in current:\n                vals.append(node.val)\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)\n            current = next_level\n            result.append(vals)\n        return result\n\n"
    },
    {
        "problem_name": "binary-tree-longest-consecutive-sequence-ii",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def longestConsecutive(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def longestConsecutiveHelper(root):\n            if not root:\n                return 0, 0\n            left_len = longestConsecutiveHelper(root.left)\n            right_len = longestConsecutiveHelper(root.right)\n            cur_inc_len, cur_dec_len = 1, 1\n            if root.left:\n                if root.left.val == root.val + 1:\n                    cur_inc_len = max(cur_inc_len, left_len[0] + 1)\n                elif root.left.val == root.val - 1:\n                    cur_dec_len = max(cur_dec_len, left_len[1] + 1)\n            if root.right:\n                if root.right.val == root.val + 1:\n                    cur_inc_len = max(cur_inc_len, right_len[0] + 1)\n                elif root.right.val == root.val - 1:\n                    cur_dec_len = max(cur_dec_len, right_len[1] + 1)\n            self.max_len = max(self.max_len, cur_dec_len + cur_inc_len - 1)\n            return cur_inc_len, cur_dec_len\n\n        self.max_len = 0\n        longestConsecutiveHelper(root)\n        return self.max_len\n\n"
    },
    {
        "problem_name": "binary-tree-longest-consecutive-sequence",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def longestConsecutive(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        self.max_len = 0\n\n        def longestConsecutiveHelper(root):\n            if not root:\n                return 0\n\n            left_len = longestConsecutiveHelper(root.left)\n            right_len = longestConsecutiveHelper(root.right)\n\n            cur_len = 1\n            if root.left and root.left.val == root.val + 1:\n                cur_len = max(cur_len, left_len + 1)\n            if root.right and root.right.val == root.val + 1:\n                cur_len = max(cur_len, right_len + 1)\n\n            self.max_len = max(self.max_len, cur_len)\n\n            return cur_len\n\n        longestConsecutiveHelper(root)\n        return self.max_len\n\n"
    },
    {
        "problem_name": "binary-tree-maximum-path-sum",
        "solution": "# Time:  O(n)\n# Space: O(h), h is height of binary tree\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return an integer\n    def maxPathSum(self, root):\n        def iter_dfs(node):\n            result = float(\"-inf\")\n            max_sum = [0]\n            stk = [(1, [node, max_sum])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    result = max(result, node.val+max(ret1[0], 0)+max(ret2[0], 0))\n                    ret[0] = node.val+max(ret1[0], ret2[0], 0)\n            return result\n        \n        return iter_dfs(root)\n\n\n# Time:  O(n)\n# Space: O(h), h is height of binary tree\nclass Solution2(object):\n    # @param root, a tree node\n    # @return an integer\n    def maxPathSum(self, root):\n        def dfs(node):\n            if not node:\n                return (float(\"-inf\"), 0)\n            max_left, curr_left = dfs(node.left)\n            max_right, curr_right = dfs(node.right)\n            return (max(max_left, max_right, node.val+max(curr_left, 0)+max(curr_right, 0)),\n                    node.val+max(curr_left, curr_right, 0))\n        \n        return dfs(root)[0]\n"
    },
    {
        "problem_name": "binary-tree-paths",
        "solution": "# Time:  O(n * h)\n# Space: O(h)\n\nclass Solution(object):\n    # @param {TreeNode} root\n    # @return {string[]}\n    def binaryTreePaths(self, root):\n        result, path = [], []\n        self.binaryTreePathsRecu(root, path, result)\n        return result\n\n    def binaryTreePathsRecu(self, node, path, result):\n        if node is None:\n            return\n\n        if node.left is node.right is None:\n            ans = \"\"\n            for n in path:\n                ans += str(n.val) + \"->\"\n            result.append(ans + str(node.val))\n\n        if node.left:\n            path.append(node)\n            self.binaryTreePathsRecu(node.left, path, result)\n            path.pop()\n\n        if node.right:\n            path.append(node)\n            self.binaryTreePathsRecu(node.right, path, result)\n            path.pop()\n\n"
    },
    {
        "problem_name": "binary-tree-postorder-traversal",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n# Morris Traversal Solution\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        dummy = TreeNode(0)\n        dummy.left = root\n        result, cur = [], dummy\n        while cur:\n            if cur.left is None:\n                cur = cur.right\n            else:\n                node = cur.left\n                while node.right and node.right != cur:\n                    node = node.right\n\n                if node.right is None:\n                    node.right = cur\n                    cur = cur.left\n                else:\n                    result += self.traceBack(cur.left, node)\n                    node.right = None\n                    cur = cur.right\n\n        return result\n\n    def traceBack(self, frm, to):\n        result, cur = [], frm\n        while cur is not to:\n            result.append(cur.val)\n            cur = cur.right\n        result.append(to.val)\n        result.reverse()\n        return result\n\n\n# Time:  O(n)\n# Space: O(h)\n# Stack Solution\nclass Solution2(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result, stack = [], [(root, False)]\n        while stack:\n            root, is_visited = stack.pop()\n            if root is None:\n                continue\n            if is_visited:\n                result.append(root.val)\n            else:\n                stack.append((root, True))\n                stack.append((root.right, False))\n                stack.append((root.left, False))\n        return result\n\n"
    },
    {
        "problem_name": "binary-tree-preorder-traversal",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n# Morris Traversal Solution\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result, curr = [], root\n        while curr:\n            if curr.left is None:\n                result.append(curr.val)\n                curr = curr.right\n            else:\n                node = curr.left\n                while node.right and node.right != curr:\n                    node = node.right\n\n                if node.right is None:\n                    result.append(curr.val)\n                    node.right = curr\n                    curr = curr.left\n                else:\n                    node.right = None\n                    curr = curr.right\n\n        return result\n\n\n# Time:  O(n)\n# Space: O(h)\n# Stack Solution\nclass Solution2(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result, stack = [], [(root, False)]\n        while stack:\n            root, is_visited = stack.pop()\n            if root is None:\n                continue\n            if is_visited:\n                result.append(root.val)\n            else:\n                stack.append((root.right, False))\n                stack.append((root.left, False))\n                stack.append((root, True))\n        return result\n\n"
    },
    {
        "problem_name": "binary-tree-pruning",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def pruneTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n        root.left = self.pruneTree(root.left)\n        root.right = self.pruneTree(root.right)\n        if not root.left and not root.right and root.val == 0:\n            return None\n        return root\n\n"
    },
    {
        "problem_name": "binary-tree-right-side-view",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a list of integers\n    def rightSideView(self, root):\n        result = []\n        self.rightSideViewDFS(root, 1, result)\n        return result\n\n    def rightSideViewDFS(self, node, depth, result):\n        if not node:\n            return\n\n        if depth > len(result):\n            result.append(node.val)\n\n        self.rightSideViewDFS(node.right, depth+1, result)\n        self.rightSideViewDFS(node.left, depth+1, result)\n\n\n# BFS solution\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    # @param root, a tree node\n    # @return a list of integers\n    def rightSideView(self, root):\n        if root is None:\n            return []\n\n        result, current = [], [root]\n        while current:\n            next_level = []\n            for node in current:\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)                \n            result.append(node.val)\n            current = next_level\n\n        return result\n\n"
    },
    {
        "problem_name": "binary-tree-tilt",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def findTilt(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def postOrderTraverse(root, tilt):\n            if not root:\n                return 0, tilt\n            left, tilt = postOrderTraverse(root.left, tilt)\n            right, tilt = postOrderTraverse(root.right, tilt)\n            tilt += abs(left-right)\n            return left+right+root.val, tilt\n\n        return postOrderTraverse(root, 0)[1]\n\n"
    },
    {
        "problem_name": "binary-tree-upside-down",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return root of the upside down tree\n    def upsideDownBinaryTree(self, root):\n        p, parent, parent_right = root, None, None\n\n        while p:\n            left = p.left\n            p.left = parent_right\n            parent_right = p.right\n            p.right = parent\n            parent = p\n            p = left\n\n        return parent\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    # @param root, a tree node\n    # @return root of the upside down tree\n    def upsideDownBinaryTree(self, root):\n        return self.upsideDownBinaryTreeRecu(root, None)\n\n    def upsideDownBinaryTreeRecu(self, p, parent):\n        if p is None:\n            return parent\n\n        root = self.upsideDownBinaryTreeRecu(p.left, p)\n        if parent:\n            p.left = parent.right\n        else:\n            p.left = None\n        p.right = parent\n\n        return root\n\n"
    },
    {
        "problem_name": "binary-tree-vertical-order-traversal",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# BFS + hash solution.\nclass Solution(object):\n    def verticalOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        cols = collections.defaultdict(list)\n        queue = [(root, 0)]\n        for node, i in queue:\n            if node:\n                cols[i].append(node.val)\n                queue += (node.left, i - 1), (node.right, i + 1)\n        return [cols[i] for i in xrange(min(cols.keys()),\n                                        max(cols.keys()) + 1)] if cols else []\n\n"
    },
    {
        "problem_name": "binary-tree-zigzag-level-order-traversal",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a list of lists of integers\n    def zigzagLevelOrder(self, root):\n        if root is None:\n            return []\n        result, current = [], [root]\n        while current:\n            next_level, vals = [], []\n            for node in current:\n                vals.append(node.val)\n                if node.left:\n                    next_level.append(node.left)\n                if node.right:\n                    next_level.append(node.right)\n            result.append(vals[::-1] if len(result) % 2 else vals)\n            current = next_level\n        return result\n"
    },
    {
        "problem_name": "binary-trees-with-factors",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\n\nclass Solution(object):\n    def numFactoredBinaryTrees(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        M = 10**9 + 7\n        A.sort()\n        dp = {}\n        for i in xrange(len(A)):\n            dp[A[i]] = 1\n            for j in xrange(i):\n                if A[i] % A[j] == 0 and A[i] // A[j] in dp:\n                    dp[A[i]] += dp[A[j]] * dp[A[i] // A[j]]\n                    dp[A[i]] %= M\n        return sum(dp.values()) % M\n\n"
    },
    {
        "problem_name": "binary-watch",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n\nclass Solution(object):\n    def readBinaryWatch(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[str]\n        \"\"\"\n        def bit_count(bits):\n            count = 0\n            while bits:\n                bits &= bits-1\n                count += 1\n            return count\n\n        return ['%d:%02d' % (h, m) for h in xrange(12) for m in xrange(60)\n                if bit_count(h) + bit_count(m) == num]\n\n    def readBinaryWatch2(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[str]\n        \"\"\"\n        return ['{0}:{1}'.format(str(h), str(m).zfill(2))\n                for h in range(12) for m in range(60)\n                if (bin(h) + bin(m)).count('1') == num]\n\n"
    },
    {
        "problem_name": "bitwise-and-of-numbers-range",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    # @param m, an integer\n    # @param n, an integer\n    # @return an integer\n    def rangeBitwiseAnd(self, m, n):\n        while m < n:\n            n &= n - 1\n        return n\n\n\nclass Solution2(object):\n    # @param m, an integer\n    # @param n, an integer\n    # @return an integer\n    def rangeBitwiseAnd(self, m, n):\n        i, diff = 0, n-m\n        while diff:\n            diff >>= 1\n            i += 1\n        return n & m >> i << i\n\n"
    },
    {
        "problem_name": "bitwise-or-of-all-subsequence-sums",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def subsequenceSumOr(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = prefix = 0\n        for x in nums:\n            prefix += x\n            result |= x|prefix\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# bit manipulation\nclass Solution2(object):\n    def subsequenceSumOr(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = cnt = 0\n        for i in xrange(64):\n            cnt >>= 1\n            for x in nums:\n                cnt += (x>>i)&1\n            if cnt:\n                result |= 1<<i\n        return result\n"
    },
    {
        "problem_name": "bitwise-ors-of-subarrays",
        "solution": "# Time:  O(32 * n)\n# Space: O(1)\n\nclass Solution(object):\n    def subarrayBitwiseORs(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = set(), {0}\n        for i in A:\n            curr = {i} | {i | j for j in curr}\n            result |= curr\n        return len(result)\n\n"
    },
    {
        "problem_name": "bitwise-xor-of-all-pairings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport operator\n\n\n# bit manipulation\nclass Solution(object):\n    def xorAllNums(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        return (reduce(operator.xor, nums1) if len(nums2)%2 else 0) ^ \\\n               (reduce(operator.xor, nums2) if len(nums1)%2 else 0)\n"
    },
    {
        "problem_name": "boats-to-save-people",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def numRescueBoats(self, people, limit):\n        \"\"\"\n        :type people: List[int]\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        people.sort()\n        result = 0\n        left, right = 0, len(people)-1\n        while left <= right:\n            result += 1\n            if people[left] + people[right] <= limit:\n                left += 1\n            right -= 1\n        return result\n\n"
    },
    {
        "problem_name": "bold-words-in-string",
        "solution": "# Time:  O(n * l), n is the length of S, l is the average length of words\n# Space: O(t)    , t is the size of trie\n\nimport collections\nimport functools\n\n\nclass Solution(object):\n    def boldWords(self, words, S):\n        \"\"\"\n        :type words: List[str]\n        :type S: str\n        :rtype: str\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        for i, word in enumerate(words):\n            functools.reduce(dict.__getitem__, word, trie).setdefault(\"_end\")\n\n        lookup = [False] * len(S)\n        for i in xrange(len(S)):\n            curr = trie\n            k = -1\n            for j in xrange(i, len(S)):\n                if S[j] not in curr:\n                    break\n                curr = curr[S[j]]\n                if \"_end\" in curr:\n                    k = j\n            for j in xrange(i, k+1):\n                lookup[j] = True\n\n        result = []\n        for i in xrange(len(S)):\n            if lookup[i] and (i == 0 or not lookup[i-1]):\n                result.append(\"<b>\")\n            result.append(S[i])\n            if lookup[i] and (i == len(S)-1 or not lookup[i+1]):\n                result.append(\"</b>\")\n        return \"\".join(result)\n\n\n# Time:  O(n * d * l), l is the average length of words\n# Space: O(n)\nclass Solution2(object):\n    def boldWords(self, words, S):\n        \"\"\"\n        :type words: List[str]\n        :type S: str\n        :rtype: str\n        \"\"\"\n        lookup = [0] * len(S)\n        for d in words:\n            pos = S.find(d)\n            while pos != -1:\n                lookup[pos:pos+len(d)] = [1] * len(d)\n                pos = S.find(d, pos+1)\n\n        result = []\n        for i in xrange(len(S)):\n            if lookup[i] and (i == 0 or not lookup[i-1]):\n                result.append(\"<b>\")\n            result.append(S[i])\n            if lookup[i] and (i == len(S)-1 or not lookup[i+1]):\n                result.append(\"</b>\")\n        return \"\".join(result)\n\n"
    },
    {
        "problem_name": "bomb-enemy",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\n\nclass Solution(object):\n    def maxKilledEnemies(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        result = 0\n        if not grid or not grid[0]:\n            return result\n\n        down = [[0 for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))]\n        right = [[0 for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))]\n        for i in reversed(xrange(len(grid))):\n            for j in reversed(xrange(len(grid[0]))):\n                if grid[i][j] != 'W':\n                    if i + 1 < len(grid):\n                        down[i][j] = down[i + 1][j]\n                    if j + 1 < len(grid[0]):\n                        right[i][j] = right[i][j + 1]\n                    if grid[i][j] == 'E':\n                        down[i][j] += 1\n                        right[i][j] += 1\n\n        up = [0 for _ in xrange(len(grid[0]))]\n        for i in xrange(len(grid)):\n            left = 0\n            for j in xrange(len(grid[0])):\n                if grid[i][j] == 'W':\n                    up[j], left = 0, 0\n                elif grid[i][j] == 'E':\n                    up[j] += 1\n                    left += 1\n                else:\n                    result = max(result,\n                                 left + up[j] + right[i][j] + down[i][j])\n\n        return result\n\n"
    },
    {
        "problem_name": "booking-concert-tickets-in-groups",
        "solution": "# Time:  ctor:    O(n)\n#        gather:  O(logn)\n#        scatter: O(logn), amortized\n# Space: O(n)\n\n# Template:\n# https://github.com/kamyu104/LeetCode-Solutions/blob/master/Python/longest-substring-of-one-repeating-character.py\nclass SegmentTree(object):\n    def __init__(self, N,\n                 build_fn=lambda _: float(\"inf\"),\n                 query_fn=lambda x, y: y if x is None else x if y is None else min(x, y),\n                 update_fn=lambda x: x):\n        self.tree = [None]*(2*2**((N-1).bit_length()))\n        self.base = len(self.tree)//2\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        for i in xrange(self.base, self.base+N):\n            self.tree[i] = build_fn(i-self.base)\n        for i in reversed(xrange(1, self.base)):\n            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n\n    def update(self, i, h):\n        x = self.base+i\n        self.tree[x] = self.update_fn(h)\n        while x > 1:\n            x //= 2\n            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n\n    def query(self, L, R):\n        L += self.base\n        R += self.base\n        left = right = None\n        while L <= R:\n            if L & 1:\n                left = self.query_fn(left, self.tree[L])\n                L += 1\n            if R & 1 == 0:\n                right = self.query_fn(self.tree[R], right)\n                R -= 1\n            L //= 2\n            R //= 2\n        return self.query_fn(left, right)\n\n\n# design, segment tree, binary search\nclass BookMyShow(object):\n\n    def __init__(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        \"\"\"\n        self.__st = SegmentTree(n,\n                                build_fn=lambda _: [m]*2,\n                                query_fn=lambda x, y: y if x is None else x if y is None else [max(x[0], y[0]), x[1]+y[1]])\n        self.__m = m\n        self.__i = 0\n\n    def gather(self, k, maxRow):\n        \"\"\"\n        :type k: int\n        :type maxRow: int\n        :rtype: List[int]\n        \"\"\"\n        i = 1\n        if k > self.__st.tree[i][0]:\n            return []\n        while i < self.__st.base:\n            i = 2*i+int(self.__st.tree[2*i][0] < k)\n        if i-self.__st.base > maxRow:\n            return []\n        cnt = self.__st.tree[i][0]\n        c = self.__m-cnt\n        i -= self.__st.base\n        self.__st.update(i, [cnt-k]*2)\n        return [i, c]\n\n    def scatter(self, k, maxRow):\n        \"\"\"\n        :type k: int\n        :type maxRow: int\n        :rtype: bool\n        \"\"\"\n        cnt = self.__st.query(self.__i, maxRow)\n        if not cnt or cnt[1] < k:\n            return False\n        for i in xrange(self.__i, maxRow+1):\n            cnt = self.__st.tree[self.__st.base+i][1]\n            c = min(cnt, k)\n            cnt -= c\n            if not cnt:\n                self.__i += 1\n            self.__st.update(i, [cnt]*2)\n            k -= c\n            if not k:\n                break\n        return True\n"
    },
    {
        "problem_name": "boundary-of-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def boundaryOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        def leftBoundary(root, nodes):\n            if not root or (not root.left and not root.right):\n                return\n            nodes.append(root.val)\n            if not root.left:\n                leftBoundary(root.right, nodes)\n            else:\n                leftBoundary(root.left, nodes)\n\n        def rightBoundary(root, nodes):\n            if not root or (not root.left and not root.right):\n                return\n            if not root.right:\n                rightBoundary(root.left, nodes)\n            else:\n                rightBoundary(root.right, nodes)\n            nodes.append(root.val)\n\n        def leaves(root, nodes):\n            if not root:\n                return\n            if not root.left and not root.right:\n                nodes.append(root.val)\n                return\n            leaves(root.left, nodes)\n            leaves(root.right, nodes)\n\n        if not root:\n            return []\n\n        nodes = [root.val]\n        leftBoundary(root.left, nodes)\n        leaves(root.left, nodes)\n        leaves(root.right, nodes)\n        rightBoundary(root.right, nodes)\n        return nodes\n\n"
    },
    {
        "problem_name": "brace-expansion-ii",
        "solution": "# Time:  O(p*l * log(p*l)), p is the production of all number of options\n#                         , l is the length of a word\n# Space: O(p*l)\n\nimport itertools\n\n\nclass Solution(object):\n    def braceExpansionII(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: List[str]\n        \"\"\"\n        def form_words(options):\n            words = map(\"\".join, itertools.product(*options))\n            words.sort()\n            return words\n\n        def generate_option(expr, i):\n            option_set = set()\n            while i[0] != len(expr) and expr[i[0]] != \"}\":\n                i[0] += 1  # { or ,\n                for option in generate_words(expr, i):\n                    option_set.add(option)\n            i[0] += 1  # }\n            option = list(option_set)\n            option.sort()\n            return option\n\n        def generate_words(expr, i):\n            options = []\n            while i[0] != len(expr) and expr[i[0]] not in \",}\":\n                tmp = []\n                if expr[i[0]] not in \"{,}\":\n                    tmp.append(expr[i[0]])\n                    i[0] += 1  # a-z\n                elif expr[i[0]] == \"{\":\n                    tmp = generate_option(expr, i)\n                options.append(tmp)\n            return form_words(options)\n\n        return generate_words(expression, [0])\n\n\nclass Solution2(object):\n    def braceExpansionII(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: List[str]\n        \"\"\"\n        def form_words(options):\n            words = []\n            total = 1\n            for opt in options:\n                total *= len(opt)\n            for i in xrange(total):\n                tmp = []\n                for opt in reversed(options):\n                    i, c = divmod(i, len(opt))\n                    tmp.append(opt[c])\n                tmp.reverse()\n                words.append(\"\".join(tmp))\n            words.sort()\n            return words\n\n        def generate_option(expr, i):\n            option_set = set()\n            while i[0] != len(expr) and expr[i[0]] != \"}\":\n                i[0] += 1  # { or ,\n                for option in generate_words(expr, i):\n                    option_set.add(option)\n            i[0] += 1  # }\n            option = list(option_set)\n            option.sort()\n            return option\n\n        def generate_words(expr, i):\n            options = []\n            while i[0] != len(expr) and expr[i[0]] not in \",}\":\n                tmp = []\n                if expr[i[0]] not in \"{,}\":\n                    tmp.append(expr[i[0]])\n                    i[0] += 1  # a-z\n                elif expr[i[0]] == \"{\":\n                    tmp = generate_option(expr, i)\n                options.append(tmp)\n            return form_words(options)\n\n        return generate_words(expression, [0])\n"
    },
    {
        "problem_name": "brace-expansion",
        "solution": "# Time:  O(p*l * log(p*l)), p is the production of all number of options\n#                         , l is the length of a word\n# Space: O(p*l)\n\nimport itertools\n\n\nclass Solution(object):\n    def expand(self, S):  # nested is fine\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        def form_words(options):\n            words = map(\"\".join, itertools.product(*options))\n            words.sort()\n            return words\n\n        def generate_option(expr, i):\n            option_set = set()\n            while i[0] != len(expr) and expr[i[0]] != \"}\":\n                i[0] += 1  # { or ,\n                for option in generate_words(expr, i):\n                    option_set.add(option)\n            i[0] += 1  # }\n            option = list(option_set)\n            option.sort()\n            return option\n\n        def generate_words(expr, i):\n            options = []\n            while i[0] != len(expr) and expr[i[0]] not in \",}\":\n                tmp = []\n                if expr[i[0]] not in \"{,}\":\n                    tmp.append(expr[i[0]])\n                    i[0] += 1  # a-z\n                elif expr[i[0]] == \"{\":\n                    tmp = generate_option(expr, i)\n                options.append(tmp)\n            return form_words(options)\n\n        return generate_words(S, [0])\n\n\nclass Solution2(object):\n    def expand(self, S):  # nested is fine\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        def form_words(options):\n            words = []\n            total = 1\n            for opt in options:\n                total *= len(opt)\n            for i in xrange(total):\n                tmp = []\n                for opt in reversed(options):\n                    i, c = divmod(i, len(opt))\n                    tmp.append(opt[c])\n                tmp.reverse()\n                words.append(\"\".join(tmp))\n            words.sort()\n            return words\n\n        def generate_option(expr, i):\n            option_set = set()\n            while i[0] != len(expr) and expr[i[0]] != \"}\":\n                i[0] += 1  # { or ,\n                for option in generate_words(expr, i):\n                    option_set.add(option)\n            i[0] += 1  # }\n            option = list(option_set)\n            option.sort()\n            return option\n\n        def generate_words(expr, i):\n            options = []\n            while i[0] != len(expr) and expr[i[0]] not in \",}\":\n                tmp = []\n                if expr[i[0]] not in \"{,}\":\n                    tmp.append(expr[i[0]])\n                    i[0] += 1  # a-z\n                elif expr[i[0]] == \"{\":\n                    tmp = generate_option(expr, i)\n                options.append(tmp)\n            return form_words(options)\n\n        return generate_words(S, [0])\n"
    },
    {
        "problem_name": "break-a-palindrome",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def breakPalindrome(self, palindrome):\n        \"\"\"\n        :type palindrome: str\n        :rtype: str\n        \"\"\"\n        for i in xrange(len(palindrome)//2):\n            if palindrome[i] != 'a':\n                return palindrome[:i] + 'a' + palindrome[i+1:]\n        return palindrome[:-1] + 'b' if len(palindrome) >= 2 else \"\"\n"
    },
    {
        "problem_name": "brick-wall",
        "solution": "# Time:  O(n), n is the total number of the bricks\n# Space: O(m), m is the total number different widths\n\nimport collections\n\n\nclass Solution(object):\n    def leastBricks(self, wall):\n        \"\"\"\n        :type wall: List[List[int]]\n        :rtype: int\n        \"\"\"\n        widths = collections.defaultdict(int)\n        result = len(wall)\n        for row in wall:\n            width = 0\n            for i in xrange(len(row)-1):\n                width += row[i]\n                widths[width] += 1\n                result = min(result, len(wall) - widths[width])\n        return result\n\n"
    },
    {
        "problem_name": "bricks-falling-when-hit",
        "solution": "# Time:  O(r * c)\n# Space: O(r * c)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n+1)\n        self.size = [1]*(n+1)\n        self.size[-1] = 0\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        self.size[max(x_root, y_root)] += self.size[min(x_root, y_root)]\n        return True\n\n    def top(self):\n        return self.size[self.find_set(len(self.size)-1)]\n\n\nclass Solution(object):\n    def hitBricks(self, grid, hits):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type hits: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def index(C, r, c):\n            return r*C+c\n\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n        R, C = len(grid), len(grid[0])\n\n        hit_grid = [row[:] for row in grid]\n        for i, j in hits:\n            hit_grid[i][j] = 0\n\n        union_find = UnionFind(R*C)\n        for r, row in enumerate(hit_grid):\n            for c, val in enumerate(row):\n                if not val:\n                    continue\n                if r == 0:\n                    union_find.union_set(index(C, r, c), R*C)\n                if r and hit_grid[r-1][c]:\n                    union_find.union_set(index(C, r, c), index(C, r-1, c))\n                if c and hit_grid[r][c-1]:\n                    union_find.union_set(index(C, r, c), index(C, r, c-1))\n\n        result = []\n        for r, c in reversed(hits):\n            prev_roof = union_find.top()\n            if grid[r][c] == 0:\n                result.append(0)\n                continue\n            for d in directions:\n                nr, nc = (r+d[0], c+d[1])\n                if 0 <= nr < R and 0 <= nc < C and hit_grid[nr][nc]:\n                    union_find.union_set(index(C, r, c), index(C, nr, nc))\n            if r == 0:\n                union_find.union_set(index(C, r, c), R*C)\n            hit_grid[r][c] = 1\n            result.append(max(0, union_find.top()-prev_roof-1))\n        return result[::-1]\n\n"
    },
    {
        "problem_name": "brightest-position-on-street",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def brightestPosition(self, lights):\n        \"\"\"\n        :type lights: List[List[int]]\n        :rtype: int\n        \"\"\"\n        count = collections.Counter()\n        for i, r in lights:\n            count[i-r] += 1\n            count[i+r+1] -= 1\n        result = None\n        max_cnt = cnt = 0\n        for i, c in sorted(count.iteritems()):\n            cnt += c\n            if cnt > max_cnt:\n                max_cnt, result = cnt, i\n        return result\n"
    },
    {
        "problem_name": "broken-calculator",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def brokenCalc(self, X, Y):\n        \"\"\"\n        :type X: int\n        :type Y: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while X < Y:\n            if Y%2:\n                Y += 1\n            else:\n                Y /= 2\n            result += 1\n        return result + X-Y\n"
    },
    {
        "problem_name": "buddy-strings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def buddyStrings(self, A, B):\n        \"\"\"\n        :type A: str\n        :type B: str\n        :rtype: bool\n        \"\"\"\n        if len(A) != len(B):\n            return False\n        diff = []\n        for a, b in itertools.izip(A, B):\n            if a != b:\n                diff.append((a, b))\n                if len(diff) > 2:\n                    return False\n        return (not diff and len(set(A)) < len(A)) or \\\n               (len(diff) == 2 and diff[0] == diff[1][::-1])\n\n"
    },
    {
        "problem_name": "build-a-matrix-with-conditions",
        "solution": "# Time:  O(k^2 + r + c), r = len(rowConditions), c = len(colConditions)\n# Space: O(k + r + c)\n\n# topological sort\nclass Solution(object):\n    def buildMatrix(self, k, rowConditions, colConditions):\n        \"\"\"\n        :type k: int\n        :type rowConditions: List[List[int]]\n        :type colConditions: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def topological_sort(conditions):\n            adj = [[] for _ in xrange(k)]\n            in_degree = [0]*k\n            for u, v in conditions:\n                u -= 1\n                v -= 1\n                adj[u].append(v)\n                in_degree[v] += 1\n            result = []\n            q = [u for u in xrange(k) if not in_degree[u]]\n            while q:\n                new_q = []\n                for u in q:\n                    result.append(u)\n                    for v in adj[u]:\n                        in_degree[v] -= 1\n                        if in_degree[v]:\n                            continue\n                        new_q.append(v)\n                q = new_q\n            return result\n\n        row_order = topological_sort(rowConditions)\n        if len(row_order) != k:\n            return []\n        col_order = topological_sort(colConditions)\n        if len(col_order) != k:\n            return []\n        row_idx = {x:i for i, x in enumerate(row_order)}\n        col_idx = {x:i for i, x in enumerate(col_order)}\n        result = [[0]*k for _ in xrange(k)]\n        for i in xrange(k):\n            result[row_idx[i]][col_idx[i]] = i+1\n        return result\n"
    },
    {
        "problem_name": "build-an-array-with-stack-operations",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def buildArray(self, target, n):\n        \"\"\"\n        :type target: List[int]\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result, curr = [], 1\n        for t in target:\n            result.extend([\"Push\", \"Pop\"]*(t-curr))\n            result.append(\"Push\")\n            curr = t+1\n        return result\n"
    },
    {
        "problem_name": "build-array-from-permutation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# inplace solution\nclass Solution(object):\n    def buildArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in xrange(len(nums)):\n            prev, curr = i, nums[i]\n            while curr >= 0 and curr != i:\n                nums[prev], nums[curr] = ~nums[curr], ~nums[prev] if prev == i else nums[prev]\n                prev, curr = curr, ~nums[prev]\n        for i in xrange(len(nums)):\n            if nums[i] < 0:\n                nums[i] = ~nums[i]\n        return nums\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def buildArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [nums[x] for x in nums]\n"
    },
    {
        "problem_name": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons",
        "solution": "# Time:  O(n * m * k)\n# Space: O(m * k)\n\nclass Solution(object):\n    def numOfArrays(self, n, m, k):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        # dp[l][i][j] = number of ways of constructing array length l with max element i at search cost j\n        dp = [[[0]*(k+1) for _ in xrange(m+1)] for _ in xrange(2)]\n        # prefix_dp[l][i][j] = sum(dp[l][i][j] for i in [1..i])\n        prefix_dp = [[[0]*(k+1) for _ in xrange(m+1)] for _ in xrange(2)]\n        for i in xrange(1, m+1):\n            dp[1][i][1] = 1\n            prefix_dp[1][i][1] = (prefix_dp[1][i-1][1] + dp[1][i][1])%MOD\n        for l in xrange(2, n+1):\n            for i in xrange(1, m+1):\n                for j in xrange(1, k+1):\n                    dp[l%2][i][j] = (i*dp[(l-1)%2][i][j]%MOD + prefix_dp[(l-1)%2][i-1][j-1])%MOD\n                    prefix_dp[l%2][i][j] = (prefix_dp[l%2][i-1][j] + dp[l%2][i][j])%MOD\n        return prefix_dp[n%2][m][k]\n"
    },
    {
        "problem_name": "build-binary-expression-tree-from-infix-expression",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# Definition for a binary tree node.\nclass Node(object):\n    def __init__(self, val=\" \", left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def expTree(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: Node\n        \"\"\"\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(Node(val=operators.pop(), left=left, right=right))\n\n        precedence = {'+':0, '-':0, '*':1, '/':1}\n        operands, operators, operand = [], [], 0\n        for i in xrange(len(s)):\n            if s[i].isdigit():\n                operand = operand*10 + int(s[i])\n                if i == len(s)-1 or not s[i+1].isdigit():\n                    operands.append(Node(val=str(operand)))\n                    operand = 0\n            elif s[i] == '(':\n                operators.append(s[i])\n            elif s[i] == ')':\n                while operators[-1] != '(':\n                    compute(operands, operators)\n                operators.pop()\n            elif s[i] in precedence:\n                while operators and operators[-1] in precedence and \\\n                      precedence[operators[-1]] >= precedence[s[i]]:\n                    compute(operands, operators)\n                operators.append(s[i])\n        while operators:\n            compute(operands, operators)\n        return operands[-1]\n"
    },
    {
        "problem_name": "building-boxes",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nimport math\n\n\nclass Solution(object):\n    def minimumBoxes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # find max h s.t. sum(k*(k+1)//2 for k in xrange(1, h+1)) <= n\n        # => find max h s.t. h*(h+1)*(h+2)//6 <= n\n        h = int((6*n)**(1.0/3))  \n        if h*(h+1)*(h+2) > 6*n:\n            # (h-1)*h*(h+1) < h^3 <= 6n < h*(h+1)*(h+2) < (h+1)^3\n            h -= 1\n        n -= h*(h+1)*(h+2)//6\n        d = int(math.ceil((-1+(1+8*n)**0.5)/2))  # find min d s.t. d*(d+1)//2 >= n\n        return h*(h+1)//2 + d\n"
    },
    {
        "problem_name": "building-h2o",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport threading\n\n\nclass H2O(object):\n    def __init__(self):\n        self.__l = threading.Lock()\n        self.__nH = 0\n        self.__nO = 0\n        self.__releaseHydrogen = None\n        self.__releaseOxygen = None\n\n    def hydrogen(self, releaseHydrogen):\n        with self.__l:\n            self.__releaseHydrogen = releaseHydrogen\n            self.__nH += 1\n            self.__output()\n\n    def oxygen(self, releaseOxygen):\n        with self.__l:\n            self.__releaseOxygen = releaseOxygen\n            self.__nO += 1\n            self.__output()\n\n    def __output(self):\n        while self.__nH >= 2 and \\\n              self.__nO >= 1:\n            self.__nH -= 2\n            self.__nO -= 1\n            self.__releaseHydrogen()\n            self.__releaseHydrogen()\n            self.__releaseOxygen()\n\n\n# Time:  O(n)\n# Space: O(1)\n# TLE\nclass H2O2(object):\n    def __init__(self):\n        self.__nH = 0\n        self.__nO = 0\n        self.__cv = threading.Condition()\n\n    def hydrogen(self, releaseHydrogen):\n        \"\"\"\n        :type releaseHydrogen: method\n        :rtype: void\n        \"\"\"\n        with self.__cv:\n            while (self.__nH+1) - 2*self.__nO > 2:\n                self.__cv.wait()\n            self.__nH += 1\n            # releaseHydrogen() outputs \"H\". Do not change or remove this line.\n            releaseHydrogen()\n            self.__cv.notifyAll()\n\n    def oxygen(self, releaseOxygen):\n        \"\"\"\n        :type releaseOxygen: method\n        :rtype: void\n        \"\"\"\n        with self.__cv:\n            while 2*(self.__nO+1) - self.__nH > 2:\n                self.__cv.wait()\n            self.__nO += 1\n            # releaseOxygen() outputs \"O\". Do not change or remove this line.\n            releaseOxygen()\n            self.__cv.notifyAll()\n"
    },
    {
        "problem_name": "buildings-with-an-ocean-view",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def findBuildings(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i, h in enumerate(heights):\n            while result and heights[result[-1]] <= h:\n                result.pop()\n            result.append(i)\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def findBuildings(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in reversed(xrange(len(heights))):\n            if not result or heights[result[-1]] < heights[i]:\n                result.append(i)\n        result.reverse()\n        return result\n"
    },
    {
        "problem_name": "bulb-switcher-ii",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def flipLights(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        if m == 0:\n            return 1\n        if n == 1:\n            return 2\n        if m == 1 and n == 2:\n            return 3\n        if m == 1 or n == 2:\n            return 4\n        if m == 2:\n            return 7\n        return 8\n\n"
    },
    {
        "problem_name": "bulb-switcher-iii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numTimesAllBlue(self, light):\n        \"\"\"\n        :type light: List[int]\n        :rtype: int\n        \"\"\"\n        result, right = 0, 0\n        for i, num in enumerate(light, 1):\n            right = max(right, num)\n            result += (right == i)\n        return result\n"
    },
    {
        "problem_name": "bulb-switcher-iv",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minFlips(self, target):\n        \"\"\"\n        :type target: str\n        :rtype: int\n        \"\"\"\n        result, curr = 0, '0'\n        for c in target:\n            if c == curr:\n                continue\n            curr = c\n            result += 1\n        return result\n"
    },
    {
        "problem_name": "bulb-switcher",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nimport math\n\n\nclass Solution(object):\n    def bulbSwitch(self, n):\n        \"\"\"\n        type n: int\n        rtype: int\n        \"\"\"\n        # The number of full squares.\n        return int(math.sqrt(n))\n\n"
    },
    {
        "problem_name": "bulls-and-cows",
        "solution": "# Time:  O(n)\n# Space: O(10) = O(1)\n\nimport operator\n\n\n# One pass solution.\nfrom collections import defaultdict, Counter\nfrom itertools import izip, imap\n\n\nclass Solution(object):\n    def getHint(self, secret, guess):\n        \"\"\"\n        :type secret: str\n        :type guess: str\n        :rtype: str\n        \"\"\"\n        A, B = 0, 0\n        lookup = defaultdict(int)\n        for s, g in izip(secret, guess):\n            if s == g:\n                A += 1\n            else:\n                B += int(lookup[s] < 0) + int(lookup[g] > 0)\n                lookup[s] += 1\n                lookup[g] -= 1\n        return \"%dA%dB\" % (A, B)\n\n\n# Two pass solution.\nclass Solution2(object):\n    def getHint(self, secret, guess):\n        \"\"\"\n        :type secret: str\n        :type guess: str\n        :rtype: str\n        \"\"\"\n        A = sum(imap(operator.eq, secret, guess))\n        B = sum((Counter(secret) & Counter(guess)).values()) - A\n        return \"%dA%dB\" % (A, B)\n\n"
    },
    {
        "problem_name": "burst-balloons",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\n\nclass Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        coins = [1] + [i for i in nums if i > 0] + [1]\n        n = len(coins)\n        max_coins = [[0 for _ in xrange(n)] for _ in xrange(n)]\n\n        for k in xrange(2, n):\n            for left in xrange(n - k):\n                right = left + k\n                for i in xrange(left + 1, right):\n                    max_coins[left][right] = \\\n                        max(max_coins[left][right],\n                            coins[left] * coins[i] * coins[right] +\n                            max_coins[left][i] +\n                            max_coins[i][right])\n\n        return max_coins[0][-1]\n\n"
    },
    {
        "problem_name": "bus-routes",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|V| + |E|)\n\nimport collections\n\n\nclass Solution(object):\n    def numBusesToDestination(self, routes, S, T):\n        \"\"\"\n        :type routes: List[List[int]]\n        :type S: int\n        :type T: int\n        :rtype: int\n        \"\"\"\n        if S == T:\n            return 0\n\n        to_route = collections.defaultdict(set)\n        for i, route in enumerate(routes):\n            for stop in route:\n                to_route[stop].add(i)\n\n        result = 1\n        q = [S]\n        lookup = set([S])\n        while q:\n            next_q = []\n            for stop in q:\n                for i in to_route[stop]:\n                    for next_stop in routes[i]:\n                        if next_stop in lookup:\n                            continue\n                        if next_stop == T:\n                            return result\n                        next_q.append(next_stop)\n                        to_route[next_stop].remove(i)\n                        lookup.add(next_stop)\n            q = next_q\n            result += 1\n\n        return -1\n\n"
    },
    {
        "problem_name": "buy-two-chocolates",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def buyChoco(self, prices, money):\n        \"\"\"\n        :type prices: List[int]\n        :type money: int\n        :rtype: int\n        \"\"\"\n        i = min(xrange(len(prices)), key=lambda x: prices[x])\n        j = min((j for j in xrange(len(prices)) if j != i), key=lambda x: prices[x])\n        return money-(prices[i]+prices[j]) if prices[i]+prices[j] <= money else money\n"
    },
    {
        "problem_name": "calculate-amount-paid-in-taxes",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# simulation\nclass Solution(object):\n    def calculateTax(self, brackets, income):\n        \"\"\"\n        :type brackets: List[List[int]]\n        :type income: int\n        :rtype: float\n        \"\"\"\n        result = prev = 0\n        for u, p in brackets:\n            result += max((min(u, income)-prev)*p/100.0, 0.0)\n            prev = u\n        return result\n"
    },
    {
        "problem_name": "calculate-delayed-arrival-time",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\n        \"\"\"\n        :type arrivalTime: int\n        :type delayedTime: int\n        :rtype: int\n        \"\"\"\n        return (arrivalTime + delayedTime)%24\n"
    },
    {
        "problem_name": "calculate-digit-sum-of-a-string",
        "solution": "# Time:  O(n + n * (log10(9k)/k) + ... + k)\n#      = O((n - (log10(9k)/k)*k)/(1-log10(9k)/k))\n#      = O(n / (1-log10(9k)/k)) = O(n) for k >= 2\n# Space: O(n)\n\n# simulation\nclass Solution(object):\n    def digitSum(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        while len(s) > k:\n            s = \"\".join(map(str, (sum(map(int, s[i:i+k])) for i in xrange(0, len(s), k))))\n        return s\n"
    },
    {
        "problem_name": "calculate-money-in-leetcode-bank",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def totalMoney(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def arithmetic_sequence_sum(a, d, n):\n            return (2*a + (n-1)*d) * n //2\n\n        cost, day = 1, 7\n        first_week_cost = arithmetic_sequence_sum(cost, cost, day)\n        week, remain_day = divmod(n, day)\n        return arithmetic_sequence_sum(first_week_cost, cost*day, week) + \\\n               arithmetic_sequence_sum(cost*(week+1), cost, remain_day)\n"
    },
    {
        "problem_name": "camelcase-matching",
        "solution": "# Time:  O(n * l), n is number of quries\n#                , l is length of query\n# Space: O(1)\n\nclass Solution(object):\n    def camelMatch(self, queries, pattern):\n        \"\"\"\n        :type queries: List[str]\n        :type pattern: str\n        :rtype: List[bool]\n        \"\"\"\n        def is_matched(query, pattern):\n            i = 0\n            for c in query:\n                if i < len(pattern) and pattern[i] == c:\n                    i += 1\n                elif c.isupper():\n                    return False\n            return i == len(pattern)\n        \n        result = []\n        for query in queries:\n            result.append(is_matched(query, pattern))\n        return result\n"
    },
    {
        "problem_name": "campus-bikes-ii",
        "solution": "# Time:  O(w * b * 2^b)\n# Space: O(b * 2^b)\n\n# if w = b, we can even apply Hungarian algorithm (see https://en.wikipedia.org/wiki/Hungarian_algorithm),\n# it can be improved to O(w^3), see https://github.com/t3nsor/codebook/blob/master/bipartite-mincost.cpp\nclass Solution(object):  # this is slower than Solution2 in python\n    def assignBikes(self, workers, bikes):\n        \"\"\"\n        :type workers: List[List[int]]\n        :type bikes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        dp = [[float(\"inf\")]*((1<<len(bikes))) for _ in xrange(2)]\n        dp[0][0] = 0\n        for i in xrange(len(workers)):\n            dp[(i+1)%2] = [float(\"inf\")] * ((1<<len(bikes)))\n            for j in xrange(len(bikes)):\n                for taken in xrange((1<<len(bikes))):\n                    if taken & (1<<j):\n                        continue\n                    dp[(i+1)%2][taken|(1<<j)] = \\\n                        min(dp[(i+1)%2][taken|(1<<j)],\n                            dp[i%2][taken] +\n                            manhattan(workers[i], bikes[j]))\n        return min(dp[len(workers)%2])\n\n\n# Time:  O((w * b * 2^b) * log(w * b * 2^b))\n# Space: O(w * b * 2^b)\nimport heapq\n\n\nclass Solution2(object):\n    def assignBikes(self, workers, bikes):\n        \"\"\"\n        :type workers: List[List[int]]\n        :type bikes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        min_heap = [(0, 0, 0)]\n        lookup = set()\n        while min_heap:\n            cost, i, taken = heapq.heappop(min_heap)\n            if (i, taken) in lookup:\n                continue\n            lookup.add((i, taken))\n            if i == len(workers):\n                return cost\n            for j in xrange(len(bikes)):\n                if taken & (1<<j):\n                    continue\n                heapq.heappush(min_heap, (cost+manhattan(workers[i], bikes[j]),  # O(b)\n                                          i+1,            # O(w)\n                                          taken|(1<<j)))  # O(2^b)\n\n"
    },
    {
        "problem_name": "campus-bikes",
        "solution": "# Time:  O((w * b) * log(w * b))\n# Space: O(w * b)\n\nimport heapq\n\n\nclass Solution(object):\n    def assignBikes(self, workers, bikes):\n        \"\"\"\n        :type workers: List[List[int]]\n        :type bikes: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        distances = [[] for _ in xrange(len(workers))]\n        for i in xrange(len(workers)):\n            for j in xrange(len(bikes)):\n                distances[i].append((manhattan(workers[i], bikes[j]), i, j))\n            distances[i].sort(reverse = True)\n        \n        result = [None] * len(workers)\n        lookup = set()\n        min_heap = []\n        for i in xrange(len(workers)):\n            heapq.heappush(min_heap, distances[i].pop())\n        while len(lookup) < len(workers):\n            _, worker, bike = heapq.heappop(min_heap)\n            if bike not in lookup:\n                result[worker] = bike\n                lookup.add(bike)\n            else:\n                heapq.heappush(min_heap, distances[worker].pop())\n        return result\n"
    },
    {
        "problem_name": "can-convert-string-in-k-moves",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def canConvertString(self, s, t, k):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n        cnt = [0]*26\n        for a, b in itertools.izip(s, t):\n            diff = (ord(b)-ord(a)) % len(cnt)\n            if diff != 0 and cnt[diff]*len(cnt) + diff > k:\n                return False\n            cnt[diff] += 1\n        return True\n"
    },
    {
        "problem_name": "can-i-win",
        "solution": "# Time:  O(n!)\n# Space: O(n)\n\nclass Solution(object):\n    def canIWin(self, maxChoosableInteger, desiredTotal):\n        \"\"\"\n        :type maxChoosableInteger: int\n        :type desiredTotal: int\n        :rtype: bool\n        \"\"\"\n        def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):\n            if visited in lookup:\n                return lookup[visited]\n\n            mask = 1\n            for i in xrange(maxChoosableInteger):\n                if visited & mask == 0:\n                    if i + 1 >= desiredTotal or \\\n                       not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup):\n                        lookup[visited] = True\n                        return True\n                mask <<= 1\n            lookup[visited] = False\n            return False\n\n        if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:\n            return False\n\n        return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})\n\n"
    },
    {
        "problem_name": "can-make-arithmetic-progression-from-sequence",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def canMakeArithmeticProgression(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        m = min(arr)\n        d = (max(arr)-m)//(len(arr)-1)\n        if not d:\n            return True\n        i = 0\n        while i < len(arr):\n            if arr[i] == m+i*d:\n                i += 1\n            else:\n                j, r = divmod(arr[i]-m, d)\n                if r or j >= len(arr) or arr[i] == arr[j]:\n                    return False\n                arr[i], arr[j] = arr[j], arr[i]\n        return True\n"
    },
    {
        "problem_name": "can-make-palindrome-from-substring",
        "solution": "# Time:  O(m + n), m is the number of queries, n is the length of s\n# Space: O(n)\n\nimport itertools\n\n\nclass Solution(object):\n    def canMakePaliQueries(self, s, queries):\n        \"\"\"\n        :type s: str\n        :type queries: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        CHARSET_SIZE = 26\n        curr, count = [0]*CHARSET_SIZE, [[0]*CHARSET_SIZE]\n        for c in s:\n            curr[ord(c)-ord('a')] += 1\n            count.append(curr[:])\n        return [sum((b-a)%2 for a, b in itertools.izip(count[left], count[right+1]))//2 <= k\n                for left, right, k in queries]\n"
    },
    {
        "problem_name": "can-place-flowers",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def canPlaceFlowers(self, flowerbed, n):\n        \"\"\"\n        :type flowerbed: List[int]\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        for i in xrange(len(flowerbed)):\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and \\\n                (i == len(flowerbed)-1 or flowerbed[i+1] == 0):\n                flowerbed[i] = 1\n                n -= 1\n            if n <= 0:\n                return True\n        return False\n\n"
    },
    {
        "problem_name": "can-you-eat-your-favorite-candy-on-your-favorite-day",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def canEat(self, candiesCount, queries):\n        \"\"\"\n        :type candiesCount: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        prefix = [0]*(len(candiesCount)+1)\n        for i, c in enumerate(candiesCount):\n            prefix[i+1] = prefix[i]+c\n        return [prefix[t]//c < d+1 <= prefix[t+1]//1 for t, d, c in queries]\n"
    },
    {
        "problem_name": "candy-crush",
        "solution": "# Time:  O((R * C)^2)\n# Space: O(1)\n\nclass Solution(object):\n    def candyCrush(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        R, C = len(board), len(board[0])\n        changed = True\n\n        while changed:\n            changed = False\n\n            for r in xrange(R):\n                for c in xrange(C-2):\n                    if abs(board[r][c]) == abs(board[r][c+1]) == abs(board[r][c+2]) != 0:\n                        board[r][c] = board[r][c+1] = board[r][c+2] = -abs(board[r][c])\n                        changed = True\n\n            for r in xrange(R-2):\n                for c in xrange(C):\n                    if abs(board[r][c]) == abs(board[r+1][c]) == abs(board[r+2][c]) != 0:\n                        board[r][c] = board[r+1][c] = board[r+2][c] = -abs(board[r][c])\n                        changed = True\n\n            for c in xrange(C):\n                i = R-1\n                for r in reversed(xrange(R)):\n                    if board[r][c] > 0:\n                        board[i][c] = board[r][c]\n                        i -= 1\n                for r in reversed(xrange(i+1)):\n                    board[r][c] = 0\n\n        return board\n\n"
    },
    {
        "problem_name": "candy",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    # @param ratings, a list of integer\n    # @return an integer\n    def candy(self, ratings):\n        candies = [1 for _ in xrange(len(ratings))]\n        for i in xrange(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        for i in reversed(xrange(1, len(ratings))):\n            if ratings[i - 1] > ratings[i] and candies[i - 1] <= candies[i]:\n                candies[i - 1] = candies[i] + 1\n\n        return sum(candies)\n"
    },
    {
        "problem_name": "capacity-to-ship-packages-within-d-days",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\nclass Solution(object):\n    def shipWithinDays(self, weights, D):\n        \"\"\"\n        :type weights: List[int]\n        :type D: int\n        :rtype: int\n        \"\"\"\n        def possible(weights, D, mid):\n            result, curr = 1, 0\n            for w in weights:\n                if curr+w > mid:\n                    result += 1\n                    curr = 0\n                curr += w\n            return result <= D\n    \n        left, right = max(weights), sum(weights)\n        while left <= right:\n            mid = left + (right-left)//2\n            if possible(weights, D, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "capitalize-the-title",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def capitalizeTitle(self, title):\n        \"\"\"\n        :type title: str\n        :rtype: str\n        \"\"\"\n        title = list(title)\n        j = 0\n        for i in xrange(len(title)+1):\n            if i < len(title) and title[i] != ' ':\n                title[i] = title[i].lower()\n                continue\n            if i-j > 2:\n                title[j] = title[j].upper()\n            j = i+1\n        return \"\".join(title)\n"
    },
    {
        "problem_name": "car-fleet-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def getCollisionTimes(self, cars):\n        \"\"\"\n        :type cars: List[List[int]]\n        :rtype: List[float]\n        \"\"\"\n        stk = []\n        result = [-1.0]*len(cars)\n        for i in reversed(xrange(len(cars))):\n            p, s = cars[i]\n            while stk and (cars[stk[-1]][1] >= s or \n                           0 < result[stk[-1]] <= float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])):\n                stk.pop()\n            if stk:\n                result[i] = float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])\n            stk.append(i)\n        return result\n"
    },
    {
        "problem_name": "car-fleet",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def carFleet(self, target, position, speed):\n        \"\"\"\n        :type target: int\n        :type position: List[int]\n        :type speed: List[int]\n        :rtype: int\n        \"\"\"\n        times = [float(target-p)/s for p, s in sorted(zip(position, speed))]\n        result, curr = 0, 0\n        for t in reversed(times):\n            if t > curr:\n                result += 1\n                curr = t\n        return result\n\n"
    },
    {
        "problem_name": "car-pooling",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def carPooling(self, trips, capacity):\n        \"\"\"\n        :type trips: List[List[int]]\n        :type capacity: int\n        :rtype: bool\n        \"\"\"\n        line = [x for num, start, end in trips for x in [[start, num], [end, -num]]]\n        line.sort()\n        for _, num in line:\n            capacity -= num\n            if capacity < 0:\n                return False\n        return True\n"
    },
    {
        "problem_name": "card-flipping-game",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport itertools\n\n\nclass Solution(object):\n    def flipgame(self, fronts, backs):\n        \"\"\"\n        :type fronts: List[int]\n        :type backs: List[int]\n        :rtype: int\n        \"\"\"\n        same = {n for i, n in enumerate(fronts) if n == backs[i]}\n        result = float(\"inf\")\n        for n in itertools.chain(fronts, backs):\n            if n not in same:\n                result = min(result, n)\n        return result if result < float(\"inf\") else 0\n\n"
    },
    {
        "problem_name": "cat-and-mouse-ii",
        "solution": "# Time:  O((m * n)^2 * (m + n))\n# Space: O((m * n)^2)\n\nimport collections\n\n\nclass Solution(object):\n    def canMouseWin(self, grid, catJump, mouseJump):\n        \"\"\"\n        :type grid: List[str]\n        :type catJump: int\n        :type mouseJump: int\n        :rtype: bool\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        DRAW, MOUSE, CAT = range(3)\n        def parents(m, c, t):\n            if t == CAT:\n                for nm in graph[m, MOUSE^CAT^t]:\n                    yield nm, c, MOUSE^CAT^t\n            else:\n                for nc in graph[c, MOUSE^CAT^t]:\n                    yield m, nc, MOUSE^CAT^t\n\n        R, C = len(grid), len(grid[0])\n        N = R*C\n        WALLS = set()\n        FOOD, MOUSE_START, CAT_START = [-1]*3\n        for r in xrange(R):\n            for c in xrange(C):\n                if grid[r][c] == 'M':\n                    MOUSE_START = r*C + c\n                elif grid[r][c] == 'C':\n                    CAT_START = r*C + c\n                elif grid[r][c] == 'F':\n                    FOOD = r*C + c\n                elif grid[r][c] == '#':\n                    WALLS.add(r*C + c)\n\n        graph = collections.defaultdict(set)\n        jump = {MOUSE:mouseJump, CAT:catJump}\n        for r in xrange(R):\n            for c in xrange(C):\n                if grid[r][c] == '#':\n                    continue\n                pos = r*C + c\n                for t in [MOUSE, CAT]:\n                    for dr, dc in directions:\n                        for d in xrange(jump[t]+1):\n                            nr, nc = r+dr*d, c+dc*d\n                            if not (0 <= nr < R and 0 <= nc < C and grid[nr][nc] != '#'):\n                                break\n                            graph[pos, t].add(nr*C + nc)\n\n        degree = {}\n        for m in xrange(N):\n            for c in xrange(N):\n                degree[m, c, MOUSE] = len(graph[m, MOUSE])\n                degree[m, c, CAT] = len(graph[c, CAT])\n        color = collections.defaultdict(int)\n        q = collections.deque()\n        for i in xrange(N):\n            if i in WALLS or i == FOOD:\n                continue\n            color[FOOD, i, CAT] = MOUSE\n            q.append((FOOD, i, CAT, MOUSE))\n            color[i, FOOD, MOUSE] = CAT\n            q.append((i, FOOD, MOUSE, CAT))\n            for t in [MOUSE, CAT]:\n                color[i, i, t] = CAT\n                q.append((i, i, t, CAT))\n        while q:\n            i, j, t, c = q.popleft()\n            for ni, nj, nt in parents(i, j, t):\n                if color[ni, nj, nt] != DRAW:\n                    continue\n                if nt == c:\n                    color[ni, nj, nt] = c\n                    q.append((ni, nj, nt, c))\n                    continue\n                degree[ni, nj, nt] -= 1\n                if not degree[ni, nj, nt]:\n                    color[ni, nj, nt] = c\n                    q.append((ni, nj, nt, c))\n        return color[MOUSE_START, CAT_START, MOUSE] == MOUSE\n\n\n# Time:  O((m * n)^2 * (m + n))\n# Space: O((m * n)^2)\nimport collections\n\n\nclass Solution2(object):\n    def canMouseWin(self, grid, catJump, mouseJump):\n        \"\"\"\n        :type grid: List[str]\n        :type catJump: int\n        :type mouseJump: int\n        :rtype: bool\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        DRAW, MOUSE, CAT = range(3)\n        def parents(m, c, t):\n            if t == CAT:\n                for nm in graph[m, MOUSE^CAT^t]:\n                    yield nm, c, MOUSE^CAT^t\n            else:\n                for nc in graph[c, MOUSE^CAT^t]:\n                    yield m, nc, MOUSE^CAT^t\n\n        R, C = len(grid), len(grid[0])\n        N = R*C\n        WALLS = set()\n        FOOD, MOUSE_START, CAT_START = [-1]*3\n        for r in xrange(R):\n            for c in xrange(C):\n                if grid[r][c] == 'M':\n                    MOUSE_START = r*C + c\n                elif grid[r][c] == 'C':\n                    CAT_START = r*C + c\n                elif grid[r][c] == 'F':\n                    FOOD = r*C + c\n                elif grid[r][c] == '#':\n                    WALLS.add(r*C + c)\n        graph = collections.defaultdict(set)\n        jump = {MOUSE:mouseJump, CAT:catJump}\n        for r in xrange(R):\n            for c in xrange(C):\n                if grid[r][c] == '#':\n                    continue\n                pos = r*C + c\n                for t in [MOUSE, CAT]:\n                    for dr, dc in directions:\n                        for d in xrange(jump[t]+1):\n                            nr, nc = r+dr*d, c+dc*d\n                            if not (0 <= nr < R and 0 <= nc < C and grid[nr][nc] != '#'):\n                                break\n                            graph[pos, t].add(nr*C + nc)\n\n        degree = {}\n        for m in xrange(N):\n            for c in xrange(N):\n                # degree[m, c, MOUSE] = len(graph[m, MOUSE])\n                degree[m, c, CAT] = len(graph[c, CAT])\n        color = collections.defaultdict(int)\n        q1 = collections.deque()\n        # q2 = collections.deque()\n        for i in xrange(N):\n            if i in WALLS or i == FOOD:\n                continue\n            color[FOOD, i, CAT] = MOUSE\n            q1.append((FOOD, i, CAT))\n            color[i, FOOD, MOUSE] = CAT\n            # q2.append((i, FOOD, MOUSE))\n            for t in [MOUSE, CAT]:\n                color[i, i, t] = CAT\n                # q2.append((i, i, t))\n        while q1:\n            i, j, t = q1.popleft()\n            for ni, nj, nt in parents(i, j, t):\n                if color[ni, nj, nt] != DRAW:\n                    continue\n                if t == CAT:\n                    color[ni, nj, nt] = MOUSE\n                    q1.append((ni, nj, nt))\n                    continue\n                degree[ni, nj, nt] -= 1\n                if not degree[ni, nj, nt]:\n                    color[ni, nj, nt] = MOUSE\n                    q1.append((ni, nj, nt))\n        # while q2:\n        #     i, j, t = q2.popleft()\n        #     for ni, nj, nt in parents(i, j, t):\n        #         if color[ni, nj, nt] != DRAW:\n        #             continue\n        #         if t == MOUSE:\n        #             color[ni, nj, nt] = CAT\n        #             q2.append((ni, nj, nt))\n        #             continue\n        #         degree[ni, nj, nt] -= 1\n        #         if not degree[ni, nj, nt]:\n        #             color[ni, nj, nt] = CAT\n        #             q2.append((ni, nj, nt))\n        return color[MOUSE_START, CAT_START, MOUSE] == MOUSE\n"
    },
    {
        "problem_name": "cat-and-mouse",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\nimport collections\n\n\nclass Solution(object):\n    def catMouseGame(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: int\n        \"\"\"\n        HOLE, MOUSE_START, CAT_START = range(3)\n        DRAW, MOUSE, CAT = range(3)\n        def parents(m, c, t):\n            if t == CAT:\n                for nm in graph[m]:\n                    yield nm, c, MOUSE^CAT^t\n            else:\n                for nc in graph[c]:\n                    if nc != HOLE:\n                        yield m, nc, MOUSE^CAT^t\n\n        degree = {}\n        ignore = set(graph[HOLE])\n        for m in xrange(len(graph)):\n            for c in xrange(len(graph)):\n                degree[m, c, MOUSE] = len(graph[m])\n                degree[m, c, CAT] = len(graph[c])-(c in ignore)\n        color = collections.defaultdict(int)\n        q = collections.deque()\n        for i in xrange(len(graph)):\n            if i == HOLE:\n                continue\n            color[HOLE, i, CAT] = MOUSE\n            q.append((HOLE, i, CAT, MOUSE))\n            for t in [MOUSE, CAT]:\n                color[i, i, t] = CAT\n                q.append((i, i, t, CAT))\n        while q:\n            i, j, t, c = q.popleft()\n            for ni, nj, nt in parents(i, j, t):\n                if color[ni, nj, nt] != DRAW:\n                    continue\n                if nt == c:\n                    color[ni, nj, nt] = c\n                    q.append((ni, nj, nt, c))\n                    continue\n                degree[ni, nj, nt] -= 1\n                if not degree[ni, nj, nt]:\n                    color[ni, nj, nt] = c\n                    q.append((ni, nj, nt, c))\n        return color[MOUSE_START, CAT_START, MOUSE]\n\n    \n# Time:  O(n^3)\n# Space: O(n^2)\nimport collections\n\n\nclass Solution2(object):\n    def catMouseGame(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: int\n        \"\"\"\n        HOLE, MOUSE_START, CAT_START = range(3)\n        DRAW, MOUSE, CAT = range(3)\n        def parents(m, c, t):\n            if t == CAT:\n                for nm in graph[m]:\n                    yield nm, c, MOUSE^CAT^t\n            else:\n                for nc in graph[c]:\n                    if nc != HOLE:\n                        yield m, nc, MOUSE^CAT^t\n\n        color = collections.defaultdict(int)\n        degree = {}\n        ignore = set(graph[HOLE])\n        for m in xrange(len(graph)):\n            for c in xrange(len(graph)):\n                degree[m, c, MOUSE] = len(graph[m])\n                degree[m, c, CAT] = len(graph[c])-(c in ignore)\n        q1 = collections.deque()\n        q2 = collections.deque()\n        for i in xrange(len(graph)):\n            if i == HOLE:\n                continue\n            color[HOLE, i, CAT] = MOUSE\n            q1.append((HOLE, i, CAT))\n            for t in [MOUSE, CAT]:\n                color[i, i, t] = CAT\n                q2.append((i, i, t))\n        while q1:\n            i, j, t = q1.popleft()\n            for ni, nj, nt in parents(i, j, t):\n                if color[ni, nj, nt] != DRAW:\n                    continue\n                if t == CAT:\n                    color[ni, nj, nt] = MOUSE\n                    q1.append((ni, nj, nt))\n                    continue\n                degree[ni, nj, nt] -= 1\n                if not degree[ni, nj, nt]:\n                    color[ni, nj, nt] = MOUSE\n                    q1.append((ni, nj, nt))\n        while q2:\n            i, j, t = q2.popleft()\n            for ni, nj, nt in parents(i, j, t):\n                if color[ni, nj, nt] != DRAW:\n                    continue\n                if t == MOUSE:\n                    color[ni, nj, nt] = CAT\n                    q2.append((ni, nj, nt))\n                    continue\n                degree[ni, nj, nt] -= 1\n                if not degree[ni, nj, nt]:\n                    color[ni, nj, nt] = CAT\n                    q2.append((ni, nj, nt))\n        return color[MOUSE_START, CAT_START, MOUSE]\n"
    },
    {
        "problem_name": "categorize-box-according-to-criteria",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math, implementation\nclass Solution(object):\n    def categorizeBox(self, length, width, height, mass):\n        \"\"\"\n        :type length: int\n        :type width: int\n        :type height: int\n        :type mass: int\n        :rtype: str\n        \"\"\"\n        bulky = any(x >= 10**4 for x in (length, width, height)) or length*width*height >= 10**9\n        heavy = mass >= 100\n        if bulky and heavy:\n            return \"Both\"\n        if bulky:\n            return \"Bulky\"\n        if heavy:\n            return \"Heavy\"\n        return \"Neither\"\n\n\n# Time:  O(1)\n# Space: O(1)\n# math, implementation\nclass Solution2(object):\n    def categorizeBox(self, length, width, height, mass):\n        \"\"\"\n        :type length: int\n        :type width: int\n        :type height: int\n        :type mass: int\n        :rtype: str\n        \"\"\"\n        CATEGORIES = [\"Neither\", \"Heavy\", \"Bulky\", \"Both\"]\n        i = 2*(any(x >= 10**4 for x in (length, width, height)) or length*width*height >= 10**9)+int(mass >= 100)\n        return CATEGORIES[i]\n"
    },
    {
        "problem_name": "cells-in-a-range-on-an-excel-sheet",
        "solution": "# Time:  O(26^2)\n# Space: O(1)\n\n# enumeration\nclass Solution(object):\n    def cellsInRange(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        return [chr(x)+chr(y) for x in xrange(ord(s[0]), ord(s[3])+1) for y in xrange(ord(s[1]), ord(s[4])+1)]\n"
    },
    {
        "problem_name": "cells-with-odd-values-in-a-matrix",
        "solution": "# Time:  O(n + m)\n# Space: O(n + m)\n\nclass Solution(object):\n    def oddCells(self, n, m, indices):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :type indices: List[List[int]]\n        :rtype: int\n        \"\"\"\n        row, col = [0]*n, [0]*m\n        for r, c in indices:\n            row[r] ^= 1\n            col[c] ^= 1\n        row_sum, col_sum = sum(row), sum(col)\n        return row_sum*m+col_sum*n-2*row_sum*col_sum\n\n\n# Time:  O(n + m)\n# Space: O(n + m)\nimport collections\nimport itertools\n\n\nclass Solution2(object):\n    def oddCells(self, n, m, indices):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :type indices: List[List[int]]\n        :rtype: int\n        \"\"\"\n        fn = lambda x: sum(count&1 for count in collections.Counter(x).itervalues())\n        row_sum, col_sum = map(fn, itertools.izip(*indices))\n        return row_sum*m+col_sum*n-2*row_sum*col_sum\n"
    },
    {
        "problem_name": "chalkboard-xor-game",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nfrom operator import xor\nfrom functools import reduce\n\n\nclass Solution(object):\n    def xorGame(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return reduce(xor, nums) == 0 or \\\n            len(nums) % 2 == 0\n\n"
    },
    {
        "problem_name": "champagne-tower",
        "solution": "# Time:  O(n^2) = O(1), since n is at most 99\n# Space: O(n) = O(1)\n\nclass Solution(object):\n    def champagneTower(self, poured, query_row, query_glass):\n        \"\"\"\n        :type poured: int\n        :type query_row: int\n        :type query_glass: int\n        :rtype: float\n        \"\"\"\n        result = [poured] + [0] * query_row\n        for i in xrange(1, query_row+1):\n            for j in reversed(xrange(i+1)):\n                result[j] = max(result[j]-1, 0)/2.0 + \\\n                            max(result[j-1]-1, 0)/2.0\n        return min(result[query_glass], 1)\n\n"
    },
    {
        "problem_name": "change-minimum-characters-to-satisfy-one-of-three-conditions",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def minCharacters(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        count1 = collections.Counter(ord(c)-ord('a') for c in a)\n        count2 = collections.Counter(ord(c)-ord('a') for c in b)\n        result = len(a) + len(b) - max((count1+count2).itervalues())  # condition 3\n        for i in xrange(26-1):\n            if i > 0:\n                count1[i] += count1[i-1]\n                count2[i] += count2[i-1]\n            result = min(result, len(a) - count1[i] + count2[i])  # condition 1\n            result = min(result, len(b) - count2[i] + count1[i])  # condition 2\n        return result\n"
    },
    {
        "problem_name": "change-the-root-of-a-binary-tree",
        "solution": "# Time:  O(h)\n# Space: O(1)\n\n# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        pass\n\n\nclass Solution(object):\n    def flipBinaryTree(self, root, leaf):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n        curr, parent = leaf, None\n        while True:\n            child = curr.parent\n            curr.parent = parent\n            if curr.left == parent:\n                curr.left = None\n            else:\n                curr.right = None\n            if curr == root:\n                break\n            if curr.left:\n                curr.right = curr.left\n            curr.left = child\n            curr, parent = child, curr\n        return leaf\n"
    },
    {
        "problem_name": "cheapest-flights-within-k-stops",
        "solution": "# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),\n#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport collections\nimport heapq\n\n\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        \"\"\"\n        :type n: int\n        :type flights: List[List[int]]\n        :type src: int\n        :type dst: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n        adj = collections.defaultdict(list)\n        for u, v, w in flights:\n            adj[u].append((v, w))\n        best = collections.defaultdict(lambda: collections.defaultdict(lambda: float(\"inf\")))\n        best[src][K+1] = 0\n        min_heap = [(0, src, K+1)]\n        while min_heap:\n            result, u, k = heapq.heappop(min_heap)\n            if k < 0 or best[u][k] < result:\n                continue\n            if u == dst:\n                return result\n            for v, w in adj[u]:\n                if result+w < best[v][k-1]:\n                    best[v][k-1] = result+w                    \n                    heapq.heappush(min_heap, (result+w, v, k-1))\n        return -1\n\n"
    },
    {
        "problem_name": "check-array-formation-through-concatenation",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def canFormArray(self, arr, pieces):\n        \"\"\"\n        :type arr: List[int]\n        :type pieces: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        lookup = {x[0]: i for i, x in enumerate(pieces)}\n        i = 0\n        while i < len(arr): \n            if arr[i] not in lookup:\n                return False\n            for c in pieces[lookup[arr[i]]]:\n                if i == len(arr) or arr[i] != c:\n                    return False\n                i += 1\n        return True \n"
    },
    {
        "problem_name": "check-completeness-of-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(w)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def isCompleteTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        end = False\n        current = [root]\n        while current:\n            next_level = []\n            for node in current:\n                if not node:\n                    end = True\n                    continue\n                if end:\n                    return False\n                next_level.append(node.left)\n                next_level.append(node.right)\n            current = next_level\n        return  True\n\n\n# Time:  O(n)\n# Space: O(w)\nclass Solution2(object):\n    def isCompleteTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        prev_level, current = [], [(root, 1)]\n        count = 0\n        while current:\n            count += len(current)\n            next_level = []\n            for node, v in current:\n                if not node:\n                    continue\n                next_level.append((node.left, 2*v))\n                next_level.append((node.right, 2*v+1))\n            prev_level, current = current, next_level\n        return prev_level[-1][1] == count\n"
    },
    {
        "problem_name": "check-distances-between-same-letters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# hash table\nclass Solution(object):\n    def checkDistances(self, s, distance):\n        \"\"\"\n        :type s: str\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        for i in xrange(len(s)):\n            if i+distance[ord(s[i])-ord('a')]+1 >= len(s) or s[i+distance[ord(s[i])-ord('a')]+1] != s[i]:\n                return False\n            distance[ord(s[i])-ord('a')] = -1\n        return True\n"
    },
    {
        "problem_name": "check-for-contradictions-in-equations",
        "solution": "# Time:  O(e + q)\n# Space: O(n)\n\nimport collections\nimport itertools\n\n\nclass UnionFind(object):\n    def __init__(self):\n        self.set = {}\n        self.rank = collections.Counter()\n\n    def find_set(self, x):\n        xp, xr = self.set.setdefault(x, (x, 1.0))\n        if x != xp:\n            pp, pr = self.find_set(xp)  # path compression.\n            self.set[x] = (pp, xr*pr)  # x/pp = xr*pr\n        return self.set[x]\n\n    def union_set(self, x, y, r):\n        (xp, xr), (yp, yr) =  map(self.find_set, (x, y))\n        if xp == yp:\n            return False\n        if self.rank[xp] < self.rank[yp]:  # union by rank\n            # to make x/yp = r*yr and merge xp into yp\n            # => since x/xp = xr, we can merge with xp/yp = r*yr/xr \n            self.set[xp] = (yp, r*yr/xr)\n        elif self.rank[xp] > self.rank[yp]:\n            # to make y/xp = 1/r*xr and merge xp into yp\n            # => since y/yp = yr, we can merge with yp/xp = 1/r*xr/yr \n            self.set[yp] = (xp, 1.0/r*xr/yr)\n        else:\n            # to make y/xp = 1/r*xr and merge xp into yp\n            # => since y/yp = yr, we can merge with yp/xp = 1/r*xr/yr \n            self.set[yp] = (xp, 1.0/r*xr/yr)\n            self.rank[xp] += 1 \n        return True\n\n    def query_set(self, x, y):\n        if x not in self.set or y not in self.set:\n            return -1.0\n        (xp, xr), (yp, yr) = map(self.find_set, (x, y))\n        return xr/yr if xp == yp else -1.0\n\n\n# Time:  O(e + q)\n# Space: O(n)\nimport itertools\n\n\n# union find\nclass Solution(object):\n    def checkContradictions(self, equations, values):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :rtype: bool\n        \"\"\"\n        EPS = 1e-5\n        uf = UnionFind()\n        return any(not uf.union_set(a, b, k) and abs(uf.query_set(a, b)-k) >= EPS for (a, b), k in itertools.izip(equations, values))\n\n\n# Time:  O(e + q)\n# Space: O(n)\nimport collections\nimport itertools\n\n\n# dfs\nclass Solution2(object):\n    def checkContradictions(self, equations, values):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :rtype: bool\n        \"\"\"\n        def isclose(a, b, rel_tol=1e-09, abs_tol=0.0):\n            return abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)\n\n        def iter_dfs(adj, u, lookup):\n            stk = [u]\n            lookup[u] = 1.0\n            while stk:\n                u = stk.pop()\n                for v, k in adj[u]:\n                    if v in lookup:\n                        if not isclose(lookup[v], lookup[u]*k):\n                            return True\n                        continue\n                    lookup[v] = lookup[u]*k\n                    stk.append(v)\n            return False\n\n        adj = collections.defaultdict(set)\n        for (a, b), k in itertools.izip(equations, values):\n            adj[a].add((b, 1.0/k))\n            adj[b].add((a, 1.0*k))\n        lookup = {}\n        for u in adj.iterkeys():\n            if u in lookup:\n                continue\n            if iter_dfs(adj, u, lookup):\n                return True\n        return False\n"
    },
    {
        "problem_name": "check-if-a-number-is-majority-element-in-a-sorted-array",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport bisect\n\n\nclass Solution(object):\n    def isMajorityElement(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if len(nums) % 2:\n            if nums[len(nums)//2] != target:\n                return False\n        else:\n            if not (nums[len(nums)//2-1] == nums[len(nums)//2] == target):\n                return False\n\n        left = bisect.bisect_left(nums, target)\n        right= bisect.bisect_right(nums, target)\n        return (right-left)*2 > len(nums)\n"
    },
    {
        "problem_name": "check-if-a-parentheses-string-can-be-valid",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def canBeValid(self, s, locked):\n        \"\"\"\n        :type s: str\n        :type locked: str\n        :rtype: bool\n        \"\"\"\n        if len(s)%2:\n            return False\n        for direction, c in ((lambda x:x, '('), (reversed, ')')):\n            cnt = bal = 0\n            for i in direction(xrange(len(s))):\n                if locked[i] == '0':\n                    cnt += 1\n                else:\n                    bal += 1 if s[i] == c else -1\n                    if cnt+bal < 0:\n                        return False\n        return True\n"
    },
    {
        "problem_name": "check-if-a-string-can-break-another-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\nimport string\n\n\nclass Solution(object):\n    def checkIfCanBreak(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        def is_break(count1, count2):\n            curr1, curr2 = 0, 0\n            for c in string.ascii_lowercase:\n                curr1 += count1[c]\n                curr2 += count2[c]\n                if curr1 < curr2:\n                    return False\n            return True\n\n        count1, count2 = collections.Counter(s1), collections.Counter(s2)\n        return is_break(count1, count2) or is_break(count2, count1)\n    \n\n# Time:  O(nlogn)\n# Space: O(1)\nimport itertools\n\n\nclass Solution2(object):\n    def checkIfCanBreak(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        return not {1, -1}.issubset(set(cmp(a, b) for a, b in itertools.izip(sorted(s1), sorted(s2))))\n\n\n# Time:  O(nlogn)\n# Space: O(1)\nimport itertools\n\n\nclass Solution3(object):\n    def checkIfCanBreak(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        s1, s2 = sorted(s1), sorted(s2)\n        return all(a >= b for a, b in itertools.izip(s1, s2)) or \\\n               all(a <= b for a, b in itertools.izip(s1, s2))\n"
    },
    {
        "problem_name": "check-if-a-string-contains-all-binary-codes-of-size-k",
        "solution": "# Time:  O(n * k)\n# Space: O(k * 2^k)\n\nclass Solution(object):\n    def hasAllCodes(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        return 2**k <= len(s) and len({s[i:i+k] for i in xrange(len(s)-k+1)}) == 2**k\n    \n\n# Time:  O(n * k)\n# Space: O(2^k)\nclass Solution2(object):\n    def hasAllCodes(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        lookup = set()\n        base = 2**k\n        if base > len(s):\n            return False\n        num = 0\n        for i in xrange(len(s)):\n            num = (num << 1) + (s[i] == '1')\n            if i >= k-1:\n                lookup.add(num)\n                num -= (s[i-k+1] == '1') * (base//2)\n        return len(lookup) == base\n"
    },
    {
        "problem_name": "check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(w)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# bfs solution\nclass Solution(object):\n    def isValidSequence(self, root, arr):\n        \"\"\"\n        :type root: TreeNode\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        q = [root]\n        for depth in xrange(len(arr)):\n            new_q = []\n            while q:\n                node = q.pop()\n                if not node or node.val != arr[depth]:\n                    continue\n                if depth+1 == len(arr) and node.left == node.right:\n                    return True\n                new_q.extend(child for child in (node.left, node.right))\n            q = new_q\n        return False\n\n\n# Time:  O(n)\n# Space: O(h)\n# dfs solution with stack\nclass Solution2(object):\n    def isValidSequence(self, root, arr):\n        \"\"\"\n        :type root: TreeNode\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        s = [(root, 0)]\n        while s:\n            node, depth = s.pop()\n            if not node or depth == len(arr) or node.val != arr[depth]:\n                continue\n            if depth+1 == len(arr) and node.left == node.right:\n                return True\n            s.append((node.right, depth+1))\n            s.append((node.left, depth+1))\n        return False\n\n\n# Time:  O(n)\n# Space: O(h)\n# dfs solution with recursion\nclass Solution3(object):\n    def isValidSequence(self, root, arr):\n        \"\"\"\n        :type root: TreeNode\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        def dfs(node, arr, depth):\n            if not node or depth == len(arr) or node.val != arr[depth]:\n                return False\n            if depth+1 == len(arr) and node.left == node.right:\n                return True\n            return dfs(node.left, arr, depth+1) or dfs(node.right, arr, depth+1)\n\n        return dfs(root, arr, 0)\n"
    },
    {
        "problem_name": "check-if-a-string-is-an-acronym-of-words",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\n# string\nclass Solution(object):\n    def isAcronym(self, words, s):\n        \"\"\"\n        :type words: List[str]\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return len(words) == len(s) and all(w[0] == c for w, c in itertools.izip(words, s))\n"
    },
    {
        "problem_name": "check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def isPrefixOfWord(self, sentence, searchWord):\n        \"\"\"\n        :type sentence: str\n        :type searchWord: str\n        :rtype: int\n        \"\"\"\n        def KMP(text, pattern):\n            def getPrefix(pattern):\n                prefix = [-1] * len(pattern)\n                j = -1\n                for i in xrange(1, len(pattern)):\n                    while j > -1 and pattern[j + 1] != pattern[i]:\n                        j = prefix[j]\n                    if pattern[j + 1] == pattern[i]:\n                        j += 1\n                    prefix[i] = j\n                return prefix\n    \n            prefix = getPrefix(pattern)\n            j = -1\n            for i in xrange(len(text)):\n                while j != -1 and pattern[j+1] != text[i]:\n                    j = prefix[j]\n                if pattern[j+1] == text[i]:\n                    j += 1\n                if j+1 == len(pattern):\n                    return i-j\n            return -1\n        \n        if sentence.startswith(searchWord):\n            return 1\n        p = KMP(sentence, ' ' + searchWord)\n        if p == -1:\n            return -1\n        return 1+sum(sentence[i] == ' ' for i in xrange(p+1))\n"
    },
    {
        "problem_name": "check-if-all-1s-are-at-least-length-k-places-away",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def kLengthApart(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        prev = -k-1\n        for i in xrange(len(nums)):\n            if not nums[i]:\n                continue\n            if i-prev <= k:\n                return False\n            prev = i\n        return True\n"
    },
    {
        "problem_name": "check-if-all-as-appears-before-all-bs",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def checkString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return \"ba\" not in s\n"
    },
    {
        "problem_name": "check-if-all-characters-have-equal-number-of-occurrences",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def areOccurrencesEqual(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return len(set(collections.Counter(s).itervalues())) == 1\n"
    },
    {
        "problem_name": "check-if-all-the-integers-in-a-range-are-covered",
        "solution": "# Time:  O(n + r)\n# Space: O(r)\n\n# if r is small, this is better\nclass Solution(object):\n    def isCovered(self, ranges, left, right):\n        \"\"\"\n        :type ranges: List[List[int]]\n        :type left: int\n        :type right: int\n        :rtype: bool\n        \"\"\"\n        RANGE_SIZE = 50\n\n        interval = [0]*(RANGE_SIZE+1)\n        for l, r in ranges:\n            interval[l-1] += 1\n            interval[(r-1)+1] -= 1\n        cnt = 0\n        for i in xrange((right-1)+1):\n            cnt += interval[i]\n            if i >= left-1 and not cnt:\n                return False\n        return True\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# if r is big, this is better\nclass Solution2(object):\n    def isCovered(self, ranges, left, right):\n        \"\"\"\n        :type ranges: List[List[int]]\n        :type left: int\n        :type right: int\n        :rtype: bool\n        \"\"\"\n        ranges.sort()\n        for l, r in ranges:\n            if l <= left <= r:\n                left = r+1\n        return left > right\n\n\n# Time:  O(n * r)\n# Space: O(1)\nclass Solution3(object):\n    def isCovered(self, ranges, left, right):\n        \"\"\"\n        :type ranges: List[List[int]]\n        :type left: int\n        :type right: int\n        :rtype: bool\n        \"\"\"\n        return all(any(l <= i <= r for l, r in ranges) for i in xrange(left, right+1))\n"
    },
    {
        "problem_name": "check-if-an-array-is-consecutive",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table\nclass Solution(object):\n    def isConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return max(nums)-min(nums)+1 == len(nums) == len(set(nums))\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# sort\nclass Solution2(object):\n    def isConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        nums.sort()\n        return all(nums[i]+1 == nums[i+1] for i in xrange(len(nums)-1))\n"
    },
    {
        "problem_name": "check-if-an-original-string-exists-given-two-encoded-strings",
        "solution": "# Time:  O(m * n * k), k is the max number of consecutive digits in s1 and s2\n# Space: O(m * n * k)\n\n# top-down dp (faster since accessing less states)\nclass Solution(object):\n    def possiblyEquals(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        def general_possible_numbers(s):  # Time: O(2^l), Space: O(2^l), l is the length of consecutive digits, and l is at most 3\n            dp = [set() for _ in xrange(len(s))]\n            for i in xrange(len(s)):\n                curr, basis = 0, 1\n                for j in reversed(xrange(i+1)):\n                    curr += int(s[j])*basis\n                    basis *= 10\n                    if s[j] == '0':\n                        continue\n                    if j == 0:\n                        dp[i].add(curr)\n                    else:\n                        dp[i].update(x+curr for x in dp[j-1])        \n            return dp[-1]\n\n        def optimized_possible_numbers(s):\n            assert(len(s) <= 3)\n            result = {int(s)}\n            if len(s) >= 2:\n                if s[1] != '0':\n                    result.add(int(s[:1])+int(s[1:]))\n            if len(s) >= 3:\n                if s[2] != '0':\n                    result.add(int(s[:2])+int(s[2:]))\n                    if s[1] != '0':\n                        result.add(int(s[0:1])+int(s[1:2])+int(s[2:]))\n            return result\n    \n        def memoization(s1, s2, i, j, k, lookup):\n            if (i, j, k) not in lookup:\n                if i == len(s1) and j == len(s2):\n                    lookup[(i, j, k)] = (k == 0)\n                elif i != len(s1) and s1[i].isdigit():\n                    lookup[(i, j, k)] = False\n                    for ni in xrange(i+1, len(s1)+1):\n                        if ni == len(s1) or not s1[ni].isdigit():\n                            break\n                    for x in optimized_possible_numbers(s1[i:ni]):\n                        if memoization(s1, s2, ni, j, k+x, lookup):\n                            lookup[(i, j, k)] = True\n                            break\n                elif j != len(s2) and s2[j].isdigit():\n                    lookup[(i, j, k)] = False\n                    for nj in xrange(j+1, len(s2)+1):\n                        if nj == len(s2) or not s2[nj].isdigit():\n                            break\n                    for x in optimized_possible_numbers(s2[j:nj]):\n                        if memoization(s1, s2, i, nj, k-x, lookup):\n                            lookup[(i, j, k)] = True\n                            break\n                elif k < 0:\n                    lookup[(i, j, k)] = memoization(s1, s2, i+1, j, k+1, lookup) if i != len(s1) else False\n                elif k > 0:\n                    lookup[(i, j, k)] = memoization(s1, s2, i, j+1, k-1, lookup) if j != len(s2) else False\n                else:\n                    lookup[(i, j, k)] = memoization(s1, s2, i+1, j+1, k, lookup) if i != len(s1) and j != len(s2) and s1[i] == s2[j] else False\n            return lookup[(i, j, k)]\n\n        return memoization(s1, s2, 0, 0, 0, {})\n\n\n# Time:  O(m * n * k), k is the max number of consecutive digits in s1 and s2\n# Space: O(m * n * k)\n# top-down dp (faster since accessing less states)\nclass Solution2(object):\n    def possiblyEquals(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        def memoization(s1, s2, i, j, k, lookup):\n            if (i, j, k) not in lookup:\n                if i == len(s1) and j == len(s2):\n                    lookup[(i, j, k)] = (k == 0)\n                elif i != len(s1) and s1[i].isdigit():\n                    lookup[(i, j, k)] = False\n                    for ni in xrange(i+1, len(s1)+1):\n                        if (ni == len(s1) or s1[ni] != '0') and memoization(s1, s2, ni, j, k+int(s1[i:ni]), lookup):\n                            lookup[(i, j, k)] = True\n                            break\n                        if ni == len(s1) or not s1[ni].isdigit():\n                            break\n                elif j != len(s2) and s2[j].isdigit():\n                    lookup[(i, j, k)] = False\n                    for nj in xrange(j+1, len(s2)+1):\n                        if (nj == len(s2) or s2[nj] != '0') and memoization(s1, s2, i, nj, k-int(s2[j:nj]), lookup):\n                            lookup[(i, j, k)] = True\n                            break\n                        if nj == len(s2) or not s2[nj].isdigit():\n                            break\n                elif k < 0:\n                    lookup[(i, j, k)] = memoization(s1, s2, i+1, j, k+1, lookup) if i != len(s1) else False\n                elif k > 0:\n                    lookup[(i, j, k)] = memoization(s1, s2, i, j+1, k-1, lookup) if j != len(s2) else False\n                else:\n                    lookup[(i, j, k)] = memoization(s1, s2, i+1, j+1, k, lookup) if i != len(s1) and j != len(s2) and s1[i] == s2[j] else False\n            return lookup[(i, j, k)]\n\n        return memoization(s1, s2, 0, 0, 0, {})\n\n\n# Time:  O(m * n * k), k is the max number of consecutive digits in s1 and s2\n# Space: O(min(m, n) * k)\n# bottom-up dp\nclass Solution3(object):\n    def possiblyEquals(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        MAX_DIGIT_LEN = 3\n        w = 1+MAX_DIGIT_LEN\n        dp = [[set() for _ in xrange(len(s2)+1)] for _ in xrange(w)]\n        dp[0][0].add(0)\n        for i in xrange(len(s1)+1):\n            if i:\n                dp[(i-1)%w] = [set() for _ in xrange(len(s2)+1)]\n            if i != len(s1) and s1[i] == '0':\n                continue\n            for j in xrange(len(s2)+1):\n                for k in dp[i%w][j]:\n                    if i != len(s1) and j != len(s2) and s1[i] == s2[j] and k == 0:\n                        dp[(i+1)%w][j+1].add(k)\n                    if k <= 0 and i != len(s1):\n                        if not s1[i].isdigit():\n                            if k:\n                                dp[(i+1)%w][j].add(k+1)\n                        elif s1[i] != '0':\n                            curr = 0\n                            for ni in xrange(i, len(s1)):\n                                if not s1[ni].isdigit():\n                                    break\n                                curr = curr*10 + int(s1[ni])\n                                dp[(ni+1)%w][j].add(k+curr)\n                    if k >= 0 and j != len(s2):\n                        if not s2[j].isdigit():\n                            if k:\n                                dp[i%w][j+1].add(k-1)\n                        elif s2[j] != '0':\n                            curr = 0\n                            for nj in xrange(j, len(s2)):\n                                if not s2[nj].isdigit():\n                                    break\n                                curr = curr*10 + int(s2[nj])\n                                dp[i%w][nj+1].add(k-curr)\n        return 0 in dp[len(s1)%w][len(s2)]\n"
    },
    {
        "problem_name": "check-if-array-is-good",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# freq table\nclass Solution(object):\n    def isGood(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        cnt = [0]*len(nums)\n        for x in nums:\n            if x < len(cnt):\n                cnt[x] += 1\n            else:\n                return False\n        return all(cnt[x] == 1 for x in xrange(1, len(nums)-1))\n"
    },
    {
        "problem_name": "check-if-array-is-sorted-and-rotated",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def check(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        count = 0\n        for i in xrange(len(nums)):\n            if nums[i] > nums[(i+1)%len(nums)]:\n                count += 1\n                if count > 1:\n                    return False\n        return True\n"
    },
    {
        "problem_name": "check-if-array-pairs-are-divisible-by-k",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\nimport collections\n\n\nclass Solution(object):\n    def canArrange(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        count = collections.Counter(i%k for i in arr)\n        return (0 not in count or not count[0]%2) and \\\n                all(k-i in count and count[i] == count[k-i] for i in xrange(1, k) if i in count)\n"
    },
    {
        "problem_name": "check-if-binary-string-has-at-most-one-segment-of-ones",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def checkOnesSegment(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return \"01\" not in s\n"
    },
    {
        "problem_name": "check-if-bitwise-or-has-trailing-zeros",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def hasTrailingZeros(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return sum(x%2 == 0 for x in nums) >= 2\n"
    },
    {
        "problem_name": "check-if-every-row-and-column-contains-all-numbers",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def checkValid(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        return all(len(set(row)) == len(matrix) for row in matrix) and all(len(set(matrix[i][j] for i in xrange(len(matrix)))) == len(matrix) for j in xrange(len(matrix[0])))\n\n\n# Time:  O(n^2)\n# Space: O(1)\n# [[1,3,3,4,4],[4,1,3,3,4],[4,4,1,3,3],[3,4,4,1,3],[3,3,4,4,1]]\nclass Solution_Wrong(object):\n    def checkValid(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        return all(reduce(lambda x, y: x^y, (matrix[i][j]^(j+1) for j in xrange(len(matrix[0])))) == 0 for i in xrange(len(matrix))) and \\\n               all(reduce(lambda x, y: x^y, (matrix[i][j]^(i+1) for i in xrange(len(matrix)))) == 0 for j in xrange(len(matrix[0])))\n"
    },
    {
        "problem_name": "check-if-grid-satisfies-conditions",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def satisfiesConditions(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        return (all(grid[i][j] == grid[i+1][j] for j in xrange(len(grid[0])) for i in xrange(len(grid)-1)) and \n                all(grid[0][j] != grid[0][j+1] for j in xrange(len(grid[0])-1)))\n"
    },
    {
        "problem_name": "check-if-it-is-a-good-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isGoodArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        # B\u00e9zout's identity\n        result = nums[0]\n        for num in nums:\n            result = gcd(result, num)\n            if result == 1:\n                break\n        return result == 1\n"
    },
    {
        "problem_name": "check-if-it-is-a-straight-line",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def checkStraightLine(self, coordinates):\n        \"\"\"\n        :type coordinates: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        i, j = coordinates[:2]\n        return all(i[0] * j[1] - j[0] * i[1] +\n                   j[0] * k[1] - k[0] * j[1] +\n                   k[0] * i[1] - i[0] * k[1] == 0\n                   for k in coordinates)\n"
    },
    {
        "problem_name": "check-if-it-is-possible-to-split-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# constructive algorithms\nclass Solution(object):\n    def canSplitArray(self, nums, m):\n        \"\"\"\n        :type nums: List[int]\n        :type m: int\n        :rtype: bool\n        \"\"\"\n        return len(nums) <= 2 or any(nums[i]+nums[i+1] >= m for i in xrange(len(nums)-1))\n"
    },
    {
        "problem_name": "check-if-matrix-is-x-matrix",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def checkXMatrix(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        return all((i-j == 0 or i+j == len(grid)-1) == (grid[i][j] != 0) for i in xrange(len(grid)) for j in xrange(len(grid[0])))\n"
    },
    {
        "problem_name": "check-if-move-is-legal",
        "solution": "# Time:  O(8 * n) = O(1), grid is a n x n board and n = 8\n# Space: O(1)\n\nclass Solution(object):\n    def checkMove(self, board, rMove, cMove, color):\n        \"\"\"\n        :type board: List[List[str]]\n        :type rMove: int\n        :type cMove: int\n        :type color: str\n        :rtype: bool\n        \"\"\"\n        def check(board, color, r, c, dr, dc):\n            l = 2\n            while 0 <= r < len(board) and 0 <= c < len(board[0]) and board[r][c] != '.':\n                if board[r][c] == color:\n                    return l >= 3    \n                r += dr\n                c += dc\n                l += 1\n            return False\n\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0),\n                      (-1, -1), (1, -1), (-1, 1), (1, 1)]\n        for dr, dc in directions:\n            r, c = rMove+dr, cMove+dc\n            if check(board, color, r, c, dr, dc):\n                return True\n        return False\n"
    },
    {
        "problem_name": "check-if-n-and-its-double-exist",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def checkIfExist(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        lookup = set()\n        for x in arr:\n            if 2*x in lookup or \\\n               (x%2 == 0 and x//2 in lookup):\n                return True\n            lookup.add(x)\n        return False\n"
    },
    {
        "problem_name": "check-if-number-has-equal-digit-count-and-digit-value",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def digitCount(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: bool\n        \"\"\"\n        cnt = collections.Counter(num)\n        return all(cnt[str(i)] == int(x) for i, x in enumerate(num))\n"
    },
    {
        "problem_name": "check-if-number-is-a-sum-of-powers-of-three",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def checkPowersOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        while n > 0:\n            if n%3 == 2:\n                return False\n            n //= 3\n        return True\n"
    },
    {
        "problem_name": "check-if-numbers-are-ascending-in-a-sentence",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def areNumbersAscending(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        prev = curr = -1\n        for i, c in enumerate(s):\n            if c.isdigit():\n                curr = max(curr, 0)*10+int(c)\n                continue\n            if prev != -1 and curr != -1 and prev >= curr:\n                return False\n            if curr != -1:\n                prev = curr\n            curr = -1            \n        return curr == -1 or prev < curr\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def areNumbersAscending(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        nums = [int(x) for x in s.split() if x.isdigit()]\n        return all(nums[i] < nums[i+1] for i in xrange(len(nums)-1))\n"
    },
    {
        "problem_name": "check-if-one-string-swap-can-make-strings-equal",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def areAlmostEqual(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        diff = []\n        for a, b in itertools.izip(s1, s2):\n            if a == b:\n                continue\n            if len(diff) == 2:\n                return False\n            diff.append([a, b] if not diff else [b, a])\n        return not diff or (len(diff) == 2 and diff[0] == diff[1])\n"
    },
    {
        "problem_name": "check-if-point-is-reachable",
        "solution": "# Time:  O(log(min(a, b)))\n# Space: O(1)\n\n# number theory\nclass Solution(object):\n    def isReachable(self, targetX, targetY):\n        \"\"\"\n        :type targetX: int\n        :type targetY: int\n        :rtype: bool\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n    \n        g = gcd(targetX, targetY)\n        return g == (g&~(g-1))  # co-prime other than factor 2\n"
    },
    {
        "problem_name": "check-if-string-is-a-prefix-of-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isPrefixString(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: bool\n        \"\"\"\n        i = j = 0\n        for c in s:\n            if i == len(words) or words[i][j] != c:\n                return False \n            j += 1\n            if j == len(words[i]):\n                i += 1\n                j = 0\n        return j == 0\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def isPrefixString(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: bool\n        \"\"\"\n        i = 0\n        for word in words:\n            for c in word:\n                if i == len(s) or s[i] != c:\n                    return False\n                i += 1\n            if i == len(s):\n                return True\n        return False\n"
    },
    {
        "problem_name": "check-if-string-is-decomposable-into-value-equal-substrings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isDecomposable(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s)%3 != 2:\n            return False\n        for left in xrange(0, len(s), 3):\n            if any(s[i] != s[i-1] for i in xrange(left+1, min(left+3, len(s)))):\n                break            \n        for right in reversed(xrange(left+1, len(s), 3)):\n            if any(s[i] != s[i+1] for i in reversed(xrange(max(right-2, left), right))):\n                break\n        return right-left == 1\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def isDecomposable(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        found, i = False, 0\n        while i < len(s):\n            l = 1\n            for j in xrange(i+1, min(i+3, len(s))):\n                if s[j] != s[i]:\n                    break\n                l += 1\n            if l < 2:\n                return False\n            if l == 2:\n                if found:\n                    return False\n                found = True\n            i += l  \n        return found\n        \n\n# Time:  O(n)\n# Space: O(1)\nclass Solution3(object):\n    def isDecomposable(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        found, l = False, 0\n        for i, c in enumerate(s):\n            if not l or c != s[i-1]:\n                if l:\n                    return False\n                l = 1\n                continue\n            l += 1\n            if l == 2:\n                if i == len(s)-1 or s[i] != s[i+1]:\n                    if found:\n                        return False\n                    found, l = True, 0\n            elif l == 3:\n                 l =  0\n        return found\n"
    },
    {
        "problem_name": "check-if-string-is-transformable-with-substring-sort-operations",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def isTransformable(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        idxs = [[] for _ in xrange(10)]\n        for i in reversed(xrange(len(s))):\n            idxs[int(s[i])].append(i)\n        for c in t:\n            d = int(c)\n            if not idxs[d]:\n                return False\n            for k in xrange(d):  # a char can be moved left to the current position if it meets no smaller one\n                if idxs[k] and idxs[k][-1] < idxs[d][-1]:\n                    return False\n            idxs[d].pop()\n        return True\n"
    },
    {
        "problem_name": "check-if-strings-can-be-made-equal-with-operations-i",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def canBeEqual(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        return all(collections.Counter(s1[j] for j in xrange(i, len(s1), 2)) == collections.Counter(s2[j] for j in xrange(i, len(s2), 2)) for i in xrange(2))\n\n\n# Time:  O(1)\n# Space: O(1)\n# brute force\nclass Solution2(object):\n    def canBeEqual(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        return (((s1[0] == s2[0] and s1[2] == s2[2]) or (s1[0] == s2[2] and s1[2] == s2[0])) and\n                ((s1[1] == s2[1] and s1[3] == s2[3]) or (s1[1] == s2[3] and s1[3] == s2[1])))\n"
    },
    {
        "problem_name": "check-if-strings-can-be-made-equal-with-operations-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def checkStrings(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        return all(collections.Counter(s1[j] for j in xrange(i, len(s1), 2)) == collections.Counter(s2[j] for j in xrange(i, len(s2), 2)) for i in xrange(2))\n"
    },
    {
        "problem_name": "check-if-the-number-is-fascinating",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# string, bitmasks\nclass Solution(object):\n    def isFascinating(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        lookup = [0]\n        def check(x):\n            while x:\n                x, d = divmod(x, 10)\n                if d == 0 or lookup[0]&(1<<d):\n                    return False\n                lookup[0] |= (1<<d)\n            return True\n    \n        return check(n) and check(2*n) and check(3*n)\n\n\n# Time:  O(logn)\n# Space: O(logn)\n# string\nclass Solution2(object):\n    def isFascinating(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        s = str(n)+str(2*n)+str(3*n)\n        return '0' not in s and len(s) == 9 and len(set(s)) == 9\n"
    },
    {
        "problem_name": "check-if-the-sentence-is-pangram",
        "solution": "# Time:  O(n)\n# Space: O(26) = O(1)\n\nclass Solution(object):\n    def checkIfPangram(self, sentence):\n        \"\"\"\n        :type sentence: str\n        :rtype: bool\n        \"\"\"\n        return len(set(sentence)) == 26\n"
    },
    {
        "problem_name": "check-if-there-is-a-path-with-equal-number-of-0s-and-1s",
        "solution": "# Time:  O(m * n)\n# Space: O(n)\n\n# dp\nclass Solution(object):\n    def isThereAPath(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if (len(grid)+len(grid[0])-1)%2:\n            return False\n        dp_left = [[float(\"inf\")]*(len(grid[0])+1) for _ in xrange(2)]\n        dp_left[0][1] = dp_left[1][0] = 0\n        dp_right = [[float(\"-inf\")]*(len(grid[0])+1) for _ in xrange(2)]\n        dp_right[0][1] = dp_right[1][0] = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                dp_left[(i+1)%2][j+1] = min(dp_left[i%2][j+1], dp_left[(i+1)%2][j])+grid[i][j]\n                dp_right[(i+1)%2][j+1] = max(dp_right[i%2][j+1], dp_right[(i+1)%2][j])+grid[i][j]\n        return dp_left[len(grid)%2][-1] <= (len(grid)+len(grid[0])-1)//2 <= dp_right[len(grid)%2][-1]\n"
    },
    {
        "problem_name": "check-if-there-is-a-valid-parentheses-string-path",
        "solution": "# Time:  O((m * n) * (m + n) / 32)\n# Space: O(n * (m + n) / 32)\n\n# dp with bitsets\nclass Solution(object):\n    def hasValidPath(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        if (len(grid)+len(grid[0])-1)%2:\n            return False\n        dp = [0]*(len(grid[0])+1)\n        for i in xrange(len(grid)):\n            dp[0] = int(not i)\n            for j in xrange(len(grid[0])):\n                dp[j+1] = (dp[j]|dp[j+1])<<1 if grid[i][j] == '(' else (dp[j]|dp[j+1])>>1\n        return dp[-1]&1\n\n\n# Time:  O(m * n)\n# Space: O(n)\n# dp, optimized from solution1 (wrong answer)\nclass Solution_WA(object):\n    def hasValidPath(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        if (len(grid)+len(grid[0])-1)%2:\n            return False\n        dp = [[float(\"inf\"), float(\"-inf\")] for _ in xrange(len(grid[0])+1)]\n        for i in xrange(len(grid)):\n            dp[0] = [0, 0] if not i else [float(\"inf\"), float(\"-inf\")]\n            for j in xrange(len(grid[0])):\n                d = 1 if grid[i][j] == '(' else -1\n                dp[j+1] = [min(dp[j+1][0], dp[j][0])+d, max(dp[j+1][1], dp[j][1])+d]\n                # bitset pattern is like xxx1010101xxxx (in fact, it is not always true in this problem where some paths are invalid)\n                if dp[j+1][1] < 0:\n                    dp[j+1] = [float(\"inf\"), float(\"-inf\")]\n                else:\n                    dp[j+1][0] = max(dp[j+1][0], dp[j+1][1]%2)\n        return dp[-1][0] == 0\n"
    },
    {
        "problem_name": "check-if-there-is-a-valid-partition-for-the-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def validPartition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        dp = [False]*4\n        dp[0] = True\n        for i in xrange(len(nums)):\n            dp[(i+1)%4] = False\n            if i-1 >= 0 and nums[i] == nums[i-1]:\n                dp[(i+1)%4] |= dp[((i+1)-2)%4]\n            if i-2 >= 0 and (nums[i] == nums[i-1] == nums[i-2] or\n                             nums[i] == nums[i-1]+1 == nums[i-2]+2):\n                dp[(i+1)%4] |= dp[((i+1)-3)%4]\n        return dp[len(nums)%4]\n"
    },
    {
        "problem_name": "check-if-there-is-a-valid-path-in-a-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def hasValidPath(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        E, S, W, N = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        directions = [\n            [W, E], [N, S],\n            [W, S], [S, E],\n            [W, N], [N, E]\n        ]\n\n        for r, c in directions[grid[0][0]-1]:\n            if not (0 <= r < len(grid) and 0 <= c < len(grid[0])):\n                continue\n            pr, pc = 0, 0\n            while r != len(grid)-1 or c != len(grid[0])-1:\n                for dx, dy in directions[grid[r][c]-1]:\n                    nr, nc = r+dx, c+dy\n                    if (nr == pr and nc == pc) or \\\n                       not(0 <= nr < len(grid) and 0 <= nc < len(grid[0])) or \\\n                       (-dx, -dy) not in directions[grid[nr][nc]-1]:\n                        continue\n                    pr, pc, r, c = r, c, nr, nc\n                    break\n                else:\n                    return False\n            return True\n        return len(grid) == len(grid[0]) == 1 \n"
    },
    {
        "problem_name": "check-if-two-expression-trees-are-equivalent",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\nimport functools\n\n\n# Definition for a binary tree node.\nclass Node(object):\n    def __init__(self, val=\" \", left=None, right=None):\n        pass\n\n\n# morris traversal\nclass Solution(object):\n    def checkEquivalence(self, root1, root2):\n        \"\"\"\n        :type root1: Node\n        :type root2: Node\n        :rtype: bool\n        \"\"\"\n        def add_counter(counter, prev, d, val):\n            if val.isalpha():\n                counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d\n            prev[0] = val\n    \n        def morris_inorder_traversal(root, cb):\n            curr = root\n            while curr:\n                if curr.left is None:\n                    cb(curr.val)\n                    curr = curr.right\n                else:\n                    node = curr.left\n                    while node.right and node.right != curr:\n                        node = node.right\n                    if node.right is None:\n                        node.right = curr\n                        curr = curr.left\n                    else:\n                        cb(curr.val)\n                        node.right = None\n                        curr = curr.right\n\n        counter = collections.defaultdict(int)\n        morris_inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1))\n        morris_inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1))\n        return all(v == 0 for v in counter.itervalues())\n\n\n# Time:  O(n)\n# Space: O(h)\nimport collections\nimport functools\n\n\nclass Solution2(object):\n    def checkEquivalence(self, root1, root2):\n        \"\"\"\n        :type root1: Node\n        :type root2: Node\n        :rtype: bool\n        \"\"\"\n        def add_counter(counter, prev, d, val):\n            if val.isalpha():\n                counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d\n            prev[0] = val\n\n        def inorder_traversal(root, cb):\n            def traverseLeft(node, stk):\n                while node:\n                    stk.append(node)\n                    node = node.left \n\n            stk = []\n            traverseLeft(root, stk)\n            while stk:\n                curr = stk.pop()\n                cb(curr.val)\n                traverseLeft(curr.right, stk)\n                \n        counter = collections.defaultdict(int)\n        inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1))\n        inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1))\n        return all(v == 0 for v in counter.itervalues())\n"
    },
    {
        "problem_name": "check-if-two-string-arrays-are-equivalent",
        "solution": "# Time:  O(n), n is the total length of word1 and word2\n# Space: O(1)\n\nclass Solution(object):\n    def arrayStringsAreEqual(self, word1, word2):\n        \"\"\"\n        :type word1: List[str]\n        :type word2: List[str]\n        :rtype: bool\n        \"\"\"\n        idx1 = idx2 = arr_idx1 = arr_idx2 = 0\n        while arr_idx1 < len(word1) and arr_idx2 < len(word2):\n            if word1[arr_idx1][idx1] != word2[arr_idx2][idx2]:\n                break\n            idx1 += 1\n            if idx1 == len(word1[arr_idx1]):\n                idx1 = 0\n                arr_idx1 += 1\n            idx2 += 1\n            if idx2 == len(word2[arr_idx2]):\n                idx2 = 0\n                arr_idx2 += 1\n        return arr_idx1 == len(word1) and arr_idx2 == len(word2)\n"
    },
    {
        "problem_name": "check-if-word-can-be-placed-in-crossword",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def placeWordInCrossword(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def get_val(mat, i, j, transposed):\n            return mat[i][j] if not transposed else mat[j][i]\n\n        def get_vecs(mat, transposed):\n            for i in xrange(len(mat) if not transposed else len(mat[0])):\n                yield (get_val(mat, i, j, transposed) for j in xrange(len(mat[0]) if not transposed else len(mat)))\n\n        for direction in (lambda x: iter(x), reversed):\n            for transposed in xrange(2):\n                for row in get_vecs(board, transposed):\n                    it, matched = direction(word), True\n                    for c in row:\n                        if c == '#':\n                            if next(it, None) is None and matched:\n                                return True\n                            it, matched = direction(word), True\n                            continue\n                        if not matched:\n                            continue\n                        nc = next(it, None)\n                        matched = (nc is not None) and c in (nc, ' ')\n                    if (next(it, None) is None) and matched:\n                        return True\n        return False\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\nclass Solution2(object):\n    def placeWordInCrossword(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        words = [word, word[::-1]]\n        for mat in (board, zip(*board)):\n            for row in mat:\n                blocks = ''.join(row).split('#')\n                for s in blocks:\n                    if len(s) != len(word):\n                        continue\n                    for w in words:\n                        if all(s[i] in (w[i], ' ') for i in xrange(len(s))):\n                            return True\n        return False\n"
    },
    {
        "problem_name": "check-if-word-equals-summation-of-two-words",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isSumEqual(self, firstWord, secondWord, targetWord):\n        \"\"\"\n        :type firstWord: str\n        :type secondWord: str\n        :type targetWord: str\n        :rtype: bool\n        \"\"\"\n        def stoi(s):\n            result = 0\n            for c in s:\n                result = result*10 + ord(c)-ord('a')\n            return result\n        \n        return stoi(firstWord) + stoi(secondWord) == stoi(targetWord)\n"
    },
    {
        "problem_name": "check-if-word-is-valid-after-substitutions",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def isValid(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        for i in S:\n            if i == 'c':\n                if stack[-2:] == ['a', 'b']:\n                    stack.pop()\n                    stack.pop()\n                else:\n                    return False\n            else:\n                stack.append(i)\n        return not stack\n"
    },
    {
        "problem_name": "check-knight-tour-configuration",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\n# hash table, simulation\nclass Solution(object):\n    def checkValidGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if grid[0][0]:\n            return False\n        lookup = [None]*(len(grid)*len(grid[0]))\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                lookup[grid[i][j]] = (i, j)\n        return all(sorted([abs(lookup[i+1][0]-lookup[i][0]), abs(lookup[i+1][1]-lookup[i][1])]) == [1, 2] for i in xrange(len(lookup)-1))\n\n    \n# Time:  O(m * n)\n# Space: O(m * n)\n# hash table, simulation\nclass Solution2(object):\n    def checkValidGrid(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        lookup = {grid[i][j]:(i, j) for i in xrange(len(grid)) for j in xrange(len(grid[0]))}\n        return grid[0][0] == 0 and all(sorted([abs(lookup[i+1][0]-lookup[i][0]), abs(lookup[i+1][1]-lookup[i][1])]) == [1, 2] for i in xrange(len(lookup)-1))\n"
    },
    {
        "problem_name": "check-whether-two-strings-are-almost-equivalent",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def checkAlmostEquivalent(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: bool\n        \"\"\"\n        k = 3\n        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)\n        return all(abs(cnt1[c]-cnt2[c]) <= k for c in set(cnt1.keys()+cnt2.keys()))\n\n"
    },
    {
        "problem_name": "checking-existence-of-edge-length-limited-paths-ii",
        "solution": "# Time:  ctor:  O(mlogm + m * \u03b1(n) + nlogn) ~= O(mlogm + nlogn)\n#        query: O(\u03b1(n) + logn) ~= O(logn)\n# Space: O(nlogn + m)\n\nfrom functools import partial\n\n# Template:\n# https://github.com/kamyu104/GoogleKickStart-2020/blob/main/Round%20D/locked_doors.py\nclass TreeInfos(object):  # Time: O(NlogN), Space: O(NlogN), N is the number of nodes\n    def __init__(self, children):\n        def preprocess(curr, parent, weight):\n            if parent != -1:\n                W[curr].append(weight)\n                P[curr].append(parent)  # ancestors of the node i\n            i = 0\n            while i < len(P[curr]) and i < len(P[P[curr][i]]):\n                W[curr].append(max(W[curr][i], W[P[curr][i]][i]))\n                P[curr].append(P[P[curr][i]][i])\n                i += 1\n            C[0] += 1\n            L[curr] = C[0]  # the subtree of the node i is represented by traversal index L[i]..R[i]\n\n        def divide(curr, parent, weight):\n            stk.append(partial(postprocess, curr))\n            for child, w in reversed(children[curr]):\n                if child == parent:\n                    continue\n                stk.append(partial(divide, child, curr, w))\n            stk.append(partial(preprocess, curr, parent, weight))\n\n        def postprocess(curr):\n            R[curr] = C[0]  # the subtree of the node i is represented by traversal index L[i]..R[i]\n\n        N = len(children)\n        L, R, P, W, C = [0]*N, [0]*N, [[] for _ in xrange(N)], [[] for _ in xrange(N)], [-1]\n        for i in xrange(N):\n            if L[i]:\n                continue\n            stk = []\n            stk.append(partial(divide, i, -1, 0))\n            while stk:\n                stk.pop()()\n        self.L, self.R, self.P, self.W = L, R, P, W\n    \n    def is_ancestor(self, a, b):  # includes itself\n        return self.L[a] <= self.L[b] <= self.R[b] <= self.R[a]\n    \n    def max_weights(self, a, b):\n        def binary_lift(a, b):\n            w = 0\n            for i in reversed(xrange(len(self.P[a]))):  # O(logN)\n                if i < len(self.P[a]) and not self.is_ancestor(self.P[a][i], b):\n                    w = max(w, self.W[a][i])\n                    a = self.P[a][i]\n            return max(w, self.W[a][0])\n\n        w = 0\n        if not self.is_ancestor(a, b):\n            w = max(w, binary_lift(a, b))\n        if not self.is_ancestor(b, a):\n            w = max(w, binary_lift(b, a))\n        return w\n\n    \nclass UnionFind(object):  # Time: O(n * \u03b1(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:  # union by rank\n            self.set[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.set[y_root] = x_root\n        else:\n            self.set[y_root] = x_root\n            self.rank[x_root] += 1\n        return True\n\n\nclass DistanceLimitedPathsExist(object):\n\n    def __init__(self, n, edgeList):\n        \"\"\"\n        :type n: int\n        :type edgeList: List[List[int]]\n        \"\"\"\n        edgeList.sort(key = lambda x:x[2])\n        self.__uf = UnionFind(n)\n        self.__adj = [[] for _ in xrange(n)]\n        for index, (i, j, weight) in enumerate(edgeList):\n            if not self.__uf.union_set(i, j):\n                continue\n            self.__adj[i].append((j, weight))\n            self.__adj[j].append((i, weight))\n        self.__tree_infos = TreeInfos(self.__adj)\n\n    def query(self, p, q, limit):\n        \"\"\"\n        :type p: int\n        :type q: int\n        :type limit: int\n        :rtype: bool\n        \"\"\"\n        if self.__uf.find_set(p) != self.__uf.find_set(q):\n            return False\n        return self.__tree_infos.max_weights(p, q) < limit\n\n\n# Time:  ctor:  O(mlogm + m * \u03b1(n) * logm) ~= O(mlogm)\n#        query: O(logm + \u03b1(n) * logm) ~= O(logm)\n# Space: O(n + m * \u03b1(n) + m) ~= O(n + m)\nimport collections\nimport sortedcontainers\nimport bisect\n\n\nclass SnapshotArray(object):\n\n    def __init__(self, length):\n        \"\"\"\n        :type length: int\n        \"\"\"\n        self.__snaps = collections.defaultdict(lambda:sortedcontainers.SortedList([(0, 0)]))\n\n    def set(self, index, val, snap_id):\n        \"\"\"\n        :type index: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        i = self.__snaps[index].bisect_left((snap_id, float(\"-inf\")))\n        if i != len(self.__snaps[index]) and self.__snaps[index][i][0] == snap_id:\n            self.__snaps[index].remove(self.__snaps[index][i])\n        self.__snaps[index].add((snap_id, val))\n\n    def get(self, index, snap_id):\n        \"\"\"\n        :type index: int\n        :type snap_id: int\n        :rtype: int\n        \"\"\"\n        i = self.__snaps[index].bisect_left((snap_id+1, float(\"-inf\"))) - 1\n        return self.__snaps[index][i][1]   \n \n\nclass VersionedUnionFind(object):  # Time: O(n * \u03b1(n)), Space: O(n)\n\n    def __init__(self, n):\n        self.snap_id = 0\n        self.set = SnapshotArray(n)\n        for i in xrange(n):\n            self.set.set(i, i, self.snap_id)\n        self.rank = SnapshotArray(n)\n\n    def find_set(self, x, snap_id):\n        stk = []\n        while self.set.get(x, snap_id) != x:  # path compression\n            stk.append(x)\n            x = self.set.get(x, snap_id)\n        while stk:\n            self.set.set(stk.pop(), x, snap_id)\n        return x\n\n    def union_set(self, x, y):\n        x_root = self.find_set(x, self.snap_id)\n        y_root = self.find_set(y, self.snap_id)\n        if x_root == y_root:\n            return False\n        if self.rank.get(x_root, self.snap_id) < self.rank.get(y_root, self.snap_id):  # union by rank\n            self.set.set(x_root, y_root, self.snap_id)\n        elif self.rank.get(x_root, self.snap_id) > self.rank.get(y_root, self.snap_id):\n            self.set.set(y_root, x_root, self.snap_id)\n        else:\n            self.set.set(y_root, x_root, self.snap_id)\n            self.rank.set(x_root, self.rank.get(x_root, self.snap_id)+1, self.snap_id)\n        return True\n\n    def snap(self):\n        self.snap_id += 1\n\n\nclass DistanceLimitedPathsExist2(object):\n\n    def __init__(self, n, edgeList):\n        \"\"\"\n        :type n: int\n        :type edgeList: List[List[int]]\n        \"\"\"\n        edgeList.sort(key = lambda x:x[2])\n        self.__uf = VersionedUnionFind(n)\n        self.__weights = []\n        for index, (i, j, weight) in enumerate(edgeList):\n            if not self.__uf.union_set(i, j):\n                continue\n            self.__uf.snap()\n            self.__weights.append(weight)  \n\n    def query(self, p, q, limit):\n        \"\"\"\n        :type p: int\n        :type q: int\n        :type limit: int\n        :rtype: bool\n        \"\"\"\n        snap_id = bisect.bisect_left(self.__weights, limit)-1\n        if snap_id == -1:\n            return False\n        return self.__uf.find_set(p, snap_id) == self.__uf.find_set(q, snap_id)\n"
    },
    {
        "problem_name": "checking-existence-of-edge-length-limited-paths",
        "solution": "# Time:  O(nlogn + mlogm + n * \u03b1(n)) = O(nlogn + mlogm)\n# Space: O(n)\n\nclass UnionFind(object):  # Time: O(n * \u03b1(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:  # union by rank\n            self.set[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.set[y_root] = x_root\n        else:\n            self.set[y_root] = x_root\n            self.rank[x_root] += 1\n        return True\n\n\nclass Solution(object):\n    def distanceLimitedPathsExist(self, n, edgeList, queries):\n        \"\"\"\n        :type n: int\n        :type edgeList: List[List[int]]\n        :type queries: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        for i, q in enumerate(queries):\n            q.append(i)\n        edgeList.sort(key=lambda x: x[2])\n        queries.sort(key=lambda x: x[2])\n        \n        union_find = UnionFind(n)\n        result = [False]*len(queries)\n        curr = 0\n        for u, v, w, i in queries: \n            while curr < len(edgeList) and edgeList[curr][2] < w: \n                union_find.union_set(edgeList[curr][0], edgeList[curr][1])\n                curr += 1\n            result[i] = union_find.find_set(u) == union_find.find_set(v)\n        return result \n"
    },
    {
        "problem_name": "cherry-pickup-ii",
        "solution": "# Time:  O(m * n^2)\n# Space: O(n^2)\n\nimport itertools\n\n\nclass Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = [[[float(\"-inf\")]*(len(grid[0])+2) for _ in xrange(len(grid[0])+2)] for _ in xrange(2)]\n        dp[0][1][len(grid[0])] = grid[0][0] + grid[0][len(grid[0])-1]\n        for i in xrange(1, len(grid)):\n            for j in xrange(1, len(grid[0])+1):\n                for k in xrange(1, len(grid[0])+1):\n                    dp[i%2][j][k] = max(dp[(i-1)%2][j+d1][k+d2] for d1 in xrange(-1, 2) for d2 in xrange(-1, 2)) + \\\n                                    ((grid[i][j-1]+grid[i][k-1]) if j != k else grid[i][j-1])\n        return max(itertools.imap(max, *dp[(len(grid)-1)%2]))\n\n\n# Time:  O(m * n^2)\n# Space: O(n^2)\nimport itertools\n\n\nclass Solution2(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = [[[float(\"-inf\")]*len(grid[0]) for _ in xrange(len(grid[0]))] for _ in xrange(2)]\n        dp[0][0][len(grid[0])-1] = grid[0][0] + grid[0][len(grid[0])-1]\n        for i in xrange(1, len(grid)):\n            for j in xrange(len(grid[0])):\n                for k in xrange(len(grid[0])):\n                    dp[i%2][j][k] = max(dp[(i-1)%2][j+d1][k+d2] for d1 in xrange(-1, 2) for d2 in xrange(-1, 2)\n                                        if 0 <= j+d1 < len(grid[0]) and 0 <= k+d2 < len(grid[0])) + \\\n                                    ((grid[i][j]+grid[i][k]) if j != k else grid[i][j])\n        return max(itertools.imap(max, *dp[(len(grid)-1)%2]))\n"
    },
    {
        "problem_name": "cherry-pickup",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\nclass Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # dp holds the max # of cherries two k-length paths can pickup.\n        # The two k-length paths arrive at (i, k - i) and (j, k - j),\n        # respectively.\n        n = len(grid)\n        dp = [[-1 for _ in xrange(n)] for _ in xrange(n)]\n        dp[0][0] = grid[0][0]\n        max_len = 2 * (n-1)\n        directions = [(0, 0), (-1, 0), (0, -1), (-1, -1)]\n        for k in xrange(1, max_len+1):\n            for i in reversed(xrange(max(0, k-n+1), min(k+1, n))):  # 0 <= i < n, 0 <= k-i < n\n                for j in reversed(xrange(i, min(k+1, n))):          # i <= j < n, 0 <= k-j < n\n                    if grid[i][k-i] == -1 or grid[j][k-j] == -1:\n                        dp[i][j] = -1\n                        continue\n                    cnt = grid[i][k-i]\n                    if i != j:\n                        cnt += grid[j][k-j]\n                    max_cnt = -1\n                    for direction in directions:\n                        ii, jj = i+direction[0], j+direction[1]\n                        if ii >= 0 and jj >= 0 and dp[ii][jj] >= 0:\n                            max_cnt = max(max_cnt, dp[ii][jj]+cnt)\n                    dp[i][j] = max_cnt\n        return max(dp[n-1][n-1], 0)\n\n"
    },
    {
        "problem_name": "choose-edges-to-maximize-score-in-a-tree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# iterative dfs, tree dp\nclass Solution(object):\n    def maxScore(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def iter_dfs():\n            result = [(0, 0) for _ in xrange(len(adj))]\n            stk = [(1, 0)]\n            while stk:\n                step, u = stk.pop()\n                if step == 1:\n                    if not adj[u]:\n                        continue\n                    stk.append((2, u))\n                    for v, _ in adj[u]:\n                        stk.append((1, v))\n                elif step == 2:\n                    without_u = sum(max(result[v]) for v, w in adj[u])\n                    with_u = max(without_u-max(result[v])+(result[v][1]+w) for v, w in adj[u])\n                    result[u] = (with_u, without_u)\n            return max(result[0])\n            \n        adj = [[] for _ in xrange(len(edges))]\n        for i, (p, w) in enumerate(edges):\n            if i == 0:\n                continue\n            adj[p].append((i, w))\n        return iter_dfs()\n\n    \n# Time:  O(n)\n# Space: O(n)\n# dfs, tree dp\nclass Solution2(object):\n    def maxScore(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def dfs(u):\n            if not adj[u]:\n                return (0, 0)\n            children = [dfs(v) for v, _ in adj[u]]\n            without_u = sum(max(with_v, without_v) for with_v, without_v in children)\n            with_u = max(without_u-max(with_v, without_v)+(without_v+adj[u][i][1]) for i, (with_v, without_v) in enumerate(children))\n            return (with_u, without_u)\n            \n        adj = [[] for _ in xrange(len(edges))]\n        for i, (p, w) in enumerate(edges):\n            if i == 0:\n                continue\n            adj[p].append((i, w))\n        return max(dfs(0))\n"
    },
    {
        "problem_name": "choose-numbers-from-two-arrays-in-range",
        "solution": "# Time:  O(n^2 * v), v is max(max(nums1), max(nums2))\n# Space: O(n * v)\n\nimport collections\nimport itertools\n\n\n# dp\nclass Solution(object):\n    def countSubranges(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        result = 0\n        dp = collections.Counter()\n        for x, y in itertools.izip(nums1, nums2):\n            new_dp = collections.Counter()\n            new_dp[x] += 1\n            new_dp[-y] += 1\n            for v, c in dp.iteritems():\n                new_dp[v+x] = (new_dp[v+x]+c)%MOD\n                new_dp[v-y] = (new_dp[v-y]+c)%MOD\n            dp = new_dp\n            result = (result+dp[0])%MOD\n        return result\n"
    },
    {
        "problem_name": "cinema-seat-allocation",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def maxNumberOfFamilies(self, n, reservedSeats):\n        \"\"\"\n        :type n: int\n        :type reservedSeats: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = collections.defaultdict(lambda: [False]*3)\n        for r, c in reservedSeats:\n            if 2 <= c <= 5:\n                lookup[r][0] = True\n            if 4 <= c <= 7:\n                lookup[r][1] = True\n            if 6 <= c <= 9:\n                lookup[r][2] = True\n        result = 2*n\n        for a, b, c in lookup.itervalues():\n            if not a and not c:\n                continue\n            if not a or not b or not c:\n                result -= 1\n                continue\n            result -= 2\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(1)\nclass Solution2(object):\n    def maxNumberOfFamilies(self, n, reservedSeats):\n        \"\"\"\n        :type n: int\n        :type reservedSeats: List[List[int]]\n        :rtype: int\n        \"\"\"\n        reservedSeats.sort()\n        result, i = 2*n, 0\n        while i < len(reservedSeats):\n            reserved = [False]*3\n            curr = reservedSeats[i][0]\n            while i < len(reservedSeats) and reservedSeats[i][0] == curr:\n                _, c  = reservedSeats[i]\n                if 2 <= c <= 5:\n                    reserved[0] = True\n                if 4 <= c <= 7:\n                    reserved[1] = True\n                if 6 <= c <= 9:\n                    reserved[2] = True\n                i += 1\n            if not reserved[0] and not reserved[2]:\n                continue\n            if not all(reserved):\n                result -= 1\n                continue\n            result -= 2\n        return result\n"
    },
    {
        "problem_name": "circle-and-rectangle-overlapping",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):\n        \"\"\"\n        :type radius: int\n        :type x_center: int\n        :type y_center: int\n        :type x1: int\n        :type y1: int\n        :type x2: int\n        :type y2: int\n        :rtype: bool\n        \"\"\"\n        x1 -= x_center\n        y1 -= y_center\n        x2 -= x_center\n        y2 -= y_center\n        x = x1 if x1 > 0 else x2 if x2 < 0 else 0\n        y = y1 if y1 > 0 else y2 if y2 < 0 else 0\n        return x**2 + y**2 <= radius**2\n\n\n# Time:  O(1)\n# Space: O(1)\nclass Solution2(object):\n    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):\n        \"\"\"\n        :type radius: int\n        :type x_center: int\n        :type y_center: int\n        :type x1: int\n        :type y1: int\n        :type x2: int\n        :type y2: int\n        :rtype: bool\n        \"\"\"\n        x1 -= x_center\n        y1 -= y_center\n        x2 -= x_center\n        y2 -= y_center        \n        x = min(abs(x1), abs(x2)) if x1*x2 > 0 else 0\n        y = min(abs(y1), abs(y2)) if y1*y2 > 0 else 0\n        return x**2 + y**2 <= radius**2\n"
    },
    {
        "problem_name": "circular-array-loop",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def circularArrayLoop(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def next_index(nums, i):\n            return (i + nums[i]) % len(nums)\n\n        for i in xrange(len(nums)):\n            if nums[i] == 0:\n                continue\n\n            slow, fast = i, i\n            while nums[next_index(nums, slow)] * nums[i] > 0 and \\\n                  nums[next_index(nums, fast)] * nums[i] > 0 and \\\n                  nums[next_index(nums, next_index(nums, fast))] * nums[i] > 0:\n                slow = next_index(nums, slow)\n                fast = next_index(nums, next_index(nums, fast))\n                if slow == fast:\n                    if slow == next_index(nums, slow):\n                        break\n                    return True\n\n            slow, val = i, nums[i]\n            while nums[slow] * val > 0:\n                tmp = next_index(nums, slow)\n                nums[slow] = 0\n                slow = tmp\n\n        return False\n\n"
    },
    {
        "problem_name": "circular-permutation-in-binary-representation",
        "solution": "# Time:  O(2^n)\n# Space: O(1)\n\nclass Solution(object):\n    def circularPermutation(self, n, start):\n        \"\"\"\n        :type n: int\n        :type start: int\n        :rtype: List[int]\n        \"\"\"\n        return [start ^ (i>>1) ^ i for i in xrange(1<<n)]\n"
    },
    {
        "problem_name": "circular-sentence",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def isCircularSentence(self, sentence):\n        \"\"\"\n        :type sentence: str\n        :rtype: bool\n        \"\"\"\n        return sentence[0] == sentence[-1] and all(sentence[i-1] == sentence[i+1]for i in xrange(len(sentence)) if sentence[i] == ' ')\n"
    },
    {
        "problem_name": "climbing-stairs",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 1],\n             [1, 0]]\n        return matrix_mult([[1,  0]], matrix_expo(T, n))[0][0]  # [a0, a(-1)] * T^n\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    def climbStairs(self, n):\n        prev, current = 0, 1\n        for i in xrange(n):\n            prev, current = current, prev + current,\n        return current\n"
    },
    {
        "problem_name": "clone-binary-tree-with-random-pointer",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for Node.\nclass Node(object):\n    def __init__(self, val=0, left=None, right=None, random=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.random = random\n\n\n# Definition for NodeCopy.\nclass NodeCopy(object):\n    def __init__(self, val=0, left=None, right=None, random=None):\n        pass\n\n\nclass Solution(object):\n    def copyRandomBinaryTree(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: NodeCopy\n        \"\"\"\n        def iter_dfs(node, callback):\n            result = None\n            stk = [node]\n            while stk:\n                node = stk.pop()\n                if not node:\n                    continue\n                left_node, copy = callback(node)\n                if not result:\n                    result = copy\n                stk.append(node.right)\n                stk.append(left_node)\n            return result\n    \n        def merge(node):\n            copy = NodeCopy(node.val)\n            node.left, copy.left = copy, node.left\n            return copy.left, copy\n        \n        def clone(node):\n            copy = node.left\n            node.left.random = node.random.left if node.random else None\n            node.left.right = node.right.left if node.right else None\n            return copy.left, copy\n        \n        def split(node):\n            copy = node.left\n            node.left, copy.left = copy.left, copy.left.left if copy.left else None\n            return node.left, copy\n    \n        iter_dfs(root, merge)\n        iter_dfs(root, clone)\n        return iter_dfs(root, split)\n\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution_Recu(object):\n    def copyRandomBinaryTree(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: NodeCopy\n        \"\"\"\n        def dfs(node, callback):\n            if not node:\n                return None\n            left_node, copy = callback(node)\n            dfs(left_node, callback)\n            dfs(node.right, callback) \n            return copy\n    \n        def merge(node):\n            copy = NodeCopy(node.val)\n            node.left, copy.left = copy, node.left\n            return copy.left, copy\n        \n        def clone(node):\n            copy = node.left\n            node.left.random = node.random.left if node.random else None\n            node.left.right = node.right.left if node.right else None\n            return copy.left, copy\n        \n        def split(node):\n            copy = node.left\n            node.left, copy.left = copy.left, copy.left.left if copy.left else None\n            return node.left, copy\n    \n        dfs(root, merge)\n        dfs(root, clone)\n        return dfs(root, split)\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\nclass Solution2(object):\n    def copyRandomBinaryTree(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: NodeCopy\n        \"\"\" \n        lookup = collections.defaultdict(lambda: NodeCopy())\n        lookup[None] = None\n        stk = [root]\n        while stk:\n            node = stk.pop()\n            if not node:\n                continue\n            lookup[node].val = node.val\n            lookup[node].left = lookup[node.left]\n            lookup[node].right = lookup[node.right]\n            lookup[node].random = lookup[node.random]\n            stk.append(node.right)\n            stk.append(node.left)\n        return lookup[root]\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\nclass Solution2_Recu(object):\n    def copyRandomBinaryTree(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: NodeCopy\n        \"\"\" \n        def dfs(node, lookup):\n            if not node:\n                return\n            lookup[node].val = node.val\n            lookup[node].left = lookup[node.left]\n            lookup[node].right = lookup[node.right]\n            lookup[node].random = lookup[node.random]\n            dfs(node.left, lookup)\n            dfs(node.right, lookup)\n    \n        lookup = collections.defaultdict(lambda: NodeCopy())\n        lookup[None] = None\n        dfs(root, lookup)\n        return lookup[root]\n"
    },
    {
        "problem_name": "clone-graph",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass UndirectedGraphNode(object):\n    def __init__(self, x):\n        self.label = x\n        self.neighbors = []\n\nclass Solution(object):\n    # @param node, a undirected graph node\n    # @return a undirected graph node\n    def cloneGraph(self, node):\n        if node is None:\n            return None\n        cloned_node = UndirectedGraphNode(node.label)\n        cloned, queue = {node:cloned_node}, [node]\n\n        while queue:\n            current = queue.pop()\n            for neighbor in current.neighbors:\n                if neighbor not in cloned:\n                    queue.append(neighbor)\n                    cloned_neighbor = UndirectedGraphNode(neighbor.label)\n                    cloned[neighbor] = cloned_neighbor\n                cloned[current].neighbors.append(cloned[neighbor])\n        return cloned[node]\n\n"
    },
    {
        "problem_name": "clone-n-ary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\n\nclass Solution(object):\n    def cloneTree(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: Node\n        \"\"\"\n        result = [None]\n        stk = [(1, (root, result))]\n        while stk:\n            step, params = stk.pop()\n            if step == 1:\n                node, ret = params\n                if not node:\n                    continue\n                ret[0] = Node(node.val)\n                for child in reversed(node.children):\n                    ret1 = [None]\n                    stk.append((2, (ret1, ret)))\n                    stk.append((1, (child, ret1)))\n            else:\n                ret1, ret = params\n                ret[0].children.append(ret1[0])\n        return result[0]\n\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def cloneTree(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: Node\n        \"\"\"\n        def dfs(node):\n            if not node:\n                return None\n            copy = Node(node.val)\n            for child in node.children:\n                copy.children.append(dfs(child))\n            return copy\n        \n        return dfs(root)\n"
    },
    {
        "problem_name": "closest-binary-search-tree-value-ii",
        "solution": "# Time:  O(h + k)\n# Space: O(h)\n\nclass Solution(object):\n    def closestKValues(self, root, target, k):\n        \"\"\"\n        :type root: TreeNode\n        :type target: float\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # Helper to make a stack to the next node.\n        def nextNode(stack, child1, child2):\n            if stack:\n                if child2(stack):\n                    stack.append(child2(stack))\n                    while child1(stack):\n                        stack.append(child1(stack))\n                else:\n                    child = stack.pop()\n                    while stack and child is child2(stack):\n                        child = stack.pop()\n\n        # The forward or backward iterator.\n        backward = lambda stack: stack[-1].left\n        forward = lambda stack: stack[-1].right\n\n        # Build the stack to the closest node.\n        stack = []\n        while root:\n            stack.append(root)\n            root = root.left if target < root.val else root.right\n        dist = lambda node: abs(node.val - target)\n        forward_stack = stack[:stack.index(min(stack, key=dist))+1]\n\n        # Get the stack to the next smaller node.\n        backward_stack = list(forward_stack)\n        nextNode(backward_stack, backward, forward)\n\n        # Get the closest k values by advancing the iterators of the stacks.\n        result = []\n        for _ in xrange(k):\n            if forward_stack and \\\n                (not backward_stack or dist(forward_stack[-1]) < dist(backward_stack[-1])):\n                result.append(forward_stack[-1].val)\n                nextNode(forward_stack, forward, backward)\n            elif backward_stack and \\\n                (not forward_stack or dist(backward_stack[-1]) <= dist(forward_stack[-1])):\n                result.append(backward_stack[-1].val)\n                nextNode(backward_stack, backward, forward)\n        return result\n\n\nclass Solution2(object):\n    def closestKValues(self, root, target, k):\n        \"\"\"\n        :type root: TreeNode\n        :type target: float\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        # Helper class to make a stack to the next node.\n        class BSTIterator:\n            # @param root, a binary search tree's root node\n            def __init__(self, stack, child1, child2):\n                self.stack = list(stack)\n                self.cur = self.stack.pop()\n                self.child1 = child1\n                self.child2 = child2\n\n            # @return an integer, the next node\n            def next(self):\n                node = None\n                if self.cur and self.child1(self.cur):\n                    self.stack.append(self.cur)\n                    node = self.child1(self.cur)\n                    while self.child2(node):\n                        self.stack.append(node)\n                        node = self.child2(node)\n                elif self.stack:\n                    prev = self.cur\n                    node = self.stack.pop()\n                    while node:\n                        if self.child2(node) is prev:\n                            break\n                        else:\n                            prev = node\n                            node = self.stack.pop() if self.stack else None\n                self.cur = node\n                return node\n\n        # Build the stack to the closet node.\n        stack = []\n        while root:\n            stack.append(root)\n            root = root.left if target < root.val else root.right\n        dist = lambda node: abs(node.val - target) if node else float(\"inf\")\n        stack = stack[:stack.index(min(stack, key=dist))+1]\n\n        # The forward or backward iterator.\n        backward = lambda node: node.left\n        forward = lambda node: node.right\n        smaller_it, larger_it = BSTIterator(stack, backward, forward), BSTIterator(stack, forward, backward)\n        smaller_node, larger_node = smaller_it.next(), larger_it.next()\n\n        # Get the closest k values by advancing the iterators of the stacks.\n        result = [stack[-1].val]\n        for _ in xrange(k - 1):\n            if dist(smaller_node) < dist(larger_node):\n                result.append(smaller_node.val)\n                smaller_node = smaller_it.next()\n            else:\n                result.append(larger_node.val)\n                larger_node = larger_it.next()\n        return result\n\n\n\n"
    },
    {
        "problem_name": "closest-binary-search-tree-value",
        "solution": "# Time:  O(h)\n# Space: O(1)\n\nclass Solution(object):\n    def closestValue(self, root, target):\n        \"\"\"\n        :type root: TreeNode\n        :type target: float\n        :rtype: int\n        \"\"\"\n        gap = float(\"inf\")\n        closest = float(\"inf\")\n        while root:\n            if abs(root.val - target) < gap:\n                gap = abs(root.val - target)\n                closest = root.val\n            if target == root.val:\n                break\n            elif target < root.val:\n                root = root.left\n            else:\n                root = root.right\n        return closest\n"
    },
    {
        "problem_name": "closest-dessert-cost",
        "solution": "# Time:  O(m * max(max_base, target + max_topping / 2)) ~= O(m * t)\n# Space: O(max(max_base, target + max_topping / 2)) ~= O(t)\n\nclass Solution(object):\n    def closestCost(self, baseCosts, toppingCosts, target):\n        \"\"\"\n        :type baseCosts: List[int]\n        :type toppingCosts: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        max_count = 2\n        max_base, max_topping = max(baseCosts), max(toppingCosts)\n        dp = [False]*(max(max_base, target+max_topping//2)+1)\n        for b in baseCosts:\n            dp[b] = True\n        for t in toppingCosts:\n            for _ in xrange(max_count):\n                for i in reversed(xrange(len(dp)-t)):\n                    if dp[i]:\n                        dp[i+t] = True\n        result = float(\"inf\")\n        for i in xrange(1, len(dp)):\n            if not dp[i]:\n                continue\n            if abs(i-target) < abs(result-target):\n                result = i\n            if i >= target:\n                break\n        return result\n            \n\n# Time:  O(n * 3^m)\n# Space: O(m * t)\nclass Solution2(object):\n    def closestCost(self, baseCosts, toppingCosts, target):\n        \"\"\"\n        :type baseCosts: List[int]\n        :type toppingCosts: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        max_count = 2\n        def backtracking(toppingCosts, i, cost, target, lookup, result):\n            if (i, cost) in lookup:\n                return\n            lookup.add((i, cost))\n            if cost >= target or i == len(toppingCosts):\n                if (abs(cost-target), cost) < (abs(result[0]-target), result[0]):\n                    result[0] = cost\n                return\n            for j in xrange(max_count+1):\n                backtracking(toppingCosts, i+1, cost+j*toppingCosts[i], target, lookup, result)\n\n        result = [float(\"inf\")]\n        lookup = set()\n        for b in baseCosts:\n            backtracking(toppingCosts, 0, b, target, lookup, result)\n        return result[0]\n\n\n# Time:  O(3^m*log(3^m)) + O(n*log(3^m)) = O(m*(3^m + n))\n# Space: O(3^m)\nimport bisect\n\n\nclass Solution3(object):\n    def closestCost(self, baseCosts, toppingCosts, target):\n        \"\"\"\n        :type baseCosts: List[int]\n        :type toppingCosts: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        max_count = 2\n        combs = set([0])\n        for t in toppingCosts:\n            combs = set([c+i*t for c in combs for i in xrange(max_count+1)])\n        result, combs = float(\"inf\"), sorted(combs)\n        for b in baseCosts:\n            idx = bisect.bisect_left(combs, target-b)\n            if idx < len(combs):\n                result = min(result, b+combs[idx], key=lambda x: (abs(x-target), x))\n            if idx > 0:\n                result = min(result, b+combs[idx-1], key=lambda x: (abs(x-target), x))        \n        return result\n\n\n# Time:  O(n * 3^m)\n# Space: O(3^m)\nclass Solution4(object):\n    def closestCost(self, baseCosts, toppingCosts, target):\n        \"\"\"\n        :type baseCosts: List[int]\n        :type toppingCosts: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        max_count = 2\n        combs = set([0])\n        for t in toppingCosts:\n            combs = set([c+i*t for c in combs for i in xrange(max_count+1)])\n        result = float(\"inf\")\n        for b in baseCosts:\n            for c in combs:\n                result = min(result, b+c, key=lambda x: (abs(x-target), x))      \n        return result\n"
    },
    {
        "problem_name": "closest-divisors",
        "solution": "# Time:  O(sqrt(n))\n# Space: O(1)\n\nclass Solution(object):\n    def closestDivisors(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[int]\n        \"\"\"\n        def divisors(n):\n            for d in reversed(xrange(1, int(n**0.5)+1)):\n                if n % d == 0:\n                    return d, n//d\n            return 1, n\n\n        return min([divisors(num+1), divisors(num+2)], key=lambda x: x[1]-x[0])\n\n\n\n# Time:  O(sqrt(n))\n# Space: O(1)\nclass Solution2(object):\n    def closestDivisors(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[int]\n        \"\"\"\n        result, d = [1, num+1], 1\n        while d*d <= num+2:\n            if (num+2) % d == 0:\n                result = [d, (num+2)//d]\n            if (num+1) % d == 0:\n                result = [d, (num+1)//d]\n            d += 1\n        return result\n"
    },
    {
        "problem_name": "closest-fair-integer",
        "solution": "# Time:  O(logn)\n# Space: O(logn)\n\n# constructive algorithms, greedy\nclass Solution(object):\n    def closestFair(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        digits = map(int, str(n))\n        result = []\n        if len(digits)%2 == 0:            \n            left = [0]*2\n            for d in digits:\n                left[d%2] += 1\n            if left[0] == len(digits)//2:\n                return n\n            for i in reversed(xrange(len(digits)//2, len(digits))):\n                left[digits[i]%2] -= 1\n                right = [len(digits)//2-left[0], len(digits)//2-left[1]]\n                if any(x < 0 for x in right):\n                    continue\n                d = digits[i]+1 if right[(digits[i]+1)%2]-1 >= 0 else digits[i]+2\n                if d > 9:\n                    continue\n                right[d%2] -= 1\n                result = digits[:i]+[d]+[0]*right[0]+[1]*right[1]\n                break\n        if not result:\n            l = len(digits)//2+1\n            result = [1]+[0]*l+[1]*(l-1)\n        return int(\"\".join(map(str, result)))\n"
    },
    {
        "problem_name": "closest-leaf-in-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def findClosestLeaf(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def traverse(node, neighbors, leaves):\n            if not node:\n                return\n            if not node.left and not node.right:\n                leaves.add(node.val)\n                return\n            if node.left:\n                neighbors[node.val].append(node.left.val)\n                neighbors[node.left.val].append(node.val)\n                traverse(node.left, neighbors, leaves)\n            if node.right:\n                neighbors[node.val].append(node.right.val)\n                neighbors[node.right.val].append(node.val)\n                traverse(node.right, neighbors, leaves)\n\n        neighbors, leaves = collections.defaultdict(list), set()\n        traverse(root, neighbors, leaves)\n        q, lookup = [k], set([k])\n        while q:\n            next_q = []\n            for u in q:\n                if u in leaves:\n                    return u\n                for v in neighbors[u]:\n                    if v in lookup:\n                        continue\n                    lookup.add(v)\n                    next_q.append(v)\n            q = next_q\n        return 0\n\n"
    },
    {
        "problem_name": "closest-node-to-path-in-tree",
        "solution": "# Time:  O(n + q)\n# Space: O(n + q)\n\nimport collections\nfrom functools import partial\n\n\n# Template:\n# https://github.com/kamyu104/GoogleKickStart-2021/blob/main/Round%20H/dependent_events3.py\n# Tarjan's Offline LCA Algorithm\nclass UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n        self.ancestor = range(n)  # added\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x, y = self.find_set(x), self.find_set(y)\n        if x == y:\n            return False\n        if self.rank[x] > self.rank[y]:  # union by rank\n            x, y = y, x\n        self.set[x] = self.set[y]\n        if self.rank[x] == self.rank[y]:\n            self.rank[y] += 1\n        return True\n\n    def find_ancestor_of_set(self, x):  # added\n        return self.ancestor[self.find_set(x)]\n\n    def update_ancestor_of_set(self, x):  # added\n        self.ancestor[self.find_set(x)] = x\n\n\nclass TreeInfos(object):  # Time: O(N), Space: O(N + Q), N is the number of nodes\n    def __init__(self, children, pairs):\n        def preprocess(curr, parent):\n            # depth of the node i\n            D[curr] = 1 if parent == -1 else D[parent]+1\n\n        def divide(curr, parent):\n            stk.append(partial(postprocess, curr))\n            for i in reversed(xrange(len(children[curr]))):\n                child = children[curr][i]\n                if child == parent:\n                    continue\n                stk.append(partial(conquer, child, curr))\n                stk.append(partial(divide, child, curr))\n            stk.append(partial(preprocess, curr, parent))\n\n        def conquer(curr, parent):\n            uf.union_set(curr, parent)\n            uf.update_ancestor_of_set(parent)\n\n        def postprocess(u):\n            lookup[u] = True\n            for v in pairs[u]:\n                if not lookup[v]:\n                    continue\n                lca[min(u, v), max(u, v)] = uf.find_ancestor_of_set(v)\n\n        N = len(children)\n        D, uf, lca = [0]*N, UnionFind(N), {}\n        stk, lookup = [], [False]*N\n        stk.append(partial(divide, 0, -1))\n        while stk:\n            stk.pop()()\n        self.D, self.lca = D, lca\n\n\n# Tarjan's Offline LCA Algorithm\nclass Solution(object):\n    def closestNode(self, n, edges, query):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type query: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v), adj[v].append(u)\n        pairs = collections.defaultdict(set)\n        for start, end, node in query:\n            pairs[start].add(end), pairs[end].add(start)\n            pairs[start].add(node), pairs[node].add(start)\n            pairs[end].add(node), pairs[node].add(end)\n        tree_infos = TreeInfos(adj, pairs)\n        return [max((tree_infos.lca[min(x, y), max(x, y)] for x, y in ((start, end), (start, node), (end, node))), key=lambda x: tree_infos.D[x]) for start, end, node in query]\n\n\n# Time:  O(nlogn + qlogn)\n# Space: O(nlogn)\nfrom functools import partial\n\n\n# Template:\n# https://github.com/kamyu104/GoogleKickStart-2021/blob/main/Round%20H/dependent_events2.py\nclass TreeInfos2(object):  # Time: O(NlogN), Space: O(NlogN), N is the number of nodes\n    def __init__(self, children):  # modified\n        def preprocess(curr, parent):\n            # depth of the node i\n            D[curr] = 1 if parent == -1 else D[parent]+1\n            # ancestors of the node i\n            if parent != -1:\n                P[curr].append(parent)\n            i = 0\n            while i < len(P[curr]) and i < len(P[P[curr][i]]):\n                P[curr].append(P[P[curr][i]][i])\n                i += 1\n            # the subtree of the node i is represented by traversal index L[i]..R[i]\n            C[0] += 1\n            L[curr] = C[0]\n\n        def divide(curr, parent):\n            stk.append(partial(postprocess, curr))\n            for i in reversed(xrange(len(children[curr]))):\n                child = children[curr][i]\n                if child == parent:\n                    continue\n                stk.append(partial(divide, child, curr))\n            stk.append(partial(preprocess, curr, parent))\n\n        def postprocess(curr):\n            R[curr] = C[0]\n\n        N = len(children)\n        L, R, D, P, C = [0]*N, [0]*N, [0]*N, [[] for _ in xrange(N)], [-1]\n        stk = []\n        stk.append(partial(divide, 0, -1))\n        while stk:\n            stk.pop()()\n        assert(C[0] == N-1)\n        self.L, self.R, self.D, self.P = L, R, D, P\n\n    # Template:\n    # https://github.com/kamyu104/FacebookHackerCup-2019/blob/master/Final%20Round/little_boat_on_the_sea.py\n    def is_ancestor(self, a, b):  # includes itself\n        return self.L[a] <= self.L[b] <= self.R[b] <= self.R[a]\n\n    def lca(self, a, b):\n        if self.D[a] > self.D[b]:\n            a, b = b, a\n        if self.is_ancestor(a, b):\n            return a\n        for i in reversed(xrange(len(self.P[a]))):  # O(logN)\n            if i < len(self.P[a]) and not self.is_ancestor(self.P[a][i], b):\n                a = self.P[a][i]\n        return self.P[a][0]\n\n\n# binary lifting (online lca algorithm)\nclass Solution2(object):\n    def closestNode(self, n, edges, query):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type query: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v), adj[v].append(u)\n        tree_infos = TreeInfos2(adj)\n        return [max((tree_infos.lca(x, y) for x, y in ((start, end), (start, node), (end, node))), key=lambda x: tree_infos.D[x]) for start, end, node in query]\n\n\n# Time:  O(n + q * h)\n# Space: O(n)\nfrom functools import partial\n\n\n# Template:\n# https://github.com/kamyu104/GoogleKickStart-2021/blob/main/Round%20H/dependent_events2.py\nclass TreeInfos3(object):  # Time: O(N), Space: O(N), N is the number of nodes\n    def __init__(self, children):  # modified\n        def preprocess(curr, parent):\n            # depth of the node i\n            D[curr] = 1 if parent == -1 else D[parent]+1\n            # ancestors of the node i\n            P[curr] = parent\n\n        def divide(curr, parent):\n            for i in reversed(xrange(len(children[curr]))):\n                child = children[curr][i]\n                if child == parent:\n                    continue\n                stk.append(partial(divide, child, curr))\n            stk.append(partial(preprocess, curr, parent))\n\n        N = len(children)\n        D, P = [0]*N, [0]*N\n        stk = []\n        stk.append(partial(divide, 0, -1))\n        while stk:\n            stk.pop()()\n        self.D, self.P = D, P\n\n    def lca(self, a, b):  # Time: O(h)\n        while self.D[a] > self.D[b]:\n            a = self.P[a]\n        while self.D[a] < self.D[b]:\n            b = self.P[b]\n        while a != b:\n            a, b = self.P[a], self.P[b]\n        return a\n\n\n# lca\nclass Solution3(object):\n    def closestNode(self, n, edges, query):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type query: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v), adj[v].append(u)\n        tree_infos = TreeInfos3(adj)\n        return [max((tree_infos.lca(x, y) for x, y in ((start, end), (start, node), (end, node))), key=lambda x: tree_infos.D[x]) for start, end, node in query]\n\n\n# Time:  O(n^2 + q * n)\n# Space: O(n^2)\n# bfs\nclass Solution4(object):\n    def closestNode(self, n, edges, query):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type query: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def bfs(adj, root):\n            dist = [len(adj)]*len(adj)\n            q = [root]\n            dist[root] = 0\n            d = 0\n            while q:\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if d+1 >= dist[v]:\n                            continue\n                        dist[v] = d+1\n                        new_q.append(v)\n                q = new_q\n                d += 1\n            return dist\n\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v), adj[v].append(u)\n        dist = [bfs(adj, i) for i in xrange(n)]\n        result = []\n        for start, end, node in query:\n            x = end\n            while start != end:\n                if dist[node][start] < dist[node][x]:\n                    x = start\n                start = next(u for u in adj[start] if dist[u][end] < dist[start][end])\n            result.append(x)\n        return result\n\n\n# Time:  O(n^2 + q * n)\n# Space: O(n^2)\n# bfs\nclass Solution5(object):\n    def closestNode(self, n, edges, query):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type query: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def bfs(adj, root):\n            dist = [len(adj)]*len(adj)\n            q = [root]\n            dist[root] = 0\n            d = 0\n            while q:\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if d+1 >= dist[v]:\n                            continue\n                        dist[v] = d+1\n                        new_q.append(v)\n                q = new_q\n                d += 1\n            return dist\n\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v), adj[v].append(u)\n        dist = [bfs(adj, i) for i in xrange(n)]\n        return [max((i for i in xrange(n) if dist[start][node]+dist[node][end]-2*dist[node][i] == dist[start][i]+dist[i][end]), key=lambda x: dist[node][x]) for start, end, node in query]\n"
    },
    {
        "problem_name": "closest-nodes-queries-in-a-binary-search-tree",
        "solution": "# Time:  O(n + qlogn)\n# Space: O(n)\n\nimport bisect\n\n\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\n# iterative dfs, binary search\nclass Solution(object):\n    def closestNodes(self, root, queries):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type queries: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        def iter_dfs():\n            inorder = []\n            stk = [(1, root)]\n            while stk:\n                step, node = stk.pop()\n                if step == 1:\n                    if not node:\n                        continue\n                    stk.append((1, node.right))\n                    stk.append((2, node))\n                    stk.append((1, node.left))\n                elif step == 2:\n                    inorder.append(node.val)\n            return inorder\n\n        inorder = iter_dfs()\n        result = []\n        for q in queries:\n            i = bisect.bisect_left(inorder, q)\n            if i == len(inorder):\n                result.append([inorder[i-1], -1])\n            elif inorder[i] == q:\n                result.append([inorder[i], inorder[i]])\n            elif i-1 >= 0:\n                result.append([inorder[i-1], inorder[i]])\n            else:\n                result.append([-1, inorder[i]])\n        return result\n\n\n# Time:  O(n + qlogn)\n# Space: O(n)\nimport bisect\n\n\n# dfs, binary search\nclass Solution2(object):\n    def closestNodes(self, root, queries):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type queries: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        def dfs(node):\n            if not node:\n                return\n            dfs(node.left)\n            inorder.append(node.val)\n            dfs(node.right)\n\n        inorder = []\n        dfs(root)\n        result = []\n        for q in queries:\n            i = bisect.bisect_left(inorder, q)\n            if i == len(inorder):\n                result.append([inorder[i-1], -1])\n            elif inorder[i] == q:\n                result.append([inorder[i], inorder[i]])\n            elif i-1 >= 0:\n                result.append([inorder[i-1], inorder[i]])\n            else:\n                result.append([-1, inorder[i]])\n        return result\n"
    },
    {
        "problem_name": "closest-prime-numbers-in-range",
        "solution": "# Time:  precompute:  O(MAX_N * log(MAX_N))\n#        runtime:     O(log(MAX_N))\n# Space: O(MAX_N)\n\nimport bisect\n\n\n# Template:\n# https://github.com/kamyu104/LeetCode-Solutions/blob/master/Python/booking-concert-tickets-in-groups.py\nclass SegmentTree(object):\n    def __init__(self, N, build_fn, query_fn):\n        self.tree = [None]*(2*2**((N-1).bit_length()))\n        self.base = len(self.tree)//2\n        self.query_fn = query_fn\n        for i in xrange(self.base, self.base+N):\n            self.tree[i] = build_fn(i-self.base)\n        for i in reversed(xrange(1, self.base)):\n            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n\n    def query(self, L, R):\n        L += self.base\n        R += self.base\n        left = right = None\n        while L <= R:\n            if L & 1:\n                left = self.query_fn(left, self.tree[L])\n                L += 1\n            if R & 1 == 0:\n                right = self.query_fn(self.tree[R], right)\n                R -= 1\n            L //= 2\n            R //= 2\n        return self.query_fn(left, right)\n\n\n# number theory, segment tree\ndef linear_sieve_of_eratosthenes(n):\n    primes = []\n    spf = [-1]*(n+1)  # the smallest prime factor\n    for i in xrange(2, n+1):\n        if spf[i] == -1:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if i*p > n or p > spf[i]:\n                break\n            spf[i*p] = p\n    return primes  # len(primes) = O(n/(logn-1)), reference: https://math.stackexchange.com/questions/264544/how-to-find-number-of-prime-numbers-up-to-to-n\n\n\nMAX_N = 10**6\nPRIMES = linear_sieve_of_eratosthenes(MAX_N)\nST = SegmentTree(len(PRIMES)-1,\n                 build_fn=lambda i: [PRIMES[i+1]-PRIMES[i], [PRIMES[i], PRIMES[i+1]]],\n                 query_fn=lambda x, y: y if x is None else x if y is None else min(x, y))\nclass Solution(object):\n    def closestPrimes(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: List[int]\n        \"\"\"\n        i = bisect.bisect_left(PRIMES, left)\n        j = bisect.bisect_right(PRIMES, right)-1\n        return ST.query(i, j-1)[1] if i <= j-1 else [-1]*2\n"
    },
    {
        "problem_name": "closest-room",
        "solution": "# Time:  O(nlogn + klogk + klogn)\n# Space: O(n + k)\n\nfrom sortedcontainers import SortedList\n\n\nclass Solution(object):\n    def closestRoom(self, rooms, queries):\n        \"\"\"\n        :type rooms: List[List[int]]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def find_closest(ids, r):\n            result, min_dist = -1, float(\"inf\")\n            i = ids.bisect_right(r)\n            if i-1 >= 0 and abs(ids[i-1]-r) < min_dist:\n                min_dist = abs(ids[i-1]-r)\n                result = ids[i-1]\n            if i < len(ids) and abs(ids[i]-r) < min_dist:\n                min_dist = abs(ids[i]-r)\n                result = ids[i]\n            return result\n\n        rooms.sort(key=lambda x: x[1], reverse=True)\n        for i, q in enumerate(queries):\n            q.append(i)\n        queries.sort(key=lambda x: x[1], reverse=True)\n        ids = SortedList()\n        i = 0\n        result = [-1]*len(queries)\n        for r, s, idx in queries:\n            while i < len(rooms) and rooms[i][1] >= s:\n                ids.add(rooms[i][0])\n                i += 1\n            result[idx] = find_closest(ids, r)\n        return result\n\n    \n# Time:  O(nlogn + klogk + klogn)\n# Space: O(n + k)\nfrom sortedcontainers import SortedList\n\n\nclass Solution2(object):\n    def closestRoom(self, rooms, queries):\n        \"\"\"\n        :type rooms: List[List[int]]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def find_closest(ids, r):\n            result, min_dist = -1, float(\"inf\")\n            i = ids.bisect_right(r)\n            if i-1 >= 0 and abs(ids[i-1]-r) < min_dist:\n                min_dist = abs(ids[i-1]-r)\n                result = ids[i-1]\n            if i < len(ids) and abs(ids[i]-r) < min_dist:\n                min_dist = abs(ids[i]-r)\n                result = ids[i]\n            return result\n\n        rooms.sort(key=lambda x: x[1])\n        for i, q in enumerate(queries):\n            q.append(i)\n        queries.sort(key=lambda x: x[1])\n        ids = SortedList(i for i, _ in rooms)        \n        i = 0\n        result = [-1]*len(queries)\n        for r, s, idx in queries:\n            while i < len(rooms) and rooms[i][1] < s:\n                ids.remove(rooms[i][0])\n                i += 1\n            result[idx] = find_closest(ids, r)\n        return result\n"
    },
    {
        "problem_name": "closest-subsequence-sum",
        "solution": "# Time:  O(n * 2^(n/2))\n# Space: O(2^(n/2))\n\nimport bisect\n\n\nclass Solution(object):\n    def minAbsDifference(self, nums, goal):\n        \"\"\"\n        :type nums: List[int]\n        :type goal: int\n        :rtype: int\n        \"\"\"\n        mx, mn = sum(x for x in nums if x > 0), sum(x for x in nums if x < 0)\n        if goal > mx:\n            return goal-mx\n        if goal < mn:\n            return mn-goal\n        result = abs(goal)\n        sums1 = set([0])\n        for i in xrange(len(nums)//2):\n            for x in list(sums1):\n                if x+nums[i] in sums1:\n                    continue\n                sums1.add(x+nums[i])\n                result = min(result, abs(goal-x-nums[i]))  # case of right half part is 0\n        sorted_sums1 = sorted(sums1)  # Time: O((n/2) * 2^(n/2)) = O(n * 2^(n/2)), Space: O(2^(n/2))\n        sums2 = set([0])\n        for i in xrange(len(nums)//2, len(nums)):\n            for x in list(sums2):\n                if x+nums[i] in sums2:\n                    continue\n                sums2.add(x+nums[i])\n                ni = bisect.bisect_left(sorted_sums1, goal-x-nums[i])  # Time: O(2^(n/2)) * O(n/2)\n                if ni < len(sorted_sums1):\n                    result = min(result, abs(goal-x-nums[i]-sorted_sums1[ni]))\n                if ni > 0:\n                    result = min(result, abs(goal-x-nums[i]-sorted_sums1[ni-1]))\n                if result == 0:\n                    return result\n        return result\n"
    },
    {
        "problem_name": "clumsy-factorial",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# observation:\n# i*(i-1)/(i-2) = i+1+2/(i-2)\n#     if i = 3  => i*(i-1)/(i-2) = i + 3\n#     if i = 4  => i*(i-1)/(i-2) = i + 2\n#     if i >= 5 => i*(i-1)/(i-2) = i + 1\n#\n# clumsy(N):\n#     if N = 1 => N\n#     if N = 2 => N\n#     if N = 3 => N + 3\n#     if N = 4 => N + 2 + 1 = N + 3\n#     if N > 4 and N % 4 == 1 => N + 1 + (... = 0) + 2 - 1           = N + 2\n#     if N > 4 and N % 4 == 2 => N + 1 + (... = 0) + 3 - 2 * 1       = N + 2\n#     if N > 4 and N % 4 == 3 => N + 1 + (... = 0) + 4 - 3 * 2 / 1   = N - 1\n#     if N > 4 and N % 4 == 0 => N + 1 + (... = 0) + 5 - (4*3/2) + 1 = N + 1\n\nclass Solution(object):\n    def clumsy(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        if N <= 2:\n            return N\n        if N <= 4:\n            return N+3\n        \n        if N % 4 == 0:\n            return N+1\n        elif N % 4 <= 2:\n            return N+2\n        return N-1\n"
    },
    {
        "problem_name": "coin-change-2",
        "solution": "# Time:  O(n * m)\n# Space: O(m)\n\nclass Solution(object):\n    def change(self, amount, coins):\n        \"\"\"\n        :type amount: int\n        :type coins: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [0] * (amount+1)\n        dp[0] = 1\n        for coin in coins:\n            for i in xrange(coin, amount+1):\n                dp[i] += dp[i-coin]\n        return dp[amount]\n\n"
    },
    {
        "problem_name": "coin-change",
        "solution": "# Time:  O(n * k), n is the number of coins, k is the amount of money\n# Space: O(k)\n\nclass Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n        INF = 0x7fffffff  # Using float(\"inf\") would be slower.\n        dp = [INF] * (amount + 1)\n        dp[0] = 0\n        for i in xrange(amount + 1):\n            if dp[i] != INF:\n                for coin in coins:\n                    if i + coin <= amount:\n                        dp[i + coin] = min(dp[i + coin], dp[i] + 1)\n        return dp[amount] if dp[amount] != INF else -1\n\n\n"
    },
    {
        "problem_name": "coin-path",
        "solution": "# Time:  O(n * B)\n# Space: O(n)\n\nclass Solution(object):\n    def cheapestJump(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        if not A or A[-1] == -1:\n            return result\n        n = len(A)\n        dp, next_pos = [float(\"inf\")] * n, [-1] * n\n        dp[n-1] = A[n-1]\n        for i in reversed(xrange(n-1)):\n            if A[i] == -1:\n                continue\n            for j in xrange(i+1, min(i+B+1,n)):\n                if A[i] + dp[j] < dp[i]:\n                    dp[i] = A[i] + dp[j]\n                    next_pos[i] = j\n        if dp[0] == float(\"inf\"):\n            return result\n        k = 0\n        while k != -1:\n            result.append(k+1)\n            k = next_pos[k]\n        return result\n\n"
    },
    {
        "problem_name": "collect-coins-in-a-tree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# tree, bfs\nclass Solution(object):\n    def collectTheCoins(self, coins, edges):\n        \"\"\"\n        :type coins: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DISTANCE = 2\n\n        adj = [set() for _ in xrange(len(coins))]\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        n = len(coins)\n        q = []\n        for u in xrange(len(coins)):\n            while len(adj[u]) == 1 and not coins[u]:\n                v = adj[u].pop()\n                adj[v].remove(u)\n                n -= 1\n                u = v\n        q = [u for u in xrange(len(coins)) if len(adj[u]) == 1]\n        for _ in xrange(DISTANCE):\n            new_q = []\n            for u in q:\n                if not adj[u]:\n                    assert(n == 1)\n                    break\n                v = adj[u].pop()\n                adj[v].remove(u)\n                n -= 1\n                if len(adj[v]) == 1:\n                    new_q.append(v)\n            q = new_q\n        return (n-1)*2\n"
    },
    {
        "problem_name": "collecting-chocolates",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# mono stack, difference array, prefix sum\nclass Solution(object):\n    def minCost(self, nums, x):\n        \"\"\"\n        :type nums: List[int]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        def accumulate(a):\n            for i in xrange(len(a)-1):\n                a[i+1] += a[i]\n            return a\n\n        i = min(xrange(len(nums)), key=lambda x: nums[x])\n        nums = nums[i:]+nums[:i]\n        left, right = [-1]*len(nums), [len(nums)]*len(nums)\n        stk = []\n        for i in xrange(len(nums)):\n            while stk and nums[stk[-1]] > nums[i]:\n                right[stk.pop()] = i\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        diff2 = [0]*(len(nums)+1)\n        diff2[0] = (+1)*sum(nums)             # diff1[k] has sum((+1)*nums[i] for i in xrange(len(nums))) for k >= 0\n        diff2[1] = x                          # diff1[k] has x for k >= 1\n        diff2[-1] += (-1)*nums[0]             # diff1[len(nums)] has 0*nums[0]\n        for i in xrange(1, len(nums)):\n            l, r = i-left[i], right[i]-i\n            diff2[min(l, r)] += (-1)*nums[i]  # diff1[k] has 0*nums[i] for min(l, r) <= k < max(l, r)\n            diff2[max(l, r)] += (-1)*nums[i]  # diff1[k] has (-1)*nums[i] for max(l, r) <= k < l+r\n            diff2[l+r] += (+1)*nums[i]        # diff1[k] has 0*nums[i] to for k >= l+r\n        return min(accumulate(accumulate(diff2)))\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport collections\n\n\n# binary search, mono deque\nclass Solution2(object):\n    def minCost(self, nums, x):\n        \"\"\"\n        :type nums: List[int]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        def cost(k):\n            w = k+1\n            result = x*k\n            dq = collections.deque()\n            for i in xrange(len(nums)+w-1):\n                if dq and i-dq[0] == w:\n                    dq.popleft()\n                while dq and nums[dq[-1]%len(nums)] >= nums[i%len(nums)]:\n                    dq.pop()\n                dq.append(i)\n                if i >= w-1:\n                    result += nums[dq[0]%len(nums)]\n            return result\n\n        def check(x):\n            return cost(x) <= cost(x+1)\n\n        left, right = 0, len(nums)\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return cost(left)\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# brute force\nclass Solution3(object):\n    def minCost(self, nums, x):\n        \"\"\"\n        :type nums: List[int]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        result = [x*k for k in xrange(len(nums)+1)]\n        for i in xrange(len(nums)):\n            curr = nums[i]\n            for k in xrange(len(result)):\n                curr = min(curr, nums[(i+k)%len(nums)])\n                result[k] += curr\n        return min(result)\n"
    },
    {
        "problem_name": "color-the-triangle-red",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n# constructive algorithms\nclass Solution(object):\n    def colorRed(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = [[1, 1]]\n        for i in xrange(2, n+1):\n            if i%2 == n%2:\n                result.extend([i, j] for j in xrange((1 if i%4 == n%4 else 3), 2*i, 2))\n            else:\n                result.append([i, (2 if i%4 == (n-1)%4 else 1)])\n        return result\n"
    },
    {
        "problem_name": "coloring-a-border",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nimport collections\n\n\nclass Solution(object):\n    def colorBorder(self, grid, r0, c0, color):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type r0: int\n        :type c0: int\n        :type color: int\n        :rtype: List[List[int]]\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        lookup, q, borders = set([(r0, c0)]), collections.deque([(r0, c0)]), []\n        while q:\n            r, c = q.popleft()\n            is_border = False\n\n            for direction in directions:\n                nr, nc = r+direction[0], c+direction[1]\n                if not ((0 <= nr < len(grid)) and \\\n                        (0 <= nc < len(grid[0])) and \\\n                        grid[nr][nc] == grid[r][c]):\n                    is_border = True\n                    continue\n                if (nr, nc) in lookup:\n                    continue\n                lookup.add((nr, nc))\n                q.append((nr, nc))\n\n            if is_border:\n                borders.append((r, c))\n\n        for r, c in borders:\n            grid[r][c] = color\n        return grid\n    \n"
    },
    {
        "problem_name": "combination-sum-ii",
        "solution": "# Time:  O(k * C(n, k))\n# Space: O(k)\n\nclass Solution(object):\n    # @param candidates, a list of integers\n    # @param target, integer\n    # @return a list of lists of integers\n    def combinationSum2(self, candidates, target):\n        result = []\n        self.combinationSumRecu(sorted(candidates), result, 0, [], target)\n        return result\n\n    def combinationSumRecu(self, candidates, result, start, intermediate, target):\n        if target == 0:\n            result.append(list(intermediate))\n        prev = 0\n        while start < len(candidates) and candidates[start] <= target:\n            if prev != candidates[start]:\n                intermediate.append(candidates[start])\n                self.combinationSumRecu(candidates, result, start + 1, intermediate, target - candidates[start])\n                intermediate.pop()\n                prev = candidates[start]\n            start += 1\n\n"
    },
    {
        "problem_name": "combination-sum-iii",
        "solution": "# Time:  O(k * C(n, k))\n# Space: O(k)\n\nclass Solution(object):\n    # @param {integer} k\n    # @param {integer} n\n    # @return {integer[][]}\n    def combinationSum3(self, k, n):\n        result = []\n        self.combinationSumRecu(result, [], 1, k, n)\n        return result\n\n    def combinationSumRecu(self, result, intermediate, start, k, target):\n        if k == 0 and target == 0:\n            result.append(list(intermediate))\n        elif k < 0:\n            return\n        while start < 10 and start * k + k * (k - 1) / 2 <= target:\n            intermediate.append(start)\n            self.combinationSumRecu(result, intermediate, start + 1, k - 1, target - start)\n            intermediate.pop()\n            start += 1\n\n"
    },
    {
        "problem_name": "combination-sum-iv",
        "solution": "# Time:  O(nlon + n * t), t is the value of target.\n# Space: O(t)\n\nclass Solution(object):\n    def combinationSum4(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        dp = [0] * (target+1)\n        dp[0] = 1\n        nums.sort()\n\n        for i in xrange(1, target+1):\n            for j in xrange(len(nums)):\n                if nums[j] <= i:\n                    dp[i] += dp[i - nums[j]]\n                else:\n                    break\n\n        return dp[target]\n\n"
    },
    {
        "problem_name": "combination-sum",
        "solution": "# Time:  O(k * n^k)\n# Space: O(k)\n\nclass Solution(object):\n    # @param candidates, a list of integers\n    # @param target, integer\n    # @return a list of lists of integers\n    def combinationSum(self, candidates, target):\n        result = []\n        self.combinationSumRecu(sorted(candidates), result, 0, [], target)\n        return result\n\n    def combinationSumRecu(self, candidates, result, start, intermediate, target):\n        if target == 0:\n            result.append(list(intermediate))\n        while start < len(candidates) and candidates[start] <= target:\n            intermediate.append(candidates[start])\n            self.combinationSumRecu(candidates, result, start, intermediate, target - candidates[start])\n            intermediate.pop()\n            start += 1\n\n"
    },
    {
        "problem_name": "combinations",
        "solution": "# Time:  O(k * C(n, k))\n# Space: O(k)\n\nclass Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if k > n:\n            return []\n        nums, idxs = range(1, n+1), range(k)\n        result = [[nums[i] for i in idxs]]\n        while True:\n            for i in reversed(xrange(k)):\n                if idxs[i] != i+n-k:\n                    break\n            else:\n                break\n            idxs[i] += 1\n            for j in xrange(i+1, k):\n                idxs[j] = idxs[j-1]+1\n            result.append([nums[i] for i in idxs])\n        return result\n\n\n# Time:  O(k * C(n, k))\n# Space: O(k)\nclass Solution2(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result, combination = [], []\n        i = 1\n        while True:\n            if len(combination) == k:\n                result.append(combination[:])\n            if len(combination) == k or \\\n               len(combination)+(n-i+1) < k:\n                if not combination:\n                    break\n                i = combination.pop()+1\n            else:\n                combination.append(i)\n                i += 1\n        return result\n\n\n# Time:  O(k * C(n, k))\n# Space: O(k)\nclass Solution3(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def combineDFS(n, start, intermediate, k, result):\n            if k == 0:\n                result.append(intermediate[:])\n                return\n            for i in xrange(start, n):\n                intermediate.append(i+1)\n                combineDFS(n, i+1, intermediate, k-1, result)\n                intermediate.pop()\n\n        result = []\n        combineDFS(n, 0, [], k, result)\n        return result\n\n\n"
    },
    {
        "problem_name": "compare-strings-by-frequency-of-the-smallest-character",
        "solution": "# Time:  O((m + n)logn), m is the number of queries, n is the number of words\n# Space: O(n)\n\nimport bisect\n\n\nclass Solution(object):\n    def numSmallerByFrequency(self, queries, words):\n        \"\"\"\n        :type queries: List[str]\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        words_freq = sorted(word.count(min(word)) for word in words)\n        return [len(words)-bisect.bisect_right(words_freq, query.count(min(query))) \\\n                for query in queries]\n"
    },
    {
        "problem_name": "compare-version-numbers",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        n1, n2 = len(version1), len(version2)\n        i, j = 0, 0\n        while i < n1 or j < n2:\n            v1, v2 = 0, 0\n            while i < n1 and version1[i] != '.':\n                v1 = v1 * 10 + int(version1[i])\n                i += 1\n            while j < n2 and version2[j] != '.':\n                v2 = v2 * 10 + int(version2[j])\n                j += 1\n            if v1 != v2:\n                return 1 if v1 > v2 else -1\n            i += 1\n            j += 1\n\n        return 0\n\n# Time:  O(n)\n# Space: O(n)\n\n\nclass Solution2(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        v1, v2 = version1.split(\".\"), version2.split(\".\")\n\n        if len(v1) > len(v2):\n            v2 += ['0' for _ in xrange(len(v1) - len(v2))]\n        elif len(v1) < len(v2):\n            v1 += ['0' for _ in xrange(len(v2) - len(v1))]\n\n        i = 0\n        while i < len(v1):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n            else:\n                i += 1\n\n        return 0\n\n    def compareVersion2(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        while len(v1) != len(v2):\n            if len(v1) > len(v2):\n                v2.append(0)\n            else:\n                v1.append(0)\n        return cmp(v1, v2)\n\n    def compareVersion3(self, version1, version2):\n        splits = (map(int, v.split('.')) for v in (version1, version2))\n        return cmp(*zip(*itertools.izip_longest(*splits, fillvalue=0)))\n\n    def compareVersion4(self, version1, version2):\n        main1, _, rest1 = ('0' + version1).partition('.')\n        main2, _, rest2 = ('0' + version2).partition('.')\n        return cmp(int(main1), int(main2)) or len(rest1 + rest2) and self.compareVersion4(rest1, rest2)\n\n\n"
    },
    {
        "problem_name": "complement-of-base-10-integer",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def bitwiseComplement(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        mask = 1\n        while N > mask:\n            mask = mask*2+1\n        return mask-N\n"
    },
    {
        "problem_name": "complete-binary-tree-inserter",
        "solution": "# Time:  ctor:     O(n)\n#        insert:   O(1)\n#        get_root: O(1)\n# Space: O(n)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass CBTInserter(object):\n\n    def __init__(self, root):\n        \"\"\"\n        :type root: TreeNode\n        \"\"\"\n        self.__tree = [root]\n        for i in self.__tree:\n            if i.left:\n                self.__tree.append(i.left)\n            if i.right:\n                self.__tree.append(i.right)        \n\n    def insert(self, v):\n        \"\"\"\n        :type v: int\n        :rtype: int\n        \"\"\"\n        n = len(self.__tree)\n        self.__tree.append(TreeNode(v))\n        if n % 2:\n            self.__tree[(n-1)//2].left = self.__tree[-1]\n        else:\n            self.__tree[(n-1)//2].right = self.__tree[-1]\n        return self.__tree[(n-1)//2].val\n\n    def get_root(self):\n        \"\"\"\n        :rtype: TreeNode\n        \"\"\"\n        return self.__tree[0]\n\n\n\n"
    },
    {
        "problem_name": "complex-number-multiplication",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def complexNumberMultiply(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        ra, ia = map(int, a[:-1].split('+'))\n        rb, ib = map(int, b[:-1].split('+'))\n        return '%d+%di' % (ra * rb - ia * ib, ra * ib + ia * rb)\n\n"
    },
    {
        "problem_name": "concatenated-words",
        "solution": "# Time:  O(n * l^2)\n# Space: O(n * l)\n\nclass Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        lookup = set(words)\n        result = []\n        for word in words:\n            dp = [False] * (len(word)+1)\n            dp[0] = True\n            for i in xrange(len(word)):\n                if not dp[i]:\n                    continue\n\n                for j in xrange(i+1, len(word)+1):\n                    if j - i < len(word) and word[i:j] in lookup:\n                        dp[j] = True\n\n                if dp[len(word)]:\n                    result.append(word)\n                    break\n\n        return result\n\n"
    },
    {
        "problem_name": "concatenation-of-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def getConcatenation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.extend(nums)\n        return nums\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def getConcatenation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return nums+nums\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution3(object):\n    def getConcatenation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return nums*2\n"
    },
    {
        "problem_name": "concatenation-of-consecutive-binary-numbers",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def concatenatedBinary(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result = l = 0\n        for i in xrange(1, n+1):\n            if i&(i-1) == 0:\n                l += 1\n            result = ((result<<l)%MOD+i)%MOD\n        return result\n"
    },
    {
        "problem_name": "confusing-number-ii",
        "solution": "# Time:  O(logn)\n# Space: O(logn)\n\nclass Solution(object):\n    def confusingNumberII(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        lookup = {\"0\":\"0\", \"1\":\"1\", \"6\":\"9\", \"8\":\"8\", \"9\":\"6\"}\n        centers = {\"0\":\"0\", \"1\":\"1\", \"8\":\"8\"}\n        def totalCount(n):  # count all numbers in the pattern of [01689]{1,len(n)} in the range of [1, n]\n            s = str(n)\n            total = 0 \n            p = len(lookup)**(len(s)-1)\n            for i in xrange(len(s)+1):\n                if i == len(s):\n                    total += 1\n                    break\n                smaller = sum(int(c < s[i]) for c in lookup.iterkeys())\n                total += smaller * p\n                if s[i] not in lookup:\n                    break\n                p //= len(lookup)\n            return total-1  # exclude 0\n\n        def validCountInLessLength(n):  # count unconfusing numbers in the pattern of [01689]{1,len(n)-1} in the range of [1, n]\n            s = str(n)\n            valid = 0\n            total = len(centers)\n            for i in xrange(1, len(s), 2):  # count unconfusing numbers for each odd length less than s\n                if i == 1:\n                    valid += len({c for c in centers.iterkeys() if c != '0'})\n                else:\n                    valid += total * (len(lookup)-1)\n                    total *= len(lookup)\n            total = 1\n            for i in xrange(2, len(s), 2):  # count unconfusing numbers for each even length less than s\n                valid += total * (len(lookup)-1)\n                total *= len(lookup)\n            return valid\n\n        def validCountInFullLength(n):  # count unconfusing numbers in the pattern of [01689]{len(n)} in the range of [1, n]\n            s = str(n)\n            half_s = s[:(len(s)+1)//2]\n            total = 0\n            choices = centers if (len(s) % 2) else lookup\n            p = int(len(lookup)**(len(half_s)-2) * len(choices))\n            for i in xrange(len(half_s)):\n                if i == len(half_s)-1:\n                    total += sum(int(c < half_s[i]) for c in choices.iterkeys() if i != 0 or c != '0')\n                    if half_s[i] not in choices:\n                        break\n                    tmp = list(half_s)+[lookup[half_s[i]] for i in reversed(xrange(len(half_s)-(len(s) % 2)))]\n                    total += 0 < int(\"\".join(tmp)) <= n\n                    break\n                smaller = sum(int(c < half_s[i]) for c in lookup.iterkeys() if i != 0 or c != '0')\n                total += smaller * p\n                if half_s[i] not in lookup:\n                    break\n                p //= len(lookup)\n            return total\n\n        return totalCount(n) - validCountInLessLength(n) - validCountInFullLength(n)\n\n\n# Time:  O(logn)\n# Space: O(logn)\nclass Solution2(object):\n    def confusingNumberII(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        lookup = {\"0\":\"0\", \"1\":\"1\", \"6\":\"9\", \"8\":\"8\", \"9\":\"6\"}\n        centers = {\"0\":\"0\", \"1\":\"1\", \"8\":\"8\"}\n        def totalCount(n):  # count all numbers in the pattern of [01689]{1,len(n)} in the range of [0, n]\n            s = str(n)\n            total = 0 \n            p = len(lookup)**(len(s)-1)\n            for i in xrange(len(s)+1):\n                if i == len(s):\n                    total += 1\n                    break\n                smaller = sum(int(c < s[i]) for c in lookup.iterkeys())\n                total += smaller * p\n                if s[i] not in lookup:\n                    break\n                p //= len(lookup)\n            return total\n\n        def validCountInLessLength(n):  # count unconfusing numbers in the pattern of [01689]{1,len(n)-1} in the range of [0, n]\n            s = str(n)\n            valid = 0\n            total = len(centers)\n            for i in xrange(1, len(s), 2):  # count unconfusing numbers for each odd length less than s\n                if i == 1:\n                    valid += len(centers)\n                else:\n                    valid += total * (len(lookup)-1)\n                    total *= len(lookup)\n            total = 1\n            for i in xrange(2, len(s), 2):  # count unconfusing numbers for each even length less than s\n                valid += total * (len(lookup)-1)\n                total *= len(lookup)\n            return valid\n\n        def validCountInFullLength(n):  # count unconfusing numbers in the pattern of [01689]{len(n)} in the range of [0, n]\n            s = str(n)\n            half_s = s[:(len(s)+1)//2]\n            total = 0\n            choices = centers if (len(s) % 2) else lookup\n            p = int(len(lookup)**(len(half_s)-2) * len(choices))\n            for i in xrange(len(half_s)):\n                if i == len(half_s)-1:\n                    total += sum(int(c < half_s[i]) for c in choices.iterkeys() if len(s) != 2 or c != '0')\n                    if half_s[i] not in choices:\n                        break\n                    tmp = list(half_s)+[lookup[half_s[i]] for i in reversed(xrange(len(half_s)-(len(s) % 2)))]\n                    total += int(\"\".join(tmp)) <= n\n                    break\n                smaller = sum(int(c < half_s[i]) for c in lookup.iterkeys() if i != 0 or c != '0')\n                total += smaller * p\n                if half_s[i] not in lookup:\n                    break\n                p //= len(lookup)\n            return total\n\n        def f(n):  # count confusing numbers in the range of [0, n]\n            return totalCount(n) - validCountInLessLength(n) - validCountInFullLength(n)\n\n        return f(n) - f(0)  # f(0) is always 0 and could be ignored\n"
    },
    {
        "problem_name": "confusing-number",
        "solution": "# Time:  O(logn)\n# Space: O(logn)\n\nclass Solution(object):\n    def confusingNumber(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: bool\n        \"\"\"\n        lookup = {\"0\":\"0\", \"1\":\"1\", \"6\":\"9\", \"8\":\"8\", \"9\":\"6\"}\n        \n        S = str(N)\n        result = []\n        for i in xrange(len(S)):\n            if S[i] not in lookup:\n                return False\n        for i in xrange((len(S)+1)//2):\n            if S[i] != lookup[S[-(i+1)]]:\n                return True\n        return False\n"
    },
    {
        "problem_name": "connecting-cities-with-minimum-cost",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        self.count -= 1\n        return True\n\n\nclass Solution(object):\n    def minimumCost(self, N, connections):\n        \"\"\"\n        :type N: int\n        :type connections: List[List[int]]\n        :rtype: int\n        \"\"\"\n        connections.sort(key = lambda x: x[2])\n        union_find = UnionFind(N)\n        result = 0\n        for u, v, val in connections:\n            if union_find.union_set(u-1, v-1):\n                result += val\n        return result if union_find.count == 1 else -1\n"
    },
    {
        "problem_name": "consecutive-characters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxPower(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, count = 1, 1\n        for i in xrange(1, len(s)):\n            if s[i] == s[i-1]:\n                count += 1\n            else:\n                count = 1\n            result = max(result, count)\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\nimport itertools\n\n\nclass Solution2(object):\n    def maxPower(self, s):\n        return max(len(list(v)) for _, v in itertools.groupby(s))\n"
    },
    {
        "problem_name": "consecutive-numbers-sum",
        "solution": "# Time:  O(sqrt(n))\n# Space: O(1)\n\nclass Solution(object):\n    def consecutiveNumbersSum(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        # x + x+1 + x+2 + ... + x+l-1 = N = 2^k * M, where k >= 0 and M is odd\n        # => l*x + (l-1)*l/2 = 2^k * M\n        # => x = (2^k * M - (l-1)*l/2) / l = 2^k * M/l - (l-1)/2 is a positive integer\n        # => l is either 2^(k+1)*M/f or f (f is factors of M)\n        # => the answer is the number of all odd factors of M\n        # if prime factorization of N is 2^k * p1^a * p2^b * ...\n        # => answer is the number of all odd factors = (a+1) * (b+1) * ...\n        result = 1\n        while N % 2 == 0:\n            N /= 2\n        i = 3\n        while i*i <= N:\n            count = 0\n            while N % i == 0:\n                N /= i\n                count += 1\n            result *= count+1\n            i += 2\n        if N != 1:  # N is the last prime if N != 1\n            result *= 1+1\n        return result\n\n"
    },
    {
        "problem_name": "constrained-subset-sum",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\nimport collections\n\n\nclass Solution(object):\n    def constrainedSubsetSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result, dq = float(\"-inf\"), collections.deque()\n        for i in xrange(len(nums)):\n            if dq and i-dq[0][0] == k+1:\n                dq.popleft()\n            curr = nums[i] + (dq[0][1] if dq else 0)\n            while dq and dq[-1][1] <= curr:\n                dq.pop()\n            if curr > 0:\n                dq.append((i, curr))\n            result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "construct-binary-search-tree-from-preorder-traversal",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def bstFromPreorder(self, preorder):\n        \"\"\"\n        :type preorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        def bstFromPreorderHelper(preorder, left, right, index):\n            if index[0] == len(preorder) or \\\n               preorder[index[0]] < left or \\\n               preorder[index[0]] > right:\n                return None\n\n            root = TreeNode(preorder[index[0]])\n            index[0] += 1\n            root.left = bstFromPreorderHelper(preorder, left, root.val, index)\n            root.right = bstFromPreorderHelper(preorder, root.val, right, index)\n            return root\n        \n        return bstFromPreorderHelper(preorder, float(\"-inf\"), float(\"inf\"), [0])\n"
    },
    {
        "problem_name": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param inorder, a list of integers\n    # @param postorder, a list of integers\n    # @return a tree node\n    def buildTree(self, inorder, postorder):\n        lookup = {}\n        for i, num in enumerate(inorder):\n            lookup[num] = i\n        return self.buildTreeRecu(lookup, postorder, inorder, len(postorder), 0, len(inorder))\n\n    def buildTreeRecu(self, lookup, postorder, inorder, post_end, in_start, in_end):\n        if in_start == in_end:\n            return None\n        node = TreeNode(postorder[post_end - 1])\n        i = lookup[postorder[post_end - 1]]\n        node.left = self.buildTreeRecu(lookup, postorder, inorder, post_end - 1 - (in_end - i - 1), in_start, i)\n        node.right = self.buildTreeRecu(lookup, postorder, inorder, post_end - 1, i + 1, in_end)\n        return node\n\n"
    },
    {
        "problem_name": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param preorder, a list of integers\n    # @param inorder, a list of integers\n    # @return a tree node\n    def buildTree(self, preorder, inorder):\n        lookup = {}\n        for i, num in enumerate(inorder):\n            lookup[num] = i\n        return self.buildTreeRecu(lookup, preorder, inorder, 0, 0, len(inorder))\n\n    def buildTreeRecu(self, lookup, preorder, inorder, pre_start, in_start, in_end):\n        if in_start == in_end:\n            return None\n        node = TreeNode(preorder[pre_start])\n        i = lookup[preorder[pre_start]]\n        node.left = self.buildTreeRecu(lookup, preorder, inorder, pre_start + 1, in_start, i)\n        node.right = self.buildTreeRecu(lookup, preorder, inorder, pre_start + 1 + i - in_start, i + 1, in_end)\n        return node\n\n\n# time: O(n)\n# space: O(n)\nclass Solution2(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        preorder_iterator = iter(preorder)\n        inorder_lookup = {n: i for i, n in enumerate(inorder)}\n        \n        def helper(start, end):\n            if start > end:\n                return None\n            \n            root_val = next(preorder_iterator)\n            root = TreeNode(root_val)\n            idx = inorder_lookup[root_val]\n            root.left = helper(start, idx-1)\n            root.right = helper(idx+1, end)\n            return root\n\n        return helper(0, len(inorder)-1)\n"
    },
    {
        "problem_name": "construct-binary-tree-from-preorder-and-postorder-traversal",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def constructFromPrePost(self, pre, post):\n        \"\"\"\n        :type pre: List[int]\n        :type post: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        stack = [TreeNode(pre[0])]\n        j = 0\n        for i in xrange(1, len(pre)):\n            node = TreeNode(pre[i])\n            while stack[-1].val == post[j]:\n                stack.pop()\n                j += 1\n            if not stack[-1].left:\n                stack[-1].left = node\n            else:\n                stack[-1].right = node\n            stack.append(node)\n        return stack[0]\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def constructFromPrePost(self, pre, post):\n        \"\"\"\n        :type pre: List[int]\n        :type post: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        def constructFromPrePostHelper(pre, pre_s, pre_e, post, post_s, post_e, post_entry_idx_map):\n            if pre_s >= pre_e or post_s >= post_e:\n                return None\n            node = TreeNode(pre[pre_s])\n            if pre_e-pre_s > 1:\n                left_tree_size = post_entry_idx_map[pre[pre_s+1]]-post_s+1\n                node.left = constructFromPrePostHelper(pre, pre_s+1, pre_s+1+left_tree_size, \n                                                       post, post_s, post_s+left_tree_size,\n                                                       post_entry_idx_map)\n                node.right = constructFromPrePostHelper(pre, pre_s+1+left_tree_size, pre_e,\n                                                        post, post_s+left_tree_size, post_e-1,\n                                                        post_entry_idx_map)\n            return node\n\n        post_entry_idx_map = {}\n        for i, val in enumerate(post):\n            post_entry_idx_map[val] = i\n        return constructFromPrePostHelper(pre, 0, len(pre), post, 0, len(post), post_entry_idx_map)\n\n"
    },
    {
        "problem_name": "construct-binary-tree-from-string",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def str2tree(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: TreeNode\n        \"\"\"\n        def str2treeHelper(s, i):\n            start = i\n            if s[i] == '-': i += 1\n            while i < len(s) and s[i].isdigit(): i += 1\n            node = TreeNode(int(s[start:i]))\n            if i < len(s) and s[i] == '(':\n                i += 1\n                node.left, i = str2treeHelper(s, i)\n                i += 1\n            if i < len(s) and s[i] == '(':\n                i += 1\n                node.right, i = str2treeHelper(s, i)\n                i += 1\n            return node, i\n\n        return str2treeHelper(s, 0)[0] if s else None\n\n"
    },
    {
        "problem_name": "construct-k-palindrome-strings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def canConstruct(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        count = collections.Counter(s)\n        odd = sum(v%2 for v in count.itervalues())\n        return odd <= k <= len(s)\n"
    },
    {
        "problem_name": "construct-product-matrix",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\n# prefix sum\nclass Solution(object):\n    def constructProductMatrix(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        MOD = 12345\n        right = [1]*(len(grid)*len(grid[0])+1)\n        for i in reversed(xrange(len(grid))):\n            for j in reversed(xrange(len(grid[0]))):\n                right[i*len(grid[0])+j] = (right[(i*len(grid[0])+j)+1]*grid[i][j])%MOD\n        left = 1\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                grid[i][j], left = (left*right[(i*len(grid[0])+j)+1])%MOD, (left*grid[i][j])%MOD\n        return grid\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\n# prefix sum\nclass Solution2(object):\n    def constructProductMatrix(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        MOD = 12345\n        left = [1]*(len(grid)*len(grid[0])+1)\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                left[(i*len(grid[0])+j)+1] = (left[i*len(grid[0])+j]*grid[i][j])%MOD\n        right = [1]*(len(grid)*len(grid[0])+1)\n        for i in reversed(xrange(len(grid))):\n            for j in reversed(xrange(len(grid[0]))):\n                right[i*len(grid[0])+j] = (right[(i*len(grid[0])+j)+1]*grid[i][j])%MOD\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                grid[i][j] = (left[i*len(grid[0])+j]*right[(i*len(grid[0])+j)+1])%MOD\n        return grid\n"
    },
    {
        "problem_name": "construct-quad-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Node(object):\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\n\nclass Solution(object):\n    def construct(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: Node\n        \"\"\"\n        def dfs(grid, x, y, l):\n            if l == 1:\n                return Node(grid[x][y] == 1, True, None, None, None, None)\n            half = l // 2\n            topLeftNode = dfs(grid, x, y, half)\n            topRightNode = dfs(grid, x, y+half, half)\n            bottomLeftNode = dfs(grid, x+half, y, half)\n            bottomRightNode = dfs(grid, x+half, y+half, half)\n            if topLeftNode.isLeaf and topRightNode.isLeaf and \\\n               bottomLeftNode.isLeaf and bottomRightNode.isLeaf and \\\n               topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val:\n                return Node(topLeftNode.val, True, None, None, None, None)\n            return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode)\n        \n        if not grid:\n            return None\n        return dfs(grid, 0, 0, len(grid))\n\n"
    },
    {
        "problem_name": "construct-smallest-number-from-di-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# constructive algorithms\nclass Solution(object):\n    def smallestNumber(self, pattern):\n        \"\"\"\n        :type pattern: str\n        :rtype: str\n        \"\"\"\n        result = []\n        for i in xrange(len(pattern)+1):\n            if not (i == len(pattern) or pattern[i] == 'I'):\n                continue\n            for x in reversed(range(len(result)+1, (i+1)+1)):\n                result.append(x)\n        return \"\".join(map(str, result))\n"
    },
    {
        "problem_name": "construct-string-from-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def tree2str(self, t):\n        \"\"\"\n        :type t: TreeNode\n        :rtype: str\n        \"\"\"\n        if not t: return \"\"\n        s = str(t.val)\n        if t.left or t.right:\n            s += \"(\" + self.tree2str(t.left) + \")\"\n        if t.right:\n            s += \"(\" + self.tree2str(t.right) + \")\"\n        return s\n\n"
    },
    {
        "problem_name": "construct-string-with-repeat-limit",
        "solution": "# Time:  O(26 * n)\n# Space: O(26)\n\nimport collections\n\n\n# greedy\nclass Solution(object):\n    def repeatLimitedString(self, s, repeatLimit):\n        \"\"\"\n        :type s: str\n        :type repeatLimit: int\n        :rtype: str\n        \"\"\"\n        cnt = collections.Counter(map(lambda x: ord(x)-ord('a'), s))\n        result = []\n        top1 = 25\n        while True:\n            top1 = next((i for i in reversed(xrange(top1+1)) if cnt[i]), -1)\n            if top1 == -1:\n                break\n            c = min(cnt[top1], repeatLimit-int(len(result) > 0 and result[-1] == top1))\n            cnt[top1] -= c\n            result.extend([top1]*c)\n            top2 = next((j for j in reversed(xrange(top1)) if cnt[j]), -1)\n            if top2 == -1:\n                break\n            cnt[top2] -= 1\n            result.append(top2)\n        return \"\".join(map(lambda x: chr(x+ord('a')), result))\n"
    },
    {
        "problem_name": "construct-target-array-with-multiple-sums",
        "solution": "# Time:  O(log(max(t)) * logn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def isPossible(self, target):\n        \"\"\"\n        :type target: List[int]\n        :rtype: bool\n        \"\"\"\n        # (1) x + remain = y\n        # (2) y + remain = total\n        # (1) - (2) => x - y = y - total\n        #           => x = 2*y - total\n        total = sum(target)\n        max_heap = [-x for x in target]\n        heapq.heapify(max_heap)\n        while total != len(target):\n            y = -heapq.heappop(max_heap)\n            remain = total-y\n            x = y-remain\n            if x <= 0:\n                return False\n            if x > remain:  # for case [1, 1000000000]\n                x = x%remain + remain\n            heapq.heappush(max_heap, -x)\n            total = x+remain\n        return True\n"
    },
    {
        "problem_name": "construct-the-lexicographically-largest-valid-sequence",
        "solution": "# Time:  O(n!)\n# Space: O(n)\n\nclass Solution(object):\n    def constructDistancedSequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        def backtracking(n, i, result, lookup):\n            if i == len(result):\n                return True\n            if result[i]:\n                return backtracking(n, i+1, result, lookup)\n            for x in reversed(xrange(1, n+1)):\n                j = i if x == 1 else i+x\n                if lookup[x] or j >= len(result) or result[j]:\n                    continue\n                result[i], result[j], lookup[x] = x, x, True\n                if backtracking(n, i+1, result, lookup):\n                    return True\n                result[i], result[j], lookup[x] = 0, 0, False\n            return False\n\n        result, lookup = [0]*(2*n-1), [False]*(n+1)\n        backtracking(n, 0, result, lookup)\n        return result\n"
    },
    {
        "problem_name": "construct-the-longest-new-string",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# constructive algorithms, math\nclass Solution(object):\n    def longestString(self, x, y, z):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :type z: int\n        :rtype: int\n        \"\"\"\n        return ((min(x, y)*2+int(x != y))+z)*2\n"
    },
    {
        "problem_name": "construct-the-rectangle",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nimport math\n\n\nclass Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        w = int(math.sqrt(area))\n        while area % w:\n            w -= 1\n        return [area // w, w]\n\n"
    },
    {
        "problem_name": "contain-virus",
        "solution": "# Time:  O((m * n)^(4/3)), days = O((m * n)^(1/3))\n# Space: O(m * n)\n\nclass Solution(object):\n    def containVirus(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n\n        def dfs(grid, r, c, lookup, regions, frontiers, perimeters):\n            if (r, c) in lookup:\n                return\n            lookup.add((r, c))\n            regions[-1].add((r, c))\n            for d in directions:\n                nr, nc = r+d[0], c+d[1]\n                if not (0 <= nr < len(grid) and \\\n                        0 <= nc < len(grid[r])):\n                    continue\n                if grid[nr][nc] == 1:\n                    dfs(grid, nr, nc, lookup, regions, frontiers, perimeters)\n                elif grid[nr][nc] == 0:\n                    frontiers[-1].add((nr, nc))\n                    perimeters[-1] += 1\n\n        result = 0\n        while True:\n            lookup, regions, frontiers, perimeters = set(), [], [], []\n            for r, row in enumerate(grid):\n                for c, val in enumerate(row):\n                    if val == 1 and (r, c) not in lookup:\n                        regions.append(set())\n                        frontiers.append(set())\n                        perimeters.append(0)\n                        dfs(grid, r, c, lookup, regions, frontiers, perimeters)\n\n            if not regions: break\n\n            triage_idx = frontiers.index(max(frontiers, key = len))\n            for i, region in enumerate(regions):\n                if i == triage_idx:\n                    result += perimeters[i]\n                    for r, c in region:\n                        grid[r][c] = -1\n                    continue\n                for r, c in region:\n                    for d in directions:\n                        nr, nc = r+d[0], c+d[1]\n                        if not (0 <= nr < len(grid) and \\\n                                0 <= nc < len(grid[r])):\n                            continue\n                        if grid[nr][nc] == 0:\n                            grid[nr][nc] = 1\n\n        return result\n\n"
    },
    {
        "problem_name": "container-with-most-water",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @return an integer\n    def maxArea(self, height):\n        max_area, i, j = 0, 0, len(height) - 1\n        while i < j:\n            max_area = max(max_area, min(height[i], height[j]) * (j - i))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return max_area\n\n"
    },
    {
        "problem_name": "contains-duplicate-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {boolean}\n    def containsNearbyDuplicate(self, nums, k):\n        lookup = {}\n        for i, num in enumerate(nums):\n            if num not in lookup:\n                lookup[num] = i\n            else:\n                # If the value occurs before, check the difference.\n                if i - lookup[num] <= k:\n                    return True\n                # Update the index of the value.\n                lookup[num] = i\n        return False\n\n"
    },
    {
        "problem_name": "contains-duplicate-iii",
        "solution": "# Time:  O(n * t)\n# Space: O(max(k, t))\n\nimport collections\n\n\nclass Solution(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @param {integer} t\n    # @return {boolean}\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        if k < 0 or t < 0:\n            return False\n        window = collections.OrderedDict()\n        for n in nums:\n            # Make sure window size\n            if len(window) > k:\n                window.popitem(False)\n\n            bucket = n if not t else n // t\n            # At most 2t items.\n            for m in (window.get(bucket - 1), window.get(bucket), window.get(bucket + 1)):\n                if m is not None and abs(n - m) <= t:\n                    return True\n            window[bucket] = n\n        return False\n\n"
    },
    {
        "problem_name": "contains-duplicate",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        return len(nums) > len(set(nums))\n\n"
    },
    {
        "problem_name": "contiguous-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def findMaxLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, count = 0, 0\n        lookup = {0: -1}\n        for i, num in enumerate(nums):\n            count += 1 if num == 1 else -1\n            if count in lookup:\n                result = max(result, i - lookup[count])\n            else:\n                lookup[count] = i\n\n        return result\n\n"
    },
    {
        "problem_name": "continuous-subarray-sum",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\nclass Solution(object):\n    def checkSubarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        count = 0\n        lookup = {0: -1}\n        for i, num in enumerate(nums):\n            count += num\n            if k:\n                count %= k\n            if count in lookup:\n                if i - lookup[count] > 1:\n                    return True\n            else:\n                lookup[count] = i\n\n        return False\n\n"
    },
    {
        "problem_name": "continuous-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\n# two pointers\nclass Solution(object):\n    def continuousSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = left = 0\n        mn, mx = float(\"inf\"), float(\"-inf\")\n        for right in xrange(len(nums)):\n            if mn <= nums[right] <= mx:\n                mn, mx = max(mn, nums[right]-2), min(mx, nums[right]+2)\n            else:\n                mn, mx = nums[right]-2, nums[right]+2\n                for left in reversed(xrange(right)):\n                    if not mn <= nums[left] <= mx:\n                        break\n                    mn, mx = max(mn, nums[left]-2), min(mx, nums[left]+2)\n                else:\n                    left = -1\n                left += 1\n            result += right-left+1\n        return result\n    \n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\n# mono deque, two pointers\nclass Solution2(object):\n    def continuousSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        mn, mx = collections.deque(), collections.deque()\n        result = left = 0\n        for right in xrange(len(nums)):\n            while mn and nums[mn[-1]] > nums[right]:\n                mn.pop()\n            mn.append(right)\n            while mx and nums[mx[-1]] < nums[right]:\n                mx.pop()\n            mx.append(right)\n            while not nums[right]-nums[mn[0]] <= 2:\n                left = max(left, mn.popleft()+1)\n            while not nums[mx[0]]-nums[right] <= 2:\n                left = max(left, mx.popleft()+1)\n            result += right-left+1\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nfrom sortedcontainers import SortedDict\n\n\n# ordered dict, two pointers\nclass Solution3(object):\n    def continuousSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = left = 0;\n        lookup = SortedDict()\n        for right in xrange(len(nums)):\n            lookup[nums[right]] = right\n            to_del = []\n            for x, i in lookup.items():\n                if nums[right]-x <= 2:\n                    break\n                left = max(left, i+1)\n                to_del.append(x)\n            for x, i in reversed(lookup.items()):\n                if x-nums[right] <= 2:\n                    break\n                left = max(left, i+1)\n                to_del.append(x) \n            for x in to_del:\n                del lookup[x]\n            result += right-left+1;\n        return result;\n"
    },
    {
        "problem_name": "convert-1d-array-into-2d-array",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def construct2DArray(self, original, m, n):\n        \"\"\"\n        :type original: List[int]\n        :type m: int\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        return [original[i:i+n] for i in xrange(0, len(original), n)] if len(original) == m*n else []\n"
    },
    {
        "problem_name": "convert-a-number-to-hexadecimal",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if not num:\n            return \"0\"\n\n        result = []\n        while num and len(result) != 8:\n            h = num & 15\n            if h < 10:\n                result.append(str(chr(ord('0') + h)))\n            else:\n                result.append(str(chr(ord('a') + h-10)))\n            num >>= 4\n        result.reverse()\n\n        return \"\".join(result)\n\n"
    },
    {
        "problem_name": "convert-an-array-into-a-2d-array-with-conditions",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table, constructive algorithms\nclass Solution(object):\n    def findMatrix(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        cnt = collections.Counter()\n        for x in nums:\n            if cnt[x] == len(result):\n                result.append([])\n            result[cnt[x]].append(x)\n            cnt[x] += 1\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\n# freq table, constructive algorithms\nclass Solution2(object):\n    def findMatrix(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        cnt = collections.Counter(nums)\n        while cnt:\n            result.append(cnt.keys())\n            cnt = {k:v-1 for k, v in cnt.iteritems() if v-1}\n        return result\n"
    },
    {
        "problem_name": "convert-binary-number-in-a-linked-list-to-integer",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def getDecimalValue(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: int\n        \"\"\"\n        result = 0\n        while head: \n            result = result*2 + head.val \n            head = head.next \n        return result\n"
    },
    {
        "problem_name": "convert-binary-search-tree-to-sorted-doubly-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Node(object):\n    def __init__(self, val, left, right):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def treeToDoublyList(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: Node\n        \"\"\"\n        if not root:\n            return None\n        left_head, left_tail, right_head, right_tail = root, root, root, root\n        if root.left:\n            left_head = self.treeToDoublyList(root.left)\n            left_tail = left_head.left\n        if root.right:\n            right_head = self.treeToDoublyList(root.right)\n            right_tail = right_head.left\n        left_tail.right, right_head.left = root, root\n        root.left, root.right = left_tail, right_head\n        left_head.left, right_tail.right = right_tail, left_head\n        return left_head\n\n"
    },
    {
        "problem_name": "convert-bst-to-greater-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def convertBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        def convertBSTHelper(root, cur_sum):\n            if not root:\n                return cur_sum\n\n            if root.right:\n                cur_sum = convertBSTHelper(root.right, cur_sum)\n            cur_sum += root.val\n            root.val = cur_sum\n            if root.left:\n                cur_sum = convertBSTHelper(root.left, cur_sum)\n            return cur_sum\n\n        convertBSTHelper(root, 0)\n        return root\n\n"
    },
    {
        "problem_name": "convert-integer-to-the-sum-of-two-no-zero-integers",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def getNoZeroIntegers(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        a, curr, base = 0, n, 1\n        while curr: \n            if curr % 10 == 0 or (curr % 10 == 1 and curr != 1):\n                a += base\n                curr -= 10  # carry\n            a += base\n            base *= 10\n            curr //= 10\n        return [a, n-a]\n\n\n# Time:  O(nlogn)\n# Space: O(logn)\nclass Solution2(object):\n    def getNoZeroIntegers(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        return next([a, n-a] for a in xrange(1, n) if '0' not in '{}{}'.format(a, n-a))\n"
    },
    {
        "problem_name": "convert-sorted-array-to-binary-search-tree",
        "solution": "# Time:  O(n)\n# Space: O(logn)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        return self.sortedArrayToBSTRecu(nums, 0, len(nums))\n\n    def sortedArrayToBSTRecu(self, nums, start, end):\n        if start == end:\n            return None\n        mid = start + self.perfect_tree_pivot(end - start)\n        node = TreeNode(nums[mid])\n        node.left = self.sortedArrayToBSTRecu(nums, start, mid)\n        node.right = self.sortedArrayToBSTRecu(nums, mid + 1, end)\n        return node\n\n    def perfect_tree_pivot(self, n):\n        \"\"\"\n        Find the point to partition n keys for a perfect binary search tree\n        \"\"\"\n        x = 1\n        # find a power of 2 <= n//2\n        # while x <= n//2:  # this loop could probably be written more elegantly :)\n        #     x *= 2\n        x = 1 << (n.bit_length() - 1)  # use the left bit shift, same as multiplying x by 2**n-1\n\n        if x // 2 - 1 <= (n - x):\n            return x - 1  # case 1: the left subtree of the root is perfect and the right subtree has less nodes\n        else:\n            return n - x // 2  # case 2 == n - (x//2 - 1) - 1 : the left subtree of the root\n                               # has more nodes and the right subtree is perfect.\n\n# Time:  O(n)\n# Space: O(logn)\nclass Solution2(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        self.iterator = iter(nums)\n        return self.helper(0, len(nums))\n    \n    def helper(self, start, end):\n        if start == end:\n            return None\n        \n        mid = (start + end) // 2\n        left = self.helper(start, mid)\n        current = TreeNode(next(self.iterator))\n        current.left = left\n        current.right = self.helper(mid+1, end)\n        return current\n"
    },
    {
        "problem_name": "convert-sorted-list-to-binary-search-tree",
        "solution": "# Time:  O(n)\n# Space: O(logn)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n#\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    head = None\n    # @param head, a list node\n    # @return a tree node\n    def sortedListToBST(self, head):\n        current, length = head, 0\n        while current is not None:\n            current, length = current.next, length + 1\n        self.head = head\n        return self.sortedListToBSTRecu(0, length)\n\n    def sortedListToBSTRecu(self, start, end):\n        if start == end:\n            return None\n        mid = start + (end - start) / 2\n        left = self.sortedListToBSTRecu(start, mid)\n        current = TreeNode(self.head.val)\n        current.left = left\n        self.head = self.head.next\n        current.right = self.sortedListToBSTRecu(mid + 1, end)\n        return current\n\n"
    },
    {
        "problem_name": "convert-the-temperature",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def convertTemperature(self, celsius):\n        \"\"\"\n        :type celsius: float\n        :rtype: List[float]\n        \"\"\"\n        return [celsius+273.15, celsius*1.80+32.00]\n"
    },
    {
        "problem_name": "convert-to-base-2",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def baseNeg2(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: str\n        \"\"\"\n        result = []\n        while N:\n            result.append(str(-N & 1))  # N % -2\n            N = -(N >> 1)  # N //= -2\n        result.reverse()\n        return \"\".join(result) if result else \"0\"\n\n\n# Time:  O(logn)\n# Space: O(1)\nclass Solution2(object):\n    def baseNeg2(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: str\n        \"\"\"\n        BASE = -2\n        result = []\n        while N:\n            N, r = divmod(N, BASE)\n            if r < 0:\n                r -= BASE\n                N += 1\n            result.append(str(r))\n        result.reverse()\n        return \"\".join(result) if result else \"0\"\n"
    },
    {
        "problem_name": "convex-polygon",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isConvex(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        def det(A):\n            return A[0][0]*A[1][1] - A[0][1]*A[1][0]\n\n        n, prev, curr = len(points), 0, None\n        for i in xrange(len(points)):\n            A = [[points[(i+j) % n][0] - points[i][0], points[(i+j) % n][1] - points[i][1]] for j in (1, 2)]\n            curr = det(A)\n            if curr:\n                if curr * prev < 0:\n                    return False\n                prev = curr\n        return True\n\n\n"
    },
    {
        "problem_name": "coordinate-with-maximum-network-quality",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def bestCoordinate(self, towers, radius):\n        \"\"\"\n        :type towers: List[List[int]]\n        :type radius: int\n        :rtype: List[int]\n        \"\"\"\n        min_x = min(towers, key=lambda x:x[0])[0]\n        max_x = max(towers, key=lambda x:x[0])[0]\n        min_y = min(towers, key=lambda x:x[1])[1]\n        max_y = max(towers, key=lambda x:x[1])[1]\n        max_quality = 0\n        for x in xrange(min_x, max_x+1):\n            for y in xrange(min_y, max_y+1):\n                q = 0\n                for nx, ny, nq in towers:\n                    d = ((nx-x)**2+(ny-y)**2)**0.5\n                    if d <= radius:\n                        q += int(nq/(1+d))\n                if q > max_quality:\n                    max_quality = q\n                    result = x, y\n        return result\n"
    },
    {
        "problem_name": "copy-list-with-random-pointer",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Node(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        self.random = None\n\nclass Solution(object):\n    # @param head, a RandomListNode\n    # @return a RandomListNode\n    def copyRandomList(self, head):\n        # copy and combine copied list with original list\n        current = head\n        while current:\n            copied = Node(current.val)\n            copied.next = current.next\n            current.next = copied\n            current = copied.next\n\n        # update random node in copied list\n        current = head\n        while current:\n            if current.random:\n                current.next.random = current.random.next\n            current = current.next.next\n\n        # split copied list from combined one\n        dummy = Node(0)\n        copied_current, current = dummy, head\n        while current:\n            copied_current.next = current.next\n            current.next = current.next.next\n            copied_current, current = copied_current.next, current.next\n        return dummy.next\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    # @param head, a RandomListNode\n    # @return a RandomListNode\n    def copyRandomList(self, head):\n        dummy = Node(0)\n        current, prev, copies = head, dummy, {}\n\n        while current:\n            copied = Node(current.val)\n            copies[current] = copied\n            prev.next = copied\n            prev, current = prev.next, current.next\n\n        current = head\n        while current:\n            if current.random:\n                copies[current].random = copies[current.random]\n            current = current.next\n\n        return dummy.next\n\n# time: O(n)\n# space: O(n)\nfrom collections import defaultdict\n\n\nclass Solution3(object):\n    def copyRandomList(self, head):\n        \"\"\"\n        :type head: RandomListNode\n        :rtype: RandomListNode\n        \"\"\"\n        clone = defaultdict(lambda: Node(0))\n        clone[None] = None\n        cur = head\n\n        while cur:\n            clone[cur].val = cur.val\n            clone[cur].next = clone[cur.next]\n            clone[cur].random = clone[cur.random]\n            cur = cur.next\n\n        return clone[head]\n"
    },
    {
        "problem_name": "corporate-flight-bookings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def corpFlightBookings(self, bookings, n):\n        \"\"\"\n        :type bookings: List[List[int]]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*(n+1)\n        for i, j, k in bookings:\n            result[i-1] += k\n            result[j] -= k\n        for i in xrange(1, len(result)):\n            result[i] += result[i-1]\n        result.pop()\n        return result\n"
    },
    {
        "problem_name": "correct-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(w)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\nclass Solution(object):\n    def correctBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        q = {root:None}\n        while q:\n            new_q = {}\n            for node, parent in q.iteritems():\n                if node.right in q:\n                    if parent.left == node:\n                        parent.left = None\n                    else:\n                        parent.right = None\n                    return root\n                if node.left:\n                    new_q[node.left] = node\n                if node.right:\n                    new_q[node.right] = node\n            q = new_q\n"
    },
    {
        "problem_name": "count-all-possible-routes",
        "solution": "# Time:  O(nlogn + n * f)\n# Space: O(n * f)\n\nimport bisect\n\n\nclass Solution(object):\n    def countRoutes(self, locations, start, finish, fuel):\n        \"\"\"\n        :type locations: List[int]\n        :type start: int\n        :type finish: int\n        :type fuel: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        s, f = locations[start], locations[finish];\n        locations.sort()\n        start, finish = bisect.bisect_left(locations, s), bisect.bisect_left(locations, f)\n\n        left = [[0]*(fuel+1) for _ in xrange(len(locations))]  # left[i][f], last move is toward left to location i by f fuel\n        right = [[0]*(fuel+1) for _ in xrange(len(locations))]  # right[i][f], last move is toward right to location i by f fuel\n        for f in xrange(1, fuel+1):\n            for j in xrange(len(locations)-1):\n                d = locations[j+1]-locations[j]\n                if f > d:\n                    # left[j][f] = right[j+1][f-d(j, j+1)] + 2*right[j+2][f-d(j, j+2)] + ... + 2^(k-1)*right[j+k][f-d(j, j+k)]\n                    # => left[j+1][f] = (ight[j+2][f-d(j+1, j+2)] + 2*right[j+3][f-d(j+1, j+3)] + ... + 2^(k-2)*right[j+1+k-1][f-d(j+1, j+1+k-1)]\n                    # => left[j+1][f-d(j, j+1)] = right[j+2][f-d(j, j+2)] + 2*right[j+3][f-d(j, j+3)] + ... + 2^(k-2)*right[j+k][f-d(j, j+k)]\n                    # => left[j][f] = right[j+1][f-d(j, j+1)] + 2*left[j+1][f-d(j, j+1)]\n                    left[j][f] = (right[j+1][f-d] + 2*left[j+1][f-d] % MOD) % MOD;\n                elif f == d:\n                    left[j][f] = int(j+1 == start)\n            for j in xrange(1, len(locations)):\n                d = locations[j]-locations[j-1]\n                if f > d:\n                    # right[j][f] = left[j-1][f-d(j, j-1)] + 2*left[j-2][f-d(j, j-2)] + ... + 2^(k-1)*left[j-k][f-d(j, j-k)]\n                    # => right[j-1][f] = left[j-2][f-d(j-1, j-2)] + 2*left[j-3][f-d(j-1, j-3)] + ... + 2^(k-2)*left[j-1-k+1][f-d(j-1, j-1-k+1)]\n                    # => right[j-1][f-d(j, j-1)] = left[j-2][f-d(j, j-2)] + 2*left[j-3][f-d(j, j-3)] + ... + 2^(k-2)*left[j-k][f-d(j, j-k)]\n                    # => right[j][f] = left[j-1][f-d(j, j-1)] + 2*right[j-1][f-d(j, j-1)]\n                    right[j][f] = (left[j-1][f-d] + 2*right[j-1][f-d] % MOD) % MOD\n                elif f == d:\n                    right[j][f] = int(j-1 == start)\n        result = int(start == finish)\n        for f in xrange(1, fuel+1):\n            result = ((result + left[finish][f]) % MOD + right[finish][f]) % MOD\n        return result\n\n\n# Time:  O(n^2 * f)\n# Space: O(n * f)\nclass Solution2(object):\n    def countRoutes(self, locations, start, finish, fuel):\n        \"\"\"\n        :type locations: List[int]\n        :type start: int\n        :type finish: int\n        :type fuel: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [[0]*(fuel+1) for _ in xrange(len(locations))]\n        dp[start][0] = 1\n        for f in xrange(fuel+1):\n            for i in xrange(len(locations)):\n                for j in xrange(len(locations)):\n                    if i == j:\n                        continue\n                    d = abs(locations[i]-locations[j])\n                    if f-d < 0:\n                        continue\n                    dp[i][f] = (dp[i][f]+dp[j][f-d])%MOD\n        return reduce(lambda x, y: (x+y)%MOD, dp[finish])\n"
    },
    {
        "problem_name": "count-all-valid-pickup-and-delivery-options",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countOrders(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result = 1\n        for i in reversed(xrange(2, 2*n+1, 2)):\n            result = result * i*(i-1)//2 % MOD\n        return result\n"
    },
    {
        "problem_name": "count-alternating-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def countAlternatingSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = curr = 0\n        for i in xrange(len(nums)):\n            if i-1 >= 0 and nums[i-1] == nums[i]:\n                curr = 0\n            curr += 1\n            result += curr\n        return result\n"
    },
    {
        "problem_name": "count-anagrams",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# combinatorics\nclass Solution(object):\n    def countAnagrams(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        fact, inv, inv_fact = [[1]*2 for _ in xrange(3)]\n        def lazy_init(n):\n            while len(inv) <= n:  # lazy initialization\n                fact.append(fact[-1]*len(inv) % MOD)\n                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD)  # https://cp-algorithms.com/algebra/module-inverse.html\n                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)\n\n        def factorial(n):\n            lazy_init(n)\n            return fact[n]\n\n        def inv_factorial(n):\n            lazy_init(n)\n            return inv_fact[n]\n\n        def count(j, i):\n            result = 1\n            cnt = collections.Counter()\n            for k in  xrange(j, i+1):\n                cnt[s[k]] += 1\n            result = factorial(sum(cnt.itervalues()))\n            for c in cnt.itervalues():\n                result = (result*inv_factorial(c))%MOD\n            return result\n\n        result = 1\n        j = 0\n        for i in xrange(len(s)):\n            if i+1 != len(s) and s[i+1] != ' ':\n                continue\n            result = (result*count(j, i))%MOD\n            j = i+2\n        return result\n"
    },
    {
        "problem_name": "count-and-say",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(2^n)\n\nclass Solution(object):\n    # @return a string\n    def countAndSay(self, n):\n        seq = \"1\"\n        for i in xrange(n - 1):\n            seq = self.getNext(seq)\n        return seq\n\n    def getNext(self, seq):\n        i, next_seq = 0, \"\"\n        while i < len(seq):\n            cnt = 1\n            while i < len(seq) - 1 and seq[i] == seq[i + 1]:\n                cnt += 1\n                i += 1\n            next_seq += str(cnt) + seq[i]\n            i += 1\n        return next_seq\n\n"
    },
    {
        "problem_name": "count-array-pairs-divisible-by-k",
        "solution": "# Time:  O(nlogk + sqrt(k)^2) = O(nlogk + k)\n# Space: O(sqrt(k)), number of factors of k is at most sqrt(k)\n\nimport collections\n\n\n# math, number theory\nclass Solution(object):\n    def countPairs(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(x, y):\n            while y:\n                x, y = y, x%y\n            return x\n    \n        cnt = collections.Counter()\n        for x in nums:\n            cnt[gcd(x, k)] += 1\n        result = 0\n        for x in cnt.iterkeys():\n            for y in cnt.iterkeys():\n                if x > y or x*y%k:\n                    continue\n                result += cnt[x]*cnt[y] if x != y else cnt[x]*(cnt[x]-1)//2\n        return result\n\n\n# Time:  O(nlogk + n * sqrt(k))\n# Space: O(sqrt(k)), number of factors of k is at most sqrt(k)\nimport collections\n\n\n# math, number theory\nclass Solution2(object):\n    def countPairs(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(x, y):\n            while y:\n                x, y = y, x%y\n            return x\n\n        result = 0\n        gcds = collections.Counter()\n        for x in nums:\n            gcd_i = gcd(x, k)\n            result += sum(cnt for gcd_j, cnt in gcds.iteritems() if gcd_i*gcd_j%k == 0)\n            gcds[gcd_i] += 1\n        return result\n"
    },
    {
        "problem_name": "count-artifacts-that-can-be-extracted",
        "solution": "# Time:  O(a + d), a is the number of grids covered by artifacts, d is the size of dig\n# Space: O(d)\n\n# hash table\nclass Solution(object):\n    def digArtifacts(self, n, artifacts, dig):\n        \"\"\"\n        :type n: int\n        :type artifacts: List[List[int]]\n        :type dig: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = set(map(tuple, dig))\n        return sum(all((i, j) in lookup for i in xrange(r1, r2+1) for j in xrange(c1, c2+1)) for r1, c1, r2, c2 in artifacts)\n    \n\n# Time:  O(a + d), a is the number of grids covered by artifacts, d is the size of dig\n# Space: O(a)\n# hash table\nclass Solution2(object):\n    def digArtifacts(self, n, artifacts, dig):\n        \"\"\"\n        :type n: int\n        :type artifacts: List[List[int]]\n        :type dig: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = {(i, j):idx for idx, (r1, c1, r2, c2) in enumerate(artifacts) for i in xrange(r1, r2+1) for j in xrange(c1, c2+1)}\n        cnt = [(r2-r1+1)*(c2-c1+1) for r1, c1, r2, c2 in artifacts]\n        result = 0\n        for i, j in dig:\n            if (i, j) not in lookup:\n                continue\n            cnt[lookup[i, j]] -= 1\n            if not cnt[lookup[i, j]]:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "count-asterisks",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def countAsterisks(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = cnt = 0\n        for c in s:\n            if c == '|':\n                cnt = (cnt+1)%2\n                continue\n            if c == '*' and cnt == 0:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "count-beautiful-substrings-i",
        "solution": "# Time:  O(n + sqrt(k))\n# Space: O(n)\n\n# number theory, prefix sum, freq table\nclass Solution(object):\n    def beautifulSubstrings(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        VOWELS = set(\"aeiou\")\n        prefix = [0]*(len(s)+1)\n        for i in xrange(len(s)):\n            prefix[i+1] = prefix[i]+(+1 if s[i] in VOWELS else -1)\n        new_k = 1\n        x = k\n        for i in xrange(2, k+1):\n            if i*i > k:\n                break\n            cnt = 0\n            while x%i == 0:\n                x //= i\n                cnt += 1\n            if cnt:\n                new_k *= i**((cnt+1)//2+int(i == 2))\n        if x != 1:\n            new_k *= x**((1+1)//2+int(x == 2))\n        cnt = collections.Counter()\n        result = 0\n        for i, p in enumerate(prefix):\n            result += cnt[p, i%new_k]\n            cnt[p, i%new_k] += 1\n        return result\n    \n\n# Time:  O(n^2)\n# Space: O(1)\n# brute force\nclass Solution2(object):\n    def beautifulSubstrings(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        VOWELS = set(\"aeiou\")\n        result = 0\n        for i in xrange(len(s)):\n            c = v = 0\n            for j in xrange(i, len(s)):\n                if s[j] in VOWELS:\n                    v += 1\n                else:\n                    c += 1\n                if c == v and (c*v)%k == 0:\n                    result += 1\n        return result\n    \n"
    },
    {
        "problem_name": "count-beautiful-substrings-ii",
        "solution": "# Time:  O(n + sqrt(k))\n# Space: O(1)\n\nimport collections\n\n\n# number theory, prefix sum, freq table\nclass Solution(object):\n    def beautifulSubstrings(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        VOWELS = set(\"aeiou\")\n        prefix = [0]*(len(s)+1)\n        for i in xrange(len(s)):\n            prefix[i+1] = prefix[i]+(+1 if s[i] in VOWELS else -1)\n        new_k = 1\n        x = k\n        for i in xrange(2, k+1):\n            if i*i > k:\n                break\n            cnt = 0\n            while x%i == 0:\n                x //= i\n                cnt += 1\n            if cnt:\n                new_k *= i**((cnt+1)//2+int(i == 2))\n        if x != 1:\n            new_k *= x**((1+1)//2+int(x == 2))\n        cnt = collections.Counter()\n        result = 0\n        for i, p in enumerate(prefix):\n            result += cnt[p, i%new_k]\n            cnt[p, i%new_k] += 1\n        return result\n"
    },
    {
        "problem_name": "count-binary-substrings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countBinarySubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, prev, curr = 0, 0, 1\n        for i in xrange(1, len(s)):\n            if s[i-1] != s[i]:\n                result += min(prev, curr)\n                prev, curr = curr, 1\n            else:\n                curr += 1\n        result += min(prev, curr)\n        return result\n\n"
    },
    {
        "problem_name": "count-collisions-of-monkeys-on-a-polygon",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# combinatorics, fast exponentiation\nclass Solution(object):\n    def monkeyMove(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        return (pow(2, n, MOD)-2)%MOD\n"
    },
    {
        "problem_name": "count-collisions-on-a-road",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# counting, simulation\nclass Solution(object):\n    def countCollisions(self, directions):\n        \"\"\"\n        :type directions: str\n        :rtype: int\n        \"\"\"\n        result = cnt = 0\n        smooth = 1\n        for x in directions:\n            if x == 'R':\n                cnt += 1\n            elif x == 'S' or (cnt or not smooth):\n                result += cnt+int(x == 'L')\n                cnt = smooth = 0\n        return result\n"
    },
    {
        "problem_name": "count-common-words-with-one-occurrence",
        "solution": "# Time:  O(m + n)\n# Space: O(m + n)\n\nimport collections\n\n\nclass Solution(object):\n    def countWords(self, words1, words2):\n        \"\"\"\n        :type words1: List[str]\n        :type words2: List[str]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(words1)\n        for c in words2:\n            if cnt[c] < 2:\n                cnt[c] -= 1\n        return sum(v == 0 for v in cnt.itervalues())\n"
    },
    {
        "problem_name": "count-complete-subarrays-in-an-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table, two pointers, sliding window\nclass Solution(object):\n    def countCompleteSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums_set = set(nums)\n        result = left = 0\n        cnt = collections.Counter()\n        for right in xrange(len(nums)):\n            cnt[nums[right]] += 1\n            while len(cnt) == len(nums_set):\n                cnt[nums[left]] -= 1\n                if cnt[nums[left]] == 0:\n                    del cnt[nums[left]]\n                left += 1\n            result += left\n        return result\n"
    },
    {
        "problem_name": "count-complete-substrings",
        "solution": "# Time:  O(26 + d * n), d = len(set(word))\n# Space: O(26)\n\n# freq table, two pointers, sliding window\nclass Solution(object):\n    def countCompleteSubstrings(self, word, k):\n        \"\"\"\n        :type word: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = valid = 0\n        cnt = [0]*26\n        for c in xrange(1, len(set(word))+1):\n            left = 0\n            for right in xrange(len(word)):\n                cnt[ord(word[right])-ord('a')] += 1\n                curr = cnt[ord(word[right])-ord('a')]\n                valid += 1 if curr == k else -1 if curr == k+1 else 0\n                if right-left+1 == c*k+1:\n                    curr = cnt[ord(word[left])-ord('a')]\n                    valid -= 1 if curr == k else -1 if curr == k+1 else 0\n                    cnt[ord(word[left])-ord('a')] -= 1\n                    left += 1\n                if valid == c:\n                    result += 1\n                if right+1 == len(word) or abs(ord(word[right+1])-ord(word[right])) > 2:\n                    while left < right+1:\n                        curr = cnt[ord(word[left])-ord('a')]\n                        valid -= 1 if curr == k else -1 if curr == k+1 else 0\n                        cnt[ord(word[left])-ord('a')] -= 1\n                        left += 1\n        return result\n"
    },
    {
        "problem_name": "count-complete-tree-nodes",
        "solution": "# Time:  O(h * h) = O((logn)^2)\n# Space: O(1)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def height(root):\n            h = -1\n            while root:\n                h += 1\n                root = root.left\n            return h\n\n        result, h = 0, height(root)\n        while root:\n            if height(root.right) == h-1:\n                result += 2**h\n                root = root.right\n            else:\n                result += 2**(h-1)\n                root = root.left\n            h -= 1\n        return result\n\n    \n# Time:  O(h * logn) = O((logn)^2)\n# Space: O(1)\nclass Solution2(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def check(node, n):\n            base = 1\n            while base <= n:\n                base <<= 1\n            base >>= 2\n\n            while base:\n                if (n & base) == 0:\n                    node = node.left\n                else:\n                    node = node.right\n                base >>= 1\n            return bool(node)\n\n        if not root:\n            return 0\n\n        node, level = root, 0\n        while node.left:\n            node = node.left\n            level += 1\n\n        left, right = 2**level, 2**(level+1)-1\n        while left <= right:\n            mid = left+(right-left)//2\n            if not check(root, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "count-days-spent-together",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# prefix sum\nclass Solution(object):\n    def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob):\n        \"\"\"\n        :type arriveAlice: str\n        :type leaveAlice: str\n        :type arriveBob: str\n        :type leaveBob: str\n        :rtype: int\n        \"\"\"\n        NUMS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        prefix = [0]*(len(NUMS)+1)\n        for i in xrange(len(NUMS)):\n            prefix[i+1] += prefix[i]+NUMS[i]\n    \n        def day(date):\n            return prefix[int(date[:2])-1]+int(date[3:])\n\n        return max(day(min(leaveAlice, leaveBob))-day(max(arriveAlice, arriveBob))+1, 0)\n"
    },
    {
        "problem_name": "count-different-palindromic-subsequences",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nclass Solution(object):\n    def countPalindromicSubsequences(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        def dp(i, j, prv, nxt, lookup):\n            if lookup[i][j] is not None:\n                return lookup[i][j]\n            result = 1\n            if i <= j:\n                for x in xrange(4):\n                    i0 = nxt[i][x]\n                    j0 = prv[j][x]\n                    if i <= i0 <= j:\n                        result = (result + 1) % P\n                    if None < i0 < j0:\n                        result = (result + dp(i0+1, j0-1, prv, nxt, lookup)) % P\n            result %= P\n            lookup[i][j] = result\n            return result\n\n        prv = [None] * len(S)\n        nxt = [None] * len(S)\n\n        last = [None] * 4\n        for i in xrange(len(S)):\n            last[ord(S[i])-ord('a')] = i\n            prv[i] = tuple(last)\n\n        last = [None] * 4\n        for i in reversed(xrange(len(S))):\n            last[ord(S[i])-ord('a')] = i\n            nxt[i] = tuple(last)\n\n        P = 10**9 + 7\n        lookup = [[None] * len(S) for _ in xrange(len(S))]\n        return dp(0, len(S)-1, prv, nxt, lookup) - 1\n\n"
    },
    {
        "problem_name": "count-distinct-numbers-on-board",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def distinctIntegers(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return n-1 if n >= 2 else 1\n"
    },
    {
        "problem_name": "count-elements-with-maximum-frequency",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def maxFrequencyElements(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(nums)\n        mx = max(cnt.itervalues())\n        return sum(v for v in cnt.itervalues() if v == mx)\n"
    },
    {
        "problem_name": "count-elements-with-strictly-smaller-and-greater-elements",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def countElements(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        mn = min(nums)\n        mx = max(nums)\n        return sum(mn < x < mx for x in nums)\n"
    },
    {
        "problem_name": "count-equal-and-divisible-pairs-in-an-array",
        "solution": "# Time:  O(nlogk + n * sqrt(k))\n# Space: O(n + sqrt(k)), number of factors of k is at most sqrt(k)\n\nimport collections\n\n\n# math, number theory\nclass Solution(object):\n    def countPairs(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(x, y):\n            while y:\n                x, y = y, x%y\n            return x\n    \n        idxs = collections.defaultdict(list)\n        for i, x in enumerate(nums):\n            idxs[x].append(i)\n        result = 0\n        for idx in idxs.itervalues():\n            gcds = collections.Counter()\n            for i in idx:\n                gcd_i = gcd(i, k)\n                result += sum(cnt for gcd_j, cnt in gcds.iteritems() if gcd_i*gcd_j%k == 0)\n                gcds[gcd_i] += 1\n        return result\n\n\n# Time:  O(nlogk + n * sqrt(k)^2) = O(n * k)\n# Space: O(n * sqrt(k)), number of factors of k is at most sqrt(k)\nimport collections\n\n\n# math, number theory\nclass Solution2(object):\n    def countPairs(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(x, y):\n            while y:\n                x, y = y, x%y\n            return x\n    \n        cnts = collections.defaultdict(collections.Counter)\n        for i, x in enumerate(nums):\n            cnts[x][gcd(i, k)] += 1\n        result = 0\n        for cnt in cnts.itervalues():\n            for x in cnt.iterkeys():\n                for y in cnt.iterkeys():\n                    if x > y or x*y%k:\n                        continue\n                    result += cnt[x]*cnt[y] if x != y else cnt[x]*(cnt[x]-1)//2\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\nimport collections\n\n\n# brute force\nclass Solution3(object):\n    def countPairs(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        idxs = collections.defaultdict(list)\n        for i, x in enumerate(nums):\n            idxs[x].append(i)\n        return sum(idx[i]*idx[j]%k == 0 for idx in idxs.itervalues() for i in xrange(len(idx)) for j in xrange(i+1, len(idx)))\n"
    },
    {
        "problem_name": "count-fertile-pyramids-in-a-land",
        "solution": "# Time:  O(m * n)\n# Space: O(n)\n\nclass Solution(object):\n    def countPyramids(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def count(grid, reverse):\n            def get_grid(i, j):\n                return grid[~i][j] if reverse else grid[i][j]\n\n            result = 0\n            dp = [0]*len(grid[0])\n            for i in xrange(1, len(grid)):\n                new_dp = [0]*len(grid[0])\n                for j in xrange(1, len(grid[0])-1):\n                    if get_grid(i, j) == get_grid(i-1, j-1) == get_grid(i-1, j) == get_grid(i-1, j+1) == 1:\n                        new_dp[j] = min(dp[j-1], dp[j+1])+1\n                dp = new_dp\n                result += sum(dp)\n            return result\n        \n        return count(grid, False) + count(grid, True)\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\nclass Solution2(object):\n    def countPyramids(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def count(grid):\n            dp = [[0 for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))]\n            for i in xrange(1, len(grid)):\n                for j in xrange(1, len(grid[0])-1):\n                    if grid[i][j] == grid[i-1][j-1] == grid[i-1][j] == grid[i-1][j+1] == 1:\n                        dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1])+1\n            return sum(sum(row) for row in dp)\n        \n        return count(grid) + count(grid[::-1])\n"
    },
    {
        "problem_name": "count-good-meals",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def countPairs(self, deliciousness):\n        \"\"\"\n        :type deliciousness: List[int]\n        :rtype: int\n        \"\"\"\n        def floor_log2_x(x):\n            return x.bit_length()-1\n\n        MOD = 10**9+7\n        max_pow = floor_log2_x(max(deliciousness))+1\n        cnt = collections.Counter()\n        result = 0\n        for d in deliciousness:\n            p = 1\n            for i in xrange(max_pow+1):\n                result = (result+cnt[p-d])%MOD\n                p <<= 1\n            cnt[d] += 1    \n        return result\n"
    },
    {
        "problem_name": "count-good-nodes-in-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def goodNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = [(root, root.val)]\n        while stk:\n            node, curr_max = stk.pop()\n            if not node:\n                continue\n            curr_max = max(curr_max, node.val)\n            result += int(curr_max <= node.val)\n            stk.append((node.right, curr_max))\n            stk.append((node.left, curr_max))\n        return result\n\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def goodNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node, curr_max):\n            if not node:\n                return 0\n            curr_max = max(curr_max, node.val)\n            return (int(curr_max <= node.val) +\n                    dfs(node.left, curr_max) + dfs(node.right, curr_max))\n        \n        return dfs(root, root.val)\n"
    },
    {
        "problem_name": "count-good-numbers",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def countGoodNumbers(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def powmod(a, b, mod):\n            a %= mod\n            result = 1\n            while b:\n                if b&1:\n                    result = (result*a)%mod\n                a = (a*a)%mod\n                b >>= 1\n            return result\n\n        MOD = 10**9 + 7\n        return powmod(5, (n+1)//2%(MOD-1), MOD)*powmod(4, n//2%(MOD-1), MOD) % MOD\n\n\n# Time:  O(logn)\n# Space: O(1)\nclass Solution2(object):\n    def countGoodNumbers(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        return pow(5, (n+1)//2%(MOD-1), MOD)*pow(4, n//2%(MOD-1), MOD) % MOD\n"
    },
    {
        "problem_name": "count-good-triplets-in-an-array",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass BIT(object):  # 0-indexed.\n    def __init__(self, n):\n        self.__bit = [0]*(n+1)  # Extra one for dummy node.\n\n    def add(self, i, val):\n        i += 1  # Extra one for dummy node.\n        while i < len(self.__bit):\n            self.__bit[i] += val\n            i += (i & -i)\n\n    def query(self, i):\n        i += 1  # Extra one for dummy node.\n        ret = 0\n        while i > 0:\n            ret += self.__bit[i]\n            i -= (i & -i)\n        return ret\n\n\n# bit, fenwick tree, combinatorics\nclass Solution(object):\n    def goodTriplets(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = [0]*len(nums1)\n        for i, x in enumerate(nums1):\n            lookup[x] = i\n        result = 0\n        bit = BIT(len(nums1))\n        for i, x in enumerate(nums2):\n            smaller = bit.query(lookup[x]-1)\n            larger = (len(nums1)-(lookup[x]+1))-(i-smaller)\n            result += smaller*larger\n            bit.add(lookup[x], 1)\n        return result\n"
    },
    {
        "problem_name": "count-good-triplets",
        "solution": "# Time:  O(n^3)\n# Space: O(1)\n\nclass Solution(object):\n    def countGoodTriplets(self, arr, a, b, c):\n        \"\"\"\n        :type arr: List[int]\n        :type a: int\n        :type b: int\n        :type c: int\n        :rtype: int\n        \"\"\"\n        return sum(abs(arr[i]-arr[j]) <= a and\n                   abs(arr[j]-arr[k]) <= b and\n                   abs(arr[k]-arr[i]) <= c \n                   for i in xrange(len(arr)-2)\n                       for j in xrange(i+1, len(arr)-1)\n                           for k in xrange(j+1, len(arr)))\n  \n"
    },
    {
        "problem_name": "count-hills-and-valleys-in-an-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# simulation, array\nclass Solution(object):\n    def countHillValley(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, inc = 0, -1\n        for i in xrange(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                result += int(inc == 0)\n                inc = 1\n            elif nums[i] > nums[i+1]:\n                result += int(inc == 1)\n                inc = 0\n        return result\n"
    },
    {
        "problem_name": "count-houses-in-a-circular-street-ii",
        "solution": "# Time:  O(k)\n# Space: O(1)\n\n# Definition for a street.\nclass Street:\n    def closeDoor(self):\n        pass\n    def isDoorOpen(self):\n        pass\n    def moveRight(self):\n        pass\n\n\n# constructive algorithms\nclass Solution(object):\n    def houseCount(self, street, k):\n        \"\"\"\n        :type street: Street\n        :type k: int\n        :rtype: int\n        \"\"\"\n        while not street.isDoorOpen():\n            street.moveRight()\n        result = 0\n        for i in xrange(k+1):\n            if i and street.isDoorOpen():\n                street.closeDoor()\n                result = i\n            street.moveRight()\n        return result\n"
    },
    {
        "problem_name": "count-houses-in-a-circular-street",
        "solution": "# Time:  O(k)\n# Space: O(1)\n\n# Definition for a street.\nclass Street:\n    def openDoor(self):\n        pass\n    def closeDoor(self):\n        pass\n    def isDoorOpen(self):\n        pass\n    def moveRight(self):\n        pass\n    def moveLeft(self):\n        pass\n\n\n# constructive algorithms\nclass Solution(object):\n    def houseCount(self, street, k):\n        \"\"\"\n        :type street: Street\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for _ in xrange(k):\n            street.closeDoor()\n            street.moveRight()\n        for result in xrange(k+1):\n            if street.isDoorOpen():\n                break\n            street.openDoor()\n            street.moveRight()\n        return result\n"
    },
    {
        "problem_name": "count-increasing-quadruplets",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\n# dp\nclass Solution(object):\n    def countQuadruplets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [0]*len(nums)  # dp[j] at l: # of tuple (i, j, k) s.t. i < j < k < l and nums[i] < nums[k] < nums[j]\n        result = 0\n        for l in xrange(len(nums)):\n            cnt = 0\n            for j in xrange(l):\n                if nums[j] < nums[l]:\n                    cnt += 1\n                    result += dp[j]\n                elif nums[j] > nums[l]:\n                    dp[j] += cnt\n        return result\n\n    \n# Time:  O(n^2)\n# Space: O(n^2)\n# prefix sum\nclass Solution2(object):\n    def countQuadruplets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        right = [[0]*(len(nums)+1) for _ in xrange(len(nums))]\n        for j in xrange(len(nums)):\n            for i in reversed(xrange(j+1, len(nums))):\n                right[j][i] = right[j][i+1] + int(nums[i] > nums[j])\n        result = 0\n        for k in xrange(len(nums)):\n            left = 0\n            for j in xrange(k):\n                if nums[k] < nums[j]:\n                    result += left*right[j][k+1]\n                left += int(nums[k] > nums[j])\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\n# prefix sum\nclass Solution3(object):\n    def countQuadruplets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left = [[0]*(len(nums)+1) for _ in xrange(len(nums))]\n        for j in xrange(len(nums)):\n            for i in xrange(j):\n                left[j][i+1] = left[j][i] + int(nums[i] < nums[j])\n        right = [[0]*(len(nums)+1) for _ in xrange(len(nums))]\n        for j in xrange(len(nums)):\n            for i in reversed(xrange(j+1, len(nums))):\n                right[j][i] = right[j][i+1] + int(nums[i] > nums[j])\n        result = 0\n        for k in xrange(len(nums)):\n            for j in xrange(k):\n                if nums[k] < nums[j]:\n                    result += left[k][j]*right[j][k+1]\n        return result\n"
    },
    {
        "problem_name": "count-integers-in-intervals",
        "solution": "# Time:  ctor:  O(1)\n#        add:   O(logn), amortized\n#        count: O(1)\n# Space: O(n)\n\nfrom sortedcontainers import SortedList\n\n\n# design, sortedlist\nclass CountIntervals(object):\n\n    def __init__(self):\n        self.__sl = SortedList()\n        self.__cnt = 0\n\n    def add(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: None\n        \"\"\"\n        i = self.__sl.bisect_right((left,))\n        if i-1 >= 0 and self.__sl[i-1][1]+1 >= left:\n            i -= 1\n            left = self.__sl[i][0]\n        to_remove = []\n        for i in xrange(i, len(self.__sl)):\n            if not (right+1 >= self.__sl[i][0]):\n                break\n            right = max(right, self.__sl[i][1])\n            self.__cnt -= self.__sl[i][1]-self.__sl[i][0]+1\n            to_remove.append(i)\n        while to_remove:\n            del self.__sl[to_remove.pop()]\n        self.__sl.add((left, right))\n        self.__cnt += right-left+1\n\n    def count(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.__cnt\n"
    },
    {
        "problem_name": "count-integers-with-even-digit-sum",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def countEven(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        def parity(x):\n            result = 0\n            while x:\n                result += x%10\n                x //= 10\n            return result%2\n\n        return (num-parity(num))//2\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# brute force\nclass Solution2(object):\n    def countEven(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        def parity(x):\n            result = 0\n            while x:\n                result += x%10\n                x //= 10\n            return result%2\n\n        return sum(parity(x) == 0 for x in xrange(1, num+1))\n\n\n# Time:  O(nlogn)\n# Space: O(logn)\n# brute force\nclass Solution3(object):\n    def countEven(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        return sum(sum(map(int, str(x)))%2 == 0 for x in xrange(1, num+1))\n"
    },
    {
        "problem_name": "count-items-matching-a-rule",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countMatches(self, items, ruleKey, ruleValue):\n        \"\"\"\n        :type items: List[List[str]]\n        :type ruleKey: str\n        :type ruleValue: str\n        :rtype: int\n        \"\"\"\n        rule = {\"type\":0, \"color\":1, \"name\":2}\n        return sum(item[rule[ruleKey]] == ruleValue for item in items)\n"
    },
    {
        "problem_name": "count-k-subsequences-of-a-string-with-maximum-beauty",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\nimport random\n\n\n# greedy, quick select, combinatorics\nclass Solution(object):\n    def countKSubsequencesWithMaxBeauty(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        fact, inv, inv_fact = [[1]*2 for _ in xrange(3)]\n        def nCr(n, k):\n            if not (0 <= k <= n):\n                return 0\n            while len(inv) <= n:  # lazy initialization\n                fact.append(fact[-1]*len(inv) % MOD)\n                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD)  # https://cp-algorithms.com/algebra/module-inverse.html\n                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)\n            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD\n\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        cnt = collections.Counter(s)\n        if len(cnt) < k:\n            return 0\n        freqs = cnt.values()\n        nth_element(freqs, k-1, lambda a, b: a > b)\n        n = freqs.count(freqs[k-1])\n        r = sum(freqs[i] == freqs[k-1] for i in xrange(k))\n        return reduce(lambda a, b: a*b%MOD, (freqs[i] for i in xrange(k)), 1)*nCr(n, r)%MOD\n"
    },
    {
        "problem_name": "count-largest-group",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def countLargestGroup(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        count = collections.Counter()\n        for x in xrange(1, n+1):\n            count[sum(map(int, str(x)))] += 1\n        max_count = max(count.itervalues())\n        return sum(v == max_count for v in count.itervalues())\n"
    },
    {
        "problem_name": "count-lattice-points-inside-a-circle",
        "solution": "# Time:  O(n * r^2)\n# Space: O(min(n * r^2, max_x * max_y))\n\n# math, hash table\nclass Solution(object):\n    def countLatticePoints(self, circles):\n        \"\"\"\n        :type circles: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = set()\n        for x, y, r in circles:\n            for i in xrange(-r, r+1):\n                for j in xrange(-r, r+1):\n                    if i**2+j**2 <= r**2:\n                        lookup.add(((x+i), (y+j)))\n        return len(lookup)\n\n\n# Time:  O(n * max_x * max_y)\n# Space: O(1)\n# math\nclass Solution2(object):\n    def countLatticePoints(self, circles):\n        \"\"\"\n        :type circles: List[List[int]]\n        :rtype: int\n        \"\"\"\n        max_x = max(x+r for x, _, r in circles)\n        max_y = max(y+r for _, y, r in circles)\n        result = 0\n        for i in xrange(max_x+1):\n            for j in xrange(max_y+1):\n                if any((i-x)**2+(j-y)**2 <= r**2 for x, y, r in circles):\n                    result += 1\n        return result\n"
    },
    {
        "problem_name": "count-negative-numbers-in-a-sorted-matrix",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nclass Solution(object):\n    def countNegatives(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result, c = 0, len(grid[0])-1\n        for row in grid:\n            while c >= 0 and row[c] < 0:\n                c -= 1\n            result += len(grid[0])-1-c\n        return result\n"
    },
    {
        "problem_name": "count-nice-pairs-in-an-array",
        "solution": "# Time:  O(nlogm), m is max of nums\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def countNicePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n\n        def rev(x):\n            result = 0\n            while x:\n                x, r = divmod(x, 10)\n                result = result*10+r\n            return result\n        \n        result = 0\n        lookup = collections.defaultdict(int)\n        for num in nums:\n            result = (result + lookup[num-rev(num)])%MOD\n            lookup[num-rev(num)] += 1\n        return result\n"
    },
    {
        "problem_name": "count-nodes-equal-to-average-of-subtree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\n# dfs\nclass Solution(object):\n    def averageOfSubtree(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        def iter_dfs(root):\n            result = 0\n            stk = [(1, (root, [0]*2))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    node, ret = args\n                    if not node:\n                        continue\n                    ret1, ret2 = [0]*2, [0]*2\n                    stk.append((2, (node, ret1, ret2, ret)))\n                    stk.append((1, (node.right, ret2)))\n                    stk.append((1, (node.left, ret1)))\n                elif step == 2:\n                    node, ret1, ret2, ret = args\n                    ret[0] = ret1[0]+ret2[0]+node.val\n                    ret[1] = ret1[1]+ret2[1]+1\n                    result += int(ret[0]//ret[1] == node.val)\n            return result\n        \n        return iter_dfs(root)\n\n\n# Time:  O(n)\n# Space: O(h)\n# dfs\nclass Solution2(object):\n    def averageOfSubtree(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        def dfs(node):\n            if not node:\n                return [0]*3\n            left = dfs(node.left)\n            right = dfs(node.right)\n            return [left[0]+right[0]+node.val,\n                    left[1]+right[1]+1,\n                    left[2]+right[2]+int((left[0]+right[0]+node.val)//(left[1]+right[1]+1) == node.val)]\n        \n        return dfs(root)[2]\n"
    },
    {
        "problem_name": "count-nodes-equal-to-sum-of-descendants",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\nclass Solution(object):\n    def equalToDescendants(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        def iter_dfs(node):\n            result = 0\n            stk = [(1, [node, [0]])]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    node, ret = args\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = args\n                    if node.val == ret1[0]+ret2[0]:\n                        result += 1\n                    ret[0] = ret1[0]+ret2[0]+node.val\n            return result\n\n        return iter_dfs(root)\n\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def equalToDescendants(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        def dfs(node, result):\n            if not node:\n                return 0\n            total = dfs(node.left, result) + dfs(node.right, result)\n            if node.val == total:\n                result[0] += 1\n            return total+node.val\n\n        result = [0]\n        dfs(root, result)\n        return result[0]\n"
    },
    {
        "problem_name": "count-nodes-that-are-great-enough",
        "solution": "# Time:  O(k * h)\n# Space: O(k + h)\n\nimport bisect\n\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\n# merge sort\nclass Solution(object):\n    def countGreatEnoughNodes(self, root, k):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def merge_at_most_k(a, b):\n            result = []\n            i = j = 0\n            while i < len(a) or j < len(b):\n                if j == len(b) or (i < len(a) and a[i] < b[j]):\n                    result.append(a[i])\n                    i += 1\n                else:\n                    result.append(b[j])\n                    j += 1\n                if len(result) == k:\n                    break\n            return result\n\n        def merge_sort(node):\n            if not node:\n                return []\n            left, right = merge_sort(node.left), merge_sort(node.right)\n            smallest_k = merge_at_most_k(left, right)\n            i = bisect.bisect_left(smallest_k, node.val)\n            if i == k:\n                result[0] += 1\n            else:\n                smallest_k.insert(i, node.val)\n                if len(smallest_k) == k+1:\n                    smallest_k.pop()\n            return smallest_k\n\n        result = [0]\n        merge_sort(root)\n        return result[0]\n"
    },
    {
        "problem_name": "count-nodes-with-the-highest-score",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def countHighestScoreNodes(self, parents):\n        \"\"\"\n        :type parents: List[int]\n        :rtype: int\n        \"\"\"\n        def iter_dfs(adj):\n            result = [0]*2\n            stk = [(1, (0, [0]))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    i, ret = args\n                    cnts = [[0] for _ in xrange(len(adj[i]))]\n                    stk.append((2, (cnts, ret)))\n                    for j, child in enumerate(adj[i]):\n                        stk.append((1, (child, cnts[j])))\n                elif step == 2:\n                    cnts, ret = args\n                    ret[0] = sum(cnt[0] for cnt in cnts)+1\n                    score = max((len(adj)-ret[0]), 1)*reduce(lambda x, y: x*y[0], cnts, 1)\n                    if score > result[0]:\n                        result[:] = [score, 1]\n                    elif score == result[0]:\n                        result[1] += 1\n            return result[1]\n\n        adj = [[] for _ in xrange(len(parents))]  # Space: O(n)\n        for i in xrange(1, len(parents)):\n            adj[parents[i]].append(i)\n        return iter_dfs(adj)\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def countHighestScoreNodes(self, parents):\n        \"\"\"\n        :type parents: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(adj, i, result):\n            cnts = [dfs(adj, child, result) for child in adj[i]]\n            total = sum(cnts)+1\n            score = max((len(adj)-total), 1)*reduce(lambda x, y: x*y, cnts, 1)\n            if score > result[0]:\n                result[:] = [score, 1]\n            elif score == result[0]:\n                result[1] += 1\n            return total\n\n        adj = [[] for _ in xrange(len(parents))]  # Space: O(n)\n        for i in xrange(1, len(parents)):\n            adj[parents[i]].append(i)\n        result = [0]*2\n        dfs(adj, 0, result)\n        return result[1]\n"
    },
    {
        "problem_name": "count-number-of-bad-pairs",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def countBadPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = len(nums)*(len(nums)-1)//2\n        cnt = collections.Counter()\n        for i, x in enumerate(nums):\n            result -= cnt[x-i]\n            cnt[x-i] += 1\n        return result\n"
    },
    {
        "problem_name": "count-number-of-distinct-integers-after-reverse-operations",
        "solution": "# Time:  O(nlogr), r = max(nums)\n# Space: O(n)\n\n# hash table   \nclass Solution(object):\n    def countDistinctIntegers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def reverse(n):\n            result = 0\n            while n:\n                result = result*10 + n%10\n                n //= 10\n            return result\n\n        return len({y for x in nums for y in (x, reverse(x))})\n\n\n# Time:  O(nlogr), r = max(nums)\n# Space: O(n)\n# hash table   \nclass Solution2(object):\n    def countDistinctIntegers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return len({y for x in nums for y in (x, int(str(x)[::-1]))})\n"
    },
    {
        "problem_name": "count-number-of-homogenous-substrings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countHomogenous(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result = cnt = 0\n        for i in xrange(len(s)):\n            if i and s[i-1] == s[i]:\n                cnt += 1\n            else:\n                cnt = 1\n            result = (result+cnt)%MOD\n        return result\n"
    },
    {
        "problem_name": "count-number-of-maximum-bitwise-or-subsets",
        "solution": "# Time:  O(min(2^n, m * n)), m is the 'bitwise or' of nums\n# Space: O(min(2^n, m))\n\nimport collections\n\n\nclass Solution(object):\n    def countMaxOrSubsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = collections.Counter([0])\n        for x in nums:\n            for k, v in dp.items():\n                dp[k|x] += v\n        return dp[reduce(lambda x, y: x|y, nums)]\n"
    },
    {
        "problem_name": "count-number-of-nice-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\nclass Solution(object):\n    def numberOfSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def atMost(nums, k):\n            result, left, count = 0, 0, 0\n            for right, x in enumerate(nums):\n                count += x%2\n                while count > k:\n                    count -= nums[left]%2\n                    left += 1\n                result += right-left+1\n            return result\n\n        return atMost(nums, k) - atMost(nums, k-1)\n\n\n# Time:  O(n)\n# Space: O(k)\nimport collections\n\n\nclass Solution2(object):\n    def numberOfSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        dq = collections.deque([-1])\n        for i in xrange(len(nums)):\n            if nums[i]%2:\n                dq.append(i)\n            if len(dq) > k+1:\n                dq.popleft()\n            if len(dq) == k+1:\n                result += dq[1]-dq[0]\n        return result\n"
    },
    {
        "problem_name": "count-number-of-pairs-with-absolute-difference-k",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def countKDifference(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        lookup = collections.defaultdict(int)\n        result = 0\n        for x in nums:\n            if x-k in lookup:\n                result += lookup[x-k]\n            if x+k in lookup:\n                result += lookup[x+k]\n            lookup[x] += 1            \n        return result\n"
    },
    {
        "problem_name": "count-number-of-possible-root-nodes",
        "solution": "# Time:  O(n) \n# Space: O(h)\n\nimport collections\n\n\n# iterative dfs\nclass Solution(object):\n    def rootCount(self, edges, guesses, k):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type guesses: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def iter_dfs():\n            result = 0\n            stk = [(0, -1)]\n            while stk:\n                u, p = stk.pop()\n                result += int((p, u) in lookup)\n                for v in adj[u]:\n                    if v == p:\n                        continue\n                    stk.append((v, u))\n            return result\n        \n        def iter_dfs2(curr):\n            result = 0\n            stk = [(0, -1, curr)]\n            while stk:\n                u, p, curr = stk.pop()\n                if (p, u) in lookup:\n                    curr -= 1\n                if (u, p) in lookup:\n                    curr += 1\n                result += int(curr >= k)\n                for v in adj[u]:\n                    if v == p:\n                        continue\n                    stk.append((v, u, curr))\n            return result\n\n        adj = collections.defaultdict(list)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        lookup = {(u, v) for u, v in guesses}\n        curr = iter_dfs()\n        return iter_dfs2(curr)\n\n\n# Time:  O(n) \n# Space: O(h)\nimport collections\n\n\n# dfs\nclass Solution2(object):\n    def rootCount(self, edges, guesses, k):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type guesses: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def dfs(u, p):\n            cnt = int((p, u) in lookup)\n            for v in adj[u]:\n                if v == p:\n                    continue\n                cnt += dfs(v, u)\n            return cnt\n        \n        def dfs2(u, p, curr):\n            if (p, u) in lookup:\n                curr -= 1\n            if (u, p) in lookup:\n                curr += 1\n            cnt = int(curr >= k)\n            for v in adj[u]:\n                if v == p:\n                    continue\n                cnt += dfs2(v, u, curr)\n            return cnt\n\n        adj = collections.defaultdict(list)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        lookup = {(u, v) for u, v in guesses}\n        curr = dfs(0, -1)\n        return dfs2(0, -1, curr)\n\n\n# Time:  O(n) ~ O(n^2), worst case in star tree \n# Space: O(n)\nimport collections\n\n\n# memoization\nclass Solution3(object):\n    def rootCount(self, edges, guesses, k):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type guesses: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        cnt = [0]\n        def memoization(u, p):\n            if (u, p) not in memo:\n                memo[u, p] = int((p, u) in lookup)\n                for v in adj[u]:\n                    if v == p:\n                        continue\n                    cnt[0] += 1\n                    memo[u, p] += memoization(v, u)\n            return memo[u, p]\n\n        adj = collections.defaultdict(list)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        lookup = {(u, v) for u, v in guesses}\n        memo = {}\n        return sum(memoization(i, -1) >= k for i in adj.iterkeys())\n"
    },
    {
        "problem_name": "count-number-of-rectangles-containing-each-point",
        "solution": "# Time:  O(nlogn + m * max_y * logn), n = len(rectangles), m = len(points)\n# Space: O(n)\n\nimport bisect\n\n\n# bucket sort, binary search\nclass Solution(object):\n    def countRectangles(self, rectangles, points):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :type points: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        max_y = max(y for _, y in rectangles)\n        buckets = [[] for _ in xrange(max_y+1)]\n        for x, y in rectangles:\n            buckets[y].append(x)\n        for bucket in buckets:\n            bucket.sort()\n        return [sum(len(buckets[y])-bisect.bisect_left(buckets[y], x) for y in xrange(y, max_y+1))\n                for x, y in points]\n"
    },
    {
        "problem_name": "count-number-of-special-subsequences",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countSpecialSubsequences(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [0]*3\n        for x in nums:\n            dp[x] = ((dp[x]+dp[x])%MOD+(dp[x-1] if x-1 >= 0 else 1))%MOD\n        return dp[-1]\n"
    },
    {
        "problem_name": "count-number-of-teams",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def numTeams(self, rating):\n        \"\"\"\n        :type rating: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(1, len(rating)-1):\n            less, greater = [0]*2, [0]*2\n            for j in xrange(len(rating)):\n                if rating[i] > rating[j]:\n                    less[i < j] += 1\n                if rating[i] < rating[j]:\n                    greater[i < j] += 1\n            result += less[0]*greater[1] + greater[0]*less[1]\n        return result\n"
    },
    {
        "problem_name": "count-number-of-texts",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def countTexts(self, pressedKeys):\n        \"\"\"\n        :type pressedKeys: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [1]*5\n        for i in xrange(1, len(pressedKeys)+1):\n            dp[i%5] = 0\n            for j in reversed(xrange(max(i-(4 if pressedKeys[i-1] in \"79\" else 3), 0), i)):\n                if pressedKeys[j] != pressedKeys[i-1]:\n                    break\n                dp[i%5] = (dp[i%5]+dp[j%5])%MOD\n        return dp[len(pressedKeys)%5]\n"
    },
    {
        "problem_name": "count-number-of-ways-to-place-houses",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport itertools\n\n\n# matrix exponentiation\nclass Solution(object):\n    def countHousePlacements(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A]\n \n        def matrix_expo(A, K):\n            result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        T = [[1, 1],\n             [1, 0]]\n        return pow(matrix_mult([[1, 0]], matrix_expo(T, n+1))[0][0], 2, MOD)  # [a1, a0] * T^N\n\n    \n# Time:  O(n)\n# Space: O(1)\n# dp\nclass Solution2(object):\n    def countHousePlacements(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        prev, curr = 0, 1\n        for _ in xrange(n+1):\n            prev, curr = curr, (prev+curr)%MOD\n        return pow(curr, 2, MOD)\n"
    },
    {
        "problem_name": "count-numbers-with-unique-digits-ii",
        "solution": "# Time:  O(logb)\n# Space: O(1)\n\n# hash table, bitmasks, combinatorics\nclass Solution(object):\n    def numberCount(self, a, b):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :rtype: int\n        \"\"\"\n        def popcount(x):\n            return bin(x).count('1')\n\n        def count2(n):\n            if n == 0:\n                return 0\n            result = cnt = 1\n            for i in xrange(n-1):\n                cnt *= 9-i\n                result += cnt\n            return 9*result\n\n        def count(x):\n            n = base = 1\n            while x//(base*10):\n                base *= 10\n                n += 1\n            result = count2(n-1)\n            lookup = 0\n            cnt = reduce(lambda accu, i: accu*(9-i), xrange(n-1), 1)\n            for i in xrange(n):\n                d = (x//base)%10\n                base //= 10\n                mask = lookup&(((1<<d)-1)-int(i == 0))\n                result += ((d-int(i == 0))-popcount(mask))*cnt\n                cnt //= 9-i\n                if lookup&(1<<d):\n                    break\n                lookup |= 1<<d\n            return result\n\n        return count(b+1)-count(a)\n\n\n# Time:  O(logb)\n# Space: O(logb)\n# hash table, bitmasks, combinatorics\nclass Solution2(object):\n    def numberCount(self, a, b):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :rtype: int\n        \"\"\"\n        fact = [1]*2\n        def nPr(n, k):\n            while len(fact) <= n:  # lazy initialization\n                fact.append(fact[-1]*len(fact))\n            return fact[n]//fact[n-k]\n        \n        def popcount(x):\n            return bin(x).count('1')\n\n        def count(x):\n            digits = map(int, str(x))\n            result = 9*sum(nPr(9, i) for i in xrange(len(digits)-1))\n            lookup = 0\n            for i, d in enumerate(digits):\n                mask = lookup&(((1<<d)-1)-int(i == 0))\n                result += ((d-int(i == 0))-popcount(mask))*nPr(10-(i+1), len(digits)-(i+1))\n                if lookup&(1<<d):\n                    break\n                lookup |= 1<<d\n            return result\n\n        return count(b+1)-count(a)\n\n\n# Time:  O(blogb)\n# Space: O(1)\n# brute force, hash table, bitmasks\nclass Solution3(object):\n    def numberCount(self, a, b):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :rtype: int\n        \"\"\"\n        def check(x):\n            lookup = 0\n            while x:\n                if lookup&(1<<(x%10)):\n                    return False\n                lookup |= (1<<(x%10))\n                x //= 10\n            return True\n\n        return sum(check(x) for x in xrange(a, b+1))\n\n\n# Time:  O(blogb)\n# Space: O(logb)\n# brute force, hash table\nclass Solution4(object):\n    def numberCount(self, a, b):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :rtype: int\n        \"\"\"\n        return sum(len(set(str(x))) == len(str(x)) for x in xrange(a, b+1))\n"
    },
    {
        "problem_name": "count-numbers-with-unique-digits",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countNumbersWithUniqueDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 1\n        result = cnt = 1\n        for i in xrange(n-1):\n            cnt *= 9-i\n            result += cnt\n        return 1+9*result\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def countNumbersWithUniqueDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        fact = [1]*2\n        def nPr(n, k):\n            while len(fact) <= n:  # lazy initialization\n                fact.append(fact[-1]*len(fact))\n            return fact[n]//fact[n-k]\n\n        return 1+9*sum(nPr(9, i) for i in xrange(n))\n"
    },
    {
        "problem_name": "count-odd-numbers-in-an-interval-range",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countOdds(self, low, high):\n        \"\"\"\n        :type low: int\n        :type high: int\n        :rtype: int\n        \"\"\"\n        return (high+1)//2 - ((low-1)+1)//2\n"
    },
    {
        "problem_name": "count-of-integers",
        "solution": "# Time:  O(n * m), m = max_sum\n# Space: O(n + m)\n\n# combinatorics, dp\nclass Solution(object):\n    def count(self, num1, num2, min_sum, max_sum):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :type min_sum: int\n        :type max_sum: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def f(x):\n            dp = [[0]*(max_sum+1) for _ in xrange(2)]\n            dp[0][0] = dp[1][0] = 1\n            for i in reversed(xrange(len(x))):\n                new_dp = [[0]*(max_sum+1) for _ in xrange(2)]\n                for t in xrange(2):\n                    for total in xrange(max_sum+1):\n                        for d in xrange(min((int(x[i]) if t else 9), total)+1):\n                            new_dp[t][total] = (new_dp[t][total]+dp[int(t and d == int(x[i]))][total-d])%MOD\n                dp = new_dp\n            return reduce(lambda x, y: (x+y)%MOD, (dp[1][total] for total in xrange(min_sum, max_sum+1)))\n\n        return (f(num2)-f(str(int(num1)-1)))%MOD\n"
    },
    {
        "problem_name": "count-of-interesting-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(m)\n\nimport collections\n\n\n# freq table, prefix sum\nclass Solution(object):\n    def countInterestingSubarrays(self, nums, modulo, k):\n        \"\"\"\n        :type nums: List[int]\n        :type modulo: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter([0])\n        result = prefix = 0\n        for x in nums:\n            if x%modulo == k:\n                prefix = (prefix+1)%modulo\n            result += cnt[(prefix-k)%modulo]\n            cnt[prefix] += 1\n        return result\n"
    },
    {
        "problem_name": "count-of-matches-in-tournament",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfMatches(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return n-1\n"
    },
    {
        "problem_name": "count-of-range-sum",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        def countAndMergeSort(sums, start, end, lower, upper):\n            if end - start <= 1:  # The size of range [start, end) less than 2 is always with count 0.\n                return 0\n            mid = start + (end - start) / 2\n            count = countAndMergeSort(sums, start, mid, lower, upper) + \\\n                    countAndMergeSort(sums, mid, end, lower, upper)\n            j, k, r = mid, mid, mid\n            tmp = []\n            for i in xrange(start, mid):\n                # Count the number of range sums that lie in [lower, upper].\n                while k < end and sums[k] - sums[i] < lower:\n                    k += 1\n                while j < end and sums[j] - sums[i] <= upper:\n                    j += 1\n                count += j - k\n\n                # Merge the two sorted arrays into tmp.\n                while r < end and sums[r] < sums[i]:\n                    tmp.append(sums[r])\n                    r += 1\n                tmp.append(sums[i])\n            # Copy tmp back to sums.\n            sums[start:start+len(tmp)] = tmp\n            return count\n\n        sums = [0] * (len(nums) + 1)\n        for i in xrange(len(nums)):\n            sums[i + 1] = sums[i] + nums[i]\n        return countAndMergeSort(sums, 0, len(sums), lower, upper)\n\n\n# Divide and Conquer solution.\nclass Solution2(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        def countAndMergeSort(sums, start, end, lower, upper):\n            if end - start <= 0:  # The size of range [start, end] less than 2 is always with count 0.\n                return 0\n\n            mid = start + (end - start) / 2\n            count = countAndMergeSort(sums, start, mid, lower, upper) + \\\n                    countAndMergeSort(sums, mid + 1, end, lower, upper)\n            j, k, r = mid + 1, mid + 1, mid + 1\n            tmp = []\n            for i in xrange(start, mid + 1):\n                # Count the number of range sums that lie in [lower, upper].\n                while k <= end and sums[k] - sums[i] < lower:\n                    k += 1\n                while j <= end and sums[j] - sums[i] <= upper:\n                    j += 1\n                count += j - k\n\n                # Merge the two sorted arrays into tmp.\n                while r <= end and sums[r] < sums[i]:\n                    tmp.append(sums[r])\n                    r += 1\n                tmp.append(sums[i])\n\n            # Copy tmp back to sums\n            sums[start:start+len(tmp)] = tmp\n            return count\n\n        sums = [0] * (len(nums) + 1)\n        for i in xrange(len(nums)):\n            sums[i + 1] = sums[i] + nums[i]\n        return countAndMergeSort(sums, 0, len(sums) - 1, lower, upper)\n\n"
    },
    {
        "problem_name": "count-of-smaller-numbers-after-self",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def countAndMergeSort(num_idxs, start, end, counts):\n            if end - start <= 0:  # The size of range [start, end] less than 2 is always with count 0.\n                return\n\n            mid = start + (end - start) // 2\n            countAndMergeSort(num_idxs, start, mid, counts)\n            countAndMergeSort(num_idxs, mid + 1, end, counts)\n            r = mid + 1\n            tmp = []\n            for i in xrange(start, mid + 1):\n                # Merge the two sorted arrays into tmp.\n                while r <= end and num_idxs[r][0] < num_idxs[i][0]:\n                    tmp.append(num_idxs[r])\n                    r += 1\n                tmp.append(num_idxs[i])\n                counts[num_idxs[i][1]] += r - (mid + 1)\n\n            # Copy tmp back to num_idxs\n            num_idxs[start:start+len(tmp)] = tmp\n\n        num_idxs = []\n        counts = [0] * len(nums)\n        for i, num in enumerate(nums):\n            num_idxs.append((num, i))\n        countAndMergeSort(num_idxs, 0, len(num_idxs) - 1, counts)\n        return counts\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# BIT solution.\nclass Solution2(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n):\n                self.__bit = [0]*(n+1)  # Extra one for dummy node.\n\n            def add(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] += val\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = 0\n                while i > 0:\n                    ret += self.__bit[i]\n                    i -= (i & -i)\n                return ret\n\n        # Get the place (position in the ascending order) of each number.\n        sorted_nums = sorted(zip(nums, range(len(nums))))\n        lookup = {i:new_i for new_i, (_, i) in enumerate(sorted_nums)}\n\n        # Count the smaller elements after the number.\n        result, bit = [0]*len(nums), BIT(len(nums))\n        for i in reversed(xrange(len(nums))):\n            result[i] = bit.query(lookup[i]-1)\n            bit.add(lookup[i], 1)\n        return result\n\n\n# Time:  O(nlogn) ~ O(n^2)\n# Space: O(n)\n# BST solution.\nclass Solution3(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = [0] * len(nums)\n        bst = self.BST()\n        # Insert into BST and get left count.\n        for i in reversed(xrange(len(nums))):\n            bst.insertNode(nums[i])\n            res[i] = bst.query(nums[i])\n\n        return res\n\n    class BST(object):\n        class BSTreeNode(object):\n            def __init__(self, val):\n                self.val = val\n                self.count = 0\n                self.left = self.right = None\n\n        def __init__(self):\n            self.root = None\n\n        # Insert node into BST.\n        def insertNode(self, val):\n            node = self.BSTreeNode(val)\n            if not self.root:\n                self.root = node\n                return\n            curr = self.root\n            while curr:\n                # Insert left if smaller.\n                if node.val < curr.val:\n                    curr.count += 1  # Increase the number of left children.\n                    if curr.left:\n                        curr = curr.left\n                    else:\n                        curr.left = node\n                        break\n                else:  # Insert right if larger or equal.\n                    if curr.right:\n                        curr = curr.right\n                    else:\n                        curr.right = node\n                        break\n\n        # Query the smaller count of the value.\n        def query(self, val):\n            count = 0\n            curr = self.root\n            while curr:\n                # Insert left.\n                if val < curr.val:\n                    curr = curr.left\n                elif val > curr.val:\n                    count += 1 + curr.count  # Count the number of the smaller nodes.\n                    curr = curr.right\n                else:  # Equal.\n                    return count + curr.count\n            return 0\n\n"
    },
    {
        "problem_name": "count-of-sub-multisets-with-bounded-sum",
        "solution": "# Time:  O(n + d * r), d = len(set(nums))\n# Space: O(d + r)\n\nimport collections\n\n\n# freq table, knapsack dp, sliding window, combinatorics\nclass Solution(object):\n    def countSubMultisets(self, nums, l, r):\n        \"\"\"\n        :type nums: List[int]\n        :type l: int\n        :type r: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        cnt = collections.Counter(nums)\n        dp = [0]*(r+1)\n        dp[0] = 1\n        for x, c in cnt.iteritems():\n            for i in reversed(xrange(max(r-x+1, 1), r+1)):\n                curr = reduce(lambda x, y: (x+y)%MOD, (dp[i-x*j] for j in xrange(min(c, i//x+1))))\n                for j in reversed(xrange((i-1)%x+1, i+1, x)):\n                    curr = (curr+(dp[j-x*c] if j-x*c >= 0 else 0)-dp[j])%MOD\n                    dp[j] = (dp[j]+curr)%MOD\n        return (reduce(lambda x, y: (x+y)%MOD, (dp[i] for i in range(l, r+1)))*(cnt[0]+1))%MOD\n"
    },
    {
        "problem_name": "count-operations-to-obtain-zero",
        "solution": "# Time:  O(log(min(m, n)))\n# Space: O(1)\n\n# gcd-like solution\nclass Solution(object):\n    def countOperations(self, num1, num2):\n        \"\"\"\n        :type num1: int\n        :type num2: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while num2:\n            result += num1//num2\n            num1, num2 = num2, num1%num2\n        return result\n"
    },
    {
        "problem_name": "count-pairs-in-two-arrays",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def countPairs(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        for i in xrange(len(nums1)):\n            nums1[i] -= nums2[i]\n        nums1.sort()\n        result = 0\n        left, right = 0, len(nums1)-1\n        while left < right:\n            if nums1[left] > 0 or -nums1[left] < nums1[right]:\n                result += right-left\n                right -= 1\n            else:\n                left += 1\n        return result\n"
    },
    {
        "problem_name": "count-pairs-of-connectable-servers-in-a-weighted-tree-network",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\n# iterative dfs\nclass Solution(object):\n    def countPairsOfConnectableServers(self, edges, signalSpeed):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type signalSpeed: int\n        :rtype: List[int]\n        \"\"\"\n        def iter_dfs(u, p, dist):\n            result = 0\n            stk = [(u, p, dist)]\n            while stk:\n                u, p, dist = stk.pop()\n                if dist%signalSpeed == 0:\n                    result += 1\n                for v, w in reversed(adj[u]):\n                    if v == p:\n                        continue\n                    stk.append((v, u, dist+w))\n            return result\n        \n        adj = [[] for _ in xrange(len(edges)+1)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        result = [0]*(len(edges)+1)\n        for u in xrange(len(result)):\n            curr = 0\n            for v, w in adj[u]:\n                cnt = iter_dfs(v, u, w)\n                result[u] += curr*cnt\n                curr += cnt\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# dfs\nclass Solution2(object):\n    def countPairsOfConnectableServers(self, edges, signalSpeed):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type signalSpeed: int\n        :rtype: List[int]\n        \"\"\"\n        def dfs(u, p, dist):\n            cnt = 1 if dist%signalSpeed == 0 else 0\n            for v, w in adj[u]:\n                if v == p:\n                    continue\n                cnt += dfs(v, u, dist+w)\n            return cnt\n        \n        adj = [[] for _ in xrange(len(edges)+1)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        result = [0]*(len(edges)+1)\n        for u in xrange(len(result)):\n            curr = 0\n            for v, w in adj[u]:\n                cnt = dfs(v, u, w)\n                result[u] += curr*cnt\n                curr += cnt\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# bfs\nclass Solution3(object):\n    def countPairsOfConnectableServers(self, edges, signalSpeed):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type signalSpeed: int\n        :rtype: List[int]\n        \"\"\"\n        def bfs(u, p, dist):\n            result = 0\n            q = [(u, p, dist)]\n            while q:\n                new_q = []\n                for u, p, dist in q:\n                    if dist%signalSpeed == 0:\n                        result += 1\n                    for v, w in adj[u]:\n                        if v == p:\n                            continue\n                        new_q.append((v, u, dist+w))\n                q = new_q\n            return result\n        \n        adj = [[] for _ in xrange(len(edges)+1)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        result = [0]*(len(edges)+1)\n        for u in xrange(len(result)):\n            curr = 0\n            for v, w in adj[u]:\n                cnt = bfs(v, u, w)\n                result[u] += curr*cnt\n                curr += cnt\n        return result\n"
    },
    {
        "problem_name": "count-pairs-of-equal-substrings-with-minimum-difference",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countQuadruples(self, firstString, secondString):\n        \"\"\"\n        :type firstString: str\n        :type secondString: str\n        :rtype: int\n        \"\"\"\n        lookup1 = [-1]*26\n        for i in reversed(xrange(len(firstString))):\n            lookup1[ord(firstString[i])-ord('a')] = i\n        lookup2 = [-1]*26\n        for i in xrange(len(secondString)):\n            lookup2[ord(secondString[i])-ord('a')] = i\n        result, diff = 0, float(\"inf\")\n        for i in xrange(26):\n            if lookup1[i] == -1 or lookup2[i] == -1:\n                continue\n            if lookup1[i]-lookup2[i] < diff:\n                diff = lookup1[i]-lookup2[i]\n                result = 0\n            result += int(lookup1[i]-lookup2[i] == diff)\n        return result\n"
    },
    {
        "problem_name": "count-pairs-of-nodes",
        "solution": "# Time:  O(n + e + q)\n# Space: O(n + e)\n\nimport collections\nimport itertools\n\n\n# pure counting solution\nclass Solution(object):\n    def countPairs(self, n, edges, queries):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        degree = [0]*(n+1)\n        shared = collections.Counter((min(n1, n2), max(n1, n2)) for n1, n2 in edges)\n        for u, v in edges:\n            degree[u] += 1\n            degree[v] += 1\n        cnt = [0]*(2*(max(degree[1:])+1))\n        count = collections.Counter(degree[1:])\n        for i, j in itertools.product(count, count):  # Time: O(d^2) = O(e)\n            if i < j:\n                cnt[i+j] += count[i]*count[j]\n            elif i == j:\n                cnt[i+j] += count[i]*(count[i]-1)//2\n        for (i, j), shared_degree in shared.iteritems():\n            cnt[degree[i]+degree[j]] -= 1\n            cnt[degree[i]+degree[j]-shared_degree] += 1\n        for i in reversed(xrange(len(cnt)-1)):  # accumulate\n            cnt[i] += cnt[i+1]\n        return [cnt[q+1] if q+1 < len(cnt) else 0 for q in queries]\n\n\n# Time:  O(nlogn + q * (n + e))\n# Space: O(n + e)\nimport collections\n\n\n# two pointers solution\nclass Solution2(object):\n    def countPairs(self, n, edges, queries):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        degree = [0]*(n+1)\n        shared = collections.Counter((min(n1, n2), max(n1, n2)) for n1, n2 in edges)\n        for n1, n2 in edges:\n            degree[n1] += 1\n            degree[n2] += 1\n        sorted_degree = sorted(degree)\n        result = []\n        for k, q in enumerate(queries):\n            left, right = 1, n\n            cnt = 0\n            while left < right:\n                if q < sorted_degree[left]+sorted_degree[right]:\n                    cnt += right-left\n                    right -= 1\n                else:\n                    left += 1\n            for (i, j), shared_degree in shared.iteritems():\n                if degree[i]+degree[j]-shared_degree <= q < degree[i]+degree[j]:\n                    cnt -= 1\n            result.append(cnt)\n        return result\n"
    },
    {
        "problem_name": "count-pairs-of-points-with-distance-k",
        "solution": "# Time:  O(n * k)\n# Space: O(n)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def countPairs(self, coordinates, k):\n        \"\"\"\n        :type coordinates: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        cnt = collections.Counter()\n        for x, y in coordinates:\n            for i in xrange(k+1):\n                result += cnt.get((x^i, y^(k-i)), 0)\n            cnt[(x, y)] += 1\n        return result\n"
    },
    {
        "problem_name": "count-pairs-of-similar-strings",
        "solution": "# Time:  O(n * l)\n# Space: O(n)\n\nimport collections\nimport itertools\n\n\n# freq table, bitmask\nclass Solution(object):\n    def similarPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter()\n        result = 0\n        for w in words:\n            mask = reduce(lambda total, x: total|x, itertools.imap(lambda c: 1<<(ord(c)-ord('a')), w))\n            result += cnt[mask]\n            cnt[mask] += 1\n        return result\n"
    },
    {
        "problem_name": "count-pairs-whose-sum-is-less-than-target",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, two pointers\nclass Solution(object):\n    def countPairs(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        result = 0\n        left, right = 0, len(nums)-1\n        while left < right:\n            if nums[left]+nums[right] < target:\n                result += right-left\n                left += 1\n            else:\n                right -= 1\n        return result\n"
    },
    {
        "problem_name": "count-pairs-with-xor-in-a-range",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# dp solution\nclass Solution(object):\n    def countPairs(self, nums, low, high):\n        \"\"\"\n        :type nums: List[int]\n        :type low: int\n        :type high: int\n        :rtype: int\n        \"\"\"\n        def count(nums, x):\n            result = 0\n            dp = collections.Counter(nums)\n            while x:\n                if x&1:\n                    result += sum(dp[(x^1)^k]*dp[k] for k in dp.iterkeys())//2  # current limit is xxxxx1*****, count xor pair with xxxxx0***** pattern\n                dp = collections.Counter({k>>1: dp[k]+dp[k^1] for k in dp.iterkeys()})\n                x >>= 1\n            return result\n    \n        return count(nums, high+1)-count(nums, low)\n\n\n# Time:  O(n)\n# Space: O(n)\n# trie solution\nclass Trie(object):\n    def __init__(self):\n        self.__root = {}\n        \n    def insert(self, num):\n        node = self.__root\n        for i in reversed(xrange(32)):\n            curr = (num>>i) & 1\n            if curr not in node:\n                node[curr] = {\"_count\":0}\n            node = node[curr]\n            node[\"_count\"] += 1\n                \n    def query(self, num, limit):\n        node, result = self.__root, 0\n        for i in reversed(xrange(32)):\n            curr = (num>>i) & 1\n            bit = (limit>>i) & 1\n            if bit:\n                if curr in node:\n                    result += node[0^curr][\"_count\"]  # current limit is xxxxx1*****, count xor pair with xxxxx0***** pattern\n            if bit^curr not in node:\n                break\n            node = node[bit^curr]\n        return result\n\n\nclass Solution2(object):\n    def countPairs(self, nums, low, high):\n        \"\"\"\n        :type nums: List[int]\n        :type low: int\n        :type high: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        trie = Trie()\n        for x in nums:\n            result += trie.query(x, high+1)-trie.query(x, low)\n            trie.insert(x)\n        return result\n"
    },
    {
        "problem_name": "count-palindromic-subsequences",
        "solution": "# Time:  O(10^(l/2) * n), l = 5\n# Space: O(10^(l/2) * n)\n\n# freq table, prefix sum\nclass Solution(object):\n    def countPalindromes(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        cnt = [0]*10\n        left = [[[0]*10 for _ in xrange(10)] for _ in xrange(len(s)+1)]\n        for k in xrange(len(s)):\n            left[k+1] = [[left[k][i][j] for j in xrange(10)] for i in xrange(10)]\n            for i in xrange(10):\n                left[k+1][int(s[k])][i] += cnt[i]\n            cnt[int(s[k])] += 1\n        cnt = [0]*10\n        right = [[0]*10 for _ in xrange(10)]\n        result = 0\n        for k in reversed(xrange(len(s))):\n            for i in xrange(10):\n                for j in xrange(10):\n                    result = (result+left[k][i][j]*right[i][j])%MOD\n            for i in xrange(10):\n                right[int(s[k])][i] += cnt[i]\n            cnt[int(s[k])] += 1\n        return result\n                    \n\n# Time:  O(10^(l/2) * n * l), l = 5\n# Space: O(l)\n# dp\nclass Solution2(object):\n    def countPalindromes(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result = 0\n        for i in xrange(10):\n            for j in xrange(10):\n                pattern = \"%s%s*%s%s\" % (i, j, j, i)\n                dp = [0]*(5+1)\n                dp[0] = 1\n                for k in xrange(len(s)):\n                    for l in reversed(xrange(5)):\n                        if pattern[l] == '*' or pattern[l] == s[k]:\n                            dp[l+1] = (dp[l+1]+dp[l])%MOD\n                result = (result+dp[5])%MOD\n        return result\n"
    },
    {
        "problem_name": "count-paths-that-can-form-a-palindrome-in-a-tree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# iterative dfs, freq table\nclass Solution(object):\n    def countPalindromePaths(self, parent, s):\n        \"\"\"\n        :type parent: List[int]\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def iter_dfs():\n            result = 0\n            cnt = collections.defaultdict(int)\n            cnt[0] = 1\n            stk = [(0, 0)]\n            while stk:\n                u, mask = stk.pop()\n                if u:\n                    mask ^= 1<<(ord(s[u])-ord('a'))\n                    result += cnt[mask]+sum(cnt[mask^(1<<i)] if mask^(1<<i) in cnt else 0 for i in xrange(26))\n                    cnt[mask] += 1\n                for v in reversed(adj[u]):\n                    stk.append((v, mask))\n            return result\n\n        adj = [[] for _ in xrange(len(parent))]\n        for u, p in enumerate(parent):\n            if p != -1:\n                adj[p].append(u)\n        return iter_dfs()\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\n# dfs, freq table\nclass Solution2(object):\n    def countPalindromePaths(self, parent, s):\n        \"\"\"\n        :type parent: List[int]\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def dfs(u, mask):\n            result = 0\n            if u:\n                mask ^= 1<<(ord(s[u])-ord('a'))\n                result += cnt[mask]+sum(cnt[mask^(1<<i)] if mask^(1<<i) in cnt else 0 for i in xrange(26))\n                cnt[mask] += 1\n            return result+sum(dfs(v, mask) for v in adj[u])\n\n        adj = [[] for _ in xrange(len(parent))]\n        for u, p in enumerate(parent):\n            if p != -1:\n                adj[p].append(u)\n        cnt = collections.defaultdict(int)\n        cnt[0] = 1\n        return dfs(0, 0)\n"
    },
    {
        "problem_name": "count-positions-on-street-with-required-brightness",
        "solution": "# Time:  O(n + l)\n# Space: O(min(n, l))\n\nimport collections\n\n\n# line sweep\nclass Solution(object):\n    def meetRequirement(self, n, lights, requirement):\n        \"\"\"\n        :type n: int\n        :type lights: List[List[int]]\n        :type requirement: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = collections.defaultdict(int)\n        for p, r in lights:\n            cnt[max(p-r, 0)] += 1\n            cnt[min(p+r, n-1)+1] -= 1\n        result = curr = 0\n        for i, r in enumerate(requirement):\n            curr += cnt.get(i, 0)\n            if curr >= r:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "count-prefix-and-suffix-pairs-i",
        "solution": "# Time:  O(n * l)\n# Space: O(t)\n\nimport collections\n\n\n# trie\nclass Solution(object):\n    def countPrefixSuffixPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        result = 0\n        for w in words:\n            curr = trie\n            for i in xrange(len(w)):\n                curr = curr[w[i], w[~i]]\n                result += curr[\"_cnt\"] if \"_cnt\" in curr else 0\n            curr[\"_cnt\"] = curr[\"_cnt\"]+1 if \"_cnt\" in curr else 1\n        return result\n\n\n# Time:  O(n^2 * l)\n# Space: O(1)\n# brute force\nclass Solution2(object):\n    def countPrefixSuffixPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        def check(i, j):\n            return words[j].startswith(words[i]) and words[j].endswith(words[i])\n    \n        return sum(check(i, j) for i in xrange(len(words)) for j in xrange(i+1, len(words)))\n"
    },
    {
        "problem_name": "count-prefix-and-suffix-pairs-ii",
        "solution": "# Time:  O(n * l)\n# Space: O(t)\n\nimport collections\n\n\n# trie\nclass Solution(object):\n    def countPrefixSuffixPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        result = 0\n        for w in words:\n            curr = trie\n            for i in xrange(len(w)):\n                curr = curr[w[i], w[~i]]\n                result += curr[\"_cnt\"] if \"_cnt\" in curr else 0\n            curr[\"_cnt\"] = curr[\"_cnt\"]+1 if \"_cnt\" in curr else 1\n        return result\n"
    },
    {
        "problem_name": "count-prefixes-of-a-given-string",
        "solution": "# Time:  O(n * l)\n# Space: O(1)\n\nimport itertools\n\n\n# string\nclass Solution(object):\n    def countPrefixes(self, words, s):\n        \"\"\"\n        :type words: List[str]\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return sum(itertools.imap(s.startswith, words))\n"
    },
    {
        "problem_name": "count-primes",
        "solution": "# Time:  O(n/2 + n/3 + ... + n/p) = O(nlog(logn)), see https://mathoverflow.net/questions/4596/on-the-series-1-2-1-3-1-5-1-7-1-11\n# Space: O(n)\n\nclass Solution(object):\n    # @param {integer} n\n    # @return {integer}\n    def countPrimes(self, n):\n        if n <= 2:\n            return 0\n\n        is_prime = [True]*(n//2)\n        cnt = len(is_prime)\n        for i in xrange(3, n, 2):\n            if i * i >= n:\n                break\n            if not is_prime[i//2]:\n                continue\n            for j in xrange(i*i, n, 2*i):\n                if not is_prime[j//2]:\n                    continue\n                cnt -= 1\n                is_prime[j//2] = False\n\n        return cnt\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution_TLE(object):\n    def countPrimes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def linear_sieve_of_eratosthenes(n):\n            primes = []\n            spf = [-1]*(n+1)  # the smallest prime factor\n            for i in xrange(2, n+1):\n                if spf[i] == -1:\n                    spf[i] = i\n                    primes.append(i)\n                for p in primes:\n                    if i*p > n or p > spf[i]:\n                        break\n                    spf[i*p] = p\n            return primes\n    \n        return len(linear_sieve_of_eratosthenes(n-1))\n"
    },
    {
        "problem_name": "count-servers-that-communicate",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nclass Solution(object):\n    def countServers(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        rows, cols = [0]*len(grid), [0]*len(grid[0])\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j]:\n                    rows[i] += 1\n                    cols[j] += 1\n        result = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j] and (rows[i] > 1 or cols[j] > 1):\n                    result += 1\n        return result\n\n"
    },
    {
        "problem_name": "count-sorted-vowel-strings",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def countVowelStrings(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def nCr(n, r):  # Time: O(n), Space: O(1)\n            if n-r < r:\n                return nCr(n, n-r)\n            c = 1\n            for k in xrange(1, r+1):\n                c *= n-k+1\n                c //= k\n            return c\n    \n        return nCr(n+4, 4)  # H(5, n) = C(n+5-1, n) = C(n+4, 4)\n"
    },
    {
        "problem_name": "count-special-integers",
        "solution": "# Time:  O(logn)\n# Space: O(logn)\n\n# combinatorics\nclass Solution(object):\n    def countSpecialNumbers(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def P(m, n):\n            result = 1\n            for _ in xrange(n):\n                result *= m\n                m -= 1\n            return result\n\n        digits = map(int, str(n+1))\n        result = sum(P(9, 1)*P(9, i-1) for i in xrange(1, len(digits)))\n        lookup = set()\n        for i, x in enumerate(digits):\n            for y in xrange(int(i == 0), x):\n                if y in lookup:\n                    continue\n                result += P(9-i, len(digits)-i-1)\n            if x in lookup:\n                break\n            lookup.add(x)\n        return result\n"
    },
    {
        "problem_name": "count-special-quadruplets",
        "solution": "# Time:  O(n^3)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def countQuadruplets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        lookup = collections.defaultdict(int)\n        lookup[nums[-1]] = 1\n        for c in reversed(xrange(2, len(nums)-1)):\n            for b in xrange(1, c):\n                for a in xrange(b):\n                    if nums[a]+nums[b]+nums[c] in lookup:\n                        result += lookup[nums[a]+nums[b]+nums[c]]\n            lookup[nums[c]] += 1\n        return result\n\n    \n# Time:  O(n^2) ~ O(n^4)\n# Space: O(n^2)\nimport collections\n\n\nclass Solution2(object):\n    def countQuadruplets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = collections.defaultdict(list)\n        for d in xrange(3, len(nums)):\n            for c in xrange(2, d):\n                lookup[nums[d]-nums[c]].append(c)\n        return sum(sum(b < c for c in lookup[nums[a]+nums[b]]) for b in xrange(1, len(nums)-2) for a in xrange(b))\n"
    },
    {
        "problem_name": "count-square-submatrices-with-all-ones",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def countSquares(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for i in xrange(1, len(matrix)):\n            for j in xrange(1, len(matrix[0])):\n                if not matrix[i][j]:\n                    continue\n                l = min(matrix[i-1][j], matrix[i][j-1])\n                matrix[i][j] = l+1 if matrix[i-l][j-l] else l\n        return sum(x for row in matrix for x in row)\n"
    },
    {
        "problem_name": "count-square-sum-triples",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def countTriples(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        lookup = set()\n        for i in xrange(1, n+1):\n            lookup.add(i**2)\n        result = 0\n        for i in xrange(1, n+1):\n            for j in xrange(1, n+1):\n                result += int(i**2+j**2 in lookup)\n        return result\n"
    },
    {
        "problem_name": "count-stepping-numbers-in-range",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def countSteppingNumbers(self, low, high):\n        \"\"\"\n        :type low: str\n        :type high: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def f(s):\n            dp = [[0]*10 for _ in xrange(2)]\n            for j in xrange(1, ord(s[0])-ord('0')+1):\n                dp[0][j] = 1\n            prefix = True\n            for i in xrange(1, len(s)):\n                for j in xrange(10):\n                    dp[i%2][j] = int(j != 0)\n                    if j-1 >= 0:\n                        dp[i%2][j] = (dp[i%2][j]+(dp[(i-1)%2][j-1]-int(prefix and (ord(s[i-1])-ord('0')) == j-1 and j > (ord(s[i])-ord('0')))))%MOD\n                    if j+1 < 10:\n                        dp[i%2][j] = (dp[i%2][j]+(dp[(i-1)%2][j+1]-int(prefix and (ord(s[i-1])-ord('0')) == j+1 and j > (ord(s[i])-ord('0')))))%MOD\n                if abs(ord(s[i])-ord(s[i-1])) != 1:\n                    prefix = False\n            return reduce(lambda x, y: (x+y)%MOD, dp[(len(s)-1)%2])\n\n        return (f(high)-f(str(int(low)-1)))%MOD\n"
    },
    {
        "problem_name": "count-strictly-increasing-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers\nclass Solution(object):\n    def countSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = l = 1\n        for i in xrange(1, len(nums)):\n            if nums[i-1] >= nums[i]:\n                l = 0\n            l += 1\n            result += l\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\n# two pointers\nclass Solution2(object):\n    def countSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = left = 0\n        for right in xrange(len(nums)):\n            if not (right-1 >= 0 and nums[right-1] < nums[right]):\n                left = right\n            result += right-left+1\n        return result\n"
    },
    {
        "problem_name": "count-sub-islands",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def countSubIslands(self, grid1, grid2):\n        \"\"\"\n        :type grid1: List[List[int]]\n        :type grid2: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def dfs(grid1, grid2, i, j):\n            if not (0 <= i < len(grid2) and\n                    0 <= j < len(grid2[0]) and\n                    grid2[i][j] == 1):\n                return 1\n            grid2[i][j] = 0\n            result = grid1[i][j]\n            for di, dj in directions:\n                result &= dfs(grid1, grid2, i+di, j+dj)\n            return result\n            \n        return sum(dfs(grid1, grid2, i, j) for i in xrange(len(grid2)) for j in xrange(len(grid2[0])) if grid2[i][j])\n"
    },
    {
        "problem_name": "count-subarrays-where-max-element-appears-at-least-k-times",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers, sliding window\nclass Solution(object):\n    def countSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        mx = max(nums)\n        result = left = cnt = 0\n        for right in xrange(len(nums)):\n            cnt += int(nums[right] == mx)\n            while cnt == k:\n                cnt -= int(nums[left] == mx)\n                left += 1\n            result += left\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\n# two pointers, sliding window\nclass Solution2(object):\n    def countSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        mx = max(nums)\n        result = (len(nums)+1)*len(nums)//2\n        left = cnt = 0\n        for right in xrange(len(nums)):\n            cnt += int(nums[right] == mx)\n            while cnt == k:\n                cnt -= int(nums[left] == mx)\n                left += 1\n            result -= right-left+1\n        return result\n"
    },
    {
        "problem_name": "count-subarrays-with-fixed-bounds",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers\nclass Solution(object):\n    def countSubarrays(self, nums, minK, maxK):\n        \"\"\"\n        :type nums: List[int]\n        :type minK: int\n        :type maxK: int\n        :rtype: int\n        \"\"\"\n        result = left = 0\n        right = [-1]*2\n        for i, x in enumerate(nums):\n            if not (minK <= x <= maxK):\n                left = i+1\n                continue\n            if x == minK:\n                right[0] = i\n            if x == maxK:\n                right[1] = i\n            result += max(min(right)-left+1, 0)\n        return result\n"
    },
    {
        "problem_name": "count-subarrays-with-median-k",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table, prefix sum\nclass Solution(object):\n    def countSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        idx = nums.index(k)\n        lookup = collections.Counter()\n        curr = 0\n        for i in reversed(xrange(idx+1)):\n            curr += 0 if nums[i] == k else -1 if nums[i] < k else +1\n            lookup[curr] += 1\n        result = curr = 0\n        for i in xrange(idx, len(nums)):\n            curr += 0 if nums[i] == k else -1 if nums[i] < k else +1\n            result += lookup[-curr]+lookup[-(curr-1)]\n        return result\n"
    },
    {
        "problem_name": "count-subarrays-with-more-ones-than-zeros",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def subarraysWithMoreZerosThanOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        lookup = collections.defaultdict(int)\n        lookup[0] = 1\n        result = total = same = more = 0\n        for x in nums:\n            total += 1 if x == 1 else -1\n            new_same = lookup[total]\n            new_more = (same+more+1)%MOD if x == 1 else (more-new_same)%MOD\n            lookup[total] += 1\n            result = (result+new_more)%MOD\n            same, more = new_same, new_more\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def subarraysWithMoreZerosThanOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        lookup = {0:-1}\n        dp = [0]*len(nums)\n        result = total = 0\n        for i, x in enumerate(nums):\n            total += 1 if x == 1 else -1\n            if total not in lookup:\n                if total > 0:\n                    dp[i] = i+1\n            else:\n                j = lookup[total]\n                if j != -1:\n                    dp[i] = dp[j]\n                if x > 0:\n                    dp[i] += (i-1)-j\n            lookup[total] = i\n            result = (result+dp[i])%MOD\n        return result\n"
    },
    {
        "problem_name": "count-subarrays-with-score-less-than-k",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# sliding window, two pointers\nclass Solution(object):\n    def countSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = total = left = 0\n        for right in xrange(len(nums)):\n            total += nums[right]\n            while total*(right-left+1) >= k:\n                total -= nums[left]\n                left += 1\n            result += right-left+1\n        return result\n"
    },
    {
        "problem_name": "count-submatrices-with-all-ones",
        "solution": "# Time:  O(m * n)\n# Space: O(n)\n\nclass Solution(object):\n    def numSubmat(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def count(heights):\n            dp, stk = [0]*len(heights), []\n            for i in xrange(len(heights)):\n                while stk and heights[stk[-1]] >= heights[i]:\n                    stk.pop()\n                dp[i] = dp[stk[-1]] + heights[i]*(i-stk[-1]) if stk else heights[i]*(i-(-1))\n                stk.append(i)\n            return sum(dp)\n\n        result = 0\n        heights = [0]*len(mat[0])\n        for i in xrange(len(mat)):\n            for j in xrange(len(mat[0])):\n                heights[j] = heights[j]+1 if mat[i][j] == 1 else 0\n            result += count(heights)\n        return result\n"
    },
    {
        "problem_name": "count-submatrices-with-top-left-element-and-sum-less-than-k",
        "solution": "# Time:  O(n * m)\n# Space: O(1)\n\n# prefix sum\nclass Solution(object):\n    def countSubmatrices(self, grid, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if i-1 >= 0:\n                    grid[i][j] += grid[i-1][j]\n                if j-1 >= 0:\n                    grid[i][j] += grid[i][j-1]\n                if i-1 >= 0 and j-1 >= 0:\n                    grid[i][j] -= grid[i-1][j-1]\n                if grid[i][j] <= k:\n                    result += 1\n        return result\n"
    },
    {
        "problem_name": "count-substrings-starting-and-ending-with-given-character",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# combinatorics\nclass Solution(object):\n    def countSubstrings(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: int\n        \"\"\"\n        n = s.count(c)\n        return (n+1)*n//2\n"
    },
    {
        "problem_name": "count-substrings-that-differ-by-one-character",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def countSubstrings(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        def count(i, j):  # for each possible alignment, count the number of substrs that differ by 1 char\n            result = left_cnt = right_cnt = 0  # left and right consecutive same counts relative to the different char\n            for k in xrange(min(len(s)-i, len(t)-j)):\n                right_cnt += 1\n                if s[i+k] != t[j+k]:\n                    left_cnt, right_cnt = right_cnt, 0\n                    # prev_i = i+k-prev+1\n                result += left_cnt  # target substrs are [s[left_i+c:i+k+1] for c in xrange(left_cnt)]\n            return result\n\n        return sum(count(i, 0) for i in xrange(len(s))) + \\\n               sum(count(0, j) for j in xrange(1, len(t)))\n"
    },
    {
        "problem_name": "count-substrings-with-only-one-distinct-letter",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countLetters(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        result = len(S)\n        left = 0\n        for right in xrange(1, len(S)):\n            if S[right] == S[left]:\n                result += right-left\n            else:\n                left = right\n        return result\n"
    },
    {
        "problem_name": "count-substrings-without-repeating-character",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers, sliding window\nclass Solution(object):\n    def numberOfSpecialSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = left = 0\n        lookup = [-1]*26\n        for right in xrange(len(s)):\n            if lookup[ord(s[right])-ord('a')] >= left:\n                left = lookup[ord(s[right])-ord('a')]+1\n            lookup[ord(s[right])-ord('a')] = right\n            result += (right-left+1)\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\n# two pointers, sliding window\nclass Solution2(object):\n    def numberOfSpecialSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = left = 0\n        lookup = [False]*26\n        for right in xrange(len(s)):\n            while lookup[ord(s[right])-ord('a')]:\n                lookup[ord(s[left])-ord('a')] = False\n                left += 1\n            lookup[ord(s[right])-ord('a')] = True\n            result += (right-left+1)\n        return result\n"
    },
    {
        "problem_name": "count-subtrees-with-max-distance-between-cities",
        "solution": "# Time:  O(n^6)\n# Space: O(n^3)\n\nimport collections\n\n\nclass Solution(object):\n    def countSubgraphsForEachDiameter(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def dfs(n, adj, curr, parent, lookup, count, dp):\n            for child in adj[curr]:\n                if child == parent or lookup[child]:\n                    continue\n                dfs(n, adj, child, curr, lookup, count, dp)\n            dp[curr][0][0] = 1\n            for child in adj[curr]:\n                if child == parent or lookup[child]:\n                    continue\n                new_dp_curr = [row[:] for row in dp[curr]]\n                for curr_d in xrange(count[curr]):\n                    for curr_max_d in xrange(curr_d, min(2*curr_d+1, count[curr])):\n                        if not dp[curr][curr_d][curr_max_d]:  # pruning\n                            continue\n                        for child_d in xrange(count[child]):\n                            for child_max_d in xrange(child_d, min(2*child_d+1, count[child])):\n                                new_dp_curr[max(curr_d, child_d+1)][max(curr_max_d, child_max_d, curr_d+child_d+1)] += \\\n                                    dp[curr][curr_d][curr_max_d]*dp[child][child_d][child_max_d]  # count subtrees with new child\n                count[curr] += count[child]  # merge new child\n                dp[curr] = new_dp_curr\n\n        adj = collections.defaultdict(list)\n        for u, v in edges:\n            u -= 1\n            v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        lookup, result = [0]*n, [0]*(n-1)\n        for i in xrange(n):  # Time: sum(O(k^5) for k in [1, n]) = O(n^6)\n            dp = [[[0]*n for _ in xrange(n)] for _ in xrange(n)]\n            count = [1]*n\n            dfs(n, adj, i, -1, lookup, count, dp)  # Time: O(k^5), k is the number of the remaining cities\n            lookup[i] = 1\n            for d in xrange(1, n):  # for each depth from city i\n                for max_d in xrange(d, min(2*d+1, n)):  # for each max distance\n                    result[max_d-1] += dp[i][d][max_d]\n        return result\n    \n\n# Time:  O(n * 2^n)\n# Space: O(n)\nimport collections\nimport math\n\n\nclass Solution2(object):\n    def countSubgraphsForEachDiameter(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def popcount(mask):\n            count = 0\n            while mask:\n                mask &= mask-1\n                count += 1\n            return count\n\n        def bfs(adj, mask, start):\n            q = collections.deque([(start, 0)])\n            lookup = 1<<start\n            count = popcount(mask)-1\n            u, d = None, None\n            while q:\n                u, d = q.popleft()\n                for v in adj[u]:\n                    if not (mask&(1<<v)) or (lookup&(1<<v)):\n                        continue\n                    lookup |= 1<<v  \n                    count -= 1\n                    q.append((v, d+1))\n            return count == 0, u, d\n        \n        def max_distance(n, edges, adj, mask):\n            is_valid, farthest, _ = bfs(adj, mask, int(math.log(mask&-mask, 2)))\n            return bfs(adj, mask, farthest)[-1] if is_valid else 0\n\n        adj = collections.defaultdict(list)\n        for u, v in edges:\n            u -= 1\n            v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        result = [0]*(n-1)\n        for mask in xrange(1, 2**n):\n            max_d = max_distance(n, edges, adj, mask)\n            if max_d-1 >= 0:\n                result[max_d-1] += 1\n        return result\n\n"
    },
    {
        "problem_name": "count-symmetric-integers",
        "solution": "# Time:  O(rlogr)\n# Space: O(r)\n\n# brute force, memoization\nMAX_R = 10**4\nLOOKUP = [-1]*MAX_R\nclass Solution(object):\n    def countSymmetricIntegers(self, low, high):\n        \"\"\"\n        :type low: int\n        :type high: int\n        :rtype: int\n        \"\"\"\n        def check(x):\n            if LOOKUP[x-1] == -1:\n                digits = map(int, str(x))\n                if len(digits)%2:\n                    LOOKUP[x-1] = 0\n                else:\n                    LOOKUP[x-1] = int(sum(digits[i] for i in xrange(len(digits)//2)) == sum(digits[i] for i in xrange(len(digits)//2, len(digits))))\n            return LOOKUP[x-1]\n\n        return sum(check(x) for x in xrange(low, high+1))\n"
    },
    {
        "problem_name": "count-tested-devices-after-test-operations",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# simulation\nclass Solution(object):\n    def countTestedDevices(self, batteryPercentages):\n        \"\"\"\n        :type batteryPercentages: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for x in batteryPercentages:\n            if x > result:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "count-the-digits-that-divide-a-number",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def countDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        curr = num\n        while curr:\n            result += int(num%(curr%10) == 0)\n            curr //= 10\n        return result\n"
    },
    {
        "problem_name": "count-the-hidden-sequences",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def numberOfArrays(self, differences, lower, upper):\n        \"\"\"\n        :type differences: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        total = mn = mx = 0\n        for x in differences:\n            total += x\n            mn = min(mn, total)\n            mx = max(mx, total)\n        return max((upper-lower)-(mx-mn)+1, 0)\n"
    },
    {
        "problem_name": "count-the-number-of-beautiful-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table, combinatorics\nclass Solution(object):\n    def beautifulSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter()\n        cnt[0] = 1\n        result = curr = 0\n        for x in nums:\n            curr ^= x\n            result += cnt[curr]\n            cnt[curr] += 1\n        return result\n"
    },
    {
        "problem_name": "count-the-number-of-complete-components",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# bfs\nclass Solution(object):\n    def countCompleteComponents(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def bfs(u):\n            if lookup[u]:\n                return False\n            v_cnt = e_cnt = 0\n            lookup[u] = True\n            q = [u]\n            while q:\n                new_q = []\n                v_cnt += len(q)\n                for u in q:\n                    e_cnt += len(adj[u])\n                    for v in adj[u]:\n                        if lookup[v]:\n                            continue\n                        lookup[v] = True\n                        new_q.append(v)\n                q = new_q\n            return v_cnt*(v_cnt-1) == e_cnt\n\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        lookup = [False]*n\n        return sum(bfs(u) for u in xrange(n) if not lookup[u])\n"
    },
    {
        "problem_name": "count-the-number-of-consistent-strings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countConsistentStrings(self, allowed, words):\n        \"\"\"\n        :type allowed: str\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        lookup = [False]*26\n        for c in allowed:\n            lookup[ord(c)-ord('a')] = True\n        result = len(words)\n        for word in words:\n            for c in word:\n                if not lookup[ord(c)-ord('a')]:\n                    result -= 1\n                    break\n        return result\n"
    },
    {
        "problem_name": "count-the-number-of-fair-pairs",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, two pointers\nclass Solution(object):\n    def countFairPairs(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        def count(x):\n            cnt = 0\n            left, right = 0, len(nums)-1\n            while left < right:\n                if nums[left]+nums[right] <= x:\n                    cnt += right-left\n                    left += 1\n                else:\n                    right -= 1\n            return cnt\n        \n        nums.sort()\n        return count(upper)-count(lower-1)\n"
    },
    {
        "problem_name": "count-the-number-of-good-partitions",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table, combinatorics\nclass Solution(object):\n    def numberOfGoodPartitions(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        lookup = {x:i for i, x in enumerate(nums)}\n        result = 1\n        right = cnt = 0\n        for left, x in enumerate(nums):\n            if left == right+1:\n                cnt += 1\n            right = max(right, lookup[x])\n        return pow(2, cnt, MOD)\n"
    },
    {
        "problem_name": "count-the-number-of-good-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# two pointers, sliding window\nclass Solution(object):\n    def countGood(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = curr = left = 0\n        cnt = collections.Counter()\n        for right in xrange(len(nums)):\n            curr += cnt[nums[right]]\n            cnt[nums[right]] += 1\n            while curr >= k:\n                cnt[nums[left]] -= 1\n                curr -= cnt[nums[left]]\n                left += 1\n            result += left\n        return result\n"
    },
    {
        "problem_name": "count-the-number-of-good-subsequences",
        "solution": "# Time:  O(26 * n)\n# Space: O(n)\n\nimport collections\n\n\n# combinatorics\nclass Solution(object):\n    def countGoodSubsequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        fact, inv, inv_fact = [[1]*2 for _ in xrange(3)]\n        def nCr(n, k):\n            if not (0 <= k <= n):\n                return 0\n            while len(inv) <= n:  # lazy initialization\n                fact.append(fact[-1]*len(inv) % MOD)\n                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD)  # https://cp-algorithms.com/algebra/module-inverse.html\n                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)\n            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD\n\n        cnt = collections.Counter(s)\n        return reduce(lambda total, k: (total+reduce(lambda total, x: total*(1+nCr(x, k))%MOD, cnt.itervalues(), 1)-1)%MOD, xrange(1, max(cnt.itervalues())+1), 0)\n"
    },
    {
        "problem_name": "count-the-number-of-houses-at-a-certain-distance-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# math, prefix sum, difference array\nclass Solution(object):\n    def countOfPairs(self, n, x, y):\n        \"\"\"\n        :type n: int\n        :type x: int\n        :type y: int\n        :rtype: List[int]\n        \"\"\"\n        x, y = x-1, y-1\n        if x > y:\n            x, y = y, x\n        diff = [0]*n\n        for i in xrange(n):\n            diff[0] += 1+1                                         # i -> two routes begin\n            diff[min(abs(i-x), abs(i-y)+1)] += 1                   # i -> x -> y, fork one route at x to y\n            diff[min(abs(i-y), abs(i-x)+1)] += 1                   # i -> y -> x, fork one route at y to x\n            diff[min(abs(i-0), abs(i-y)+1+abs(x-0))] -= 1          # i -> 0, one route ends\n            diff[min(abs(i-(n-1)), abs(i-x)+1+abs(y-(n-1)))] -= 1  # i -> n-1, one route ends\n            diff[max(x-i, 0)+max(i-y, 0)+((y-x)+0)//2] -= 1        # i -> x -> ((y-x)+0)//2 <- x, one route ends\n            diff[max(x-i, 0)+max(i-y, 0)+((y-x)+1)//2] -= 1        # i -> y -> ((y-x)+1)//2 <- y, one route ends\n        for i in xrange(n-1):\n            diff[i+1] += diff[i]\n        return diff\n\n\n# Time:  O(n^2)\n# Space: O(1)\n# math\nclass Solution2(object):\n    def countOfPairs(self, n, x, y):\n        \"\"\"\n        :type n: int\n        :type x: int\n        :type y: int\n        :rtype: List[int]\n        \"\"\"\n        x, y = x-1, y-1\n        result = [0]*n\n        for i in xrange(n):\n            for j in xrange(i+1, n):\n                result[min(abs(i-j), abs(i-x)+1+abs(y-j), abs(i-y)+1+abs(x-j))-1] += 2\n        return result\n"
    },
    {
        "problem_name": "count-the-number-of-houses-at-a-certain-distance-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# math, prefix sum, difference array\nclass Solution(object):\n    def countOfPairs(self, n, x, y):\n        \"\"\"\n        :type n: int\n        :type x: int\n        :type y: int\n        :rtype: List[int]\n        \"\"\"\n        x, y = x-1, y-1\n        if x > y:\n            x, y = y, x\n        diff = [0]*n\n        for i in xrange(n):\n            diff[0] += 1+1                                         # i -> two routes begin\n            diff[min(abs(i-x), abs(i-y)+1)] += 1                   # i -> x -> y, fork one route at x to y\n            diff[min(abs(i-y), abs(i-x)+1)] += 1                   # i -> y -> x, fork one route at y to x\n            diff[min(abs(i-0), abs(i-y)+1+abs(x-0))] -= 1          # i -> 0, one route ends\n            diff[min(abs(i-(n-1)), abs(i-x)+1+abs(y-(n-1)))] -= 1  # i -> n-1, one route ends\n            diff[max(x-i, 0)+max(i-y, 0)+((y-x)+0)//2] -= 1        # i -> x -> ((y-x)+0)//2 <- x, one route ends\n            diff[max(x-i, 0)+max(i-y, 0)+((y-x)+1)//2] -= 1        # i -> y -> ((y-x)+1)//2 <- y, one route ends\n        for i in xrange(n-1):\n            diff[i+1] += diff[i]\n        return diff\n"
    },
    {
        "problem_name": "count-the-number-of-ideal-arrays",
        "solution": "# Time:  O(sqrt(m) + n + m * (logm + pi(sqrt(m)))) = O(sqrt(m) + n + m * (logm + sqrt(m)/log(sqrt(m)))), pi(n) = number of primes in a range [1, n] = O(n/logn) by prime number theorem, see https://en.wikipedia.org/wiki/Prime_number_theorem\n# Space: O(sqrt(m) + n + logm)\n\nimport collections\n\n\n# dp, factorization, combinatorics\nclass Solution(object):\n    def idealArrays(self, n, maxValue):\n        \"\"\"\n        :type n: int\n        :type maxValue: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        fact, inv, inv_fact = [[1]*2 for _ in xrange(3)]\n        def nCr(n, k):\n            while len(inv) <= n:  # lazy initialization\n                fact.append(fact[-1]*len(inv) % MOD)\n                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD)  # https://cp-algorithms.com/algebra/module-inverse.html\n                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)\n            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD\n\n        def linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)\n            primes = []\n            spf = [-1]*(n+1)  # the smallest prime factor\n            for i in xrange(2, n+1):\n                if spf[i] == -1:\n                    spf[i] = i\n                    primes.append(i)\n                for p in primes:\n                    if i*p > n or p > spf[i]:\n                        break\n                    spf[i*p] = p\n            return primes\n\n        def prime_factors(x):\n            factors = collections.Counter()\n            for p in primes:\n                if p*p > x:\n                    break\n                while x%p == 0:\n                    factors[p] += 1\n                    x //= p\n            if x != 1:\n                factors[x] += 1\n            return factors\n\n        primes = linear_sieve_of_eratosthenes(int(maxValue**0.5))\n        result = 0\n        for k in xrange(1, maxValue+1):\n            total = 1\n            for c in prime_factors(k).itervalues():\n                total = (total*nCr(n+c-1, c))%MOD  # H(n, c) = nCr(n+c-1, n)\n            result = (result+total)%MOD\n        return result\n\n\n# Time:  O(n * mlogm)\n# Space: O(n + m)\nimport collections\n\n\n# dp, combinatorics\nclass Solution2(object):\n    def idealArrays(self, n, maxValue):\n        \"\"\"\n        :type n: int\n        :type maxValue: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        fact, inv, inv_fact = [[1]*2 for _ in xrange(3)]\n        def nCr(n, k):\n            while len(inv) <= n:  # lazy initialization\n                fact.append(fact[-1]*len(inv) % MOD)\n                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD)  # https://cp-algorithms.com/algebra/module-inverse.html\n                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)\n            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD\n\n        result = 0\n        dp = collections.Counter(xrange(1, maxValue+1))\n        for i in xrange(n): \n            new_dp = collections.Counter()\n            total = 0\n            for x, c in dp.iteritems():\n                total = (total+c)%MOD\n                for y in xrange(x+x, maxValue+1, x): \n                    new_dp[y] += c\n            result = (result+total*nCr(n-1, i))%MOD\n            dp = new_dp\n        return result\n"
    },
    {
        "problem_name": "count-the-number-of-incremovable-subarrays-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers\nclass Solution(object):\n    def incremovableSubarrayCount(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        for j in reversed(xrange(1, len(nums))):\n            if not nums[j-1] < nums[j]:\n                break\n        else:\n            return (len(nums)+1)*len(nums)//2\n        result = len(nums)-j+1\n        for i in xrange(len(nums)-1):\n            while j < len(nums) and not (nums[i] < nums[j]):\n                j += 1\n            result += len(nums)-j+1\n            if not (nums[i] < nums[i+1]):\n                break\n        return result\n\n\n# Time:  O(n^3)\n# Space: O(1)\n# brute force\nclass Solution2(object):\n    def incremovableSubarrayCount(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum((left == 0 or right == len(nums)-1 or nums[left-1] < nums[right+1]) and\n                   all(nums[i] < nums[i+1] for i in xrange(left-1)) and\n                   all(nums[i] < nums[i+1] for i in xrange(right+1, len(nums)-1))\n                   for left in xrange(len(nums)) for right in xrange(left, len(nums)))\n"
    },
    {
        "problem_name": "count-the-number-of-incremovable-subarrays-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers\nclass Solution(object):\n    def incremovableSubarrayCount(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        for j in reversed(xrange(1, len(nums))):\n            if not nums[j-1] < nums[j]:\n                break\n        else:\n            return (len(nums)+1)*len(nums)//2\n        result = len(nums)-j+1\n        for i in xrange(len(nums)-1):\n            while j < len(nums) and not (nums[i] < nums[j]):\n                j += 1\n            result += len(nums)-j+1\n            if not (nums[i] < nums[i+1]):\n                break\n        return result\n"
    },
    {
        "problem_name": "count-the-number-of-infection-sequences",
        "solution": "# Time:  precompute: O(max_n)\n#        runtime:    O(s + logn)\n# Space: O(max_n)\n\n# combinatorics\nFACT, INV, INV_FACT = [[1]*2 for _ in xrange(3)]\nclass Solution(object):\n    def numberOfSequence(self, n, sick):\n        \"\"\"\n        :type n: int\n        :type sick: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def nCr(n, k):\n            while len(INV) <= n:  # lazy initialization\n                FACT.append(FACT[-1]*len(INV) % MOD)\n                INV.append(INV[MOD%len(INV)]*(MOD-MOD//len(INV)) % MOD)  # https://cp-algorithms.com/algebra/module-INVerse.html\n                INV_FACT.append(INV_FACT[-1]*INV[-1] % MOD)\n            return (FACT[n]*INV_FACT[n-k] % MOD) * INV_FACT[k] % MOD\n        \n        result = 1\n        total = cnt = 0\n        for i in xrange(len(sick)+1):\n            l = (sick[i] if i < len(sick) else n)-(sick[i-1] if i-1 >= 0 else -1)-1\n            if i not in (0, len(sick)):\n                cnt += max(l-1, 0)\n            total += l\n            result = (result*nCr(total, l))%MOD\n        result = (result*pow(2, cnt, MOD))%MOD\n        return result\n"
    },
    {
        "problem_name": "count-the-number-of-k-big-indices",
        "solution": "# Time:  O(nlogk)\n# Space: O(n)\n\nimport heapq\n\n\n# heap\nclass Solution(object):\n    def kBigIndices(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        right = [False]*len(nums)\n        max_heap1 = []\n        for i in reversed(xrange(len(nums))):\n            if len(max_heap1) == k and nums[i] > -max_heap1[0]:\n                right[i] = True\n            heapq.heappush(max_heap1, -nums[i])\n            if len(max_heap1) == k+1:\n                heapq.heappop(max_heap1)\n        result = 0\n        max_heap2 = []\n        for i in xrange(len(nums)):\n            if len(max_heap2) == k and nums[i] > -max_heap2[0] and right[i]:\n                result += 1\n            heapq.heappush(max_heap2, -nums[i])\n            if len(max_heap2) == k+1:\n                heapq.heappop(max_heap2)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nfrom sortedcontainers import SortedList\n\n\n# sorted list\nclass Solution2(object):\n    def kBigIndices(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        sl1, sl2 = SortedList(), SortedList(nums)\n        result = 0\n        for x in nums:\n            sl2.remove(x)\n            if sl1.bisect_left(x) >= k and sl2.bisect_left(x) >= k:\n                result += 1\n            sl1.add(x)\n        return result\n"
    },
    {
        "problem_name": "count-the-number-of-k-free-subsets",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\nimport operator\n\n\n# combinatorics, dp\nclass Solution(object):\n    def countTheNumOfKFreeSubsets(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def count(x):\n            y = x\n            while y-k in cnt:\n                y -= k\n            dp = [1, 0]  # dp[0]: count without i, dp[1]: count with i\n            for i in xrange(y, x+1, k):\n                dp = [dp[0]+dp[1], dp[0]*((1<<cnt[i])-1)]\n            return sum(dp)\n\n        cnt = collections.Counter(nums)\n        return reduce(operator.mul, (count(i) for i in cnt.iterkeys() if i+k not in cnt))\n"
    },
    {
        "problem_name": "count-the-number-of-powerful-integers",
        "solution": "# Time:  O(logf)\n# Space: O(1)\n\n# math, combinatorics\nclass Solution(object):\n    def numberOfPowerfulInt(self, start, finish, limit, s):\n        \"\"\"\n        :type start: int\n        :type finish: int\n        :type limit: int\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def count(x):\n            def length(x):\n                result = 0\n                while x:\n                    x //= 10\n                    result += 1\n                return result\n\n            result = 0\n            n = length(x)\n            base = 10**n\n            l = n-len(s)\n            cnt = (limit+1)**l\n            for i in xrange(l):\n                base //= 10\n                curr = x//base%10\n                cnt //= limit+1\n                result += (min(curr-1, limit)-0+1)*cnt\n                if curr > limit:\n                    break\n            else:\n                if x%base >= int(s):\n                    result += 1\n            return result\n\n        return count(finish)-count(start-1)\n\n\n# Time:  O(logf)\n# Space: O(logf)\n# math, combinatorics\nclass Solution2(object):\n    def numberOfPowerfulInt(self, start, finish, limit, s):\n        \"\"\"\n        :type start: int\n        :type finish: int\n        :type limit: int\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def count(x):\n            result = 0\n            str_x = str(x)\n            l = len(str_x)-len(s)\n            cnt = (limit+1)**l\n            for i in xrange(l):\n                cnt //= limit+1\n                result += (min(int(str_x[i])-1, limit)-0+1)*cnt\n                if int(str_x[i]) > limit:\n                    break\n            else:\n                if int(str_x[-len(s):]) >= int(s):\n                    result += 1\n            return result\n\n        return count(finish)-count(start-1)\n"
    },
    {
        "problem_name": "count-the-number-of-special-characters-i",
        "solution": "# Time:  O(n + 26)\n# Space: O(26)\n\nimport itertools\n\n\n# hash table\nclass Solution(object):\n    def numberOfSpecialChars(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        lookup1 = [False]*26\n        lookup2 = [False]*26\n        for x in word:\n            if x.islower():\n                lookup1[ord(x)-ord('a')] = True\n            else:\n                lookup2[ord(x)-ord('A')] = True\n        return sum(x == y == True for x, y in itertools.izip(lookup1, lookup2))\n"
    },
    {
        "problem_name": "count-the-number-of-special-characters-ii",
        "solution": "# Time:  O(n + 26)\n# Space: O(26)\n\nimport itertools\n\n\n# hash table\nclass Solution(object):\n    def numberOfSpecialChars(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        lookup1 = [len(word)]*26\n        lookup2 = [-1]*26\n        for i, x in enumerate(word):\n            if x.islower():\n                lookup1[ord(x)-ord('a')] = i\n            elif lookup2[ord(x)-ord('A')] == -1:\n                lookup2[ord(x)-ord('A')] = i\n        return sum(x < y for x, y in itertools.izip(lookup1, lookup2))\n"
    },
    {
        "problem_name": "count-the-number-of-square-free-subsets",
        "solution": "# Time:  O(n + m * 2^p)\n# Space: O(m * 2^p)\n\nimport collections\n\n\n# number theory, combinatorics, bitmasks, dp\nclass Solution(object):\n    def squareFreeSubsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)\n            primes = []\n            spf = [-1]*(n+1)  # the smallest prime factor\n            for i in xrange(2, n+1):\n                if spf[i] == -1:\n                    spf[i] = i\n                    primes.append(i)\n                for p in primes:\n                    if i*p > n or p > spf[i]:\n                        break\n                    spf[i*p] = p\n            return primes\n\n        MAX_NUM = max(nums)\n        PRIMES = linear_sieve_of_eratosthenes(MAX_NUM)\n        MASKS = [0]*(MAX_NUM+1)\n        for x in xrange(MAX_NUM+1):\n            y = x\n            for i, p in enumerate(PRIMES):\n                if y%p:\n                    continue\n                if y%p**2 == 0:\n                    MASKS[x] = 0\n                    break\n                MASKS[x] |= (1<<i)\n                y //= p\n        MOD = 10**9+7\n\n        cnt = collections.Counter(nums)\n        arr = [x for x in cnt.iterkeys() if x != 1]\n        dp = [1]*(1<<len(PRIMES))\n        for x in arr:\n            if not MASKS[x]:\n                continue\n            for mask in reversed(xrange(len(dp))):\n                 if MASKS[x]&mask == 0:\n                    dp[mask|MASKS[x]] = (dp[mask|MASKS[x]]+cnt[x]*dp[mask])%MOD\n        return (dp[-1]*pow(2, cnt[1], MOD)-1)%MOD if 1 in cnt else (dp[-1]-1)%MOD\n\n\n# Time:  O(n + m * 2^p)\n# Space: O(m * 2^p)\nimport collections\n\n\n# number theory, combinatorics, bitmasks, memoization\nclass Solution2(object):\n    def squareFreeSubsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)\n            primes = []\n            spf = [-1]*(n+1)  # the smallest prime factor\n            for i in xrange(2, n+1):\n                if spf[i] == -1:\n                    spf[i] = i\n                    primes.append(i)\n                for p in primes:\n                    if i*p > n or p > spf[i]:\n                        break\n                    spf[i*p] = p\n            return primes\n\n        MAX_NUM = max(nums)\n        PRIMES = linear_sieve_of_eratosthenes(MAX_NUM)\n        MASKS = [0]*(MAX_NUM+1)\n        for x in xrange(MAX_NUM+1):\n            y = x\n            for i, p in enumerate(PRIMES):\n                if y%p:\n                    continue\n                if y%p**2 == 0:\n                    MASKS[x] = 0\n                    break\n                MASKS[x] |= (1<<i)\n                y //= p\n        MOD = 10**9+7\n\n        cnt = collections.Counter(nums)\n        arr = [x for x in cnt.iterkeys() if x != 1]\n        dp = [[-1]*(1<<len(PRIMES)) for i in xrange(len(arr))]\n        def memoization(i, mask):\n            if i == len(arr):\n                return 1\n            if dp[i][mask] == -1:\n                dp[i][mask] = memoization(i+1, mask)\n                if MASKS[arr[i]] and (MASKS[arr[i]]&mask) == MASKS[arr[i]]:\n                    dp[i][mask] = (dp[i][mask]+cnt[arr[i]]*memoization(i+1, mask^MASKS[arr[i]]))%MOD\n            return dp[i][mask]\n    \n        return (memoization(0, (1<<len(PRIMES))-1)*pow(2, cnt[1], MOD)-1)%MOD if 1 in cnt else (memoization(0, (1<<len(PRIMES))-1)-1)%MOD\n"
    },
    {
        "problem_name": "count-the-number-of-vowel-strings-in-range",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def vowelStrings(self, words, left, right):\n        \"\"\"\n        :type words: List[str]\n        :type left: int\n        :type right: int\n        :rtype: int\n        \"\"\"\n        VOWELS = {'a', 'e', 'i', 'o', 'u'}\n        return sum(words[i][0] in VOWELS and words[i][-1] in VOWELS for i in xrange(left, right+1))\n"
    },
    {
        "problem_name": "count-the-repetitions",
        "solution": "# Time:  O(s1 * min(s2, n1))\n# Space: O(s2)\n\nclass Solution(object):\n    def getMaxRepetitions(self, s1, n1, s2, n2):\n        \"\"\"\n        :type s1: str\n        :type n1: int\n        :type s2: str\n        :type n2: int\n        :rtype: int\n        \"\"\"\n        repeat_count = [0] * (len(s2)+1)\n        lookup = {}\n        j, count = 0, 0\n        for k in xrange(1, n1+1):\n            for i in xrange(len(s1)):\n                if s1[i] == s2[j]:\n                    j = (j + 1) % len(s2)\n                    count += (j == 0)\n\n            if j in lookup:   # cyclic\n                i = lookup[j]\n                prefix_count = repeat_count[i]\n                pattern_count = (count - repeat_count[i]) * ((n1 - i) // (k - i))\n                suffix_count = repeat_count[i + (n1 - i) % (k - i)] - repeat_count[i]\n                return (prefix_count + pattern_count + suffix_count) / n2\n            lookup[j] = k\n            repeat_count[k] = count\n\n        return repeat_count[n1] / n2  # not cyclic iff n1 <= s2\n\n"
    },
    {
        "problem_name": "count-total-number-of-colored-cells",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def coloredCells(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return n**2+(n-1)**2\n\n\n# Time:  O(1)\n# Space: O(1)\n# math\nclass Solution2(object):\n    def coloredCells(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return (1+(1+2*(n-1)))*n//2*2-(2*n-1)\n"
    },
    {
        "problem_name": "count-triplets-that-can-form-two-arrays-of-equal-xor",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def countTriplets(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        count_sum = collections.defaultdict(lambda: [0, 0])\n        count_sum[0] = [1, 0]\n        result, prefix = 0, 0\n        for i, x in enumerate(arr):\n            prefix ^= x\n            c, t = count_sum[prefix]\n            # sum(i-(j+1) for j in index[prefix])\n            # = len(index[prefix])*i - sum((j+1) for j in index[prefix])\n            result += c*i - t\n            count_sum[prefix] = [c+1, t+i+1]\n        return result\n"
    },
    {
        "problem_name": "count-unguarded-cells-in-the-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nimport itertools\n\n\n# array, simulation\nclass Solution(object):\n    def countUnguarded(self, m, n, guards, walls):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type guards: List[List[int]]\n        :type walls: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        GREEN, RED, BLOCK = range(3)\n        grid = [[GREEN]*n for _ in xrange(m)]\n        for r, c in itertools.chain(guards, walls):\n            grid[r][c] = BLOCK\n        for r, c in guards:\n            for dr, dc in DIRECTIONS:\n                nr, nc = r+dr, c+dc\n                while 0 <= nr < m and 0 <= nc < n and grid[nr][nc] != BLOCK:\n                    grid[nr][nc] = RED\n                    nr, nc = nr+dr, nc+dc\n        return sum(grid[r][c] == GREEN for r in xrange(m) for c in xrange(n))\n"
    },
    {
        "problem_name": "count-unhappy-friends",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nclass Solution(object):\n    def unhappyFriends(self, n, preferences, pairs):\n        \"\"\"\n        :type n: int\n        :type preferences: List[List[int]]\n        :type pairs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        friends = [[0]*n for _ in xrange(n)]\n        for i in xrange(len(preferences)):\n            for j in xrange(len(preferences[i])):\n                friends[i][preferences[i][j]] = j\n        pairing = [0]*n\n        for i, j in pairs:\n            pairing[i], pairing[j] = j, i\n        return sum(any(friends[i][j] < friends[i][pairing[i]] and friends[j][i] < friends[j][pairing[j]]\n                       for j in xrange(len(friends[i])) if j != i and j != pairing[i])\n                   for i in xrange(len(friends)))\n"
    },
    {
        "problem_name": "count-unique-characters-of-all-substrings-of-a-given-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport string\n\n\nclass Solution(object):\n    def uniqueLetterString(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        M = 10**9 + 7\n        index = {c: [-1, -1] for c in string.ascii_uppercase}\n        result = 0\n        for i, c in enumerate(S):\n            k, j = index[c]\n            result = (result + (i-j) * (j-k)) % M\n            index[c] = [j, i]\n        for c in index:\n            k, j = index[c]\n            result = (result + (len(S)-j) * (j-k)) % M\n        return result\n\n"
    },
    {
        "problem_name": "count-univalue-subtrees",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    # @param {TreeNode} root\n    # @return {integer}\n    def countUnivalSubtrees(self, root):\n        [is_uni, count] = self.isUnivalSubtrees(root, 0)\n        return count\n\n    def isUnivalSubtrees(self, root, count):\n        if not root:\n            return [True, count]\n\n        [left, count] = self.isUnivalSubtrees(root.left, count)\n        [right, count] = self.isUnivalSubtrees(root.right, count)\n        if self.isSame(root, root.left, left) and \\\n           self.isSame(root, root.right, right):\n                count += 1\n                return [True, count]\n\n        return [False, count]\n\n    def isSame(self, root, child, is_uni):\n        return not child or (is_uni and root.val == child.val)\n\n"
    },
    {
        "problem_name": "count-unreachable-pairs-of-nodes-in-an-undirected-graph",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# flood fill, bfs, math\nclass Solution(object):\n    def countPairs(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def bfs(adj, u, lookup):\n            q = [u]\n            lookup[u] = 1\n            result = 1\n            while q:\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if lookup[v]:\n                            continue\n                        lookup[v] = 1\n                        result += 1\n                        new_q.append(v)\n                q = new_q\n            return result\n        \n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        lookup = [0]*n\n        result = 0\n        for u in xrange(n):\n            if lookup[u]:\n                continue\n            cnt = bfs(adj, u, lookup)\n            result += cnt*(n-cnt)\n            n -= cnt\n        return result\n"
    },
    {
        "problem_name": "count-valid-paths-in-a-tree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# number theory, tree dp, iterative dfs\nclass Solution(object):\n    def countPaths(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)\n            primes = []\n            spf = [-1]*(n+1)  # the smallest prime factor\n            for i in xrange(2, n+1):\n                if spf[i] == -1:\n                    spf[i] = i\n                    primes.append(i)\n                for p in primes:\n                    if i*p > n or p > spf[i]:\n                        break\n                    spf[i*p] = p\n            return spf\n        \n        def is_prime(u):\n            return spf[u] == u\n\n        def iter_dfs():\n            result = 0\n            stk = [(1, (0, -1, [0]*2))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    u, p, ret = args\n                    ret[:] = [1-is_prime(u+1), is_prime(u+1)]\n                    stk.append((2, (u, p, ret, 0)))\n                elif step == 2:\n                    u, p, ret, i = args\n                    if i == len(adj[u]):\n                        continue\n                    v = adj[u][i]\n                    stk.append((2, (u, p, ret, i+1)))\n                    if v == p:\n                        continue\n                    new_ret = [0]*2\n                    stk.append((3, (u, p, new_ret, ret, i)))\n                    stk.append((1, (v, u, new_ret)))\n                elif step == 3:\n                    u, p, new_ret, ret, i = args\n                    result += ret[0]*new_ret[1]+ret[1]*new_ret[0]\n                    if is_prime(u+1):\n                        ret[1] += new_ret[0]\n                    else:\n                        ret[0] += new_ret[0]\n                        ret[1] += new_ret[1]\n            return result\n\n        spf = linear_sieve_of_eratosthenes(n)\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            u, v = u-1, v-1\n            adj[u].append(v)\n            adj[v].append(u)\n        return iter_dfs()\n\n\n# Time:  O(n)\n# Space: O(n)\n# number theory, tree dp, dfs\nclass Solution2(object):\n    def countPaths(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)\n            primes = []\n            spf = [-1]*(n+1)  # the smallest prime factor\n            for i in xrange(2, n+1):\n                if spf[i] == -1:\n                    spf[i] = i\n                    primes.append(i)\n                for p in primes:\n                    if i*p > n or p > spf[i]:\n                        break\n                    spf[i*p] = p\n            return spf\n        \n        def is_prime(u):\n            return spf[u] == u\n\n        def dfs(u, p):\n            cnt = [1-is_prime(u+1), is_prime(u+1)]\n            for v in adj[u]:\n                if v == p:\n                    continue\n                new_cnt = dfs(v, u)\n                result[0] += cnt[0]*new_cnt[1]+cnt[1]*new_cnt[0]\n                if is_prime(u+1):\n                    cnt[1] += new_cnt[0]\n                else:\n                    cnt[0] += new_cnt[0]\n                    cnt[1] += new_cnt[1]\n            return cnt\n\n        spf = linear_sieve_of_eratosthenes(n)\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            u, v = u-1, v-1\n            adj[u].append(v)\n            adj[v].append(u)\n        result = [0]\n        dfs(0, -1)\n        return result[0]\n\n\n# Time:  O(n)\n# Space: O(n)\n# number theory, union find\nclass UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n        self.size = [1]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x, y = self.find_set(x), self.find_set(y)\n        if x == y:\n            return False\n        if self.rank[x] > self.rank[y]:  # union by rank\n            x, y = y, x\n        self.set[x] = self.set[y]\n        if self.rank[x] == self.rank[y]:\n            self.rank[y] += 1\n        self.size[y] += self.size[x]\n        return True\n\n    def total(self, x):\n        return self.size[self.find_set(x)]\n\n\nclass Solution3(object):\n    def countPaths(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)\n            primes = []\n            spf = [-1]*(n+1)  # the smallest prime factor\n            for i in xrange(2, n+1):\n                if spf[i] == -1:\n                    spf[i] = i\n                    primes.append(i)\n                for p in primes:\n                    if i*p > n or p > spf[i]:\n                        break\n                    spf[i*p] = p\n            return spf\n        \n        def is_prime(u):\n            return spf[u] == u\n\n        spf = linear_sieve_of_eratosthenes(n)\n        uf = UnionFind(n)\n        for u, v in edges:\n            u, v = u-1, v-1\n            if is_prime(u+1) == is_prime(v+1) == False:\n                uf.union_set(u, v) \n        result = 0\n        cnt = [1]*n\n        for u, v in edges:\n            u, v = u-1, v-1\n            if is_prime(u+1) == is_prime(v+1):\n                continue\n            if not is_prime(u+1):\n                u, v = v, u\n            result += cnt[u]*uf.total(v)\n            cnt[u] += uf.total(v)\n        return result\n"
    },
    {
        "problem_name": "count-visited-nodes-in-a-directed-graph",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# graph, hash table, stack\nclass Solution(object):\n    def countVisitedNodes(self, edges):\n        \"\"\"\n        :type edges: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def find_cycles(adj):\n            result = [0]*len(adj)\n            lookup = [0]*len(adj)\n            stk = []  # added\n            idx = 0\n            for u in xrange(len(adj)):\n                prev = idx\n                while not lookup[u]:\n                    idx += 1\n                    lookup[u] = idx\n                    stk.append(u)  # added\n                    u = adj[u]\n                if lookup[u] > prev:\n                    l = idx-lookup[u]+1\n                    for _ in xrange(l):  # added\n                        result[stk.pop()] = l\n                while stk:  # added\n                    result[stk[-1]] = result[adj[stk[-1]]]+1\n                    stk.pop()\n            return result\n        \n        return find_cycles(edges)\n"
    },
    {
        "problem_name": "count-vowel-strings-in-ranges",
        "solution": "# Time:  O(n + q)\n# Space: O(n)\n\n# prefix sum\nclass Solution(object):\n    def vowelStrings(self, words, queries):\n        \"\"\"\n        :type words: List[str]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        VOWELS = {'a', 'e', 'i', 'o', 'u'}\n        prefix = [0]*(len(words)+1)\n        for i, w in enumerate(words):\n            prefix[i+1] = prefix[i]+int(w[0] in VOWELS and w[-1] in VOWELS)\n        return [prefix[r+1]-prefix[l] for l, r in queries]\n"
    },
    {
        "problem_name": "count-vowel-substrings-of-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def countVowelSubstrings(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        VOWELS = set(\"aeiou\")\n        k = 5\n        def atLeastK(word, k):\n            cnt = collections.Counter()\n            result = left = right = 0\n            for i, c in enumerate(word):\n                if c not in VOWELS:\n                    cnt = collections.Counter()\n                    left = right = i+1\n                    continue\n                cnt[c] += 1\n                while len(cnt) > k-1:\n                    cnt[word[right]] -= 1\n                    if not cnt[word[right]]:\n                        del cnt[word[right]]\n                    right += 1\n                result += right-left\n            return result\n\n        return atLeastK(word, k)\n\n\n# Time:  O(n)\n# Space: O(1)\nimport collections\n\n\nclass Solution2(object):\n    def countVowelSubstrings(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        VOWELS = set(\"aeiou\")\n        k = 5\n        def atMostK(word, k):\n            cnt = collections.Counter()\n            result = left = 0\n            for right, c in enumerate(word):\n                if c not in VOWELS:\n                    cnt = collections.Counter()\n                    left = right+1\n                    continue\n                cnt[c] += 1\n                while len(cnt) > k:\n                    cnt[word[left]] -=1\n                    if not cnt[word[left]]:\n                        del cnt[word[left]]\n                    left += 1\n                result += right-left+1\n            return result\n\n        return atMostK(word, k) - atMostK(word, k-1)\n"
    },
    {
        "problem_name": "count-vowels-permutation",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def countVowelPermutation(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) % MOD \\\n                     for col in ZB] for row in A]\n        \n        MOD = 10**9 + 7\n        T = [[0, 1, 1, 0, 1],\n             [1, 0, 1, 0, 0],\n             [0, 1, 0, 1, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 1, 1, 0]]\n        return sum(map(sum, matrix_expo(T, n-1))) % MOD\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def countVowelPermutation(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        a, e, i, o, u = 1, 1, 1, 1, 1\n        for _ in xrange(1, n):\n            a, e, i, o, u = (e+i+u) % MOD, (a+i) % MOD, (e+o) % MOD, i, (i+o) % MOD\n        return (a+e+i+o+u) % MOD\n"
    },
    {
        "problem_name": "count-ways-to-build-good-strings",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# dp\nclass Solution(object):\n    def countGoodStrings(self, low, high, zero, one):\n        \"\"\"\n        :type low: int\n        :type high: int\n        :type zero: int\n        :type one: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result = 0\n        dp = [0]*(high+1)\n        dp[0] = 1\n        for i in xrange(1, high+1):\n            if i >= zero:\n                dp[i] = (dp[i]+dp[i-zero])%MOD\n            if i >= one:\n                dp[i] = (dp[i]+dp[i-one])%MOD\n            if i >= low:\n                result = (result+dp[i])%MOD\n        return result\n"
    },
    {
        "problem_name": "count-ways-to-build-rooms-in-an-ant-colony",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def waysToBuildRooms(self, prevRoom):\n        \"\"\"\n        :type prevRoom: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        fact = [1, 1]\n        inv = [0, 1]\n        inv_fact = [1, 1]\n        def nCr(n, k):\n            while len(inv) <= n:  # lazy initialization\n                fact.append(fact[-1]*len(inv) % MOD)\n                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD)  # https://cp-algorithms.com/algebra/module-inverse.html\n                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)\n            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD\n\n        def dfs(adj, curr):\n            total_ways, total_cnt = 1, 0\n            for child in adj[curr]:\n                ways, cnt = dfs(adj, child)\n                total_cnt += cnt\n                total_ways = (((total_ways*ways) % MOD)*nCr(total_cnt, cnt)) % MOD\n            return total_ways, total_cnt+1\n\n        adj = [[] for _ in xrange(len(prevRoom))]\n        for i in xrange(1, len(prevRoom)):\n            adj[prevRoom[i]].append(i)\n        return dfs(adj, 0)[0]\n"
    },
    {
        "problem_name": "count-ways-to-distribute-candies",
        "solution": "# Time:  O(n * k)\n# Space: O(k)\n\nclass Solution(object):\n    def waysToDistribute(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [1]*k\n        for i in xrange(1, n):\n            for j in reversed(xrange(1, min(i, k))):\n                dp[j] = ((j+1)*dp[j] + dp[j-1]) % MOD\n        return dp[k-1]\n"
    },
    {
        "problem_name": "count-ways-to-group-overlapping-ranges",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, array\nclass Solution(object):\n    def countWays(self, ranges):\n        \"\"\"\n        :type ranges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        ranges.sort()\n        cnt = 0\n        curr = float(\"-inf\")\n        for l, r in ranges:\n            if l > curr:\n                cnt += 1\n            curr = max(curr, r)\n        return pow(2, cnt, MOD)\n"
    },
    {
        "problem_name": "count-ways-to-make-array-with-product",
        "solution": "# Time:  O(sqrt(m) + n + q * (logm + pi(sqrt(m)))) = O(sqrt(m) + n + q * (logm + sqrt(m)/log(sqrt(m)))), m is max(k for _, k in queries), pi(n) = number of primes in a range [1, n] = O(n/logn) by prime number theorem, see https://en.wikipedia.org/wiki/Prime_number_theorem\n# Space: O(sqrt(m) + n + logm)\n\nimport collections\n\n\nclass Solution(object):\n    def waysToFillArray(self, queries):\n        \"\"\"\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        MOD = 10**9+7\n        fact, inv, inv_fact = [[1]*2 for _ in xrange(3)]\n        def nCr(n, k):\n            while len(inv) <= n:  # lazy initialization\n                fact.append(fact[-1]*len(inv) % MOD)\n                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD)  # https://cp-algorithms.com/algebra/module-inverse.html\n                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)\n            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD\n\n        def linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)\n            primes = []\n            spf = [-1]*(n+1)  # the smallest prime factor\n            for i in xrange(2, n+1):\n                if spf[i] == -1:\n                    spf[i] = i\n                    primes.append(i)\n                for p in primes:\n                    if i*p > n or p > spf[i]:\n                        break\n                    spf[i*p] = p\n            return primes\n\n        def prime_factors(x):\n            factors = collections.Counter()\n            for p in primes:\n                if p*p > x:\n                    break\n                while x%p == 0:\n                    factors[p] += 1\n                    x //= p\n            if x != 1:\n                factors[x] += 1\n            return factors\n\n        primes = linear_sieve_of_eratosthenes(int(max(k for _, k in queries)**0.5))\n        result = []\n        for n, k in queries:\n            total = 1\n            for c in prime_factors(k).itervalues():\n                total *= nCr(n+c-1, c)  # H(n, c) = nCr(n+c-1, n)\n            result.append(total % MOD)\n        return result\n"
    },
    {
        "problem_name": "count-words-obtained-after-adding-a-letter",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def wordCount(self, startWords, targetWords):\n        \"\"\"\n        :type startWords: List[str]\n        :type targetWords: List[str]\n        :rtype: int\n        \"\"\"\n        def bitmask(w):\n            return reduce(lambda x, y: x|y, (1 << (ord(c)-ord('a')) for i, c in enumerate(w)))\n\n        lookup = set(bitmask(w) for w in startWords)\n        result = 0 \n        for w in targetWords: \n            mask = bitmask(w)\n            result += any(mask ^ (1 << ord(c)-ord('a')) in lookup for c in w)\n        return result \n"
    },
    {
        "problem_name": "count-zero-request-servers",
        "solution": "# Time:  O(nlogn + mlogm)\n# Space: O(n + m)\n\n# sort, two pointers\nclass Solution(object):\n    def countServers(self, n, logs, x, queries):\n        \"\"\"\n        :type n: int\n        :type logs: List[List[int]]\n        :type x: int\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        logs.sort(key=lambda x:x[1])\n        result = [0]*len(queries)\n        cnt = [0]*n\n        curr = left = right = 0\n        for t, i in sorted((t, i) for i, t in enumerate(queries)):\n            while right < len(logs) and logs[right][1] <= t:\n                if cnt[logs[right][0]-1] == 0:\n                    curr += 1\n                cnt[logs[right][0]-1] += 1\n                right += 1\n            while left < right and logs[left][1] < t-x:\n                cnt[logs[left][0]-1] -= 1\n                if cnt[logs[left][0]-1] == 0:\n                    curr -= 1\n                left += 1\n            result[i] = n-curr\n        return result\n\n\n# Time:  O(nlogn + mlogm)\n# Space: O(n + m)\n# sort, line sweep\nclass Solution2(object):\n    def countServers(self, n, logs, x, queries):\n        \"\"\"\n        :type n: int\n        :type logs: List[List[int]]\n        :type x: int\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        events = []\n        for sid, t in logs:\n            events.append((t, +1, sid-1))\n            events.append((t+x+1, -1, sid-1))\n        events.append((float(\"inf\"), 0, 0))\n        events.sort()\n\n        events2 = []\n        for i, t in enumerate(queries):\n            events2.append((t, i))\n        events2.sort(reverse=True)\n\n        result = [0]*len(queries)\n        cnt = [0]*n\n        curr = 0\n        for t, c, i in events:\n            while events2 and events2[-1][0] < t:                \n                result[events2.pop()[1]] += n-curr\n            if cnt[i] == 0:\n                curr += 1\n            cnt[i] += c\n            if cnt[i] == 0:\n                curr -= 1\n        return result\n"
    },
    {
        "problem_name": "counting-bits",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def countBits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[int]\n        \"\"\"\n        res = [0]\n        for i in xrange(1, num + 1):\n            # Number of 1's in i = (i & 1) + number of 1's in (i / 2).\n            res.append((i & 1) + res[i >> 1])\n        return res\n\n    def countBits2(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[int]\n        \"\"\"\n        s = [0]\n        while len(s) <= num:\n            s.extend(map(lambda x: x + 1, s))\n        return s[:num + 1]\n\n\n"
    },
    {
        "problem_name": "counting-elements",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def countElements(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = set(arr)\n        return sum(1 for x in arr if x+1 in lookup)\n\n\n# Time:  O(nlogn)\n# Space: O(1)\nclass Solution(object):\n    def countElements(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        arr.sort()\n        result, l = 0, 1\n        for i in xrange(len(arr)-1):\n            if arr[i] == arr[i+1]:\n                l += 1\n                continue\n            if arr[i]+1 == arr[i+1]:\n                result += l\n            l = 1\n        return result\n"
    },
    {
        "problem_name": "counting-words-with-a-given-prefix",
        "solution": "# Time:  O(n * p)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def prefixCount(self, words, pref):\n        \"\"\"\n        :type words: List[str]\n        :type pref: str\n        :rtype: int\n        \"\"\"\n        return sum(x.startswith(pref) for x in words)\n"
    },
    {
        "problem_name": "couples-holding-hands",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        N = len(row)//2\n        couples = [[] for _ in xrange(N)]\n        for seat, num in enumerate(row):\n            couples[num//2].append(seat//2)\n        adj = [[] for _ in xrange(N)]\n        for couch1, couch2 in couples:\n            adj[couch1].append(couch2)\n            adj[couch2].append(couch1)\n\n        result = 0\n        for couch in xrange(N):\n            if not adj[couch]: continue\n            couch1, couch2 = couch, adj[couch].pop()\n            while couch2 != couch:\n                result += 1\n                adj[couch2].remove(couch1)\n                couch1, couch2 = couch2, adj[couch2].pop()\n        return result  # also equals to N - (# of cycles)\n\n"
    },
    {
        "problem_name": "course-schedule-ii",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|E|)\n\nimport collections\n\n\n# Khan's algorithm (bfs solution)\nclass Solution(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        q = [u for u in xrange(numCourses) if u not in in_degree]\n        while q:\n            new_q = []\n            for u in q:\n                result.append(u)\n                for v in adj[u]:\n                    in_degree[v] -= 1\n                    if in_degree[v] == 0:\n                        new_q.append(v)\n            q = new_q\n        return result if len(result) == numCourses else []\n\n\n# Time:  O(|V| + |E|)\n# Space: O(|E|)\nimport collections\n\n\n# dfs solution\nclass Solution2(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        stk = [u for u in xrange(numCourses) if u not in in_degree]\n        while stk:\n            u = stk.pop()\n            result.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    stk.append(v)\n        return result if len(result) == numCourses else []\n\n\n# Time:  O(|V| + |E|)\n# Space: O(|E|)\nimport collections\n\n\n# dfs solution\nclass Solution3(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        WHITE, GRAY, BLACK = range(3)\n        def dfs(u):\n            if lookup[u] != WHITE:\n                return lookup[u] == BLACK\n            lookup[u] = GRAY\n            if any(not dfs(v) for v in adj[u]):\n                return False\n            lookup[u] = BLACK\n            result.append(u)  # should be postorder\n            return True\n\n        result = []\n        adj = collections.defaultdict(list)\n        for u, v in prerequisites:\n            adj[u].append(v)\n        lookup = collections.defaultdict(lambda:WHITE)\n        for u in xrange(numCourses):\n            if not dfs(u):\n                return []\n        return result\n\n    \n# Time:  O(|V| + |E|)\n# Space: O(|E|)\nimport collections\n\n\n# dfs solution\nclass Solution4(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        WHITE, GRAY, BLACK = range(3)\n        def dfs(u):\n            if lookup[u] != WHITE:\n                return lookup[u] == BLACK\n            lookup[u] = GRAY\n            if any(not dfs(v) for v in adj[u]):\n                return False\n            lookup[u] = BLACK\n            result.append(u)  # should be postorder\n            return True\n\n        result = []\n        adj = collections.defaultdict(list)\n        for u, v in prerequisites:\n            adj[v].append(u)\n        lookup = collections.defaultdict(lambda:WHITE)\n        for u in xrange(numCourses):\n            if not dfs(u):\n                return []\n        result.reverse()\n        return result\n"
    },
    {
        "problem_name": "course-schedule-iii",
        "solution": "# Time:  O(nlogn)\n# Space: O(k), k is the number of courses you can take\n\nimport collections\nimport heapq\n\n\nclass Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        courses.sort(key=lambda t_end: t_end[1])\n        max_heap = []\n        now = 0\n        for t, end in courses:\n            now += t\n            heapq.heappush(max_heap, -t)\n            if now > end:\n                now += heapq.heappop(max_heap)\n        return len(max_heap)\n\n"
    },
    {
        "problem_name": "course-schedule-iv",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\nclass Solution(object):\n    def checkIfPrerequisite(self, n, prerequisites, queries):\n        \"\"\"\n        :type n: int\n        :type prerequisites: List[List[int]]\n        :type queries: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        def floydWarshall(n, graph): \n            reachable = set(map(lambda x: x[0]*n+x[1], graph)) \n            for k in xrange(n): \n                for i in xrange(n): \n                    for j in xrange(n): \n                        if i*n+j not in reachable and (i*n+k in reachable and k*n+j in reachable):\n                            reachable.add(i*n+j)\n            return reachable\n\n        reachable = floydWarshall(n, prerequisites)\n        return [i*n+j in reachable for i, j in queries]\n\n\n# Time:  O(n * q)\n# Space: O(p + n)\nimport collections\n\n\nclass Solution2(object):\n    def checkIfPrerequisite(self, n, prerequisites, queries):\n        \"\"\"\n        :type n: int\n        :type prerequisites: List[List[int]]\n        :type queries: List[List[int]]\n        :rtyp\n        \"\"\"\n        graph = collections.defaultdict(list)\n        for u, v in prerequisites:\n            graph[u].append(v)\n        result = []\n        for i, j in queries:\n            stk, lookup = [i], set([i])\n            while stk:\n                node = stk.pop()\n                for nei in graph[node]:\n                    if nei in lookup:\n                        continue\n                    stk.append(nei)\n                    lookup.add(nei)\n            result.append(j in lookup)\n        return result\n"
    },
    {
        "problem_name": "course-schedule",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|E|)\n\nimport collections\n\n\n# Khan's algorithm (bfs solution)\nclass Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        q = [u for u in xrange(numCourses) if u not in in_degree]\n        while q:\n            new_q = []\n            for u in q:\n                result.append(u)\n                for v in adj[u]:\n                    in_degree[v] -= 1\n                    if in_degree[v] == 0:\n                        new_q.append(v)\n            q = new_q\n        return len(result) == numCourses\n\n\n# Time:  O(|V| + |E|)\n# Space: O(|E|)\nimport collections\n\n\n# dfs solution\nclass Solution2(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        in_degree = collections.Counter()\n        for u, v in prerequisites:\n            in_degree[u] += 1\n            adj[v].append(u)\n        result = []\n        stk = [u for u in xrange(numCourses) if u not in in_degree]\n        while stk:\n            u = stk.pop()\n            result.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    stk.append(v)\n        return len(result) == numCourses\n"
    },
    {
        "problem_name": "cousins-in-binary-tree-ii",
        "solution": "# Time:  O(n)\n# Space: O(w)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\n# bfs\nclass Solution(object):\n    def replaceValueInTree(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        q = [(root, root.val)]\n        while q:\n            new_q = []\n            total = sum(node.val for node, _ in q)\n            for node, x in q:\n                node.val = total-x\n                x = (node.left.val if node.left else 0) + (node.right.val if node.right else 0)\n                if node.left:\n                    new_q.append((node.left, x))\n                if node.right:\n                    new_q.append((node.right, x))\n            q = new_q\n        return root\n"
    },
    {
        "problem_name": "cousins-in-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def isCousins(self, root, x, y):\n        \"\"\"\n        :type root: TreeNode\n        :type x: int\n        :type y: int\n        :rtype: bool\n        \"\"\"\n        def dfs(root, x, depth, parent):\n            if not root:\n                return False\n            if root.val == x:\n                return True\n            depth[0] += 1\n            prev_parent, parent[0] = parent[0], root\n            if dfs(root.left, x, depth, parent):\n                return True\n            parent[0] = root\n            if dfs(root.right, x, depth, parent):\n                return True\n            parent[0] = prev_parent\n            depth[0] -= 1\n            return False\n        \n        depth_x, depth_y = [0], [0]\n        parent_x, parent_y = [None], [None]\n        return dfs(root, x, depth_x, parent_x) and \\\n               dfs(root, y, depth_y, parent_y) and \\\n               depth_x[0] == depth_y[0] and \\\n               parent_x[0] != parent_y[0]\n                \n        \n"
    },
    {
        "problem_name": "cracking-the-safe",
        "solution": "# Time:  O(k^n)\n# Space: O(k^n)\n\nclass Solution(object):\n    def crackSafe(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        M = k**(n-1)\n        P = [q*k+i for i in xrange(k) for q in xrange(M)]  # rotate: i*k^(n-1) + q => q*k + i\n        result = [str(k-1)]*(n-1)\n        for i in xrange(k**n):\n            j = i\n            # concatenation in lexicographic order of Lyndon words\n            while P[j] >= 0:\n                result.append(str(j//M))\n                P[j], j = -1, P[j]\n        return \"\".join(result)\n\n\n# Time:  O(k^n)\n# Space: O(k^n)\nclass Solution2(object):\n    def crackSafe(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        total = k**n\n        M = total//k\n        unique_rolling_hash = 0\n        result = [str(0)]*(n-1)\n        lookup = set()\n        while len(lookup) < total:\n            for i in reversed(xrange(k)):  # preorder like traversal relative to initial result to avoid getting stuck, i.e. don't use 0 until there is no other choice\n                new_unique_rolling_hash = unique_rolling_hash*k + i\n                if new_unique_rolling_hash not in lookup:\n                    lookup.add(new_unique_rolling_hash)\n                    result.append(str(i))\n                    unique_rolling_hash = new_unique_rolling_hash%M\n                    break\n        return \"\".join(result)\n\n\n# Time:  O(k^n)\n# Space: O(k^n)\nclass Solution3(object):\n    def crackSafe(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        M = k**(n-1)\n        def dfs(k, unique_rolling_hash, lookup, result):\n            for i in reversed(xrange(k)):  # preorder like traversal relative to initial result to avoid getting stuck, i.e. don't use 0 until there is no other choice\n                new_unique_rolling_hash = unique_rolling_hash*k + i\n                if new_unique_rolling_hash not in lookup:\n                    lookup.add(new_unique_rolling_hash)\n                    result.append(str(i))\n                    dfs(k, new_unique_rolling_hash%M, lookup, result)\n                    break\n\n        unique_rolling_hash = 0\n        result = [str(0)]*(n-1)\n        lookup = set()\n        dfs(k, unique_rolling_hash, lookup, result)\n        return \"\".join(result)\n\n\n# Time:  O(n * k^n)\n# Space: O(n * k^n)\nclass Solution4(object):\n    def crackSafe(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        result = [str(k-1)]*(n-1)\n        lookup = set()\n        total = k**n\n        while len(lookup) < total:\n            node = result[len(result)-n+1:]\n            for i in xrange(k):  # preorder like traversal relative to initial result to avoid getting stuck, i.e. don't use k-1 until there is no other choice\n                neighbor = \"\".join(node) + str(i)\n                if neighbor not in lookup:\n                    lookup.add(neighbor)\n                    result.append(str(i))\n                    break\n        return \"\".join(result)\n\n\n# Time:  O(n * k^n)\n# Space: O(n * k^n)\nclass Solution5(object):\n    def crackSafe(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        def dfs(k, node, lookup, result):\n            for i in xrange(k):  # preorder like traversal relative to initial result to avoid getting stuck, i.e. don't use k-1 until there is no other choice\n                neighbor = node + str(i)\n                if neighbor not in lookup:\n                    lookup.add(neighbor)\n                    result.append(str(i))\n                    dfs(k, neighbor[1:], lookup, result)\n                    break\n\n        result = [str(k-1)]*(n-1)\n        lookup = set()\n        dfs(k, \"\".join(result), lookup, result)\n        return \"\".join(result)\n\n"
    },
    {
        "problem_name": "crawler-log-folder",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minOperations(self, logs):\n        \"\"\"\n        :type logs: List[str]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for log in logs:\n            if log == \"../\":\n                if result > 0:\n                    result -= 1\n            elif log != \"./\":\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "create-binary-tree-from-descriptions",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# tree\nclass Solution(object):\n    def createBinaryTree(self, descriptions):\n        \"\"\"\n        :type descriptions: List[List[int]]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        nodes = {}\n        children = set()\n        for p, c, l in descriptions:\n            parent = nodes.setdefault(p, TreeNode(p))\n            child = nodes.setdefault(c, TreeNode(c))\n            if l:\n                parent.left = child\n            else:\n                parent.right = child\n            children.add(c)\n        return nodes[next(p for p in nodes.iterkeys() if p not in children)]\n"
    },
    {
        "problem_name": "create-components-with-same-value",
        "solution": "# Time:  O(n * sqrt(n))\n# Space: O(n)\n\n# bfs, greedy\nclass Solution(object):\n    def componentValue(self, nums, edges):\n        \"\"\"\n        :type nums: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def bfs(target):\n            total = nums[:]\n            lookup = [len(adj[u]) for u in xrange(len(adj))]\n            q = [u for u in xrange(len(adj)) if lookup[u] == 1]\n            while q:\n                new_q = []\n                for u in q:\n                    if total[u] > target:\n                        return False\n                    if total[u] == target:\n                        total[u] = 0\n                    for v in adj[u]:\n                        total[v] += total[u]\n                        lookup[v] -= 1\n                        if lookup[v] == 1:\n                            new_q.append(v)\n                q = new_q\n            return True\n\n        result = 0\n        adj = [[] for _ in xrange(len(nums))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        total = sum(nums)\n        for cnt in reversed(xrange(2, len(nums)+1)):\n            if total%cnt == 0 and bfs(total//cnt):\n                return cnt-1\n        return 0\n\n\n# Time:  O(n * sqrt(n))\n# Space: O(n)\n# iterative dfs, greedy\nclass Solution2(object):\n    def componentValue(self, nums, edges):\n        \"\"\"\n        :type nums: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def iter_dfs(target):\n            total = nums[:]\n            stk = [(1, (0, -1))]\n            while stk:\n                step, (u, p) = stk.pop()\n                if step == 1:\n                    stk.append((2, (u, p)))\n                    for v in adj[u]:\n                        if v == p:\n                            continue\n                        stk.append((1, (v, u)))\n                elif step == 2:\n                    for v in adj[u]:\n                        if v == p:\n                            continue\n                        total[u] += total[v]\n                    if total[u] == target:\n                        total[u] = 0\n            return total[0]\n\n        result = 0\n        adj = [[] for _ in xrange(len(nums))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        total = sum(nums)\n        for cnt in reversed(xrange(2, len(nums)+1)):\n            if total%cnt == 0 and iter_dfs(total//cnt) == 0:\n                return cnt-1\n        return 0\n\n\n# Time:  O(n * sqrt(n))\n# Space: O(n)\n# dfs, greedy\nclass Solution3(object):\n    def componentValue(self, nums, edges):\n        \"\"\"\n        :type nums: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def dfs(u, p, target):\n            total = nums[u]\n            for v in adj[u]:\n                if v == p:\n                    continue\n                total += dfs(v, u, target)\n            return total if total != target else 0\n\n        result = 0\n        adj = [[] for _ in xrange(len(nums))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        total = sum(nums)\n        for cnt in reversed(xrange(2, len(nums)+1)):\n            if total%cnt == 0 and dfs(0, -1, total//cnt) == 0:\n                return cnt-1\n        return 0\n"
    },
    {
        "problem_name": "create-maximum-number",
        "solution": "# Time:  O(k * (m + n + k)) ~ O(k * (m + n + k^2))\n# Space: O(m + n + k^2)\n\nclass Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def get_max_digits(nums, start, end, max_digits):\n            max_digits[end] = max_digit(nums, end)\n            for i in reversed(xrange(start, end)):\n                max_digits[i] = delete_digit(max_digits[i + 1])\n\n        def max_digit(nums, k):\n            drop = len(nums) - k\n            res = []\n            for num in nums:\n                while drop and res and res[-1] < num:\n                    res.pop()\n                    drop -= 1\n                res.append(num)\n            return res[:k]\n\n        def delete_digit(nums):\n            res = list(nums)\n            for i in xrange(len(res)):\n                if i == len(res) - 1 or res[i] < res[i + 1]:\n                    res = res[:i] + res[i+1:]\n                    break\n            return res\n\n        def merge(a, b):\n            return [max(a, b).pop(0) for _ in xrange(len(a)+len(b))]\n\n        m, n = len(nums1), len(nums2)\n\n        max_digits1, max_digits2 = [[] for _ in xrange(k + 1)], [[] for _ in xrange(k + 1)]\n        get_max_digits(nums1, max(0, k - n), min(k, m), max_digits1)\n        get_max_digits(nums2, max(0, k - m), min(k, n), max_digits2)\n\n        return max(merge(max_digits1[i], max_digits2[k-i]) \\\n                   for i in xrange(max(0, k - n), min(k, m) + 1))\n\n"
    },
    {
        "problem_name": "create-sorted-array-through-instructions",
        "solution": "# Time:  O(nlogm)\n# Space: O(m)\n\nclass BIT(object):  # 0-indexed.\n    def __init__(self, n):\n        self.__bit = [0]*(n+1)  # Extra one for dummy node.\n\n    def add(self, i, val):\n        i += 1  # Extra one for dummy node.\n        while i < len(self.__bit):\n            self.__bit[i] += val\n            i += (i & -i)\n\n    def query(self, i):\n        i += 1  # Extra one for dummy node.\n        ret = 0\n        while i > 0:\n            ret += self.__bit[i]\n            i -= (i & -i)\n        return ret\n\nclass Solution(object):\n    def createSortedArray(self, instructions):\n        \"\"\"\n        :type instructions: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        bit = BIT(max(instructions))\n        result = 0\n        for i, inst in enumerate(instructions):\n            inst -= 1\n            result += min(bit.query(inst-1), i-bit.query(inst))\n            bit.add(inst, 1)\n        return result % MOD\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\nclass Solution_TLE(object):\n    def createSortedArray(self, instructions):\n        \"\"\"\n        :type instructions: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        def smallerMergeSort(idxs, start, end, counts):\n            if end - start <= 0:  # The size of range [start, end] less than 2 is always with count 0.\n                return 0\n\n            mid = start + (end - start) // 2\n            smallerMergeSort(idxs, start, mid, counts)\n            smallerMergeSort(idxs, mid + 1, end, counts)\n            r = start\n            tmp = []\n            for i in xrange(mid+1, end + 1):\n                # Merge the two sorted arrays into tmp.\n                while r <= mid and idxs[r][0] < idxs[i][0]:\n                    tmp.append(idxs[r])\n                    r += 1\n                tmp.append(idxs[i])\n                counts[idxs[i][1]] += r - start\n            while r <= mid:\n                tmp.append(idxs[r])\n                r += 1\n            # Copy tmp back to idxs\n            idxs[start:start+len(tmp)] = tmp\n        \n        def largerMergeSort(idxs, start, end, counts):\n            if end - start <= 0:  # The size of range [start, end] less than 2 is always with count 0.\n                return 0\n\n            mid = start + (end - start) // 2\n            largerMergeSort(idxs, start, mid, counts)\n            largerMergeSort(idxs, mid + 1, end, counts)\n            r = start\n            tmp = []\n            for i in xrange(mid+1, end + 1):\n                # Merge the two sorted arrays into tmp.\n                while r <= mid and idxs[r][0] <= idxs[i][0]:\n                    tmp.append(idxs[r])\n                    r += 1\n                if r <= mid:\n                    tmp.append(idxs[i])\n                counts[idxs[i][1]] += mid - r + 1\n            while r <= mid:\n                tmp.append(idxs[r])\n                r += 1\n            # Copy tmp back to idxs\n            idxs[start:start+len(tmp)] = tmp\n\n        idxs = []\n        smaller_counts, larger_counts = [[0] * len(instructions) for _ in xrange(2)]\n        for i, inst in enumerate(instructions):\n            idxs.append((inst, i))\n        smallerMergeSort(idxs[:], 0, len(idxs)-1, smaller_counts)\n        largerMergeSort(idxs, 0, len(idxs)-1, larger_counts)\n        return sum(min(s, l) for s, l in itertools.izip(smaller_counts, larger_counts)) % MOD\n"
    },
    {
        "problem_name": "create-target-array-in-the-given-order",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def createTargetArray(self, nums, index):\n        \"\"\"\n        :type nums: List[int]\n        :type index: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in xrange(len(nums)):\n            for j in xrange(i):\n                if index[j] >= index[i]:\n                    index[j] += 1\n        result = [0]*(len(nums))\n        for i in xrange(len(nums)):\n            result[index[i]] = nums[i]\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(1)\nimport itertools\n\n\nclass Solution2(object):\n    def createTargetArray(self, nums, index):\n        \"\"\"\n        :type nums: List[int]\n        :type index: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i, x in itertools.izip(index, nums):\n            result.insert(i, x)\n        return result\n\n"
    },
    {
        "problem_name": "critical-connections-in-a-network",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|V| + |E|)\n\n# variant of Tarjan's algorithm (https://www.geeksforgeeks.org/bridge-in-a-graph/)\nclass Solution(object):\n    def criticalConnections(self, n, connections):\n        \"\"\"\n        :type n: int\n        :type connections: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def dfs(edges, parent, u, idx, lowlinks, lookup, result):\n            if lookup[u]:\n                return  \n            lookup[u] = True\n            curr_idx = lowlinks[u] = idx[0]\n            idx[0] += 1\n            for v in edges[u]:\n                if v == parent:\n                    continue\n                dfs(edges, u, v, idx, lowlinks, lookup, result)\n                lowlinks[u] = min(lowlinks[u], lowlinks[v])\n                if lowlinks[v] > curr_idx:\n                    # if any lowlink of neighbors is larger than curr_idx\n                    result.append([u, v])\n        \n        edges = [[] for _ in xrange(n)]\n        idx, lowlinks, lookup = [0], [0]*n, [False]*n\n        result = []\n        for u, v in connections:\n            edges[u].append(v)\n            edges[v].append(u)\n        dfs(edges, -1, 0, idx, lowlinks, lookup, result)\n        return result\n"
    },
    {
        "problem_name": "custom-sort-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def customSortString(self, S, T):\n        \"\"\"\n        :type S: str\n        :type T: str\n        :rtype: str\n        \"\"\"\n        counter, s = collections.Counter(T), set(S)\n        result = [c*counter[c] for c in S]\n        result.extend([c*counter for c, counter in counter.iteritems() if c not in s])\n        return \"\".join(result)\n\n"
    },
    {
        "problem_name": "cut-off-trees-for-golf-event",
        "solution": "# Time:  O(t * (logt + m * n)), t is the number of trees\n# Space: O(t + m * n)\n\nimport collections\nimport heapq\n\n\nclass Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def dot(p1, p2):\n            return p1[0]*p2[0]+p1[1]*p2[1]\n\n        def minStep(p1, p2):\n            min_steps = abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n            closer, detour = [p1], []\n            lookup = set()\n            while True:\n                if not closer:  # cannot find a path in the closer expansions\n                    if not detour:  # no other possible path\n                        return -1\n                    # try other possible paths in detour expansions with extra 2-step cost\n                    min_steps += 2\n                    closer, detour = detour, closer\n                i, j = closer.pop()\n                if (i, j) == p2:\n                    return min_steps\n                if (i, j) not in lookup:\n                    lookup.add((i, j))\n                    for I, J in (i+1, j), (i-1, j), (i, j+1), (i, j-1):\n                        if 0 <= I < m and 0 <= J < n and forest[I][J] and (I, J) not in lookup:\n                            is_closer = dot((I-i, J-j), (p2[0]-i, p2[1]-j)) > 0\n                            (closer if is_closer else detour).append((I, J))\n            return min_steps\n\n        m, n = len(forest), len(forest[0])\n        min_heap = []\n        for i in xrange(m):\n            for j in xrange(n):\n                if forest[i][j] > 1:\n                    heapq.heappush(min_heap, (forest[i][j], (i, j)))\n\n        start = (0, 0)\n        result = 0\n        while min_heap:\n            tree = heapq.heappop(min_heap)\n            step = minStep(start, tree[1])\n            if step < 0:\n                return -1\n            result += step\n            start = tree[1]\n        return result\n\n\n# Time:  O(t * (logt + m * n)), t is the number of trees\n# Space: O(t + m * n)\nclass Solution_TLE(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def minStep(p1, p2):\n            min_steps = 0\n            lookup = {p1}\n            q = collections.deque([p1])\n            while q:\n                size = len(q)\n                for _ in xrange(size):\n                    (i, j) = q.popleft()\n                    if (i, j) == p2:\n                        return min_steps\n                    for i, j in (i+1, j), (i-1, j), (i, j+1), (i, j-1):\n                        if not (0 <= i < m and 0 <= j < n and forest[i][j] and (i, j) not in lookup):\n                            continue\n                        q.append((i, j))\n                        lookup.add((i, j))\n                min_steps += 1\n            return -1\n\n        m, n = len(forest), len(forest[0])\n        min_heap = []\n        for i in xrange(m):\n            for j in xrange(n):\n                if forest[i][j] > 1:\n                    heapq.heappush(min_heap, (forest[i][j], (i, j)))\n\n        start = (0, 0)\n        result = 0\n        while min_heap:\n            tree = heapq.heappop(min_heap)\n            step = minStep(start, tree[1])\n            if step < 0:\n                return -1\n            result += step\n            start = tree[1]\n        return result\n\n"
    },
    {
        "problem_name": "cutting-ribbons",
        "solution": "# Time:  O(nlogr), r is sum(ribbons)/k\n# Space: O(1)\n\nclass Solution(object):\n    def maxLength(self, ribbons, k):\n        \"\"\"\n        :type ribbons: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(ribbons, k, s):\n            return reduce(lambda total,x: total+x//s, ribbons, 0) >= k\n\n        left, right = 1, sum(ribbons)//k\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(ribbons, k, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "cycle-length-queries-in-a-tree",
        "solution": "# Time:  O(q * n)\n# Space: O(1)\n\n# tree, lca\nclass Solution(object):\n    def cycleLengthQueries(self, n, queries):\n        \"\"\"\n        :type n: int\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for x, y in queries:\n            cnt = 1\n            while x != y:\n                if x > y:\n                    x, y = y, x\n                y //= 2\n                cnt += 1\n            result.append(cnt)\n        return result\n"
    },
    {
        "problem_name": "cyclically-rotating-a-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nimport fractions\n\n\n# inplace rotation\nclass Solution(object):\n    def rotateGrid(self, grid, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def get_index(m, n, l):\n            if l < m-1:\n                return l, 0\n            if l < (m-1)+(n-1):\n                return m-1, l-(m-1)\n            if l < (m-1)+(n-1)+(m-1):\n                return (m-1)-(l-((m-1)+(n-1))), n-1\n            return 0, (n-1)-(l-((m-1)+(n-1)+(m-1)))\n\n        m, n = len(grid), len(grid[0])\n        for i in xrange(min(m, n)//2):\n            total = 2*((m-1)+(n-1))\n            nk = k%total\n            num_cycles = fractions.gcd(total, nk)\n            cycle_len = total//num_cycles\n            for offset in xrange(num_cycles):\n                r, c = get_index(m, n, offset)\n                for j in xrange(1, cycle_len):\n                    nr, nc = get_index(m, n, (offset+j*nk)%total)\n                    grid[i+nr][i+nc], grid[i+r][i+c] = grid[i+r][i+c], grid[i+nr][i+nc]\n            m, n = m-2, n-2\n        return grid\n\n\n# Time:  O(m * n)\n# Space: O(1)\n# inplace rotation\nclass Solution2(object):\n    def rotateGrid(self, grid, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def get_index(m, n, l):\n            if l < m-1:\n                return l, 0\n            if l < (m-1)+(n-1):\n                return m-1, l-(m-1)\n            if l < (m-1)+(n-1)+(m-1):\n                return (m-1)-(l-((m-1)+(n-1))), n-1\n            return 0, (n-1)-(l-((m-1)+(n-1)+(m-1)))\n\n        def reverse(grid, m, n, i, left, right):\n            while left < right:\n                lr, lc = get_index(m, n, left)\n                rr, rc = get_index(m, n, right)\n                grid[i+lr][i+lc], grid[i+rr][i+rc] = grid[i+rr][i+rc], grid[i+lr][i+lc]\n                left += 1\n                right -= 1\n\n        m, n = len(grid), len(grid[0])\n        for i in xrange(min(m, n)//2):\n            total = 2*((m-1)+(n-1))\n            nk = k%total\n            reverse(grid, m, n, i, 0, total-1)\n            reverse(grid, m, n, i, 0, nk-1)\n            reverse(grid, m, n, i, nk, total-1)\n            m, n = m-2, n-2\n        return grid\n"
    },
    {
        "problem_name": "daily-temperatures",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def dailyTemperatures(self, temperatures):\n        \"\"\"\n        :type temperatures: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * len(temperatures)\n        stk = []\n        for i in xrange(len(temperatures)):\n            while stk and \\\n                  temperatures[stk[-1]] < temperatures[i]:\n                idx = stk.pop()\n                result[idx] = i-idx\n            stk.append(i)\n        return result\n\n"
    },
    {
        "problem_name": "data-stream-as-disjoint-intervals",
        "solution": "# Time:  addNum: O(n), getIntervals: O(n), n is the number of disjoint intervals.\n# Space: O(n)\n\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass SummaryRanges(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__intervals = []\n\n    def addNum(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: void\n        \"\"\"\n        def upper_bound(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) / 2\n                if nums[mid].start > target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n\n        i = upper_bound(self.__intervals, val)\n        start, end = val, val\n        if i != 0 and self.__intervals[i-1].end + 1 >= val:\n            i -= 1\n        while i != len(self.__intervals) and \\\n              end + 1 >= self.__intervals[i].start:\n            start = min(start, self.__intervals[i].start)\n            end = max(end, self.__intervals[i].end)\n            del self.__intervals[i]\n        self.__intervals.insert(i, Interval(start, end))\n\n    def getIntervals(self):\n        \"\"\"\n        :rtype: List[Interval]\n        \"\"\"\n        return self.__intervals\n\n\n\n"
    },
    {
        "problem_name": "day-of-the-week",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def dayOfTheWeek(self, day, month, year):\n        \"\"\"\n        :type day: int\n        :type month: int\n        :type year: int\n        :rtype: str\n        \"\"\"\n        DAYS = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \\\n                \"Thursday\", \"Friday\", \"Saturday\"]\n\n        # Zeller Formula\n        if month < 3:\n            month += 12\n            year -= 1\n        c, y = divmod(year, 100)\n        w = (c//4 - 2*c + y + y//4 + 13*(month+1)//5 + day - 1) % 7\n        return DAYS[w]\n"
    },
    {
        "problem_name": "day-of-the-year",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def __init__(self):\n        def dayOfMonth(M):\n            return (28 if (M == 2) else 31-(M-1)%7%2)\n\n        self.__lookup = [0]*12\n        for M in xrange(1, len(self.__lookup)):\n            self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M)\n            \n    def dayOfYear(self, date):\n        \"\"\"\n        :type date: str\n        :rtype: int\n        \"\"\"\n        Y, M, D = map(int, date.split(\"-\"))\n        leap = 1 if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0\n        return self.__lookup[M-1]+D+leap\n\n\n# Time:  O(1)\n# Space: O(1)\nclass Solution2(object):\n    def dayOfYear(self, date):\n        \"\"\"\n        :type date: str\n        :rtype: int\n        \"\"\"\n        def numberOfDays(Y, M):\n            leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0\n            return (28+leap if (M == 2) else 31-(M-1)%7%2)\n\n        Y, M, result = map(int, date.split(\"-\"))\n        for i in xrange(1, M):\n            result += numberOfDays(Y, i)\n        return result\n"
    },
    {
        "problem_name": "decode-string",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n, curr, nums, strs = 0, [], [], []\n        for c in s:\n            if c.isdigit():\n                n = n*10 + ord(c)-ord('0')\n            elif c.isalpha():\n                curr.append(c)\n            elif c == '[':\n                nums.append(n)\n                strs.append(curr)\n                n, curr = 0, []\n            elif c == ']':\n                strs[-1].extend(curr*nums.pop())\n                curr = strs.pop()\n        return \"\".join(curr)\n"
    },
    {
        "problem_name": "decode-the-message",
        "solution": "# Time:  O(n + m)\n# Space: O(1)\n\nimport itertools\n\n\n# string, hash table\nclass Solution(object):\n    def decodeMessage(self, key, message):\n        \"\"\"\n        :type key: str\n        :type message: str\n        :rtype: str\n        \"\"\"\n        f = lambda x: ord(x)-ord('a')\n        lookup = [-1]*26\n        i = 0\n        for x in itertools.imap(f, key):\n            if x < 0 or lookup[x] != -1:\n                continue\n            lookup[x] = i\n            i += 1\n        return \"\".join(itertools.imap(lambda x: chr(ord('a')+x), (lookup[x] if x >= 0 else x for x in itertools.imap(f, message))))\n    \n"
    },
    {
        "problem_name": "decode-the-slanted-ciphertext",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def decodeCiphertext(self, encodedText, rows):\n        \"\"\"\n        :type encodedText: str\n        :type rows: int\n        :rtype: str\n        \"\"\"\n        cols = len(encodedText)//rows\n        k = len(encodedText)\n        for i in reversed(xrange(cols)):\n            for j in reversed(xrange(i, len(encodedText), cols+1)):\n                if encodedText[j] != ' ':\n                    k = j\n                    break\n            else:\n                continue\n            break\n        result = []\n        for i in xrange(cols):\n            for j in xrange(i, len(encodedText), cols+1):\n                result.append(encodedText[j])\n                if j == k:\n                    break\n            else:\n                continue\n            break\n        return \"\".join(result)\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def decodeCiphertext(self, encodedText, rows):\n        \"\"\"\n        :type encodedText: str\n        :type rows: int\n        :rtype: str\n        \"\"\"\n        cols = len(encodedText)//rows\n        result = []\n        for i in xrange(cols):\n            for j in xrange(i, len(encodedText), cols+1):\n                result.append(encodedText[j])\n        while result and result[-1] == ' ':\n            result.pop()\n        return \"\".join(result)\n\n"
    },
    {
        "problem_name": "decode-ways-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        M, W = 1000000007, 3\n        dp = [0] * W\n        dp[0] = 1\n        dp[1] = 9 if s[0] == '*' else dp[0] if s[0] != '0' else 0\n        for i in xrange(1, len(s)):\n            if s[i] == '*':\n                dp[(i + 1) % W] = 9 * dp[i % W]\n                if s[i - 1] == '1':\n                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 9 * dp[(i - 1) % W]) % M\n                elif s[i - 1] == '2':\n                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 6 * dp[(i - 1) % W]) % M\n                elif s[i - 1] == '*':\n                    dp[(i + 1) % W] = (dp[(i + 1) % W] + 15 * dp[(i - 1) % W]) % M\n            else:\n                dp[(i + 1) % W] = dp[i % W] if s[i] != '0' else 0\n                if s[i - 1] == '1':\n                    dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M\n                elif s[i - 1] == '2' and s[i] <= '6':\n                    dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M\n                elif s[i - 1] == '*':\n                    dp[(i + 1) % W] = (dp[(i + 1) % W] + (2 if s[i] <= '6' else 1) * dp[(i - 1) % W]) % M\n        return dp[len(s) % W]\n\n"
    },
    {
        "problem_name": "decode-ways",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if len(s) == 0 or s[0] == '0':\n            return 0\n        prev, prev_prev = 1, 0\n        for i in xrange(len(s)):\n            cur = 0\n            if s[i] != '0':\n                cur = prev\n            if i > 0 and (s[i - 1] == '1' or (s[i - 1] == '2' and s[i] <= '6')):\n                cur += prev_prev\n            prev, prev_prev = cur, prev\n        return prev\n\n\n"
    },
    {
        "problem_name": "decode-xored-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def decode(self, encoded, first):\n        \"\"\"\n        :type encoded: List[int]\n        :type first: int\n        :rtype: List[int]\n        \"\"\"\n        result = [first]\n        for x in encoded:\n            result.append(result[-1]^x)\n        return result\n"
    },
    {
        "problem_name": "decode-xored-permutation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def decode(self, encoded):\n        \"\"\"\n        :type encoded: List[int]\n        :rtype: List[int]\n        \"\"\"\n        curr = 0\n        for i in xrange(1, (len(encoded)+1) + 1):\n            curr ^= i\n            if i < len(encoded) and i%2 == 1:\n                curr ^= encoded[i]\n        result = [curr]\n        for x in encoded:\n            result.append(result[-1]^x)\n        return result\n"
    },
    {
        "problem_name": "decoded-string-at-index",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def decodeAtIndex(self, S, K):\n        \"\"\"\n        :type S: str\n        :type K: int\n        :rtype: str\n        \"\"\"\n        i = 0\n        for c in S:\n            if c.isdigit():\n                i *= int(c)\n            else:\n                i += 1\n\n        for c in reversed(S):\n            K %= i\n            if K == 0 and c.isalpha():\n                return c\n\n            if c.isdigit():\n                i /= int(c)\n            else:\n                i -= 1\n\n"
    },
    {
        "problem_name": "decompress-run-length-encoded-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def decompressRLElist(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [nums[i+1] for i in xrange(0, len(nums), 2) for _ in xrange(nums[i])]\n"
    },
    {
        "problem_name": "decrease-elements-to-make-array-zigzag",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def movesToMakeZigzag(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = [0, 0]\n        for i in xrange(len(nums)):\n            left = nums[i-1] if i-1 >= 0 else float(\"inf\")\n            right = nums[i+1] if i+1 < len(nums) else float(\"inf\")\n            result[i%2] += max(nums[i] - min(left, right) + 1, 0)\n        return min(result)\n"
    },
    {
        "problem_name": "decremental-string-concatenation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def minimizeConcatenatedLength(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        dp = [[float(\"-inf\")]*26 for _ in xrange(2)]\n        dp[0][ord(words[0][-1])-ord('a')] = dp[1][ord(words[0][0])-ord('a')] = 0\n        for i in xrange(1, len(words)):\n            new_dp = [[float(\"-inf\")]*26 for _ in xrange(2)]\n            for right in xrange(2):\n                for c in xrange(26):\n                    if dp[right][c] == float(\"-inf\"):\n                        continue\n                    l = c if right else ord(words[i-1][0])-ord('a')\n                    r = c if not right else ord(words[i-1][-1])-ord('a')\n                    new_dp[0][r] = max(new_dp[0][r], dp[right][c]+int(ord(words[i][-1])-ord('a') == l))\n                    new_dp[1][l] = max(new_dp[1][l], dp[right][c]+int(r == ord(words[i][0])-ord('a')))\n            dp = new_dp\n        return sum(len(w) for w in words)-max(dp[right][c] for right in xrange(2) for c in xrange(26))\n"
    },
    {
        "problem_name": "decrypt-string-from-alphabet-to-integer-mapping",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# forward solution\nclass Solution(object):\n    def freqAlphabets(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def alpha(num):\n            return chr(ord('a') + int(num)-1)\n\n        i = 0\n        result = []\n        while i < len(s):\n            if i+2 < len(s) and s[i+2] == '#':\n                result.append(alpha(s[i:i+2]))\n                i += 3\n            else:\n                result.append(alpha(s[i]))\n                i += 1\n        return \"\".join(result)\n\n\n# Time:  O(n)\n# Space: O(1)\n# backward solution\nclass Solution2(object):\n    def freqAlphabets(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def alpha(num):\n            return chr(ord('a') + int(num)-1)\n\n        i = len(s)-1\n        result = []\n        while i >= 0:\n            if s[i] == '#':\n                result.append(alpha(s[i-2:i]))\n                i -= 3\n            else:\n                result.append(alpha(s[i]))\n                i -= 1\n        return \"\".join(reversed(result))\n\n# Time:  O(n)\n# Space: O(1)\nimport re\n\n\n# regex solution\nclass Solution3(object):\n    def freqAlphabets(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def alpha(num):\n            return chr(ord('a') + int(num)-1)\n\n        return \"\".join(alpha(i[:2]) for i in re.findall(r\"\\d\\d#|\\d\", s))\n"
    },
    {
        "problem_name": "deepest-leaves-sum",
        "solution": "# Time:  O(n)\n# Space: O(w)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def deepestLeavesSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        curr = [root]\n        while curr:\n            prev, curr = curr, [child for p in curr for child in [p.left, p.right] if child]\n        return sum(node.val for node in prev)\n"
    },
    {
        "problem_name": "defanging-an-ip-address",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def defangIPaddr(self, address):\n        \"\"\"\n        :type address: str\n        :rtype: str\n        \"\"\"\n        result = []\n        for c in address:\n            if c == '.':\n                result.append(\"[.]\")\n            else:\n                result.append(c)\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "defuse-the-bomb",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def decrypt(self, code, k):\n        \"\"\"\n        :type code: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(code)\n        if k == 0:\n            return result\n        left, right = 1, k\n        if k < 0:\n            k = -k\n            left, right = len(code)-k, len(code)-1\n        total = sum(code[i] for i in xrange(left, right+1))\n        for i in xrange(len(code)):\n            result[i] = total\n            total -= code[left%len(code)]\n            total += code[(right+1)%len(code)]\n            left += 1\n            right += 1\n        return result\n"
    },
    {
        "problem_name": "degree-of-an-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def findShortestSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        counts = collections.Counter(nums)\n        left, right = {}, {}\n        for i, num in enumerate(nums):\n            left.setdefault(num, i)\n            right[num] = i\n        degree = max(counts.values())\n        return min(right[num]-left[num]+1 \\\n                   for num in counts.keys() \\\n                   if counts[num] == degree)\n\n"
    },
    {
        "problem_name": "delete-and-earn",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def deleteAndEarn(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        vals = [0] * 10001\n        for num in nums:\n            vals[num] += num\n        val_i, val_i_1 = vals[0], 0\n        for i in xrange(1, len(vals)):\n            val_i_1, val_i_2 = val_i, val_i_1\n            val_i = max(vals[i] + val_i_2, val_i_1)\n        return val_i\n\n"
    },
    {
        "problem_name": "delete-characters-to-make-fancy-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# inplace solution\nclass Solution(object):\n    def makeFancyString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        s = list(s)\n        cnt = j = 0\n        for i, c in enumerate(s):\n            cnt = cnt+1 if i >= 1 and c == s[i-1] else 1\n            if cnt < 3:\n                s[j] = c\n                j += 1\n        s[:] = s[:j]\n        return \"\".join(s)\n"
    },
    {
        "problem_name": "delete-columns-to-make-sorted-ii",
        "solution": "# Time:  O(n * l)\n# Space: O(n)\n\nclass Solution(object):\n    def minDeletionSize(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: int\n        \"\"\"\n        result = 0\n        unsorted = set(range(len(A)-1))\n        for j in xrange(len(A[0])):\n            if any(A[i][j] > A[i+1][j] for i in unsorted):\n                result += 1\n            else:\n                unsorted -= set(i for i in unsorted if A[i][j] < A[i+1][j])\n        return result\n\n\n# Time:  O(n * m)\n# Space: O(n)\nclass Solution2(object):\n    def minDeletionSize(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: int\n        \"\"\"\n        result = 0\n        is_sorted = [False]*(len(A)-1)\n        for j in xrange(len(A[0])):\n            tmp = is_sorted[:]\n            for i in xrange(len(A)-1):\n                if A[i][j] > A[i+1][j] and tmp[i] == False:\n                    result += 1\n                    break\n                if A[i][j] < A[i+1][j]:\n                    tmp[i] = True\n            else:\n                is_sorted = tmp\n        return result\n"
    },
    {
        "problem_name": "delete-columns-to-make-sorted-iii",
        "solution": "# Time:  O(n * l^2)\n# Space: O(l)\n\nclass Solution(object):\n    def minDeletionSize(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: int\n        \"\"\"\n        dp = [1] * len(A[0])\n        for j in xrange(1, len(A[0])):\n            for i in xrange(j):\n                if all(A[k][i] <= A[k][j] for k in xrange(len(A))):\n                    dp[j] = max(dp[j], dp[i]+1)\n        return len(A[0]) - max(dp)\n"
    },
    {
        "problem_name": "delete-columns-to-make-sorted",
        "solution": "# Time:  O(n * l)\n# Space: O(1)\n\nclass Solution(object):\n    def minDeletionSize(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for c in xrange(len(A[0])):\n            for r in xrange(1, len(A)):\n                if A[r-1][c] > A[r][c]:\n                    result += 1\n                    break\n        return result\n\n\n# Time:  O(n * l)\n# Space: O(n)\nimport itertools\n\n\nclass Solution2(object):\n    def minDeletionSize(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for col in itertools.izip(*A):\n            if any(col[i] > col[i+1] for i in xrange(len(col)-1)):\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "delete-duplicate-folders-in-system",
        "solution": "# Time:  O(n * m * l + tlogt + l * t), m is the max number of folders in a path,\n#                                    , n is the number of paths\n#                                    , l is the max length of folder name\n#                                    , t is the size of trie\n# Space: O(l * t)\n\nimport collections\n\n\nclass Solution(object):\n    def deleteDuplicateFolder(self, paths):\n        \"\"\"\n        :type paths: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n        def mark(node, lookup, node_ids):\n            id_pairs = []\n            for subfolder_id, child in node.iteritems():\n                if child == \"_del\":\n                    continue\n                id_pairs.append((subfolder_id, mark(child, lookup, node_ids)))\n            id_pairs.sort()\n            node_id = node_ids[tuple(id_pairs)]\n            if node_id:\n                if node_id in lookup:\n                    lookup[node_id][\"_del\"]\n                    node[\"_del\"]\n                else:\n                    lookup[node_id] = node\n            return node_id\n\n        def sweep(node, id_folders, path, result):\n            if path:\n                result.append([id_folders[i] for i in path])\n            for subfolder_id, child in node.iteritems():\n                if \"_del\" in child:\n                    continue\n                path.append(subfolder_id)\n                sweep(child, id_folders, path, result)\n                path.pop()\n\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        folder_ids = collections.defaultdict()\n        folder_ids.default_factory = folder_ids.__len__\n        id_folders = {}\n        for path in paths:\n            node = trie\n            for folder in path:\n                if folder_ids[folder] not in id_folders:\n                    id_folders[folder_ids[folder]] = folder\n                node = node[folder_ids[folder]]\n        node_ids = collections.defaultdict()\n        node_ids.default_factory = node_ids.__len__\n        mark(trie, {}, node_ids)\n        result = []\n        sweep(trie, id_folders, [], result)\n        return result\n\n\n# Time:  O(n * m * l + l * tlogt + l * t^2), m is the max number of folders in a path,\n#                                          , n is the number of paths\n#                                          , l is the max length of folder name\n#                                          , t is the size of trie\n# Space: O(l * t^2)\nimport collections\n\n\nclass Solution2(object):\n    def deleteDuplicateFolder(self, paths):\n        \"\"\"\n        :type paths: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n        def mark(node, lookup):\n            serialized_tree = \"(\" + \"\".join(subfolder + mark(child, lookup) for subfolder, child in sorted(node.iteritems()) if child != \"_del\") + \")\"\n            if serialized_tree != \"()\":\n                if serialized_tree in lookup:\n                    lookup[serialized_tree][\"_del\"]\n                    node[\"_del\"]\n                else:\n                    lookup[serialized_tree] = node\n            return serialized_tree\n        \n        def sweep(node, path, result):\n            if path:\n                result.append(path[:])\n            for subfolder, child in node.iteritems():\n                if \"_del\" in child:\n                    continue\n                path.append(subfolder)\n                sweep(child, path, result)\n                path.pop()\n\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        for path in paths:\n            reduce(dict.__getitem__, path, trie)\n        mark(trie, {})\n        result = []\n        sweep(trie, [], result)\n        return result\n"
    },
    {
        "problem_name": "delete-greatest-value-in-each-row",
        "solution": "# Time:  O(m * nlogn)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def deleteGreatestValue(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for row in grid:\n            row.sort()\n        return sum(max(grid[i][j] for i in xrange(len(grid))) for j in xrange(len(grid[0])))\n"
    },
    {
        "problem_name": "delete-leaves-with-a-given-value",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def removeLeafNodes(self, root, target):\n        \"\"\"\n        :type root: TreeNode\n        :type target: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n        root.left = self.removeLeafNodes(root.left, target)\n        root.right = self.removeLeafNodes(root.right, target)\n        return None if root.left == root.right and root.val == target else root\n"
    },
    {
        "problem_name": "delete-n-nodes-after-m-nodes-of-a-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution(object):\n    def deleteNodes(self, head, m, n):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        head = dummy = ListNode(next=head)\n        while head:\n            for _ in xrange(m):\n                if not head.next:\n                    return dummy.next\n                head = head.next\n            prev = head\n            for _ in xrange(n):\n                if not head.next:\n                    prev.next = None\n                    return dummy.next\n                head = head.next\n            prev.next = head.next\n        return dummy.next\n"
    },
    {
        "problem_name": "delete-node-in-a-bst",
        "solution": "# Time:  O(h)\n# Space: O(h)\n\nclass Solution(object):\n    def deleteNode(self, root, key):\n        \"\"\"\n        :type root: TreeNode\n        :type key: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return root\n\n        if root.val > key:\n            root.left = self.deleteNode(root.left, key)\n        elif root.val < key:\n            root.right = self.deleteNode(root.right, key)\n        else:\n            if not root.left:\n                right = root.right\n                del root\n                return right\n            elif not root.right:\n                left = root.left\n                del root\n                return left\n            else:\n                successor = root.right\n                while successor.left:\n                    successor = successor.left\n\n                root.val = successor.val\n                root.right = self.deleteNode(root.right, successor.val)\n\n        return root\n\n"
    },
    {
        "problem_name": "delete-node-in-a-linked-list",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {ListNode} node\n    # @return {void} Do not return anything, modify node in-place instead.\n    def deleteNode(self, node):\n        if node and node.next:\n            node_to_delete = node.next\n            node.val = node_to_delete.val\n            node.next = node_to_delete.next\n            del node_to_delete\n\n"
    },
    {
        "problem_name": "delete-nodes-and-return-forest",
        "solution": "# Time:  O(n)\n# Space: O(h + d), d is the number of to_delete\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n        \nclass Solution(object):\n    def delNodes(self, root, to_delete):\n        \"\"\"\n        :type root: TreeNode\n        :type to_delete: List[int]\n        :rtype: List[TreeNode]\n        \"\"\"\n        def delNodesHelper(to_delete_set, root, is_root, result):\n            if not root:\n                return None\n            is_deleted = root.val in to_delete_set\n            if is_root and not is_deleted:\n                result.append(root)\n            root.left = delNodesHelper(to_delete_set, root.left, is_deleted, result)\n            root.right = delNodesHelper(to_delete_set, root.right, is_deleted, result)\n            return None if is_deleted else root\n        \n        result = []\n        to_delete_set = set(to_delete)\n        delNodesHelper(to_delete_set, root, True, result)\n        return result\n"
    },
    {
        "problem_name": "delete-operation-for-two-strings",
        "solution": "# Time:  O(m * n)\n# Space: O(n)\n\nclass Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n+1) for _ in xrange(2)]\n        for i in xrange(m):\n            for j in xrange(n):\n                dp[(i+1)%2][j+1] = max(dp[i%2][j+1], \\\n                                       dp[(i+1)%2][j], \\\n                                       dp[i%2][j] + (word1[i] == word2[j]))\n        return m + n - 2*dp[m%2][n]\n\n"
    },
    {
        "problem_name": "delete-the-middle-node-of-a-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution(object):\n    def deleteMiddle(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        dummy = ListNode()\n        dummy.next = head\n        slow = fast = dummy\n        while fast.next and fast.next.next:\n            slow, fast = slow.next, fast.next.next\n        slow.next = slow.next.next\n        return dummy.next\n"
    },
    {
        "problem_name": "delete-tree-nodes",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def deleteTreeNodes(self, nodes, parent, value):\n        \"\"\"\n        :type nodes: int\n        :type parent: List[int]\n        :type value: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(value, children, x):\n            total, count = value[x], 1\n            for y in children[x]:\n                t, c = dfs(value, children, y)\n                total += t\n                count += c if t else 0\n            return total, count if total else 0\n\n        children = collections.defaultdict(list)\n        for i, p in enumerate(parent):\n            if i:\n                children[p].append(i)\n        return dfs(value, children, 0)[1]\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def deleteTreeNodes(self, nodes, parent, value):\n        \"\"\"\n        :type nodes: int\n        :type parent: List[int]\n        :type value: List[int]\n        :rtype: int\n        \"\"\"\n        # assuming parent[i] < i for all i > 0\n        result = [1]*nodes\n        for i in reversed(xrange(1, nodes)):\n            value[parent[i]] += value[i]\n            result[parent[i]] += result[i] if value[i] else 0\n        return result[0]\n"
    },
    {
        "problem_name": "delivering-boxes-from-storage-to-ports",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight):\n        \"\"\"\n        :type boxes: List[List[int]]\n        :type portsCount: int\n        :type maxBoxes: int\n        :type maxWeight: int\n        :rtype: int\n        \"\"\"\n        dp = [0]*(len(boxes)+1)\n        left, cost, curr = 0, 1, 0\n        for right in xrange(len(boxes)):\n            if right == 0 or boxes[right][0] != boxes[right-1][0]:\n                cost += 1\n            curr += boxes[right][1]\n            while right-left+1 > maxBoxes or \\\n                  curr > maxWeight or \\\n                  (left+1 < right+1 and dp[left+1] == dp[left]):  # greedily drop box to make cost as smaller as possible\n                curr -= boxes[left][1]\n                if boxes[left+1][0] != boxes[left][0]:\n                    cost -= 1\n                left += 1\n            dp[right+1] = dp[(left-1)+1] + cost\n        return dp[len(boxes)]\n"
    },
    {
        "problem_name": "depth-of-bst-given-insertion-order",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport sortedcontainers\n\n\nclass Solution(object):\n    def maxDepthBST(self, order):\n        \"\"\"\n        :type order: List[int]\n        :rtype: int\n        \"\"\"\n        depths = sortedcontainers.SortedDict({float(\"-inf\"):0, float(\"inf\"):0})\n        values_view = depths.values()\n        result = 0\n        for x in order:\n            i = depths.bisect_right(x)\n            depths[x] = max(values_view[i-1:i+1])+1\n            result = max(result, depths[x])\n        return result\n"
    },
    {
        "problem_name": "describe-the-painting",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def splitPainting(self, segments):\n        \"\"\"\n        :type segments: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        counts = collections.defaultdict(int)\n        for s, e, c in segments:\n            counts[s] += c\n            counts[e] -= c\n        points = sorted(x for x in counts.iteritems())\n\n        result = []\n        overlap = prev = 0\n        for curr, cnt in points:\n            if overlap:\n                result.append([prev, curr, overlap])\n            overlap += cnt\n            prev = curr\n        return result\n"
    },
    {
        "problem_name": "design-a-file-sharing-system",
        "solution": "# Time:  ctor:    O(1)\n#        join:    O(logu + c), u is the number of total joined users\n#        leave:   O(logu + c), c is the number of chunks\n#        request: O(u)\n# Space: O(u * c)\n\nimport heapq\n\n\n# \"u ~= n\" solution, n is the average number of users who own the chunk\nclass FileSharing(object):\n\n    def __init__(self, m):\n        \"\"\"\n        :type m: int\n        \"\"\"\n        self.__users = []\n        self.__lookup = set()\n        self.__min_heap = []\n\n    def join(self, ownedChunks):\n        \"\"\"\n        :type ownedChunks: List[int]\n        :rtype: int\n        \"\"\"\n        if self.__min_heap:\n            userID = heapq.heappop(self.__min_heap)\n        else:\n            userID = len(self.__users)+1\n            self.__users.append(set())\n        self.__users[userID-1] = set(ownedChunks)\n        self.__lookup.add(userID)\n        return userID\n\n    def leave(self, userID):\n        \"\"\"\n        :type userID: int\n        :rtype: None\n        \"\"\"\n        if userID not in self.__lookup:\n            return\n        self.__lookup.remove(userID)\n        self.__users[userID-1] = []\n        heapq.heappush(self.__min_heap, userID)\n\n    def request(self, userID, chunkID):\n        \"\"\"\n        :type userID: int\n        :type chunkID: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for u, chunks in enumerate(self.__users, 1):\n            if chunkID not in chunks:\n                continue\n            result.append(u)\n        if not result:\n            return\n        self.__users[userID-1].add(chunkID)\n        return result\n\n\n# Time:  ctor:    O(1)\n#        join:    O(logu + c), u is the number of total joined users\n#        leave:   O(logu + c), c is the number of chunks\n#        request: O(nlogn)   , n is the average number of users who own the chunk\n# Space: O(u * c + m), m is the total number of unique chunks\nimport collections\nimport heapq\n\n\n# \"u >> n\" solution\nclass FileSharing2(object):\n\n    def __init__(self, m):\n        \"\"\"\n        :type m: int\n        \"\"\"\n        self.__users = []\n        self.__lookup = set() \n        self.__chunks = collections.defaultdict(set)\n        self.__min_heap = []\n\n    def join(self, ownedChunks):\n        \"\"\"\n        :type ownedChunks: List[int]\n        :rtype: int\n        \"\"\"\n        if self.__min_heap:\n            userID = heapq.heappop(self.__min_heap)\n        else:\n            userID = len(self.__users)+1\n            self.__users.append(set())\n        self.__users[userID-1] = set(ownedChunks)\n        self.__lookup.add(userID)\n        for c in ownedChunks:\n            self.__chunks[c].add(userID)\n        return userID\n\n    def leave(self, userID):\n        \"\"\"\n        :type userID: int\n        :rtype: None\n        \"\"\"\n        if userID not in self.__lookup:\n            return\n        for c in self.__users[userID-1]:\n            self.__chunks[c].remove(userID)\n        self.__lookup.remove(userID)\n        self.__users[userID-1] = []\n        heapq.heappush(self.__min_heap, userID)\n\n    def request(self, userID, chunkID):\n        \"\"\"\n        :type userID: int\n        :type chunkID: int\n        :rtype: List[int]\n        \"\"\"\n        result = sorted(self.__chunks[chunkID])\n        if not result:\n            return\n        self.__users[userID-1].add(chunkID)\n        self.__chunks[chunkID].add(userID)\n        return result\n"
    },
    {
        "problem_name": "design-a-food-rating-system",
        "solution": "# Time:  ctor:         O(nlogn)\n#        changeRating: O(logn)\n#        highestRated: O(1)\n# Space: O(n)\n\nimport collections\nimport itertools\nfrom sortedcontainers import SortedList\n\n\n# sorted list\nclass FoodRatings(object):\n\n    def __init__(self, foods, cuisines, ratings):\n        \"\"\"\n        :type foods: List[str]\n        :type cuisines: List[str]\n        :type ratings: List[int]\n        \"\"\"\n        self.__food_to_cuisine = {}\n        self.__food_to_rating = {}\n        self.__cusine_to_rating_foods = collections.defaultdict(SortedList)\n        for food, cuisine, rating in itertools.izip(foods, cuisines, ratings):\n            self.__food_to_cuisine[food] = cuisine\n            self.__food_to_rating[food] = rating\n            self.__cusine_to_rating_foods[cuisine].add((-rating, food))\n\n    def changeRating(self, food, newRating):\n        \"\"\"\n        :type food: str\n        :type newRating: int\n        :rtype: None\n        \"\"\"\n        old_rating = self.__food_to_rating[food]\n        cuisine = self.__food_to_cuisine[food]\n        self.__cusine_to_rating_foods[cuisine].remove((-old_rating, food))\n        self.__food_to_rating[food] = newRating\n        self.__cusine_to_rating_foods[cuisine].add((-newRating, food))\n\n    def highestRated(self, cuisine):\n        \"\"\"\n        :type cuisine: str\n        :rtype: str\n        \"\"\"\n        return self.__cusine_to_rating_foods[cuisine][0][1]\n"
    },
    {
        "problem_name": "design-a-leaderboard",
        "solution": "# Time:  ctor:  O(1)\n#        add:   O(1)\n#        top:   O(n)\n#        reset: O(1)\n# Space: O(n)\n\nimport collections\nimport random\n\n\nclass Leaderboard(object):\n\n    def __init__(self):\n        self.__lookup = collections.Counter()\n        \n    def addScore(self, playerId, score):\n        \"\"\"\n        :type playerId: int\n        :type score: int\n        :rtype: None\n        \"\"\"\n        self.__lookup[playerId] += score\n\n    def top(self, K):\n        \"\"\"\n        :type K: int\n        :rtype: int\n        \"\"\"\n        def kthElement(nums, k, compare):\n            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == k:\n                    return\n                elif new_pivot_idx > k:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < k.\n                    left = new_pivot_idx + 1\n        \n        scores = self.__lookup.values()\n        kthElement(scores, K, lambda a, b: a > b)\n        return sum(scores[:K])\n\n    def reset(self, playerId):\n        \"\"\"\n        :type playerId: int\n        :rtype: None\n        \"\"\"\n        self.__lookup[playerId] = 0\n"
    },
    {
        "problem_name": "design-a-number-container-system",
        "solution": "# Time:  ctor:   O(1)\n#        change: O(logn)\n#        find:   O(1)\n# Space: O(n)\n\nfrom sortedcontainers import SortedList\n\n\n# sorted list\nclass NumberContainers(object):\n\n    def __init__(self):\n        self.__idx_to_num = {}\n        self.__num_to_idxs = collections.defaultdict(SortedList)\n\n    def change(self, index, number):\n        \"\"\"\n        :type index: int\n        :type number: int\n        :rtype: None\n        \"\"\"\n        if index in self.__idx_to_num:\n            self.__num_to_idxs[self.__idx_to_num[index]].remove(index)\n            if not self.__num_to_idxs[self.__idx_to_num[index]]:\n                del self.__num_to_idxs[self.__idx_to_num[index]]\n        self.__idx_to_num[index] = number\n        self.__num_to_idxs[number].add(index)\n\n    def find(self, number):\n        \"\"\"\n        :type number: int\n        :rtype: int\n        \"\"\"\n        return self.__num_to_idxs[number][0] if number in self.__num_to_idxs else -1\n"
    },
    {
        "problem_name": "design-a-stack-with-increment-operation",
        "solution": "# Time:  cotr:      O(1)\n#        push:      O(1)\n#        pop:       O(1)\n#        increment: O(1)\n# Space: O(n)\n\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.__max_size = maxSize\n        self.__stk = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.__stk) == self.__max_size:\n            return\n        self.__stk.append([x, 0])\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.__stk:\n            return -1\n        x, inc = self.__stk.pop()\n        if self.__stk:\n            self.__stk[-1][1] += inc\n        return x + inc\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        i = min(len(self.__stk), k)-1\n        if i >= 0:\n            self.__stk[i][1] += val\n"
    },
    {
        "problem_name": "design-a-text-editor",
        "solution": "# Time:  ctor:        O(1)\n#        addText:     O(l)\n#        deleteText:  O(k)\n#        cursorLeft:  O(k)\n#        cursorRight: O(k)\n# Space: O(n)\n\n# design, stack\nclass TextEditor(object):\n\n    def __init__(self):\n        self.__LAST_COUNT = 10\n        self.__left = []\n        self.__right = []\n\n    def addText(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: None\n        \"\"\"\n        for x in text:\n            self.__left.append(x)\n\n    def deleteText(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return self.__move(k, self.__left, None)\n\n    def cursorLeft(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: str\n        \"\"\"\n        self.__move(k, self.__left, self.__right)\n        return self.__last_characters()\n\n    def cursorRight(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: str\n        \"\"\"\n        self.__move(k, self.__right, self.__left)\n        return self.__last_characters()\n\n    def __move(self, k, src, dst):\n        cnt = min(k, len(src))\n        for _ in xrange(cnt):\n            if dst is not None:\n                dst.append(src[-1])\n            src.pop()\n        return cnt\n\n    def __last_characters(self):\n        return \"\".join(self.__left[-self.__LAST_COUNT:])\n"
    },
    {
        "problem_name": "design-a-todo-list",
        "solution": "# Time:  ctor:           O(1)\n#        addTask:        O(l + logn), n is the number of user's tasks, l is the max length of a task\n#        getAllTasks:    O(r), r is the length of result\n#        getTasksForTag: O(r * c), r is the length of result, c is the length of the tag\n#        completeTask:   O(l + logn)\n# Space: O(n * l)\n\nfrom sortedcontainers import SortedList\n\n\n# sortedlist\nclass TodoList(object):\n\n    def __init__(self):\n        self.__tasks = []\n        self.__user_task_ids = collections.defaultdict(SortedList)\n\n    def addTask(self, userId, taskDescription, dueDate, tags):\n        \"\"\"\n        :type userId: int\n        :type taskDescription: str\n        :type dueDate: int\n        :type tags: List[str]\n        :rtype: int\n        \"\"\"\n        self.__tasks.append([dueDate, taskDescription, set(tags)])\n        self.__user_task_ids[userId].add((dueDate, len(self.__tasks)))\n        return len(self.__tasks)\n\n    def getAllTasks(self, userId):\n        \"\"\"\n        :type userId: int\n        :rtype: List[str]\n        \"\"\"\n        if userId not in self.__user_task_ids:\n            return []\n        return [self.__tasks[i-1][1] for _, i in self.__user_task_ids[userId]]\n\n    def getTasksForTag(self, userId, tag):\n        \"\"\"\n        :type userId: int\n        :type tag: str\n        :rtype: List[str]\n        \"\"\"\n        if userId not in self.__user_task_ids:\n            return []\n        return [self.__tasks[i-1][1] for _, i in self.__user_task_ids[userId] if tag in self.__tasks[i-1][-1]]\n\n    def completeTask(self, userId, taskId):\n        \"\"\"\n        :type userId: int\n        :type taskId: int\n        :rtype: None\n        \"\"\"\n        if not (taskId-1 < len(self.__tasks) and userId in self.__user_task_ids):\n            return\n        self.__user_task_ids[userId].discard((self.__tasks[taskId-1][0], taskId))\n\n\n# Time:  ctor:           O(1)\n#        addTask:        O(l + t * logn), n is the number of user's tasks, l is the max length of a task, t is the number of tags\n#        getAllTasks:    O(r), r is the length of result\n#        getTasksForTag: O(r), r is the length of result\n#        completeTask:   O(l + t * logn)\n# Space: O(n * (l + t))\nfrom sortedcontainers import SortedList\n\n\n# sortedlist\nclass TodoList2(object):\n\n    def __init__(self):\n        self.__tasks = []\n        self.__user_task_ids = collections.defaultdict(SortedList)\n\n    def addTask(self, userId, taskDescription, dueDate, tags):\n        \"\"\"\n        :type userId: int\n        :type taskDescription: str\n        :type dueDate: int\n        :type tags: List[str]\n        :rtype: int\n        \"\"\"\n        self.__tasks.append([dueDate, taskDescription, set(tags)])\n        self.__user_task_ids[userId].add((dueDate, len(self.__tasks)))\n        for tag in self.__tasks[-1][-1]:\n            self.__user_task_ids[userId, tag].add((dueDate, len(self.__tasks)))\n        return len(self.__tasks)\n\n    def getAllTasks(self, userId):\n        \"\"\"\n        :type userId: int\n        :rtype: List[str]\n        \"\"\"\n        if userId not in self.__user_task_ids:\n            return []\n        return [self.__tasks[i-1][1] for _, i in self.__user_task_ids[userId]]\n\n    def getTasksForTag(self, userId, tag):\n        \"\"\"\n        :type userId: int\n        :type tag: str\n        :rtype: List[str]\n        \"\"\"\n        if (userId, tag) not in self.__user_task_ids:\n            return []\n        return [self.__tasks[i-1][1] for _, i in self.__user_task_ids[userId, tag]]\n\n    def completeTask(self, userId, taskId):\n        \"\"\"\n        :type userId: int\n        :type taskId: int\n        :rtype: None\n        \"\"\"\n        if not (taskId-1 < len(self.__tasks) and userId in self.__user_task_ids):\n            return\n        self.__user_task_ids[userId].discard((self.__tasks[taskId-1][0], taskId))\n        for tag in self.__tasks[taskId-1][-1]:\n            self.__user_task_ids[userId, tag].discard((self.__tasks[taskId-1][0], taskId))\n"
    },
    {
        "problem_name": "design-an-atm-machine",
        "solution": "# Time:  ctor:     O(1)\n#        deposit:  O(1)\n#        withdraw: O(1)\n# Space: O(1)\n\n# greedy\nclass ATM(object):\n\n    def __init__(self):\n        self.__vals = [20, 50, 100, 200, 500]\n        self.__cnt = [0]*len(self.__vals)\n\n    def deposit(self, banknotesCount):\n        \"\"\"\n        :type banknotesCount: List[int]\n        :rtype: None\n        \"\"\"\n        for i, x in enumerate(banknotesCount):\n            self.__cnt[i] += x\n\n    def withdraw(self, amount):\n        \"\"\"\n        :type amount: int\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(self.__cnt)\n        for i in reversed(xrange(len(self.__vals))):\n            result[i] = min(amount//self.__vals[i], self.__cnt[i])\n            amount -= result[i]*self.__vals[i]\n        if amount:\n            return [-1]\n        for i, c in enumerate(result):\n            self.__cnt[i] -= c\n        return result\n        \n"
    },
    {
        "problem_name": "design-an-expression-tree-with-evaluate-function",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nimport abc \nfrom abc import ABCMeta, abstractmethod \n\n\nclass Node:\n    __metaclass__ = ABCMeta\n    # define your fields here\n    @abstractmethod\n    def evaluate(self):\n        pass\n\n\nimport operator\n\n\nclass NodeIter(Node):\n    ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n    \n    def __init__(self, val):\n        self.val = val\n        self.left = None \n        self.right = None\n    \n    def evaluate(self):\n        result = [0]\n        stk = [(1, (self, result))]\n        while stk:\n            step, args = stk.pop()\n            if step == 1:\n                node, ret = args\n                if node.val.isdigit():\n                    ret[0] = int(node.val)\n                    continue\n                ret1, ret2 = [0], [0]\n                stk.append((2, (node, ret1, ret2, ret)))\n                stk.append((1, (node.right, ret2)))\n                stk.append((1, (node.left, ret1)))\n            elif step == 2:\n                node, ret1, ret2, ret = args\n                ret[0] = NodeIter.ops[node.val](ret1[0], ret2[0])\n        return result[0]\n\n\nclass TreeBuilder(object):\n    def buildTree(self, postfix):\n        \"\"\"\n        :type s: List[str]\n        :rtype: int\n        \"\"\"\n        stk = []\n        for c in postfix:\n            if c.isdigit():\n                stk.append(NodeIter(c))\n            else:\n                node = NodeIter(c)\n                node.right = stk.pop()\n                node.left = stk.pop()\n                stk.append(node)                \n        return stk.pop()\n\n\n# Time:  O(n)\n# Space: O(h)\nclass NodeRecu(Node):\n    ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}\n    \n    def __init__(self, val):\n        self.val = val\n        self.left = None \n        self.right = None\n\n    def evaluate(self):\n        if self.val.isdigit():\n            return int(self.val)\n        return NodeRecu.ops[self.val](self.left.evaluate(), self.right.evaluate())\n        \n\nclass TreeBuilder2(object):\n    def buildTree(self, postfix):\n        \"\"\"\n        :type s: List[str]\n        :rtype: int\n        \"\"\"\n        stk = []\n        for c in postfix:\n            if c.isdigit():\n                stk.append(NodeRecu(c))\n            else:\n                node = NodeRecu(c)\n                node.right = stk.pop()\n                node.left = stk.pop()\n                stk.append(node)\n        return stk.pop()\n"
    },
    {
        "problem_name": "design-an-ordered-stream",
        "solution": "# Time:  O(1), amortized\n# Space: O(n)\n\nclass OrderedStream(object):\n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.__i = 0      \n        self.__values = [None]*n\n\n    def insert(self, id, value):\n        \"\"\"\n        :type id: int\n        :type value: str\n        :rtype: List[str]\n        \"\"\"\n        id -= 1\n        self.__values[id] = value\n        result = []\n        if self.__i != id:\n            return result\n        while self.__i < len(self.__values) and self.__values[self.__i]:\n            result.append(self.__values[self.__i])\n            self.__i += 1\n        return result\n"
    },
    {
        "problem_name": "design-authentication-manager",
        "solution": "# Time:  ctor:     O(1)\n#        generate: O(1), amortized\n#        renew:    O(1), amortized\n#        count:    O(1), amortized\n# Space: O(n)\n\nimport collections\n\n\nclass AuthenticationManager(object):\n\n    def __init__(self, timeToLive):\n        \"\"\"\n        :type timeToLive: int\n        \"\"\"\n        self.__time = timeToLive\n        self.__lookup = collections.OrderedDict()\n\n    def __evict(self, currentTime):\n        while self.__lookup and next(self.__lookup.itervalues()) <= currentTime:\n            self.__lookup.popitem(last=False)\n\n    def generate(self, tokenId, currentTime):\n        \"\"\"\n        :type tokenId: str\n        :type currentTime: int\n        :rtype: None\n        \"\"\"\n        self.__evict(currentTime)\n        self.__lookup[tokenId] = currentTime + self.__time\n\n\n    def renew(self, tokenId, currentTime):\n        \"\"\"\n        :type tokenId: str\n        :type currentTime: int\n        :rtype: None\n        \"\"\"\n        self.__evict(currentTime)            \n        if tokenId not in self.__lookup:\n            return\n        del self.__lookup[tokenId]\n        self.__lookup[tokenId] = currentTime + self.__time\n\n    def countUnexpiredTokens(self, currentTime):\n        \"\"\"\n        :type currentTime: int\n        :rtype: int\n        \"\"\"\n        self.__evict(currentTime)\n        return len(self.__lookup)\n"
    },
    {
        "problem_name": "design-bitset",
        "solution": "# Time:  ctor:     O(n)\n#        fix:      O(1)\n#        unfix:    O(1)\n#        flip:     O(1)\n#        all:      O(1)\n#        one:      O(1)\n#        count:    O(1)\n#        toString: O(n)\n# Space: O(n)\n\n# design\nclass Bitset(object):\n\n    def __init__(self, size):\n        \"\"\"\n        :type size: int\n        \"\"\"\n        self.__lookup = [False]*size\n        self.__flip = False\n        self.__cnt = 0\n\n    def fix(self, idx):\n        \"\"\"\n        :type idx: int\n        :rtype: None\n        \"\"\"\n        if self.__lookup[idx] == self.__flip:\n            self.__lookup[idx] = not self.__lookup[idx]\n            self.__cnt += 1\n            \n    def unfix(self, idx):\n        \"\"\"\n        :type idx: int\n        :rtype: None\n        \"\"\"\n        if self.__lookup[idx] != self.__flip:\n            self.__lookup[idx] = not self.__lookup[idx]\n            self.__cnt -= 1\n\n    def flip(self):\n        \"\"\"\n        :rtype: None\n        \"\"\"\n        self.__flip = not self.__flip\n        self.__cnt = len(self.__lookup)-self.__cnt\n        \n\n    def all(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return self.__cnt == len(self.__lookup)\n\n    def one(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return self.__cnt >= 1\n\n    def count(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.__cnt\n\n    def toString(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        result = ['']*len(self.__lookup)\n        for i, x in enumerate(self.__lookup):\n            result[i] = '1' if x != self.__flip else '0'\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "design-bounded-blocking-queue",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport threading\nimport collections\n\n\nclass BoundedBlockingQueue(object):\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.__cv = threading.Condition()\n        self.__q = collections.deque()\n        self.__cap = capacity\n\n    def enqueue(self, element):\n        \"\"\"\n        :type element: int\n        :rtype: void\n        \"\"\"\n        with self.__cv:\n            while len(self.__q) == self.__cap:\n                self.__cv.wait()\n            self.__q.append(element)\n            self.__cv.notifyAll()\n\n    def dequeue(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        with self.__cv:\n            while not self.__q:\n                self.__cv.wait()\n            self.__cv.notifyAll()\n            return self.__q.popleft()\n\n    def size(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        with self.__cv:\n            return len(self.__q)\n"
    },
    {
        "problem_name": "design-browser-history",
        "solution": "# Time:  ctor  : O(1)\n#        visit : O(n)\n#        back  : O(1)\n#        foward: O(1)\n# Space: O(n)\n\nclass BrowserHistory(object):\n\n    def __init__(self, homepage):\n        \"\"\"\n        :type homepage: str\n        \"\"\"\n        self.__history = [homepage]\n        self.__curr = 0        \n\n    def visit(self, url):\n        \"\"\"\n        :type url: str\n        :rtype: None\n        \"\"\"\n        while len(self.__history) > self.__curr+1:\n            self.__history.pop()\n        self.__history.append(url)\n        self.__curr += 1\n\n    def back(self, steps):\n        \"\"\"\n        :type steps: int\n        :rtype: str\n        \"\"\"\n        self.__curr = max(self.__curr-steps, 0)\n        return self.__history[self.__curr]\n\n    def forward(self, steps):\n        \"\"\"\n        :type steps: int\n        :rtype: str\n        \"\"\"\n        self.__curr = min(self.__curr+steps, len(self.__history)-1)\n        return self.__history[self.__curr]\n"
    },
    {
        "problem_name": "design-circular-deque",
        "solution": "# Time:  O(1)\n# Space: O(k)\n\nclass MyCircularDeque(object):\n\n    def __init__(self, k):\n        \"\"\"\n        Initialize your data structure here. Set the size of the deque to be k.\n        :type k: int\n        \"\"\"\n        self.__start = 0\n        self.__size = 0\n        self.__buffer = [0] * k\n\n    def insertFront(self, value):\n        \"\"\"\n        Adds an item at the front of Deque. Return true if the operation is successful.\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        if self.isFull():\n            return False\n        self.__start = (self.__start-1) % len(self.__buffer)\n        self.__buffer[self.__start] = value\n        self.__size += 1\n        return True\n\n    def insertLast(self, value):\n        \"\"\"\n        Adds an item at the rear of Deque. Return true if the operation is successful.\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        if self.isFull():\n            return False\n        self.__buffer[(self.__start+self.__size) % len(self.__buffer)] = value\n        self.__size += 1\n        return True\n\n    def deleteFront(self):\n        \"\"\"\n        Deletes an item from the front of Deque. Return true if the operation is successful.\n        :rtype: bool\n        \"\"\"\n        if self.isEmpty():\n            return False\n        self.__start = (self.__start+1) % len(self.__buffer)\n        self.__size -= 1\n        return True\n\n    def deleteLast(self):\n        \"\"\"\n        Deletes an item from the rear of Deque. Return true if the operation is successful.\n        :rtype: bool\n        \"\"\"\n        if self.isEmpty():\n            return False\n        self.__size -= 1\n        return True\n\n    def getFront(self):\n        \"\"\"\n        Get the front item from the deque.\n        :rtype: int\n        \"\"\"\n        return -1 if self.isEmpty() else self.__buffer[self.__start]\n\n    def getRear(self):\n        \"\"\"\n        Get the last item from the deque.\n        :rtype: int\n        \"\"\"\n        return -1 if self.isEmpty() else self.__buffer[(self.__start+self.__size-1) % len(self.__buffer)]\n\n    def isEmpty(self):\n        \"\"\"\n        Checks whether the circular deque is empty or not.\n        :rtype: bool\n        \"\"\"\n        return self.__size == 0\n\n    def isFull(self):\n        \"\"\"\n        Checks whether the circular deque is full or not.\n        :rtype: bool\n        \"\"\"\n        return self.__size == len(self.__buffer)\n\n\n\n"
    },
    {
        "problem_name": "design-circular-queue",
        "solution": "# Time:  O(1)\n# Space: O(k)\n\nclass MyCircularQueue(object):\n\n    def __init__(self, k):\n        \"\"\"\n        Initialize your data structure here. Set the size of the queue to be k.\n        :type k: int\n        \"\"\"\n        self.__start = 0\n        self.__size = 0\n        self.__buffer = [0] * k\n\n    def enQueue(self, value):\n        \"\"\"\n        Insert an element into the circular queue. Return true if the operation is successful.\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        if self.isFull():\n            return False\n        self.__buffer[(self.__start+self.__size) % len(self.__buffer)] = value\n        self.__size += 1\n        return True\n\n    def deQueue(self):\n        \"\"\"\n        Delete an element from the circular queue. Return true if the operation is successful.\n        :rtype: bool\n        \"\"\"\n        if self.isEmpty():\n            return False\n        self.__start = (self.__start+1) % len(self.__buffer)\n        self.__size -= 1\n        return True\n\n    def Front(self):\n        \"\"\"\n        Get the front item from the queue.\n        :rtype: int\n        \"\"\"\n        return -1 if self.isEmpty() else self.__buffer[self.__start]\n\n    def Rear(self):\n        \"\"\"\n        Get the last item from the queue.\n        :rtype: int\n        \"\"\"\n        return -1 if self.isEmpty() else self.__buffer[(self.__start+self.__size-1) % len(self.__buffer)]\n\n    def isEmpty(self):\n        \"\"\"\n        Checks whether the circular queue is empty or not.\n        :rtype: bool\n        \"\"\"\n        return self.__size == 0\n\n    def isFull(self):\n        \"\"\"\n        Checks whether the circular queue is full or not.\n        :rtype: bool\n        \"\"\"\n        return self.__size == len(self.__buffer)\n\n\n\n"
    },
    {
        "problem_name": "design-compressed-string-iterator",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nimport re\n\n\nclass StringIterator(object):\n\n    def __init__(self, compressedString):\n        \"\"\"\n        :type compressedString: str\n        \"\"\"\n        self.__result = re.findall(r\"([a-zA-Z])(\\d+)\", compressedString)\n        self.__index, self.__num, self.__ch = 0, 0, ' '\n\n    def next(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        if not self.hasNext():\n            return ' '\n        if self.__num == 0:\n            self.__ch = self.__result[self.__index][0]\n            self.__num = int(self.__result[self.__index][1])\n            self.__index += 1\n        self.__num -= 1\n        return self.__ch\n\n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return self.__index != len(self.__result) or self.__num != 0\n\n\n\n\n"
    },
    {
        "problem_name": "design-excel-sum-formula",
        "solution": "# Time:  set: O((r * c)^2)\n#        get: O(1)\n#        sum: O((r * c)^2)\n# Space: O(r * c)\n\nimport collections\n\n\nclass Excel(object):\n\n    def __init__(self, H, W):\n        \"\"\"\n        :type H: int\n        :type W: str\n        \"\"\"\n        self.__exl = [[0 for _ in xrange(ord(W)-ord('A')+1)] \\\n                      for _ in xrange(H+1)]\n        self.__fward = collections.defaultdict(lambda : collections.defaultdict(int))\n        self.__bward = collections.defaultdict(set)\n\n\n    def set(self, r, c, v):\n        \"\"\"\n        :type r: int\n        :type c: str\n        :type v: int\n        :rtype: void\n        \"\"\"\n        self.__reset_dependency(r, c)\n        self.__update_others(r, c, v)\n\n\n    def get(self, r, c):\n        \"\"\"\n        :type r: int\n        :type c: str\n        :rtype: int\n        \"\"\"\n        return self.__exl[r][ord(c) - ord('A')]\n\n\n    def sum(self, r, c, strs):\n        \"\"\"\n        :type r: int\n        :type c: str\n        :type strs: List[str]\n        :rtype: int\n        \"\"\"\n        self.__reset_dependency(r, c)\n        result = self.__calc_and_update_dependency(r, c, strs)\n        self.__update_others(r, c, result)\n        return result\n\n\n    def __reset_dependency(self, r, c):\n        key = (r, c)\n        if key in self.__bward.keys():\n            for k in self.__bward[key]:\n                self.__fward[k].pop(key, None)\n            self.__bward[key] = set()\n\n\n    def __calc_and_update_dependency(self, r, c, strs):\n        result = 0\n        for s in strs:\n            s, e = s.split(':')[0], s.split(':')[1] if ':' in s else s\n            left, right, top, bottom = ord(s[0])-ord('A'), ord(e[0])-ord('A'), int(s[1:]), int(e[1:])\n            for i in xrange(top, bottom+1):\n                for j in xrange(left, right+1):\n                    result += self.__exl[i][j]\n                    self.__fward[(i, chr(ord('A')+j))][(r, c)] += 1\n                    self.__bward[(r, c)].add((i, chr(ord('A')+j)))\n        return result\n\n\n    def __update_others(self, r, c, v):\n        prev = self.__exl[r][ord(c)-ord('A')]\n        self.__exl[r][ord(c)-ord('A')] = v\n        q = collections.deque()\n        q.append(((r, c), v-prev))\n        while q:\n            key, diff = q.popleft()\n            if key in self.__fward:\n                for k, count in self.__fward[key].iteritems():\n                    q.append((k, diff*count))\n                    self.__exl[k[0]][ord(k[1])-ord('A')] += diff*count\n\n\n\n"
    },
    {
        "problem_name": "design-file-system",
        "solution": "# Time:  create: O(n)\n#        get:    O(n)\n# Space: O(n)\n\nclass FileSystem(object):\n\n    def __init__(self):\n        self.__lookup = {\"\": -1}\n\n    def create(self, path, value):\n        \"\"\"\n        :type path: str\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        if path[:path.rfind('/')] not in self.__lookup:\n            return False\n        self.__lookup[path] = value\n        return True\n        \n    def get(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: int\n        \"\"\"\n        if path not in self.__lookup:\n            return -1\n        return self.__lookup[path]\n"
    },
    {
        "problem_name": "design-front-middle-back-queue",
        "solution": "# Time:  O(1)\n# Space: O(n)\n\nimport collections\n\n\nclass FrontMiddleBackQueue(object):\n\n    def __init__(self):\n        self.__left, self.__right = collections.deque(), collections.deque()   \n\n    def pushFront(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: None\n        \"\"\"\n        self.__left.appendleft(val)\n        self.__balance()        \n\n    def pushMiddle(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if len(self.__left) > len(self.__right):\n            self.__right.appendleft(self.__left.pop())\n        self.__left.append(val)\n\n    def pushBack(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: None\n        \"\"\"\n        self.__right.append(val)\n        self.__balance()\n\n    def popFront(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        val = (self.__left or collections.deque([-1])).popleft()\n        self.__balance()\n        return val\n\n    def popMiddle(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        val = (self.__left or [-1]).pop()\n        self.__balance()\n        return val\n\n    def popBack(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        val = (self.__right or self.__left or [-1]).pop()\n        self.__balance()\n        return val\n\n    def __balance(self):\n        if len(self.__left) > len(self.__right)+1:\n            self.__right.appendleft(self.__left.pop())\n        elif len(self.__left) < len(self.__right):\n            self.__left.append(self.__right.popleft())\n"
    },
    {
        "problem_name": "design-graph-with-shortest-path-calculator",
        "solution": "# Time:  ctor:         O(|V| + |E|)\n#        addEdge:      O(1)\n#        shortestPath: O((|E| + |V|) * log|V|) = O(|E| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport heapq\n\n\n# dijkstra's algorithm\nclass Graph(object):\n\n    def __init__(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        \"\"\"\n        self.__adj = [[] for _ in xrange(n)]\n        for edge in edges:\n            self.addEdge(edge)\n\n    def addEdge(self, edge):\n        \"\"\"\n        :type edge: List[int]\n        :rtype: None\n        \"\"\"\n        u, v, w = edge\n        self.__adj[u].append((v, w))\n\n    def shortestPath(self, node1, node2):\n        \"\"\"\n        :type node1: int\n        :type node2: int\n        :rtype: int\n        \"\"\"\n        def dijkstra(adj, start, target):\n            best = [float(\"inf\")]*len(adj)\n            best[start] = 0\n            min_heap = [(best[start], start)]\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if curr > best[u]:\n                    continue\n                for v, w in adj[u]:                \n                    if not (curr+w < best[v]):\n                        continue\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (best[v], v))\n            return best[target] if best[target] != float(\"inf\") else -1\n\n        return dijkstra(self.__adj, node1, node2)\n"
    },
    {
        "problem_name": "design-hashmap",
        "solution": "# Time:  O(1)\n# Space: O(n)\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\n\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\n\n    def find(self, key):\n        curr = self.head\n        while curr:\n            if curr.key == key:\n                break\n            curr = curr.next\n        return curr\n\n\nclass MyHashMap(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__data = [LinkedList() for _ in xrange(10000)]\n\n    def put(self, key, value):\n        \"\"\"\n        value will always be positive.\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        l = self.__data[key % len(self.__data)]\n        node = l.find(key)\n        if node:\n            node.val = value\n        else:\n            l.insert(ListNode(key, value))\n\n    def get(self, key):\n        \"\"\"\n        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key\n        :type key: int\n        :rtype: int\n        \"\"\"\n        l = self.__data[key % len(self.__data)]\n        node = l.find(key)\n        if node:\n            return node.val\n        else:\n            return -1\n\n    def remove(self, key):\n        \"\"\"\n        Removes the mapping of the specified value key if this map contains a mapping for the key\n        :type key: int\n        :rtype: void\n        \"\"\"\n        l = self.__data[key % len(self.__data)]\n        node = l.find(key)\n        if node:\n            l.delete(node)\n\n\n\n"
    },
    {
        "problem_name": "design-hashset",
        "solution": "# Time:  O(1)\n# Space: O(n)\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\n\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\n\n    def find(self, key):\n        curr = self.head\n        while curr:\n            if curr.key == key:\n                break\n            curr = curr.next\n        return curr\n\n\nclass MyHashSet(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__data = [LinkedList() for _ in xrange(10000)]\n\n    def add(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: void\n        \"\"\"\n        l = self.__data[key % len(self.__data)]\n        node = l.find(key)\n        if not node:\n            l.insert(ListNode(key, 0))\n\n    def remove(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: void\n        \"\"\"\n        l = self.__data[key % len(self.__data)]\n        node = l.find(key)\n        if node:\n            l.delete(node)\n\n    def contains(self, key):\n        \"\"\"\n        Returns true if this set did not already contain the specified element\n        :type key: int\n        :rtype: bool\n        \"\"\"\n        l = self.__data[key % len(self.__data)]\n        node = l.find(key)\n        return node is not None\n\n\n\n"
    },
    {
        "problem_name": "design-hit-counter",
        "solution": "# Time:  O(1), amortized\n# Space: O(k), k is the count of seconds.\n\nfrom collections import deque\n\nclass HitCounter(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__k = 300\n        self.__dq = deque()\n        self.__count = 0\n\n    def hit(self, timestamp):\n        \"\"\"\n        Record a hit.\n        @param timestamp - The current timestamp (in seconds granularity).\n        :type timestamp: int\n        :rtype: void\n        \"\"\"\n        self.getHits(timestamp)\n        if self.__dq and self.__dq[-1][0] == timestamp:\n            self.__dq[-1][1] += 1\n        else:\n            self.__dq.append([timestamp, 1])\n        self.__count += 1\n\n    def getHits(self, timestamp):\n        \"\"\"\n        Return the number of hits in the past 5 minutes.\n        @param timestamp - The current timestamp (in seconds granularity).\n        :type timestamp: int\n        :rtype: int\n        \"\"\"\n        while self.__dq and self.__dq[0][0] <= timestamp - self.__k:\n            self.__count -= self.__dq.popleft()[1]\n        return self.__count\n\n\n"
    },
    {
        "problem_name": "design-in-memory-file-system",
        "solution": "# Time:  ls: O(l + klogk), l is the path length, k is the number of entries in the last level directory\n#        mkdir: O(l)\n#        addContentToFile: O(l + c), c is the content size\n#        readContentFromFile: O(l + c)\n# Space: O(n + s), n is the number of dir/file nodes, s is the total content size.\n\nclass TrieNode(object):\n\n    def __init__(self):\n        self.is_file = False\n        self.children = {}\n        self.content = \"\"\n\nclass FileSystem(object):\n\n    def __init__(self):\n        self.__root = TrieNode()\n\n\n    def ls(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: List[str]\n        \"\"\"\n        curr = self.__getNode(path)\n\n        if curr.is_file:\n            return [self.__split(path, '/')[-1]]\n\n        return sorted(curr.children.keys())\n\n\n    def mkdir(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: void\n        \"\"\"\n        curr = self.__putNode(path)\n        curr.is_file = False\n\n\n    def addContentToFile(self, filePath, content):\n        \"\"\"\n        :type filePath: str\n        :type content: str\n        :rtype: void\n        \"\"\"\n        curr = self.__putNode(filePath)\n        curr.is_file = True\n        curr.content += content\n\n\n    def readContentFromFile(self, filePath):\n        \"\"\"\n        :type filePath: str\n        :rtype: str\n        \"\"\"\n        return self.__getNode(filePath).content\n\n\n    def __getNode(self, path):\n        curr = self.__root\n        for s in self.__split(path, '/'):\n            curr = curr.children[s]\n        return curr\n\n\n    def __putNode(self, path):\n        curr = self.__root\n        for s in self.__split(path, '/'):\n            if s not in curr.children:\n                curr.children[s] = TrieNode()\n            curr = curr.children[s]\n        return curr\n\n\n    def __split(self, path, delim):\n        if path == '/':\n            return []\n        return path.split('/')[1:]\n\n\n"
    },
    {
        "problem_name": "design-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Node(object):\n    def __init__(self, value):\n        self.val = value\n        self.next = self.prev = None\n\n\nclass MyLinkedList(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__head = self.__tail = Node(-1)\n        self.__head.next = self.__tail\n        self.__tail.prev = self.__head\n        self.__size = 0\n\n    def get(self, index):\n        \"\"\"\n        Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n        :type index: int\n        :rtype: int\n        \"\"\"\n        if 0 <= index <= self.__size // 2:\n            return self.__forward(0, index, self.__head.next).val\n        elif self.__size // 2 < index < self.__size:\n            return self.__backward(self.__size, index, self.__tail).val\n        return -1\n\n    def addAtHead(self, val):\n        \"\"\"\n        Add a node of value val before the first element of the linked list.\n        After the insertion, the new node will be the first node of the linked list.\n        :type val: int\n        :rtype: void\n        \"\"\"\n        self.__add(self.__head, val)\n\n    def addAtTail(self, val):\n        \"\"\"\n        Append a node of value val to the last element of the linked list.\n        :type val: int\n        :rtype: void\n        \"\"\"\n        self.__add(self.__tail.prev, val)\n\n    def addAtIndex(self, index, val):\n        \"\"\"\n        Add a node of value val before the index-th node in the linked list.\n        If index equals to the length of linked list,\n        the node will be appended to the end of linked list.\n        If index is greater than the length, the node will not be inserted.\n        :type index: int\n        :type val: int\n        :rtype: void\n        \"\"\"\n        if 0 <= index <= self.__size // 2:\n            self.__add(self.__forward(0, index, self.__head.next).prev, val)\n        elif self.__size // 2 < index <= self.__size:\n            self.__add(self.__backward(self.__size, index, self.__tail).prev, val)\n\n    def deleteAtIndex(self, index):\n        \"\"\"\n        Delete the index-th node in the linked list, if the index is valid.\n        :type index: int\n        :rtype: void\n        \"\"\"\n        if 0 <= index <= self.__size // 2:\n            self.__remove(self.__forward(0, index, self.__head.next))\n        elif self.__size // 2 < index < self.__size:\n            self.__remove(self.__backward(self.__size, index, self.__tail))\n\n    def __add(self, preNode, val):\n        node = Node(val)\n        node.prev = preNode\n        node.next = preNode.next\n        node.prev.next = node.next.prev = node\n        self.__size += 1\n        \n    def __remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        self.__size -= 1\n        \n    def __forward(self, start, end, curr):\n        while start != end:\n            start += 1\n            curr = curr.next\n        return curr\n    \n    def __backward(self, start, end, curr):\n        while start != end:\n            start -= 1\n            curr = curr.prev\n        return curr\n\n\n\n"
    },
    {
        "problem_name": "design-log-storage-system",
        "solution": "# Time:  put:      O(1)\n#        retrieve: O(n + dlogd), n is the size of the total logs\n#                              , d is the size of the found logs\n# Space: O(n)\n\nclass LogSystem(object):\n\n    def __init__(self):\n        self.__logs = []\n        self.__granularity = {'Year': 4, 'Month': 7, 'Day': 10, \\\n                              'Hour': 13, 'Minute': 16, 'Second': 19}\n\n\n    def put(self, id, timestamp):\n        \"\"\"\n        :type id: int\n        :type timestamp: str\n        :rtype: void\n        \"\"\"\n        self.__logs.append((id, timestamp))\n\n\n    def retrieve(self, s, e, gra):\n        \"\"\"\n        :type s: str\n        :type e: str\n        :type gra: str\n        :rtype: List[int]\n        \"\"\"\n        i = self.__granularity[gra]\n        begin = s[:i]\n        end = e[:i]\n        return sorted(id for id, timestamp in self.__logs \\\n                      if begin <= timestamp[:i] <= end)\n\n\n\n"
    },
    {
        "problem_name": "design-memory-allocator",
        "solution": "# Time:  ctor:     O(1)\n#        allocate: O(logn)\n#        free:     O(logn)\n# Space: O(n)\n\nfrom sortedcontainers import SortedList\nimport collections\n\n# sorted list\nclass Allocator(object):\n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.__avails = SortedList([[0, n]])\n        self.__lookup = collections.defaultdict(list)\n\n    def allocate(self, size, mID):\n        \"\"\"\n        :type size: int\n        :type mID: int\n        :rtype: int\n        \"\"\"\n        for l, s in self.__avails:\n            if s < size:\n                continue\n            self.__avails.remove([l, s])\n            self.__lookup[mID].append([l, size])\n            if s-size > 0:\n                self.__avails.add([l+size, s-size])\n            return l\n        return -1\n\n    def free(self, mID):\n        \"\"\"\n        :type mID: int\n        :rtype: int\n        \"\"\"\n        if mID not in self.__lookup:\n            return 0\n        result = 0\n        for l, s in self.__lookup[mID]:\n            self.__avails.add([l, s])\n            i = self.__avails.bisect_left([l, s])\n            if i+1 < len(self.__avails) and self.__avails[i][0]+self.__avails[i][1] == self.__avails[i+1][0]:\n                self.__avails[i][1] += self.__avails[i+1][1]\n                del self.__avails[i+1]\n            if i-1 >= 0 and self.__avails[i-1][0]+self.__avails[i-1][1] == self.__avails[i][0]:\n                self.__avails[i-1][1] += self.__avails[i][1]\n                del self.__avails[i]            \n            result += s\n        del self.__lookup[mID]\n        return result\n"
    },
    {
        "problem_name": "design-most-recently-used-queue",
        "solution": "# Time:  ctor:  O(nlogn)\n# Space: fetch: O(logn)\n\nfrom sortedcontainers import SortedList\n\n\n# balanced bst solution\nclass MRUQueue(object):\n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.__sl = SortedList((i-1, i) for i in xrange(1, n+1))  \n\n    def fetch(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        last, _ = self.__sl[-1]\n        _, val = self.__sl.pop(k-1)\n        self.__sl.add((last+1, val))\n        return val\n\n\n# Time:  ctor:  O(n + m), m is the max number of calls\n# Space: fetch: O(log(n + m))\nclass BIT(object):  # 0-indexed.\n    def __init__(self, n):\n        MAX_CALLS = 2000\n        self.__bit = [0]*(n+MAX_CALLS+1)  # Extra one for dummy node.\n        for i in xrange(1, len(self.__bit)):\n            self.__bit[i] = (1 if i-1 < n else 0) + self.__bit[i-1]\n        for i in reversed(xrange(1, len(self.__bit))):\n            last_i = i - (i & -i)\n            self.__bit[i] -= self.__bit[last_i]\n\n    def add(self, i, val):\n        i += 1  # Extra one for dummy node.\n        while i < len(self.__bit):\n            self.__bit[i] += val\n            i += (i & -i)\n\n    def query(self, i):\n        i += 1  # Extra one for dummy node.\n        ret = 0\n        while i > 0:\n            ret += self.__bit[i]\n            i -= (i & -i)\n        return ret\n\n    def binary_lift(self, k):\n        floor_log2_n = (len(self.__bit)-1).bit_length()-1\n        pow_i = 2**floor_log2_n\n        total = pos = 0  # 1-indexed\n        for i in reversed(xrange(floor_log2_n+1)):  # O(logN)\n            if pos+pow_i < len(self.__bit) and not (total+self.__bit[pos+pow_i] >= k):\n                total += self.__bit[pos+pow_i]\n                pos += pow_i\n            pow_i >>= 1\n        return (pos+1)-1  # 0-indexed\n\n\n# fenwick / bit solution\nclass MRUQueue2(object):\n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.__bit = BIT(n)\n        self.__lookup = {i:i+1 for i in xrange(n)}\n        self.__curr = n\n        \n    def fetch(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        pos = self.__bit.binary_lift(k)  \n        val = self.__lookup.pop(pos)\n        self.__bit.add(pos, -1)\n        self.__bit.add(self.__curr, 1)\n        self.__lookup[self.__curr] = val     \n        self.__curr += 1\n        return val\n\n\n# Time:  ctor:  O(n)\n# Space: fetch: O(sqrt(n))\nimport collections\nimport math\n\n\n# sqrt decomposition solution\nclass MRUQueue3(object):\n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.__buckets = [collections.deque() for _ in xrange(int(math.ceil(n**0.5)))]\n        for i in xrange(n):\n            self.__buckets[i//len(self.__buckets)].append(i+1)\n\n    def fetch(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        k -= 1\n        left, idx = divmod(k, len(self.__buckets))\n        val = self.__buckets[left][idx]\n        del self.__buckets[left][idx]\n        self.__buckets[-1].append(val)\n        for i in reversed(xrange(left, len(self.__buckets)-1)):\n            x = self.__buckets[i+1].popleft()\n            self.__buckets[i].append(x)\n        return val\n"
    },
    {
        "problem_name": "design-movie-rental-system",
        "solution": "# Time:  ctor:   O(nlogn)\n#        search: O(logn)\n#        rent:   O(logn)\n#        drop:   O(logn)\n#        report: O(logn)\n# Space: O(n)\n\nimport collections\nfrom sortedcontainers import SortedList\n\n\nclass MovieRentingSystem(object):\n\n    def __init__(self, n, entries):\n        \"\"\"\n        :type n: int\n        :type entries: List[List[int]]\n        \"\"\"\n        self.__movie_to_ordered_price_shop = collections.defaultdict(SortedList) \n        self.__shop_movie_to_price = {}\n        self.__rented_ordered_price_shop_movie = SortedList()\n        for s, m, p in entries:\n            self.__movie_to_ordered_price_shop[m].add((p, s))\n            self.__shop_movie_to_price[s, m] = p\n\n    def search(self, movie):\n        \"\"\"\n        :type movie: int\n        :rtype: List[int]\n        \"\"\"\n        return [s for _, s in self.__movie_to_ordered_price_shop[movie][:5]]\n\n    def rent(self, shop, movie):\n        \"\"\"\n        :type shop: int\n        :type movie: int\n        :rtype: None\n        \"\"\"\n        price = self.__shop_movie_to_price[shop, movie]\n        self.__movie_to_ordered_price_shop[movie].remove((price, shop))\n        self.__rented_ordered_price_shop_movie.add((price, shop, movie))\n\n    def drop(self, shop, movie):\n        \"\"\"\n        :type shop: int\n        :type movie: int\n        :rtype: None\n        \"\"\"\n        price = self.__shop_movie_to_price[shop, movie]\n        self.__movie_to_ordered_price_shop[movie].add((price, shop))\n        self.__rented_ordered_price_shop_movie.remove((price, shop, movie))\n\n    def report(self):\n        \"\"\"\n        :rtype: List[List[int]]\n        \"\"\"\n        return [[s, m] for _, s, m in self.__rented_ordered_price_shop_movie[:5]]\n"
    },
    {
        "problem_name": "design-parking-system",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass ParkingSystem(object):\n\n    def __init__(self, big, medium, small):\n        \"\"\"\n        :type big: int\n        :type medium: int\n        :type small: int\n        \"\"\"\n        self.__space = [0, big, medium, small]\n\n    def addCar(self, carType):\n        \"\"\"\n        :type carType: int\n        :rtype: bool\n        \"\"\"\n        if self.__space[carType] > 0:\n            self.__space[carType] -= 1\n            return True\n        return False\n"
    },
    {
        "problem_name": "design-phone-directory",
        "solution": "# init:     Time: O(n), Space: O(n)\n# get:      Time: O(1), Space: O(1)\n# check:    Time: O(1), Space: O(1)\n# release:  Time: O(1), Space: O(1)\n\nclass PhoneDirectory(object):\n\n    def __init__(self, maxNumbers):\n        \"\"\"\n        Initialize your data structure here\n        @param maxNumbers - The maximum numbers that can be stored in the phone directory.\n        :type maxNumbers: int\n        \"\"\"\n        self.__curr = 0\n        self.__numbers = range(maxNumbers)\n        self.__used = [False] * maxNumbers\n\n\n    def get(self):\n        \"\"\"\n        Provide a number which is not assigned to anyone.\n        @return - Return an available number. Return -1 if none is available.\n        :rtype: int\n        \"\"\"\n        if self.__curr == len(self.__numbers):\n            return -1\n        number = self.__numbers[self.__curr]\n        self.__curr += 1\n        self.__used[number] = True\n        return number\n\n\n    def check(self, number):\n        \"\"\"\n        Check if a number is available or not.\n        :type number: int\n        :rtype: bool\n        \"\"\"\n        return 0 <= number < len(self.__numbers) and \\\n               not self.__used[number]\n\n\n    def release(self, number):\n        \"\"\"\n        Recycle or release a number.\n        :type number: int\n        :rtype: void\n        \"\"\"\n        if not 0 <= number < len(self.__numbers) or \\\n           not self.__used[number]:\n            return\n        self.__used[number] = False\n        self.__curr -= 1\n        self.__numbers[self.__curr] = number\n\n\n\n"
    },
    {
        "problem_name": "design-search-autocomplete-system",
        "solution": "# Time:  O(p^2), p is the length of the prefix\n# Space: O(p * t + s), t is the number of nodes of trie\n#                    , s is the size of the sentences\n\nimport collections\n\n\nclass TrieNode(object):\n\n    def __init__(self):\n        self.__TOP_COUNT = 3\n        self.infos = []\n        self.leaves = {}\n\n\n    def insert(self, s, times):\n        cur = self\n        cur.add_info(s, times)\n        for c in s:\n            if c not in cur.leaves:\n                cur.leaves[c] = TrieNode()\n            cur = cur.leaves[c]\n            cur.add_info(s, times)\n\n\n    def add_info(self, s, times):\n        for p in self.infos:\n            if p[1] == s:\n                p[0] = -times\n                break\n        else:\n            self.infos.append([-times, s])\n        self.infos.sort()\n        if len(self.infos) > self.__TOP_COUNT:\n            self.infos.pop()\n\n\nclass AutocompleteSystem(object):\n\n    def __init__(self, sentences, times):\n        \"\"\"\n        :type sentences: List[str]\n        :type times: List[int]\n        \"\"\"\n        self.__trie = TrieNode()\n        self.__cur_node = self.__trie\n        self.__search = []\n        self.__sentence_to_count = collections.defaultdict(int)\n        for sentence, count in zip(sentences, times):\n            self.__sentence_to_count[sentence] = count\n            self.__trie.insert(sentence, count)\n\n\n    def input(self, c):\n        \"\"\"\n        :type c: str\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        if c == '#':\n            self.__sentence_to_count[\"\".join(self.__search)] += 1\n            self.__trie.insert(\"\".join(self.__search), self.__sentence_to_count[\"\".join(self.__search)])\n            self.__cur_node = self.__trie\n            self.__search = []\n        else:\n            self.__search.append(c)\n            if self.__cur_node:\n                if c not in self.__cur_node.leaves:\n                    self.__cur_node = None\n                    return []\n                self.__cur_node = self.__cur_node.leaves[c]\n                result = [p[1] for p in self.__cur_node.infos]\n        return result\n\n\n\n"
    },
    {
        "problem_name": "design-skiplist",
        "solution": "# Time:  O(logn) on average for each operation\n# Space: O(n)\n\n# see proof in references:\n# 1. https://kunigami.blog/2012/09/25/skip-lists-in-python/\n# 2. https://opendatastructures.org/ods-cpp/4_4_Analysis_Skiplists.html\n# 3. https://brilliant.org/wiki/skip-lists/\nimport random\n\n\nclass SkipNode(object):\n    def __init__(self, level=0, num=None):\n        self.num = num\n        self.nexts = [None]*level\n\n\nclass Skiplist(object):\n    P_NUMERATOR, P_DENOMINATOR = 1, 2  # P = 1/4 in redis implementation\n    MAX_LEVEL = 32  # enough for 2^32 elements\n\n    def __init__(self):\n        self.__head = SkipNode()\n        self.__len = 0\n\n    def search(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        return True if self.__find(target, self.__find_prev_nodes(target)) else False\n        \n    def add(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: None\n        \"\"\"\n        node = SkipNode(self.__random_level(), num)\n        if len(self.__head.nexts) < len(node.nexts): \n            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))\n        prevs = self.__find_prev_nodes(num)\n        for i in xrange(len(node.nexts)):\n            node.nexts[i] = prevs[i].nexts[i]\n            prevs[i].nexts[i] = node\n        self.__len += 1\n\n    def erase(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        prevs = self.__find_prev_nodes(num)\n        curr = self.__find(num, prevs)\n        if not curr:\n            return False\n        self.__len -= 1   \n        for i in reversed(xrange(len(curr.nexts))):\n            prevs[i].nexts[i] = curr.nexts[i]\n            if not self.__head.nexts[i]:\n                self.__head.nexts.pop()\n        return True\n    \n    def __find(self, num, prevs):\n        if prevs:\n            candidate = prevs[0].nexts[0]\n            if candidate and candidate.num == num:\n                return candidate\n        return None\n\n    def __find_prev_nodes(self, num):\n        prevs = [None]*len(self.__head.nexts)\n        curr = self.__head\n        for i in reversed(xrange(len(self.__head.nexts))):\n            while curr.nexts[i] and curr.nexts[i].num < num:\n                curr = curr.nexts[i]\n            prevs[i] = curr\n        return prevs\n\n    def __random_level(self):\n        level = 1\n        while random.randint(1, Skiplist.P_DENOMINATOR) <= Skiplist.P_NUMERATOR and \\\n              level < Skiplist.MAX_LEVEL:\n            level += 1\n        return level\n\n    def __len__(self):\n        return self.__len\n    \n    def __str__(self):\n        result = []\n        for i in reversed(xrange(len(self.__head.nexts))):\n            result.append([])\n            curr = self.__head.nexts[i]\n            while curr:\n                result[-1].append(str(curr.num))\n                curr = curr.nexts[i]\n        return \"\\n\".join(map(lambda x: \"->\".join(x), result))\n"
    },
    {
        "problem_name": "design-snake-game",
        "solution": "# Time:  O(1) per move\n# Space: O(s), s is the current length of the snake.\n\nfrom collections import deque\n\nclass SnakeGame(object):\n\n    def __init__(self, width,height,food):\n        \"\"\"\n        Initialize your data structure here.\n        @param width - screen width\n        @param height - screen height\n        @param food - A list of food positions\n        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0].\n        :type width: int\n        :type height: int\n        :type food: List[List[int]]\n        \"\"\"\n        self.__width = width\n        self.__height = height\n        self.__score = 0\n        self.__f = 0\n        self.__food = food\n        self.__snake = deque([(0, 0)])\n        self.__direction = {\"U\": (-1, 0), \"L\": (0, -1), \"R\": (0, 1), \"D\": (1, 0)}\n        self.__lookup = {(0, 0)}\n\n    def move(self, direction):\n        \"\"\"\n        Moves the snake.\n        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down\n        @return The game's score after the move. Return -1 if game over.\n        Game over when snake crosses the screen boundary or bites its body.\n        :type direction: str\n        :rtype: int\n        \"\"\"\n        def valid(x, y):\n            return 0 <= x < self.__height and \\\n                   0 <= y < self.__width and \\\n                   (x, y) not in self.__lookup\n        d = self.__direction[direction]\n        x, y = self.__snake[-1][0] + d[0], self.__snake[-1][1] + d[1]\n        self.__lookup.remove(self.__snake[0])\n        tail = self.__snake.popleft()\n        if not valid(x, y):\n            return -1\n        elif self.__f != len(self.__food) and (self.__food[self.__f][0], self.__food[self.__f][1]) == (x, y):\n            self.__score += 1\n            self.__f += 1\n            self.__snake.appendleft(tail)\n            self.__lookup.add(tail)\n        self.__snake.append((x, y))\n        self.__lookup.add((x, y))\n        return self.__score\n\n"
    },
    {
        "problem_name": "design-sql",
        "solution": "# Time:  ctor:       O(t * max_m), t is the number of tables, max_m is the max number of columns in all tables\n#        insertRow:  O(m), m is the number of columns\n#        deleteRow:  O(1)\n#        selectCell: O(m)\n# Space: O(d), d is the total size of data\n\nimport itertools\n\n\n# hash table\nclass SQL(object):\n\n    def __init__(self, names, columns):\n        \"\"\"\n        :type names: List[str]\n        :type columns: List[int]\n        \"\"\"\n        self.__table = {name:[column] for name, column in itertools.izip(names, columns)}\n\n    def insertRow(self, name, row):\n        \"\"\"\n        :type name: str\n        :type row: List[str]\n        :rtype: None\n        \"\"\"\n        row.append(\"\")  # soft delete\n        self.__table[name].append(row)\n\n    def deleteRow(self, name, rowId):\n        \"\"\"\n        :type name: str\n        :type rowId: int\n        :rtype: None\n        \"\"\"\n        self.__table[name][rowId][-1] = \"deleted\"  # soft delete\n\n    def selectCell(self, name, rowId, columnId):\n        \"\"\"\n        :type name: str\n        :type rowId: int\n        :type columnId: int\n        :rtype: str\n        \"\"\"\n        return self.__table[name][rowId][columnId-1] if self.__table[name][rowId][-1] == \"\" else \"\"\n"
    },
    {
        "problem_name": "design-tic-tac-toe",
        "solution": "# Time:  O(1), per move.\n# Space: O(n^2)\n\n\nclass TicTacToe(object):\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize your data structure here.\n        :type n: int\n        \"\"\"\n        self.__size = n\n        self.__rows = [[0, 0] for _ in xrange(n)]\n        self.__cols = [[0, 0] for _ in xrange(n)]\n        self.__diagonal = [0, 0]\n        self.__anti_diagonal = [0, 0]\n\n    def move(self, row, col, player):\n        \"\"\"\n        Player {player} makes a move at ({row}, {col}).\n        @param row The row of the board.\n        @param col The column of the board.\n        @param player The player, can be either 1 or 2.\n        @return The current winning condition, can be either:\n                0: No one wins.\n                1: Player 1 wins.\n                2: Player 2 wins.\n        :type row: int\n        :type col: int\n        :type player: int\n        :rtype: int\n        \"\"\"\n        i = player - 1\n        self.__rows[row][i] += 1\n        self.__cols[col][i] += 1\n        if row == col:\n            self.__diagonal[i] += 1\n        if col == len(self.__rows) - row - 1:\n            self.__anti_diagonal[i] += 1\n        if any(self.__rows[row][i] == self.__size,\n               self.__cols[col][i] == self.__size,\n               self.__diagonal[i] == self.__size,\n               self.__anti_diagonal[i] == self.__size):\n            return player\n\n        return 0\n\n\n\n"
    },
    {
        "problem_name": "design-twitter",
        "solution": "# Time:  O(u + klogk), k is most recently number of tweets,\n#                      u is the number of the user's following.\n# Space: O(t + f), t is the total number of tweets,\n#                  f is the total number of followings.\n\nimport collections\nimport heapq\nimport random\n\n\nclass Twitter(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__number_of_most_recent_tweets = 10\n        self.__followings = collections.defaultdict(set)\n        self.__messages = collections.defaultdict(list)\n        self.__time = 0\n\n    def postTweet(self, userId, tweetId):\n        \"\"\"\n        Compose a new tweet.\n        :type userId: int\n        :type tweetId: int\n        :rtype: void\n        \"\"\"\n        self.__time += 1\n        self.__messages[userId].append((self.__time, tweetId))\n\n    def getNewsFeed(self, userId):\n        \"\"\"\n        Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n        :type userId: int\n        :rtype: List[int]\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        candidates = []\n        if self.__messages[userId]:\n            candidates.append((-self.__messages[userId][-1][0], userId, 0))\n        for uid in self.__followings[userId]:\n            if self.__messages[uid]:\n                candidates.append((-self.__messages[uid][-1][0], uid, 0))\n        nth_element(candidates, self.__number_of_most_recent_tweets-1)\n        max_heap = candidates[:self.__number_of_most_recent_tweets]\n        heapq.heapify(max_heap)\n        result = []\n        while max_heap and len(result) < self.__number_of_most_recent_tweets:\n            t, uid, curr = heapq.heappop(max_heap)\n            nxt = curr + 1\n            if nxt != len(self.__messages[uid]):\n                heapq.heappush(max_heap, (-self.__messages[uid][-(nxt+1)][0], uid, nxt))\n            result.append(self.__messages[uid][-(curr+1)][1])\n        return result\n\n    def follow(self, followerId, followeeId):\n        \"\"\"\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\n        :type followerId: int\n        :type followeeId: int\n        :rtype: void\n        \"\"\"\n        if followerId != followeeId:\n            self.__followings[followerId].add(followeeId)\n\n    def unfollow(self, followerId, followeeId):\n        \"\"\"\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n        :type followerId: int\n        :type followeeId: int\n        :rtype: void\n        \"\"\"\n        self.__followings[followerId].discard(followeeId)\n"
    },
    {
        "problem_name": "design-underground-system",
        "solution": "# Time:  ctor:       O(1)\n#        checkin:    O(1)\n#        checkout:   O(1)\n#        getaverage: O(1)\n# Space: O(n)\n\nimport collections\n\n\nclass UndergroundSystem(object):\n\n    def __init__(self):\n        self.__live = {}\n        self.__statistics = collections.defaultdict(lambda: [0, 0])\n        \n\n    def checkIn(self, id, stationName, t):\n        \"\"\"\n        :type id: int\n        :type stationName: str\n        :type t: int\n        :rtype: None\n        \"\"\"\n        self.__live[id] = (stationName, t)\n\n    def checkOut(self, id, stationName, t):\n        \"\"\"\n        :type id: int\n        :type stationName: str\n        :type t: int\n        :rtype: None\n        \"\"\"\n        startStation, startTime = self.__live.pop(id)\n        self.__statistics[startStation, stationName][0] += t-startTime\n        self.__statistics[startStation, stationName][1] += 1\n        \n    def getAverageTime(self, startStation, endStation):\n        \"\"\"\n        :type startStation: str\n        :type endStation: str\n        :rtype: float\n        \"\"\"\n        total_time, cnt = self.__statistics[startStation, endStation]\n        return float(total_time) / cnt\n"
    },
    {
        "problem_name": "design-video-sharing-platform",
        "solution": "# Time:  ctor:                O(1)\n#        upload:              O(logn+l)\n#        remove:              O(logn)\n#        like:                O(1)\n#        dislike:             O(1)\n#        view:                O(l)\n#        getLikesAndDislikes: O(1)\n#        getViews:            O(1)\n# Space: O(n * l), n = len(videos), l = max(len(v) for v in videos) \n\nimport heapq\n\n\n# design, heap\nclass VideoSharingPlatform(object):\n\n    def __init__(self):\n        self.__avails = []\n        self.__videos = []\n        self.__likes = []\n        self.__dislikes = []\n        self.__views = []\n\n    def upload(self, video):\n        \"\"\"\n        :type video: str\n        :rtype: int\n        \"\"\"\n        if self.__avails:\n            i = heapq.heappop(self.__avails)\n        else:\n            i = len(self.__videos)\n            self.__videos.append(None)\n            self.__likes.append(0)\n            self.__dislikes.append(0)\n            self.__views.append(0)\n        self.__videos[i] = video\n        return i\n        \n    def remove(self, videoId):\n        \"\"\"\n        :type videoId: int\n        :rtype: None\n        \"\"\"\n        if videoId >= len(self.__videos) or not self.__videos[videoId]:\n            return\n        heapq.heappush(self.__avails, videoId)\n        self.__videos[videoId] = None\n        self.__likes[videoId] = self.__dislikes[videoId] = self.__views[videoId] = 0\n        \n    def watch(self, videoId, startMinute, endMinute):\n        \"\"\"\n        :type videoId: int\n        :type startMinute: int\n        :type endMinute: int\n        :rtype: str\n        \"\"\"\n        if videoId >= len(self.__videos) or not self.__videos[videoId]:\n            return \"-1\"\n        self.__views[videoId] += 1\n        return self.__videos[videoId][startMinute:endMinute+1]\n\n    def like(self, videoId):\n        \"\"\"\n        :type videoId: int\n        :rtype: None\n        \"\"\"\n        if videoId >= len(self.__videos) or not self.__videos[videoId]:\n            return\n        self.__likes[videoId] += 1\n\n    def dislike(self, videoId):\n        \"\"\"\n        :type videoId: int\n        :rtype: None\n        \"\"\"\n        if videoId >= len(self.__videos) or not self.__videos[videoId]:\n            return\n        self.__dislikes[videoId] += 1\n\n    def getLikesAndDislikes(self, videoId):\n        \"\"\"\n        :type videoId: int\n        :rtype: List[int]\n        \"\"\"\n        if videoId >= len(self.__videos) or not self.__videos[videoId]:\n            return [-1]\n        return [self.__likes[videoId], self.__dislikes[videoId]]\n\n    def getViews(self, videoId):\n        \"\"\"\n        :type videoId: int\n        :rtype: int\n        \"\"\"\n        if videoId >= len(self.__videos) or not self.__videos[videoId]:\n            return -1\n        return self.__views[videoId]\n"
    },
    {
        "problem_name": "destination-city",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport itertools\n\n\nclass Solution(object):\n    def destCity(self, paths):\n        \"\"\"\n        :type paths: List[List[str]]\n        :rtype: str\n        \"\"\"\n        A, B = map(set, itertools.izip(*paths))\n        return (B-A).pop()\n"
    },
    {
        "problem_name": "destroy-sequential-targets",
        "solution": "# Time:  O(n)\n# Space: O(s), s is the value of space\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def destroyTargets(self, nums, space):\n        \"\"\"\n        :type nums: List[int]\n        :type space: int\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(x%space for x in nums)\n        mx = max(cnt.itervalues())\n        return min(x for x in nums if cnt[x%space] == mx)\n"
    },
    {
        "problem_name": "destroying-asteroids",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def asteroidsDestroyed(self, mass, asteroids):\n        \"\"\"\n        :type mass: int\n        :type asteroids: List[int]\n        :rtype: bool\n        \"\"\"\n        asteroids.sort()\n        for x in asteroids:\n            if x > mass:\n                return False\n            mass += min(x, asteroids[-1]-mass)\n        return True\n"
    },
    {
        "problem_name": "detect-capital",
        "solution": "# Time:  O(l)\n# Space: O(1)\n\nclass Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        return word.isupper() or word.islower() or word.istitle()\n\n"
    },
    {
        "problem_name": "detect-cycles-in-2d-grid",
        "solution": "# Time:  O(m * n * \u03b1(n)) ~= O(m * n)\n# Space: O(m * n)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n       if self.set[x] != x:\n           self.set[x] = self.find_set(self.set[x])  # path compression.\n       return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n            self.count -= 1\n\n\nclass Solution(object):\n    def containsCycle(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        def index(n, i, j):\n            return i*n + j\n    \n        union_find = UnionFind(len(grid)*len(grid[0]))\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if i and j and grid[i][j] == grid[i-1][j] == grid[i][j-1] and \\\n                   union_find.find_set(index(len(grid[0]), i-1, j)) == \\\n                   union_find.find_set(index(len(grid[0]), i, j-1)):\n                    return True\n                if i and grid[i][j] == grid[i-1][j]:\n                    union_find.union_set(index(len(grid[0]), i-1, j),\n                                         index(len(grid[0]),i, j))\n                if j and grid[i][j] == grid[i][j-1]:\n                    union_find.union_set(index(len(grid[0]), i, j-1),\n                                         index(len(grid[0]), i, j))\n        return False\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\nclass Solution2(object):\n    def containsCycle(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if not grid[i][j]:\n                    continue\n                val = grid[i][j]\n                q = [(i, j)]\n                while q:\n                    new_q = []\n                    for r, c in q:\n                        if not grid[r][c]:\n                            return True\n                        grid[r][c] = 0\n                        for dr, dc in directions:\n                            nr, nc = r+dr, c+dc\n                            if not (0 <= nr < len(grid) and\n                                    0 <= nc < len(grid[0]) and\n                                    grid[nr][nc] == val):\n                                continue\n                            new_q.append((nr, nc))\n                    q = new_q\n        return False\n"
    },
    {
        "problem_name": "detect-pattern-of-length-m-repeated-k-or-more-times",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def containsPattern(self, arr, m, k):\n        \"\"\"\n        :type arr: List[int]\n        :type m: int\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        cnt = 0\n        for i in xrange(len(arr)-m):\n            if arr[i] != arr[i+m]:\n                cnt = 0\n                continue\n            cnt += 1\n            if cnt == (k-1)*m:\n                return True\n        return False\n"
    },
    {
        "problem_name": "detect-squares",
        "solution": "# Time:  ctor:  O(1)\n#        add:   O(1)\n#        count: O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass DetectSquares(object):\n\n    def __init__(self):\n        self.__x_to_ys = collections.defaultdict(set)\n        self.__point_counts = collections.defaultdict(int)\n\n    def add(self, point):\n        \"\"\"\n        :type point: List[int]\n        :rtype: None\n        \"\"\"\n        self.__x_to_ys[point[0]].add(point[1])\n        self.__point_counts[tuple(point)] += 1\n        \n\n    def count(self, point):\n        \"\"\"\n        :type point: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for y in self.__x_to_ys[point[0]]:\n            if y == point[1]:\n                continue\n            dy = y-point[1]\n            result += self.__point_counts[(point[0], y)]*self.__point_counts[(point[0]+dy, point[1])]*self.__point_counts[(point[0]+dy, y)]\n            result += self.__point_counts[(point[0], y)]*self.__point_counts[(point[0]-dy, point[1])]*self.__point_counts[(point[0]-dy, y)]\n        return result \n\n\n# Time:  ctor:  O(1)\n#        add:   O(1)\n#        count: O(n)\n# Space: O(n)\nimport collections\n\n\nclass DetectSquares2(object):\n\n    def __init__(self):\n        self.__points = []\n        self.__point_counts = collections.defaultdict(int)\n\n    def add(self, point):\n        \"\"\"\n        :type point: List[int]\n        :rtype: None\n        \"\"\"\n        self.__points.append(point)\n        self.__point_counts[tuple(point)] += 1\n\n    def count(self, point):\n        \"\"\"\n        :type point: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for x, y in self.__points:\n            if not (point[0] != x and point[1] != y and (abs(point[0]-x) == abs(point[1]-y))):\n                continue\n            result += self.__point_counts[(point[0], y)]*self.__point_counts[(x, point[1])]\n        return result\n"
    },
    {
        "problem_name": "determine-color-of-a-chessboard-square",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def squareIsWhite(self, coordinates):\n        \"\"\"\n        :type coordinates: str\n        :rtype: bool\n        \"\"\"\n        return (ord(coordinates[0])-ord('a'))%2 != (ord(coordinates[1])-ord('1'))%2\n"
    },
    {
        "problem_name": "determine-if-a-cell-is-reachable-at-a-given-time",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# constructive algorithms, math\nclass Solution(object):\n    def isReachableAtTime(self, sx, sy, fx, fy, t):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type fx: int\n        :type fy: int\n        :type t: int\n        :rtype: bool\n        \"\"\"\n        diff1, diff2 = abs(sx-fx), abs(sy-fy)\n        mn = min(diff1, diff2)+abs(diff1-diff2)\n        return t >= mn if mn else t != 1\n"
    },
    {
        "problem_name": "determine-if-string-halves-are-alike",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def halvesAreAlike(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        vowels = set(\"aeiouAEIOU\")\n        cnt1 = cnt2 = 0\n        left, right = 0, len(s)-1\n        while left < right:\n            cnt1 += s[left] in vowels\n            cnt2 += s[right] in vowels\n            left += 1\n            right -= 1\n        return cnt1 == cnt2\n"
    },
    {
        "problem_name": "determine-if-two-events-have-conflict",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def haveConflict(self, event1, event2):\n        \"\"\"\n        :type event1: List[str]\n        :type event2: List[str]\n        :rtype: bool\n        \"\"\"\n        return max(event1[0], event2[0]) <= min(event1[1], event2[1])\n"
    },
    {
        "problem_name": "determine-if-two-strings-are-close",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def closeStrings(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: bool\n        \"\"\"\n        if len(word1) != len(word2):\n            return False \n        \n        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)   # Reuse of keys\n        return set(cnt1.iterkeys()) == set(cnt2.iterkeys()) and \\\n               collections.Counter(cnt1.itervalues()) == collections.Counter(cnt2.itervalues())\n"
    },
    {
        "problem_name": "determine-the-minimum-sum-of-a-k-avoiding-array",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# constructive algorithms, math\nclass Solution(object):\n    def minimumSum(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def arithmetic_progression_sum(a, d, n):\n            return (a+(a+(n-1)*d))*n//2\n    \n        a = min(k//2, n)\n        b = n-a\n        return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(k, 1, b)\n"
    },
    {
        "problem_name": "determine-the-winner-of-a-bowling-game",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def isWinner(self, player1, player2):\n        \"\"\"\n        :type player1: List[int]\n        :type player2: List[int]\n        :rtype: int\n        \"\"\"\n        k = 2\n        def f(arr):\n            result = cnt = 0\n            for i in xrange(len(arr)):\n                result += 2*arr[i] if cnt else arr[i]\n                cnt += (arr[i] == 10)\n                if i-k >= 0:\n                    cnt -= (arr[i-k] == 10)\n            return result\n\n        a, b = f(player1), f(player2)\n        return 1 if a > b else 2 if a < b else 0\n"
    },
    {
        "problem_name": "determine-whether-matrix-can-be-obtained-by-rotation",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def findRotation(self, mat, target):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type target: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        checks = [lambda i, j: mat[i][j] == target[i][j],\n                  lambda i, j: mat[i][j] == target[j][-1-i],\n                  lambda i, j: mat[i][j] == target[-1-i][-1-j],\n                  lambda i, j: mat[i][j] == target[-1-j][i]]\n        traverse = lambda check: all(check(i, j) for i in xrange(len(mat)) for j in xrange(len(mat[0])))\n        return any(traverse(check) for check in checks)\n"
    },
    {
        "problem_name": "detonate-the-maximum-bombs",
        "solution": "# Time:  O(|V|^2 + |V| * |E|)\n# Space: O(|V| + |E|)\n\n# bfs solution\nclass Solution(object):\n    def maximumDetonation(self, bombs):\n        \"\"\"\n        :type bombs: List[List[int]]\n        :rtype: int\n        \"\"\"        \n        adj = [[] for _ in xrange(len(bombs))]\n        for i, (xi, yi, ri) in enumerate(bombs):\n            for j, (xj, yj, _) in enumerate(bombs):\n                if j == i:\n                    continue\n                if (xi-xj)**2+(yi-yj)**2 <= ri**2:\n                    adj[i].append(j)\n        result = 0\n        for i in xrange(len(bombs)):\n            q = [i]\n            lookup = {i}\n            while q:\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if v in lookup:\n                            continue\n                        lookup.add(v)\n                        new_q.append(v)\n                q = new_q\n            result = max(result, len(lookup))\n            if result == len(bombs):\n                break\n        return result\n\n\n# Time:  O(|V|^2 + |V| * |E|)\n# Space: O(|V| + |E|)\n# dfs solution\nclass Solution2(object):\n    def maximumDetonation(self, bombs):\n        \"\"\"\n        :type bombs: List[List[int]]\n        :rtype: int\n        \"\"\"        \n        adj = [[] for _ in xrange(len(bombs))]\n        for i, (xi, yi, ri) in enumerate(bombs):\n            for j, (xj, yj, _) in enumerate(bombs):\n                if j == i:\n                    continue\n                if (xi-xj)**2+(yi-yj)**2 <= ri**2:\n                    adj[i].append(j)\n        result = 0\n        for i in xrange(len(bombs)):\n            stk = [i]\n            lookup = {i}\n            while stk:\n                u = stk.pop()\n                for v in adj[u]:\n                    if v in lookup:\n                        continue\n                    lookup.add(v)\n                    stk.append(v)\n            result = max(result, len(lookup))\n            if result == len(bombs):\n                break\n        return result\n"
    },
    {
        "problem_name": "di-string-match",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def diStringMatch(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        left, right = 0, len(S)\n        for c in S:\n            if c == 'I':\n                result.append(left)\n                left += 1\n            else:\n                result.append(right)\n                right -= 1\n        result.append(left)\n        return result\n"
    },
    {
        "problem_name": "diagonal-traverse-ii",
        "solution": "# Time:  O(m * n)\n# Space: O(m)\n\nimport itertools\nimport collections\n\n\nclass Solution(object):\n    def findDiagonalOrder(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result, dq, col = [], collections.deque(), 0\n        for i in xrange(len(nums)+max(itertools.imap(len, nums))-1):\n            new_dq = collections.deque()\n            if i < len(nums):\n                dq.appendleft((i, 0))\n            for r, c in dq:\n                result.append(nums[r][c])\n                if c+1 < len(nums[r]):\n                    new_dq.append((r, c+1))\n            dq = new_dq\n        return result\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\nclass Solution2(object):\n    def findDiagonalOrder(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for r, row in enumerate(nums):\n            for c, num in enumerate(row):\n                if len(result) <= r+c:\n                    result.append([])\n                result[r+c].append(num)\n        return [num for row in result for num in reversed(row)]\n"
    },
    {
        "problem_name": "diagonal-traverse",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def findDiagonalOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return []\n\n        result = []\n        row, col, d = 0, 0, 0\n        dirs = [(-1, 1), (1, -1)]\n\n        for i in xrange(len(matrix) * len(matrix[0])):\n            result.append(matrix[row][col])\n            row += dirs[d][0]\n            col += dirs[d][1]\n\n            if row >= len(matrix):\n                row = len(matrix) - 1\n                col += 2\n                d = 1 - d\n            elif col >= len(matrix[0]):\n                col = len(matrix[0]) - 1\n                row += 2\n                d = 1 - d\n            elif row < 0:\n                row = 0\n                d = 1 - d\n            elif col < 0:\n                col = 0\n                d = 1 - d\n\n        return result\n\n\n"
    },
    {
        "problem_name": "diameter-of-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def iter_dfs(node):\n            result = 0\n            stk = [(1, [node, [0]])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    result = max(result, ret1[0]+ret2[0])\n                    ret[0] = 1+max(ret1[0], ret2[0])\n            return result\n        \n        return iter_dfs(root)\n\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(root):\n            if not root: \n                return 0, 0\n            left_d, left_h = dfs(root.left)\n            right_d, right_h = dfs(root.right)\n            return max(left_d, right_d, left_h+right_h), 1+max(left_h, right_h)\n \n        return dfs(root)[0]\n"
    },
    {
        "problem_name": "diameter-of-n-ary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\n\nclass Solution(object):\n    def diameter(self, root):\n        \"\"\"\n        :type root: 'Node'\n        :rtype: int\n        \"\"\"\n        def iter_dfs(root):\n            result = [0]*2\n            stk = [(1, (root, result))]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    for child in reversed(node.children):\n                        ret2 = [0]*2\n                        stk.append((2, (ret2, ret)))\n                        stk.append((1, (child, ret2)))\n                else:\n                    ret2, ret = params\n                    ret[0] = max(ret[0], ret2[0], ret[1]+ret2[1]+1)\n                    ret[1] = max(ret[1], ret2[1]+1)\n            return result\n        \n        return iter_dfs(root)[0]\n\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def diameter(self, root):\n        \"\"\"\n        :type root: 'Node'\n        :rtype: int\n        \"\"\"\n        def dfs(node):\n            max_dia, max_depth = 0, 0\n            for child in node.children:\n                child_max_dia, child_max_depth = dfs(child)\n                max_dia = max(max_dia, child_max_dia, max_depth+child_max_depth+1)\n                max_depth = max(max_depth, child_max_depth+1)\n            return max_dia, max_depth\n        \n        return dfs(root)[0]\n"
    },
    {
        "problem_name": "dice-roll-simulation",
        "solution": "# Time:  O(m * n), m is the max of rollMax\n# Space: O(m)\n\nclass Solution(object):\n    def dieSimulator(self, n, rollMax):\n        \"\"\"\n        :type n: int\n        :type rollMax: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def sum_mod(array):\n            return reduce(lambda x, y: (x+y)%MOD, array)\n\n        dp = [[1] + [0]*(rollMax[i]-1) for i in xrange(6)]  # 0-indexed\n        for _ in xrange(n-1):\n            new_dp = [[0]*rollMax[i] for i in xrange(6)]\n            for i in xrange(6):\n                for k in xrange(rollMax[i]):\n                    for j in xrange(6):\n                        if i == j:\n                            if k < rollMax[i]-1:  # 0-indexed\n                                new_dp[j][k+1] = (new_dp[j][k+1]+dp[i][k])%MOD\n                        else:\n                            new_dp[j][0] = (new_dp[j][0]+dp[i][k])%MOD\n            dp = new_dp\n        return sum_mod(sum_mod(row) for row in dp)\n"
    },
    {
        "problem_name": "diet-plan-performance",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def dietPlanPerformance(self, calories, k, lower, upper):\n        \"\"\"\n        :type calories: List[int]\n        :type k: int\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        total = sum(itertools.islice(calories, 0, k))\n        result = int(total > upper)-int(total < lower)\n        for i in xrange(k, len(calories)):\n            total += calories[i]-calories[i-k]\n            result += int(total > upper)-int(total < lower)\n        return result\n"
    },
    {
        "problem_name": "difference-between-element-sum-and-digit-sum-of-an-array",
        "solution": "# Time:  O(nlogr), r = max(nums)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def differenceOfSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def total(x):\n            result = 0\n            while x:\n                result += x%10\n                x //= 10\n            return result\n\n        return abs(sum(nums)-sum(total(x) for x in nums))\n"
    },
    {
        "problem_name": "difference-between-maximum-and-minimum-price-sum",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# iterative dfs, tree dp\nclass Solution(object):\n    def maxOutput(self, n, edges, price):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type price: List[int]\n        :rtype: int\n        \"\"\"\n        def iter_dfs():\n            result = 0\n            stk = [(1, (0, -1, [price[0], 0]))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    u, p, ret = args\n                    stk.append((2, (u, p, ret, 0)))\n                elif step == 2:\n                    u, p, ret, i = args\n                    if i == len(adj[u]):\n                        continue\n                    stk.append((2, (u, p, ret, i+1)))\n                    v = adj[u][i]\n                    if v == p:\n                        continue\n                    new_ret = [price[v], 0]  # [max_path_sum, max_path_sum_without_last_node]\n                    stk.append((3, (u, new_ret, ret)))\n                    stk.append((1, (v, u, new_ret)))\n                elif step == 3:\n                    u, new_ret, ret = args\n                    result = max(result, ret[0]+new_ret[1], ret[1]+new_ret[0])\n                    ret[0] = max(ret[0], new_ret[0]+price[u])\n                    ret[1] = max(ret[1], new_ret[1]+price[u])\n            return result\n        \n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return iter_dfs()\n\n\n# Time:  O(n)\n# Space: O(n)\n# dfs, tree dp\nclass Solution2(object):\n    def maxOutput(self, n, edges, price):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type price: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(u, p):\n            dp = [price[u], 0]  # [max_path_sum, max_path_sum_without_last_node]\n            for v in adj[u]:\n                if v == p:\n                    continue\n                new_dp = dfs(v, u)\n                result[0] = max(result[0], dp[0]+new_dp[1], dp[1]+new_dp[0])\n                dp[0] = max(dp[0], new_dp[0]+price[u])\n                dp[1] = max(dp[1], new_dp[1]+price[u])\n            return dp\n        \n        result = [0]\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        dfs(0, -1)\n        return result[0]\n\n\n# Time:  O(n)\n# Space: O(n)\n# iterative dfs, tree dp\nclass Solution3(object):\n    def maxOutput(self, n, edges, price):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type price: List[int]\n        :rtype: int\n        \"\"\"\n        def iter_dfs():\n            dp = [0]*n  # max_sum\n            stk = [(1, 0, -1)]\n            while stk:\n                step, u, p = stk.pop()\n                if step == 1:\n                    stk.append((2, u, p))\n                    for v in adj[u]:\n                        if v == p:\n                            continue\n                        stk.append((1, v, u))\n                elif step == 2:\n                    dp[u] = price[u]\n                    for v in adj[u]:\n                        if v == p:\n                            continue\n                        dp[u] = max(dp[u], dp[v]+price[u])\n            return dp\n        \n        def iter_dfs2():\n            result = 0\n            stk = [(0, -1, 0)]\n            while stk:\n                u, p, curr = stk.pop()\n                result = max(result, curr, dp[u]-price[u])\n                top2 = [[curr, p], [0, -1]]\n                for v in adj[u]:\n                    if v == p:\n                        continue\n                    curr = [dp[v], v]\n                    for i in xrange(len(top2)):\n                        if curr > top2[i]:\n                            top2[i], curr = curr, top2[i]\n                for v in adj[u]:\n                    if v == p:\n                        continue\n                    stk.append((v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u]))\n            return result\n    \n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        dp = iter_dfs()\n        return iter_dfs2()\n\n\n# Time:  O(n)\n# Space: O(n)\n# dfs, tree dp\nclass Solution4(object):\n    def maxOutput(self, n, edges, price):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type price: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(u, p):\n            dp[u] = price[u]\n            for v in adj[u]:\n                if v == p:\n                    continue\n                dp[u] = max(dp[u], dfs(v, u)+price[u])\n            return dp[u]\n        \n        def dfs2(u, p, curr):\n            result[0] = max(result[0], curr, dp[u]-price[u])\n            top2 = [[curr, p], [0, -1]]\n            for v in adj[u]:\n                if v == p:\n                    continue\n                curr = [dp[v], v]\n                for i in xrange(len(top2)):\n                    if curr > top2[i]:\n                        top2[i], curr = curr, top2[i]\n            for v in adj[u]:\n                if v == p:\n                    continue\n                dfs2(v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u])\n    \n        result = [0]\n        dp = [0]*n  # max_sum\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        dfs(0, -1)\n        dfs2(0, -1, 0)\n        return result[0]\n"
    },
    {
        "problem_name": "difference-between-ones-and-zeros-in-row-and-column",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\n# array\nclass Solution(object):\n    def onesMinusZeros(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        rows = [sum(grid[i][j] for j in xrange(len(grid[0]))) for i in xrange(len(grid))]\n        cols = [sum(grid[i][j] for i in xrange(len(grid))) for j in xrange(len(grid[0]))]\n        return [[rows[i]+cols[j]-(len(grid)-rows[i])-(len(grid[0])-cols[j]) for j in xrange(len(grid[0]))] for i in xrange(len(grid))]\n"
    },
    {
        "problem_name": "difference-of-number-of-distinct-values-on-diagonals",
        "solution": "# Time:  O(m * n)\n# Space: O(min(m, n))\n\n# prefix sum\nclass Solution(object):\n    def differenceOfDistinctValues(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def update(i, j):\n            lookup = set()\n            for k in xrange(min(len(grid)-i, len(grid[0])-j)):\n                result[i+k][j+k] = len(lookup)\n                lookup.add(grid[i+k][j+k])\n            lookup.clear()\n            for k in reversed(xrange(min(len(grid)-i, len(grid[0])-j))):\n                result[i+k][j+k] = abs(result[i+k][j+k]-len(lookup))\n                lookup.add(grid[i+k][j+k])\n\n        result = [[0]*len(grid[0]) for _ in xrange(len(grid))]\n        for j in xrange(len(grid[0])):\n            update(0, j)\n        for i in xrange(1, len(grid)):\n            update(i, 0)\n        return result\n"
    },
    {
        "problem_name": "different-ways-to-add-parentheses",
        "solution": "# Time:  O(n * 4^n / n^(3/2)) ~= n * Catalan numbers = n * (C(2n, n) - C(2n, n - 1)),\n#                                due to the size of the results is Catalan numbers,\n#                                and every way of evaluation is the length of the string,\n#                                so the time complexity is at most n * Catalan numbers.\n# Space: O(n * 4^n / n^(3/2)), the cache size of lookup is at most n * Catalan numbers.\n\nimport operator\nimport re\n\n\nclass Solution(object):\n    # @param {string} input\n    # @return {integer[]}\n    def diffWaysToCompute(self, input):\n        tokens = re.split('(\\D)', input)\n        nums = map(int, tokens[::2])\n        ops = map({'+': operator.add, '-': operator.sub, '*': operator.mul}.get, tokens[1::2])\n        lookup = [[None for _ in xrange(len(nums))] for _ in xrange(len(nums))]\n\n        def diffWaysToComputeRecu(left, right):\n            if left == right:\n                return [nums[left]]\n            if lookup[left][right]:\n                return lookup[left][right]\n            lookup[left][right] = [ops[i](x, y)\n                                   for i in xrange(left, right)\n                                   for x in diffWaysToComputeRecu(left, i)\n                                   for y in diffWaysToComputeRecu(i + 1, right)]\n            return lookup[left][right]\n\n        return diffWaysToComputeRecu(0, len(nums) - 1)\n\nclass Solution2(object):\n    # @param {string} input\n    # @return {integer[]}\n    def diffWaysToCompute(self, input):\n        lookup = [[None for _ in xrange(len(input) + 1)] for _ in xrange(len(input) + 1)]\n        ops = {'+': operator.add, '-': operator.sub, '*': operator.mul}\n\n        def diffWaysToComputeRecu(left, right):\n            if lookup[left][right]:\n                return lookup[left][right]\n            result = []\n            for i in xrange(left, right):\n                if input[i] in ops:\n                    for x in diffWaysToComputeRecu(left, i):\n                        for y in diffWaysToComputeRecu(i + 1, right):\n                            result.append(ops[input[i]](x, y))\n\n            if not result:\n                result = [int(input[left:right])]\n            lookup[left][right] = result\n            return lookup[left][right]\n\n        return diffWaysToComputeRecu(0, len(input))\n\n"
    },
    {
        "problem_name": "digit-count-in-range",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def digitsCount(self, d, low, high):\n        \"\"\"\n        :type d: int\n        :type low: int\n        :type high: int\n        :rtype: int\n        \"\"\"\n        def digitsCount(n, k):\n            pivot, result = 1, 0\n            while n >= pivot:\n                result += (n//(10*pivot))*pivot + \\\n                           min(pivot, max(n%(10*pivot) - k*pivot + 1, 0))\n                if k == 0:\n                    result -= pivot\n                pivot *= 10\n            return result+1\n        \n        return digitsCount(high, d) - digitsCount(low-1, d)\n"
    },
    {
        "problem_name": "dinner-plate-stacks",
        "solution": "# Time:  push: O(logn)\n#        pop:  O(1), amortized\n#        popAtStack: O(logn)\n# Space: O(n * c)\n\nimport heapq\n\n\nclass DinnerPlates(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.__stks = []\n        self.__c = capacity\n        self.__min_heap = []\n\n    def push(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if self.__min_heap:\n            l = heapq.heappop(self.__min_heap)\n            if l < len(self.__stks):\n                self.__stks[l].append(val)\n                return\n            self.__min_heap = []  # nothing is valid in min heap\n        if not self.__stks or len(self.__stks[-1]) == self.__c:\n            self.__stks.append([])\n        self.__stks[-1].append(val)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.__stks and not self.__stks[-1]:\n            self.__stks.pop()\n        if not self.__stks:\n            return -1\n        return self.__stks[-1].pop()\n\n    def popAtStack(self, index):\n        \"\"\"\n        :type index: int\n        :rtype: int\n        \"\"\"\n        if index >= len(self.__stks) or not self.__stks[index]:\n            return -1\n        heapq.heappush(self.__min_heap, index)\n        return self.__stks[index].pop()\n"
    },
    {
        "problem_name": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\n# dp\nclass Solution(object):\n    def isPossibleToCutPath(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if (i, j) == (0, 0) or grid[i][j] == 0:\n                    continue\n                if (i-1 < 0 or grid[i-1][j] == 0) and (j-1 < 0 or grid[i][j-1] == 0):\n                    grid[i][j] = 0\n        for i in reversed(xrange(len(grid))):\n            for j in reversed(xrange(len(grid[0]))):\n                if (i, j) == (len(grid)-1, len(grid[0])-1) or grid[i][j] == 0:\n                    continue\n                if (i+1 >= len(grid) or grid[i+1][j] == 0) and (j+1 >= len(grid[0]) or grid[i][j+1] == 0):\n                    grid[i][j] = 0\n        cnt = [0]*(len(grid)+len(grid[0])-1)\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                cnt[i+j] += grid[i][j]\n        return any(cnt[i] <= 1 for i in xrange(1, len(grid)+len(grid[0])-2))\n\n\n# Time:  O(m * n)\n# Space: O(m + n)\n# iterative dfs\nclass Solution2(object):\n    def isPossibleToCutPath(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        def iter_dfs():\n            stk = [(0, 0)]\n            while stk:\n                i, j = stk.pop()\n                if not (i < len(grid) and j < len(grid[0]) and grid[i][j]):\n                    continue\n                if (i, j) == (len(grid)-1, len(grid[0])-1):\n                    return True\n                if (i, j) != (0, 0):\n                    grid[i][j] = 0\n                stk.append((i, j+1))\n                stk.append((i+1, j))  \n            return False\n\n        return not iter_dfs() or not iter_dfs()\n\n\n# Time:  O(m * n)\n# Space: O(m + n)\n# dfs\nclass Solution3(object):\n    def isPossibleToCutPath(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        def dfs(i, j):\n            if not (i < len(grid) and j < len(grid[0]) and grid[i][j]):\n                return False\n            if (i, j) == (len(grid)-1, len(grid[0])-1):\n                return True\n            if (i, j) != (0, 0):\n                grid[i][j] = 0\n            return dfs(i+1, j) or dfs(i, j+1)\n\n        return not dfs(0, 0) or not dfs(0, 0)\n"
    },
    {
        "problem_name": "display-table-of-food-orders-in-a-restaurant",
        "solution": "# Time:  O(n + tlogt + flogf)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def displayTable(self, orders):\n        \"\"\"\n        :type orders: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n        table_count = collections.defaultdict(collections.Counter)\n        for _, table, food in orders:\n            table_count[int(table)][food] += 1\n        foods = sorted({food for _, _, food in orders})\n        result = [[\"Table\"]]\n        result[0].extend(foods)\n        for table in sorted(table_count):\n            result.append([str(table)])\n            result[-1].extend(str(table_count[table][food]) for food in foods)\n        return result\n"
    },
    {
        "problem_name": "distance-between-bus-stops",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def distanceBetweenBusStops(self, distance, start, destination):\n        \"\"\"\n        :type distance: List[int]\n        :type start: int\n        :type destination: int\n        :rtype: int\n        \"\"\"\n        if start > destination:\n            start, destination = destination, start\n        s_to_d = sum(itertools.islice(distance, start, destination))\n        d_to_s = sum(itertools.islice(distance, 0, start)) + \\\n                 sum(itertools.islice(distance, destination, len(distance)))\n        return min(s_to_d, d_to_s)\n"
    },
    {
        "problem_name": "distance-to-a-cycle-in-undirected-graph",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|V| + |E|)\n\n# graph, dfs, bfs\nclass Solution(object):\n    def distanceToCycle(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def cycle(parent, v, u):\n            result = [parent[v], v]\n            while u != parent[v]:\n                result.append(u)\n                u = parent[u]\n            return result\n    \n        def iter_dfs(adj):\n            stk = [0]\n            parent = [-2]*len(adj)\n            parent[0] = -1\n            while stk:\n                u = stk.pop()\n                for v in reversed(adj[u]):\n                    if parent[v] != -2:\n                        if v == parent[u]:\n                            continue\n                        return cycle(parent, v, u)\n                    parent[v] = u\n                    stk.append(v)\n\n        def bfs(adj, q):\n            result = [-1]*n\n            for x in q:\n                result[x] = 0\n            d = 1\n            while q:\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if result[v] != -1:\n                            continue\n                        result[v] = d\n                        new_q.append(v)\n                q = new_q\n                d += 1\n            return result\n    \n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return bfs(adj, iter_dfs(adj))\n"
    },
    {
        "problem_name": "distant-barcodes",
        "solution": "# Time:  O(n), k is the number of distinct barcodes\n# Space: O(k)\n\nimport collections\nimport itertools\n\n\nclass Solution(object):\n    def rearrangeBarcodes(self, barcodes):\n        \"\"\"\n        :type barcodes: List[int]\n        :rtype: List[int]\n        \"\"\"\n        k = 2\n        cnts = collections.Counter(barcodes)\n        bucket_cnt = max(cnts.itervalues())\n        result = [0]*len(barcodes)\n        i = (len(barcodes)-1)%k\n        for c in itertools.chain((c for c, v in cnts.iteritems() if v == bucket_cnt), (c for c, v in cnts.iteritems() if v != bucket_cnt)):\n            for _ in xrange(cnts[c]):\n                result[i] = c\n                i += k\n                if i >= len(result):\n                    i = (i-1)%k\n        return result\n\n    \n# Time:  O(n + klogk), k is the number of distinct barcodes\n# Space: O(k)\nimport collections\n\n\nclass Solution2(object):\n    def rearrangeBarcodes(self, barcodes):\n        \"\"\"\n        :type barcodes: List[int]\n        :rtype: List[int]\n        \"\"\"\n        cnts = collections.Counter(barcodes)\n        sorted_cnts = [[v, k] for k, v in cnts.iteritems()]\n        sorted_cnts.sort(reverse=True)\n\n        i = 0\n        for v, k in sorted_cnts:\n            for _ in xrange(v):\n                barcodes[i] = k\n                i += 2\n                if i >= len(barcodes):\n                    i = 1\n        return barcodes\n"
    },
    {
        "problem_name": "distinct-echo-substrings",
        "solution": "# Time:  O(n^2 + d), d is the duplicated of result substrings size\n# Space: O(r), r is the size of result substrings set\n\nclass Solution(object):\n    def distinctEchoSubstrings(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: int\n        \"\"\"\n        def KMP(text, l, result):\n            prefix = [-1]*(len(text)-l)\n            j = -1\n            for i in xrange(1, len(prefix)):\n                while j > -1 and text[l+j+1] != text[l+i]:\n                    j = prefix[j]\n                if text[l+j+1] == text[l+i]:\n                    j += 1\n                prefix[i] = j\n                if (j+1) and (i+1) % ((i+1) - (j+1)) == 0 and \\\n                   (i+1) // ((i+1) - (j+1)) % 2 == 0:\n                    result.add(text[l:l+i+1])\n            return len(prefix)-(prefix[-1]+1) \\\n                   if prefix[-1]+1 and len(prefix) % (len(prefix)-(prefix[-1]+1)) == 0 \\\n                   else float(\"inf\")\n\n        result = set()\n        i, l = 0, len(text)-1\n        while i < l:  # aaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcdefabcdefabcdef\n            l = min(l, i + KMP(text, i, result));\n            i += 1\n        return len(result)\n\n\n# Time:  O(n^2 + d), d is the duplicated of result substrings size\n# Space: O(r), r is the size of result substrings set\nclass Solution2(object):\n    def distinctEchoSubstrings(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: int\n        \"\"\"\n        result = set()\n        for l in xrange(1, len(text)//2+1):\n            count = sum(text[i] == text[i+l] for i in xrange(l))\n            for i in xrange(len(text)-2*l):\n                if count == l:\n                    result.add(text[i:i+l])\n                count += (text[i+l] == text[i+l+l]) - (text[i] == text[i+l])\n            if count == l:\n                result.add(text[len(text)-2*l:len(text)-2*l+l])\n        return len(result)\n\n\n# Time:  O(n^2 + d), d is the duplicated of result substrings size\n# Space: O(r), r is the size of result substrings set\nclass Solution3(object):\n    def distinctEchoSubstrings(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        D = 27  # a-z and ''\n        result = set()\n        for i in xrange(len(text)-1):\n            left, right, pow_D = 0, 0, 1\n            for l in xrange(1, min(i+2, len(text)-i)):\n                left = (D*left + (ord(text[i-l+1])-ord('a')+1)) % MOD\n                right = (pow_D*(ord(text[i+l])-ord('a')+1) + right) % MOD\n                if left == right:  # assumed no collision\n                    result.add(left)\n                pow_D = (pow_D*D) % MOD \n        return len(result)\n\n\n# Time:  O(n^3 + d), d is the duplicated of result substrings size\n# Space: O(r), r is the size of result substrings set\nclass Solution_TLE(object):\n    def distinctEchoSubstrings(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: int\n        \"\"\"\n        def compare(text, l, s1, s2):\n            for i in xrange(l):\n                if text[s1+i] != text[s2+i]:\n                    return False\n            return True\n\n        MOD = 10**9+7\n        D = 27  # a-z and ''\n        result = set()\n        for i in xrange(len(text)):\n            left, right, pow_D = 0, 0, 1\n            for l in xrange(1, min(i+2, len(text)-i)):\n                left = (D*left + (ord(text[i-l+1])-ord('a')+1)) % MOD\n                right = (pow_D*(ord(text[i+l])-ord('a')+1) + right) % MOD\n                if left == right and compare(text, l, i-l+1, i+1):\n                    result.add(text[i+1:i+1+l])\n                pow_D = (pow_D*D) % MOD \n        return len(result)\n"
    },
    {
        "problem_name": "distinct-numbers-in-each-subarray",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\nimport collections\n\n\nclass Solution(object):\n    def distinctNumbers(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        count = collections.Counter()\n        for i, num in enumerate(nums):\n            count[num] += 1\n            if i >= k:\n                count[nums[i-k]] -= 1\n                if not count[nums[i-k]]:\n                    del count[nums[i-k]]\n            if i+1 >= k:\n                result.append(len(count))\n        return result\n\n"
    },
    {
        "problem_name": "distinct-prime-factors-of-product-of-array",
        "solution": "# Time:  precompute: O(sqrt(MAX_N))\n#        runtime:    O(m + nlog(logn)), m = len(nums), n = max(nums)\n# Space: O(sqrt(MAX_N))\n\n# number theory\ndef linear_sieve_of_eratosthenes(n):\n    primes = []\n    spf = [-1]*(n+1)  # the smallest prime factor\n    for i in xrange(2, n+1):\n        if spf[i] == -1:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if i*p > n or p > spf[i]:\n                break\n            spf[i*p] = p\n    return primes  # len(primes) = O(n/(logn-1)), reference: https://math.stackexchange.com/questions/264544/how-to-find-number-of-prime-numbers-up-to-to-n\n\n\nMAX_N = 10**3\nPRIMES = linear_sieve_of_eratosthenes(int(MAX_N**0.5))  \nclass Solution(object):\n    def distinctPrimeFactors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = set()\n        for x in set(nums):  # Time: O(n/p1 + n/p2 + ... + n/pk) = O(n * (1/p1 + 1/p2 + ... + 1/pk)) = O(nlog(logn))\n            for p in PRIMES:\n                if p > x:\n                    break\n                if x%p:\n                    continue\n                result.add(p)\n                while x%p == 0:\n                    x //= p\n            if x != 1:  # x is a prime\n                result.add(x)\n        return len(result)\n"
    },
    {
        "problem_name": "distinct-subsequences-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def distinctSubseqII(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result, dp = 0, [0]*26\n        for c in S:\n            result, dp[ord(c)-ord('a')] = (result+((result+1)-dp[ord(c)-ord('a')]))%MOD, (result+1)%MOD\n        return result\n"
    },
    {
        "problem_name": "distinct-subsequences",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    # @return an integer\n    def numDistinct(self, S, T):\n        ways = [0 for _ in xrange(len(T) + 1)]\n        ways[0] = 1\n        for S_char in S:\n            for j, T_char in reversed(list(enumerate(T))):\n                if S_char == T_char:\n                    ways[j + 1] += ways[j]\n        return ways[len(T)]\n\n"
    },
    {
        "problem_name": "distribute-candies-among-children-i",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# stars and bars, combinatorics, principle of inclusion-exclusion \nclass Solution(object):\n    def distributeCandies(self, n, limit):\n        \"\"\"\n        :type n: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        def nCr(n, r):  # Time: O(n), Space: O(1)\n            if not 0 <= r <= n:\n                return 0\n            if n-r < r:\n                r = n-r\n            c = 1\n            for k in xrange(1, r+1):\n                c *= n-k+1\n                c //= k\n            return c\n        \n        def nHr(n, r):\n            return nCr(n+(r-1), r-1)\n    \n        R = 3\n        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R)for r in xrange(R+1))\n\n\n# Time:  O(n)\n# Space: O(1)\n# optimized brute force\nclass Solution2(object):\n    def distributeCandies(self, n, limit):\n        \"\"\"\n        :type n: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        return sum(min(limit, n-i)-max((n-i)-limit, 0)+1 for i in xrange(max(n-2*limit, 0), min(limit, n)+1))\n\n\n# Time:  O(n^2)\n# Space: O(1)\n# brute force\nclass Solution3(object):\n    def distributeCandies(self, n, limit):\n        \"\"\"\n        :type n: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        return sum(n-i-j <= limit for i in xrange(min(limit, n)+1) for j in xrange(min(limit, n-i)+1))\n"
    },
    {
        "problem_name": "distribute-candies-among-children-ii",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# stars and bars, combinatorics, principle of inclusion-exclusion \nclass Solution(object):\n    def distributeCandies(self, n, limit):\n        \"\"\"\n        :type n: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        def nCr(n, r):  # Time: O(n), Space: O(1)\n            if not 0 <= r <= n:\n                return 0\n            if n-r < r:\n                r = n-r\n            c = 1\n            for k in xrange(1, r+1):\n                c *= n-k+1\n                c //= k\n            return c\n        \n        def nHr(n, r):\n            return nCr(n+(r-1), r-1)\n    \n        R = 3\n        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R)for r in xrange(R+1))\n\n\n# Time:  O(n)\n# Space: O(1)\n# optimized brute force\nclass Solution2(object):\n    def distributeCandies(self, n, limit):\n        \"\"\"\n        :type n: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        return sum(min(limit, n-i)-max((n-i)-limit, 0)+1 for i in xrange(max(n-2*limit, 0), min(limit, n)+1))\n"
    },
    {
        "problem_name": "distribute-candies-among-children-iii",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# stars and bars, combinatorics, principle of inclusion and exclusion\nclass Solution(object):\n    def distributeCandies(self, n, limit):\n        \"\"\"\n        :type n: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        def nCr(n, r):  # Time: O(n), Space: O(1)\n            if not 0 <= r <= n:\n                return 0\n            if n-r < r:\n                r = n-r\n            c = 1\n            for k in xrange(1, r+1):\n                c *= n-k+1\n                c //= k\n            return c\n        \n        def nHr(n, r):\n            return nCr(n+(r-1), r-1)\n    \n        R = 3\n        return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R) for r in xrange(R+1))\n"
    },
    {
        "problem_name": "distribute-candies-to-people",
        "solution": "# Time:  O(n + logc), c is the number of candies\n# Space: O(1)\n\nclass Solution(object):\n    def distributeCandies(self, candies, num_people):\n        \"\"\"\n        :type candies: int\n        :type num_people: int\n        :rtype: List[int]\n        \"\"\"\n        # find max integer p s.t. sum(1 + 2 + ... + p) <= C\n        # => remaining : 0 <= C-(1+p)*p/2 < p+1\n        # => -2p-2 < p^2+p-2C <= 0\n        # => 2C+1/4 < (p+3/2)^2 and (p+1/2)^2 <= 2C+1/4\n        # => sqrt(2C+1/4)-3/2 < p <= sqrt(2C+1/4)-1/2\n        # => p = floor(sqrt(2C+1/4)-1/2)\n        p = int((2*candies + 0.25)**0.5 - 0.5) \n        remaining = candies - (p+1)*p//2\n        rows, cols = divmod(p, num_people)\n        \n        result = [0]*num_people\n        for i in xrange(num_people):\n            result[i] = (i+1)*(rows+1) + (rows*(rows+1)//2)*num_people if i < cols else \\\n                        (i+1)*rows + ((rows-1)*rows//2)*num_people\n        result[cols] += remaining\n        return result\n\n\n# Time:  O(n + logc), c is the number of candies\n# Space: O(1)\nclass Solution2(object):\n    def distributeCandies(self, candies, num_people):\n        \"\"\"\n        :type candies: int\n        :type num_people: int\n        :rtype: List[int]\n        \"\"\"\n        # find max integer p s.t. sum(1 + 2 + ... + p) <= C\n        left, right = 1, candies\n        while left <= right:\n            mid = left + (right-left)//2\n            if not ((mid <= candies*2 // (mid+1))):\n                right = mid-1\n            else:\n                left = mid+1\n        p = right\n        remaining = candies - (p+1)*p//2\n        rows, cols = divmod(p, num_people)\n        \n        result = [0]*num_people\n        for i in xrange(num_people):\n            result[i] = (i+1)*(rows+1) + (rows*(rows+1)//2)*num_people if i < cols else \\\n                        (i+1)*rows + ((rows-1)*rows//2)*num_people\n        result[cols] += remaining\n        return result\n\n\n# Time:  O(sqrt(c)), c is the number of candies\n# Space: O(1)\nclass Solution3(object):\n    def distributeCandies(self, candies, num_people):\n        \"\"\"\n        :type candies: int\n        :type num_people: int\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*num_people\n        i = 0\n        while candies != 0:\n            result[i % num_people] += min(candies, i+1)\n            candies -= min(candies, i+1)\n            i += 1\n        return result\n"
    },
    {
        "problem_name": "distribute-candies",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n\n    def distributeCandies(self, candies):\n        \"\"\"\n        :type candies: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = set(candies)\n        return min(len(lookup), len(candies)/2)\n\n"
    },
    {
        "problem_name": "distribute-coins-in-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n        \nclass Solution(object):\n    def distributeCoins(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(root, result):\n            if not root:\n                return 0\n            left, right = dfs(root.left, result), dfs(root.right, result)\n            result[0] += abs(left) + abs(right)\n            return root.val + left + right - 1\n\n        result = [0]\n        dfs(root, result)\n        return result[0]\n"
    },
    {
        "problem_name": "distribute-elements-into-two-arrays-i",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# array\nclass Solution(object):\n    def resultArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        a, b = [nums[0]], [nums[1]]\n        for i in xrange(2, len(nums)):\n            if a[-1] > b[-1]:\n                a.append(nums[i])\n            else:\n                b.append(nums[i])\n        return a+b\n"
    },
    {
        "problem_name": "distribute-elements-into-two-arrays-ii",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nfrom sortedcontainers import SortedList\n\n\n# sorted list\nclass Solution(object):\n    def resultArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        sl1, sl2 = SortedList([nums[0]]), SortedList([nums[1]])\n        a, b = [nums[0]], [nums[1]]\n        for i in xrange(2, len(nums)):\n            cnt1 = len(sl1)-sl1.bisect_right(nums[i])\n            cnt2 = len(sl2)-sl2.bisect_right(nums[i])\n            if cnt1 > cnt2 or (cnt1 == cnt2 and len(a) <= len(b)):\n                sl1.add(nums[i])\n                a.append(nums[i])\n            else:\n                sl2.add(nums[i])\n                b.append(nums[i])\n        return a+b\n"
    },
    {
        "problem_name": "distribute-money-to-maximum-children",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def distMoney(self, money, children):\n        \"\"\"\n        :type money: int\n        :type children: int\n        :rtype: int\n        \"\"\"\n        if money < children*1:\n            return -1\n        money -= children*1\n        q, r = divmod(money, 7)\n        return min(q, children) - int(q > children or (q == children and r != 0) or (q == children-1 and r == 3))\n\n\n# Time:  O(1)\n# Space: O(1)\n# greedy\nclass Solution2(object):\n    def distMoney(self, money, children):\n        \"\"\"\n        :type money: int\n        :type children: int\n        :rtype: int\n        \"\"\"\n        if money < children*1:\n            return -1\n        money -= children*1\n        q, r = divmod(money, 7)\n        if q > children:\n            return children-1\n        if q == children:\n            return q-int(r != 0)\n        if q == children-1:\n            return q-int(r == 3)\n        return q\n"
    },
    {
        "problem_name": "distribute-repeating-integers",
        "solution": "# Time:  O(n + m * 3^m) \n# Space: O(n + 2^m)\n\nimport collections\nimport random\n\n\nclass Solution(object):\n    def canDistribute(self, nums, quantity):\n        \"\"\"\n        :type nums: List[int]\n        :type quantity: List[int]\n        :rtype: bool\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        count = collections.Counter(nums)\n        total = (1<<len(quantity))-1\n        requirement = [0]*(total+1)\n        for mask in xrange(len(requirement)):  # Time: O(2^m)\n            base = 1\n            for i in xrange(len(quantity)):  # Time: O(m)\n                if mask&base:\n                    requirement[mask] += quantity[i];\n                base <<= 1\n        dp = [[0]*(total+1) for _ in xrange(2)]\n        dp[0][0] = 1\n        i = 0\n        cnts = count.values()\n        if len(quantity) < len(cnts):  # at most use top m cnts\n            nth_element(cnts, len(quantity)-1, lambda a, b: a > b)\n            cnts = cnts[:len(quantity)]\n        for cnt in cnts:  # Time: O(m)\n            dp[(i+1)%2] = [0]*(total+1)\n            # submask enumeration:\n            # => sum(nCr(m, k) * 2^k for k in xrange(m+1)) = (1 + 2)^m = 3^m\n            # => Time: O(3^m), see https://cp-algorithms.com/algebra/all-submasks.html\n            for mask in reversed(xrange(total+1)):\n                dp[(i+1)%2][mask] |= dp[i%2][mask]\n                submask = mask\n                while submask > 0:\n                    if requirement[submask] <= cnt and dp[i%2][mask^submask]:\n                        dp[(i+1)%2][mask] = 1\n                    submask = (submask-1)&mask\n            i += 1\n        return dp[len(cnts)%2][total]\n"
    },
    {
        "problem_name": "divide-a-string-into-groups-of-size-k",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def divideString(self, s, k, fill):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :type fill: str\n        :rtype: List[str]\n        \"\"\"\n        return [s[i:i+k] + fill*(i+k-len(s)) for i in xrange(0, len(s), k)]\n"
    },
    {
        "problem_name": "divide-an-array-into-subarrays-with-minimum-cost-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport random\n\n\n# array, quick select\nclass Solution(object):\n    def minimumCost(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n            \n            right = len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        nth_element(nums, 1+(2-1), 1)\n        return nums[0]+nums[1]+nums[2]\n\n\n# Time:  O(n)\n# Space: O(1)\n# array\nclass Solution2(object):\n    def minimumCost(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def topk(a, k):\n            result = [float(\"inf\")]*k\n            for x in a:\n                for i in xrange(len(result)):\n                    if x < result[i]:\n                        result[i], x = x, result[i]\n            return result\n\n        return nums[0]+sum(topk((nums[i] for i in xrange(1, len(nums))), 2))\n"
    },
    {
        "problem_name": "divide-an-array-into-subarrays-with-minimum-cost-ii",
        "solution": "# Time:  O(nlogd)\n# Space: O(d)\n\nimport heapq\n\n\n# sliding window, heap\nclass Solution(object):\n    def minimumCost(self, nums, k, dist):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type dist: int\n        :rtype: int\n        \"\"\"\n        def get_top(heap, total):\n            while abs(heap[0][1]) < i-(1+dist):\n                heapq.heappop(heap)\n                total[0] -= 1\n            return heap[0]\n            \n        def lazy_delete(heap, total):\n            total[0] += 1\n            if total[0] <= len(heap)-total[0]:\n                return\n            heap[:] = [x for x in heap if abs(x[1]) > i-(1+dist)]\n            heapq.heapify(heap)\n            total[0] = 0\n\n        max_heap, min_heap = [], []\n        total1, total2 = [0], [0]\n        mn, curr = float(\"inf\"), 0\n        for i in xrange(1, len(nums)):\n            heapq.heappush(max_heap, (-nums[i], i))\n            curr += nums[i]\n            if i > k-1:\n                x, idx = get_top(max_heap, total1)\n                heapq.heappop(max_heap)\n                curr -= -x\n                heapq.heappush(min_heap, (-x, -idx))\n            if i > 1+dist:\n                x, idx = get_top(min_heap, total2)\n                if (x, idx) <= (nums[i-(1+dist)], -(i-(1+dist))):\n                    lazy_delete(min_heap, total2)\n                else:\n                    lazy_delete(max_heap, total1)\n                    heapq.heappop(min_heap)\n                    curr -= nums[i-(1+dist)]-x\n                    heapq.heappush(max_heap, (-x, -idx))\n            if i >= k-1:\n                mn = min(mn, curr)\n        return nums[0]+mn\n\n\n# Time:  O(nlogd)\n# Space: O(d)\nimport heapq\nimport collections\n\n\n# sliding window, heap, freq table\nclass Solution2(object):\n    def minimumCost(self, nums, k, dist):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type dist: int\n        :rtype: int\n        \"\"\"\n        def get_top(heap, cnt, total):\n            while heap[0] in cnt:\n                x = heapq.heappop(heap)\n                cnt[x] -= 1\n                if cnt[x] == 0:\n                    del cnt[x]\n                total[0] -= 1\n            return heap[0]\n\n        def lazy_delete(heap, cnt, total, x):\n            cnt[x] += 1\n            total[0] += 1\n            if total[0] <= len(heap)-total[0]:\n                return\n            new_heap = []\n            for x in heap:\n                if x not in cnt:\n                    new_heap.append(x)\n                    continue\n                cnt[x] -= 1\n                if cnt[x] == 0:\n                    del cnt[x]\n            total[0] = 0\n            heapq.heapify(new_heap)\n            heap[:] = new_heap\n\n        max_heap, min_heap = [], []\n        cnt1, cnt2 = collections.Counter(), collections.Counter()\n        total1, total2 = [0], [0]\n        mn, curr = float(\"inf\"), 0\n        for i in xrange(1, len(nums)):\n            heapq.heappush(max_heap, -nums[i])\n            curr += nums[i]\n            if (len(max_heap)-total1[0]) > k-1:\n                x = get_top(max_heap, cnt1, total1)\n                curr -= -x\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            if (len(max_heap)-total1[0])+(len(min_heap)-total2[0]) > 1+dist:\n                x = get_top(min_heap, cnt2, total2)\n                if x <= nums[i-(1+dist)]:\n                    lazy_delete(min_heap, cnt2, total2, nums[i-(1+dist)])\n                else:\n                    lazy_delete(max_heap, cnt1, total1, -nums[i-(1+dist)])\n                    heapq.heappop(min_heap)\n                    curr -= nums[i-(1+dist)]-x\n                    heapq.heappush(max_heap, -x)\n            if len(max_heap)-total1[0] == k-1:\n                mn = min(mn, curr)\n        return nums[0]+mn\n\n\n# Time:  O(nlogd)\n# Space: O(d)\nfrom sortedcontainers import SortedList\n\n\n# sliding window, sorted list\nclass Solution3(object):\n    def minimumCost(self, nums, k, dist):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type dist: int\n        :rtype: int\n        \"\"\"\n        sl1, sl2 = SortedList(), SortedList()\n        mn, curr = float(\"inf\"), 0\n        for i in xrange(1, len(nums)):\n            sl1.add(nums[i])\n            curr += nums[i]\n            if len(sl1) > k-1:\n                curr -= sl1[-1]\n                sl2.add(sl1.pop())\n            if len(sl1)+len(sl2) > 1+dist:\n                if sl2[0] <= nums[i-(1+dist)]:\n                    sl2.remove(nums[i-(1+dist)])\n                else:\n                    sl1.remove(nums[i-(1+dist)])\n                    curr -= nums[i-(1+dist)]-sl2[0]\n                    sl1.add(sl2.pop(0))\n            if len(sl1) == k-1:\n                mn = min(mn, curr)\n        return nums[0]+mn\n\n\n# Time:  O(nlogd)\n# Space: O(d)\nfrom sortedcontainers import SortedList\n\n\n# sliding window, sorted list\nclass Solution4(object):\n    def minimumCost(self, nums, k, dist):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type dist: int\n        :rtype: int\n        \"\"\"\n        sl = SortedList(nums[1:1+(1+dist)])\n        mn = curr = sum(sl[:k-1])\n        for i in xrange(1+(1+dist), len(nums)):\n            sl.add(nums[i])\n            curr += min(nums[i]-sl[k-1], 0)\n            curr -= min(nums[i-(1+dist)]-sl[k-1], 0)\n            sl.remove(nums[i-(1+dist)])\n            mn = min(mn, curr)\n        return nums[0]+mn\n"
    },
    {
        "problem_name": "divide-array-in-sets-of-k-consecutive-numbers",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def isPossibleDivide(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        count = collections.Counter(nums)\n        for num in sorted(count.keys()):\n            c = count[num]\n            if not c:\n                continue\n            for i in xrange(num, num+k):\n                if count[i] < c:\n                    return False\n                count[i] -= c\n        return True\n"
    },
    {
        "problem_name": "divide-array-into-arrays-with-max-difference",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort\nclass Solution(object):\n    def divideArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        return [nums[i:i+3] for i in xrange(0, len(nums), 3)] if all(nums[i+2]-nums[i] <= k for i in xrange(0, len(nums), 3)) else []\n"
    },
    {
        "problem_name": "divide-array-into-equal-pairs",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def divideArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return all(cnt%2 == 0 for cnt in collections.Counter(nums).itervalues())\n"
    },
    {
        "problem_name": "divide-array-into-increasing-sequences",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def canDivideIntoSubsequences(self, nums, K):\n        \"\"\"\n        :type nums: List[int]\n        :type K: int\n        :rtype: bool\n        \"\"\"\n        curr, max_count = 1, 1\n        for i in xrange(1, len(nums)):\n            curr = 1 if nums[i-1] < nums[i] else curr+1\n            max_count = max(max_count, curr)\n        return K*max_count <= len(nums)\n"
    },
    {
        "problem_name": "divide-chocolate",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def maximizeSweetness(self, sweetness, K):\n        \"\"\"\n        :type sweetness: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        def check(sweetness, K, x):\n            curr, cuts = 0, 0\n            for s in sweetness:\n                curr += s\n                if curr >= x:\n                    cuts += 1\n                    curr = 0\n            return cuts >= K+1\n\n        left, right = min(sweetness), sum(sweetness)//(K+1)\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(sweetness, K, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "divide-intervals-into-minimum-number-of-groups",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\n# sort, line sweep\nclass Solution(object):\n    def minGroups(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        events = collections.Counter()\n        for l, r in intervals:\n            events[l] += 1\n            events[r+1] -= 1\n        result = curr = 0\n        for t in sorted(events.iterkeys()):\n            curr += events[t]\n            result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "divide-nodes-into-the-maximum-number-of-groups",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\n# iterative dfs, bfs\nclass Solution(object):\n    def magnificentSets(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def iter_dfs(u):\n            group = []\n            stk = [u]\n            lookup[u] = 0\n            while stk:\n                u = stk.pop()\n                group.append(u)\n                for v in adj[u]:\n                    if lookup[v] != -1:\n                        if lookup[v] == lookup[u]:  # odd-length cycle, not bipartite\n                            return []\n                        continue\n                    lookup[v] = lookup[u]^1\n                    stk.append(v)\n            return group\n\n        def bfs(u):\n            result = 0\n            lookup = [False]*n\n            q = [u]\n            lookup[u] = True\n            while q:\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if lookup[v]:\n                            continue\n                        lookup[v] = True\n                        new_q.append(v)\n                q = new_q\n                result += 1\n            return result\n    \n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        result = 0\n        lookup = [-1]*n\n        for u in xrange(n):\n            if lookup[u] != -1:\n                continue\n            group = iter_dfs(u)\n            if not group:\n                return -1\n            result += max(bfs(u) for u in group)\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# bfs\nclass Solution2(object):\n    def magnificentSets(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def bfs(u):\n            group = []\n            q = {u}\n            lookup[u] = True\n            while q:\n                new_q = set()\n                for u in q:\n                    group.append(u)\n                    for v in adj[u]:\n                        if lookup[v]:\n                            continue\n                        lookup[v] = True\n                        new_q.add(v)\n                q = new_q\n            return group\n    \n        def bfs2(u):\n            result = 0\n            lookup = [False]*n\n            q = {u}\n            lookup[u] = True\n            while q:\n                new_q = set()\n                for u in q:\n                    for v in adj[u]:\n                        if v in q:\n                            return 0\n                        if lookup[v]:\n                            continue\n                        lookup[v] = True\n                        new_q.add(v)\n                q = new_q\n                result += 1\n            return result\n    \n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        result = 0\n        lookup = [0]*n\n        for u in xrange(n):\n            if lookup[u]:\n                continue\n            group = bfs(u)\n            mx = 0\n            for u in group:\n                d = bfs2(u)\n                if d == 0:\n                    return -1\n                mx = max(mx, d)\n            result += mx\n        return result\n"
    },
    {
        "problem_name": "divide-players-into-teams-of-equal-skill",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def dividePlayers(self, skill):\n        \"\"\"\n        :type skill: List[int]\n        :rtype: int\n        \"\"\"\n\n        target = sum(skill)//(len(skill)//2)\n        cnt = collections.Counter(skill)\n        result = 0\n        for k, v in cnt.iteritems():\n            if target-k not in cnt or cnt[target-k] != cnt[k]:\n                return -1\n            result += k*(target-k)*v\n        return result//2\n"
    },
    {
        "problem_name": "divide-two-integers",
        "solution": "# Time:  O(logn) = O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        result, dvd, dvs = 0, abs(dividend), abs(divisor)\n        while dvd >= dvs:\n            inc = dvs\n            i = 0\n            while dvd >= inc:\n                dvd -= inc\n                result += 1 << i\n                inc <<= 1\n                i += 1\n        if dividend > 0 and divisor < 0 or dividend < 0 and divisor > 0:\n            return -result\n        else:\n            return result\n\n    def divide2(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        positive = (dividend < 0) is (divisor < 0)\n        dividend, divisor = abs(dividend), abs(divisor)\n        res = 0\n        while dividend >= divisor:\n            temp, i = divisor, 1\n            while dividend >= temp:\n                dividend -= temp\n                res += i\n                i <<= 1\n                temp <<= 1\n        if not positive:\n            res = -res\n        return min(max(-2147483648, res), 2147483647)\n\n"
    },
    {
        "problem_name": "divisible-and-non-divisible-sums-difference",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def differenceOfSums(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        def arithmetic_progression_sum(a, d, l):\n            return (a+(a+(l-1)*d))*l//2\n    \n        return arithmetic_progression_sum(1, 1, n) - 2*arithmetic_progression_sum(m, m, n//m)\n\n\n# Time:  O(1)\n# Space: O(1)\n# math\nclass Solution2(object):\n    def differenceOfSums(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        return (n+1)*n//2 - 2*(((n//m+1)*(n//m)//2)*m)\n"
    },
    {
        "problem_name": "divisor-game",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def divisorGame(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: bool\n        \"\"\"\n        # 1. if we get an even, we can choose x = 1\n        #    to make the opponent always get an odd\n        # 2. if the opponent gets an odd, he can only choose x = 1 or other odds\n        #    and we can still get an even\n        # 3. at the end, the opponent can only choose x = 1 and we win\n        # 4. in summary, we win if only if we get an even and \n        #    keeps even until the opponent loses\n        return N % 2 == 0\n\n\n# Time:  O(n^3/2)\n# Space: O(n)\n# dp solution\nclass Solution2(object):\n    def divisorGame(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: bool\n        \"\"\"\n        def memoization(N, dp):\n            if N == 1:\n                return False\n            if N not in dp:\n                result = False\n                for i in xrange(1, N+1):\n                    if i*i > N:\n                        break\n                    if N % i == 0:\n                        if not memoization(N-i, dp):\n                            result = True\n                            break\n                dp[N] = result\n            return dp[N]\n        \n        return memoization(N, {})\n"
    },
    {
        "problem_name": "domino-and-tromino-tiling",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def numTilings(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        M = int(1e9+7)\n\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) % M \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 0, 0, 1],  # #(|) = #(|) + #(=)\n             [1, 0, 1, 0],  # #(\u300c) = #(|) + #(L)\n             [1, 1, 0, 0],  # #(L) = #(|) + #(\u300c)\n             [1, 1, 1, 0]]  # #(=) = #(|) + #(\u300c) + #(L)\n\n        return matrix_mult([[1, 0, 0, 0]], matrix_expo(T, N))[0][0] # [a0, a(-1), a(-2), a(-3)] * T^N\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def numTilings(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        # Prove:\n        # dp[n] = dp[n-1](|) + dp[n-2](=) + 2*(dp[n-3](\u300c\u300d) + ... + d[0](\u300c = ... = \u300d))\n        #       = dp[n-1] + dp[n-2] + dp[n-3] + dp[n-3] + 2*(dp[n-4] + ... + d[0])\n        #       = dp[n-1] + dp[n-3] + (dp[n-2] + dp[n-3] + 2*(dp[n-4] + ... + d[0])\n        #       = dp[n-1] + dp[n-3] + dp[n-1]\n        #       = 2*dp[n-1] + dp[n-3]\n        M = int(1e9+7)\n        dp = [1, 1, 2]\n        for i in xrange(3, N+1):\n            dp[i%3] = (2*dp[(i-1)%3]%M + dp[(i-3)%3])%M\n        return dp[N%3]\n"
    },
    {
        "problem_name": "dot-product-of-two-sparse-vectors",
        "solution": "# Time:  ctor: O(n)\n#        dot_product: O(min(n, m))\n# Space: O(n)\n\nclass SparseVector:\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.lookup = {i:v for i, v in enumerate(nums) if v}\n\n    def dotProduct(self, vec):\n        \"\"\"\n        :type vec: 'SparseVector'\n        :rtype: int\n        \"\"\"\n        if len(self.lookup) > len(vec.lookup):\n            self, vec = vec, self\n        return sum(v*vec.lookup[i] for i, v in self.lookup.iteritems() if i in vec.lookup)\n"
    },
    {
        "problem_name": "dota2-senate",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def predictPartyVictory(self, senate):\n        \"\"\"\n        :type senate: str\n        :rtype: str\n        \"\"\"\n        n = len(senate)\n        radiant, dire = collections.deque(), collections.deque()\n        for i, c in enumerate(senate):\n            if c == 'R':\n                radiant.append(i)\n            else:\n                dire.append(i)\n        while radiant and dire:\n            r_idx, d_idx = radiant.popleft(), dire.popleft()\n            if r_idx < d_idx:\n                radiant.append(r_idx+n)\n            else:\n                dire.append(d_idx+n)\n        return \"Radiant\" if len(radiant) > len(dire) else \"Dire\"\n\n"
    },
    {
        "problem_name": "double-a-number-represented-as-a-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# linked list\nclass Solution(object):\n    def doubleIt(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        if head.val >= 5:\n            head = ListNode(0, head)\n        curr = head\n        while curr:\n            curr.val = (curr.val*2)%10\n            if curr.next and curr.next.val >= 5:\n                curr.val += 1\n            curr = curr.next\n        return head\n"
    },
    {
        "problem_name": "double-modular-exponentiation",
        "solution": "# Time:  O(n * (logb + logc))\n# Space: O(1)\n\n# fast exponentiation\nclass Solution(object):\n    def getGoodIndices(self, variables, target):\n        \"\"\"\n        :type variables: List[List[int]]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        return [i for i, (a, b, c, m) in enumerate(variables) if pow(pow(a, b, 10), c, m) == target]\n"
    },
    {
        "problem_name": "dungeon-game",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nclass Solution(object):\n    # @param dungeon, a list of lists of integers\n    # @return a integer\n    def calculateMinimumHP(self, dungeon):\n        DP = [float(\"inf\") for _ in dungeon[0]]\n        DP[-1] = 1\n\n        for i in reversed(xrange(len(dungeon))):\n            DP[-1] = max(DP[-1] - dungeon[i][-1], 1)\n            for j in reversed(xrange(len(dungeon[i]) - 1)):\n                min_HP_on_exit = min(DP[j], DP[j + 1])\n                DP[j] = max(min_HP_on_exit - dungeon[i][j], 1)\n\n        return DP[0]\n\n# Time:  O(m * n logk), where k is the possible maximum sum of loses\n# Space: O(m + n)\nclass Solution2(object):\n    # @param dungeon, a list of lists of integers\n    # @return a integer\n    def calculateMinimumHP(self, dungeon):\n        maximum_loses = 0\n        for rooms in dungeon:\n            for room in rooms:\n                if room < 0:\n                    maximum_loses += abs(room)\n\n        return self.binarySearch(dungeon, maximum_loses)\n\n    def binarySearch(self, dungeon, maximum_loses):\n        start, end = 1, maximum_loses + 1\n        result = 0\n        while start < end:\n            mid = start + (end - start) / 2\n            if self.DP(dungeon, mid):\n                end = mid\n            else:\n                start = mid + 1\n        return start\n\n    def DP(self, dungeon, HP):\n        remain_HP = [0 for _ in dungeon[0]]\n        remain_HP[0] = HP + dungeon[0][0]\n        for j in xrange(1, len(remain_HP)):\n            if remain_HP[j - 1] > 0:\n                remain_HP[j] = max(remain_HP[j - 1] + dungeon[0][j], 0)\n\n        for i in xrange(1, len(dungeon)):\n            if remain_HP[0] > 0:\n                remain_HP[0] = max(remain_HP[0] + dungeon[i][0], 0)\n            else:\n                remain_HP[0] = 0\n\n            for j in xrange(1, len(remain_HP)):\n                remain = 0\n                if remain_HP[j - 1] > 0:\n                    remain = max(remain_HP[j - 1] + dungeon[i][j], remain)\n                if remain_HP[j] > 0:\n                    remain = max(remain_HP[j] + dungeon[i][j], remain)\n                remain_HP[j] = remain\n\n        return remain_HP[-1] > 0\n\n"
    },
    {
        "problem_name": "duplicate-zeros",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def duplicateZeros(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: None Do not return anything, modify arr in-place instead.\n        \"\"\"\n        shift, i = 0, 0\n        while i+shift < len(arr):\n            shift += int(arr[i] == 0)\n            i += 1\n        i -= 1\n        while shift:\n            if i+shift < len(arr):\n                arr[i+shift] = arr[i]\n            if arr[i] == 0:\n                shift -= 1\n                arr[i+shift] = arr[i]\n            i -= 1\n"
    },
    {
        "problem_name": "earliest-possible-day-of-full-bloom",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def earliestFullBloom(self, plantTime, growTime):\n        \"\"\"\n        :type plantTime: List[int]\n        :type growTime: List[int]\n        :rtype: int\n        \"\"\"\n        order = range(len(growTime))\n        order.sort(key=lambda x: growTime[x], reverse=True)\n        result = curr = 0\n        for i in order:\n            curr += plantTime[i]\n            result = max(result, curr+growTime[i])\n        return result\n"
    },
    {
        "problem_name": "earliest-second-to-mark-indices-i",
        "solution": "# Time:  O(mlogm)\n# Space: O(n)\n\n# binary search, greedy\nclass Solution(object):\n    def earliestSecondToMarkIndices(self, nums, changeIndices):\n        \"\"\"\n        :type nums: List[int]\n        :type changeIndices: List[int]\n        :rtype: int\n        \"\"\"\n        def check(t):\n            lookup = [-1]*len(nums)\n            for i in xrange(t):\n                lookup[changeIndices[i]-1] = i\n            if -1 in lookup:\n                return False\n            cnt = 0\n            for i in xrange(t):\n                if i != lookup[changeIndices[i]-1]:\n                    cnt += 1\n                    continue\n                cnt -= nums[changeIndices[i]-1]\n                if cnt < 0:\n                    return False\n            return True\n\n        left, right = sum(nums)+len(nums), len(changeIndices) \n        while left <= right:\n            mid = left+(right-left)//2\n            if check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left if left <= len(changeIndices) else -1\n"
    },
    {
        "problem_name": "earliest-second-to-mark-indices-ii",
        "solution": "# Time:  O((m + nlogn) * logm)\n# Space: O(n)\n\nimport heapq\n\n\n# binary search, greedy, heap\nclass Solution(object):\n    def earliestSecondToMarkIndices(self, nums, changeIndices):\n        \"\"\"\n        :type nums: List[int]\n        :type changeIndices: List[int]\n        :rtype: int\n        \"\"\"\n        def check(t):\n            min_heap = []\n            cnt = 0\n            for i in reversed(xrange(t)):\n                if i != lookup[changeIndices[i]-1]:\n                    cnt += 1\n                    continue\n                heapq.heappush(min_heap, nums[changeIndices[i]-1])\n                if cnt:\n                    cnt -= 1\n                else:\n                    cnt += 1\n                    heapq.heappop(min_heap)\n            return total-(sum(min_heap)+len(min_heap)) <= cnt\n\n        lookup = [-1]*len(nums)\n        for i in reversed(xrange(len(changeIndices))):\n            if nums[changeIndices[i]-1]:\n                lookup[changeIndices[i]-1] = i\n        total = sum(nums)+len(nums)\n        left, right = sum((1 if lookup[i] != -1 else nums[i]) for i in xrange(len(nums)))+len(nums), len(changeIndices) \n        while left <= right:\n            mid = left+(right-left)//2\n            if check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left if left <= len(changeIndices) else -1\n"
    },
    {
        "problem_name": "edit-distance",
        "solution": "# Time:  O(n * m)\n# Space: O(n + m)\n\nclass Solution(object):\n    # @return an integer\n    def minDistance(self, word1, word2):\n        if len(word1) < len(word2):\n            return self.minDistance(word2, word1)\n\n        distance = [i for i in xrange(len(word2) + 1)]\n\n        for i in xrange(1, len(word1) + 1):\n            pre_distance_i_j = distance[0]\n            distance[0] = i\n            for j in xrange(1, len(word2) + 1):\n                insert = distance[j - 1] + 1\n                delete = distance[j] + 1\n                replace = pre_distance_i_j\n                if word1[i - 1] != word2[j - 1]:\n                    replace += 1\n                pre_distance_i_j = distance[j]\n                distance[j] = min(insert, delete, replace)\n\n        return distance[-1]\n\n# Time:  O(n * m)\n# Space: O(n * m)\nclass Solution2(object):\n    # @return an integer\n    def minDistance(self, word1, word2):\n        distance = [[i] for i in xrange(len(word1) + 1)]\n        distance[0] = [j for j in xrange(len(word2) + 1)]\n\n        for i in xrange(1, len(word1) + 1):\n            for j in xrange(1, len(word2) + 1):\n                insert = distance[i][j - 1] + 1\n                delete = distance[i - 1][j] + 1\n                replace = distance[i - 1][j - 1]\n                if word1[i - 1] != word2[j - 1]:\n                    replace += 1\n                distance[i].append(min(insert, delete, replace))\n\n        return distance[-1][-1]\n\n"
    },
    {
        "problem_name": "egg-drop-with-2-eggs-and-n-floors",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nimport math\n\n\n# see the proof: https://www.geeksforgeeks.org/puzzle-set-35-2-eggs-and-100-floors/\nclass Solution(object):\n    def twoEggDrop(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return int(math.ceil((-1+(1+8*n)**0.5)/2))\n    \n\n# Time:  O(k * n^2)\n# Space: O(n)\nclass Solution2(object):\n    def twoEggDrop(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        K = 2\n        dp = [[float(\"inf\") for j in xrange(n+1)] for _ in xrange(2)]\n        dp[1] = [j for j in xrange(n+1)]\n        for i in xrange(2, K+1):\n            dp[i%2][0] = 0\n            for j in xrange(1, n+1):\n                for k in xrange(1, j+1):\n                    dp[i%2][j] = min(dp[i%2][j], 1+max(dp[(i-1)%2][k-1], dp[i%2][j-k]))\n        return dp[K%2][n]\n"
    },
    {
        "problem_name": "element-appearing-more-than-25-in-sorted-array",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport bisect\n\n\nclass Solution(object):\n    def findSpecialInteger(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        for x in [arr[len(arr)//4], arr[len(arr)//2], arr[len(arr)*3//4]]:\n            if (bisect.bisect_right(arr, x) - bisect.bisect_left(arr, x)) * 4 > len(arr):\n                return x\n        return -1\n"
    },
    {
        "problem_name": "elements-in-array-after-removing-and-replacing-elements",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def elementInNums(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for t, i in queries:\n            t %= 2*len(nums)\n            if t+i < len(nums):\n                result.append(nums[t+i])\n            elif i < t-len(nums):\n                result.append(nums[i])\n            else:\n                result.append(-1)\n        return result\n"
    },
    {
        "problem_name": "eliminate-maximum-number-of-monsters",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def eliminateMaximum(self, dist, speed):\n        \"\"\"\n        :type dist: List[int]\n        :type speed: List[int]\n        :rtype: int\n        \"\"\"\n        for i in xrange(len(dist)):\n            dist[i] = (dist[i]-1)//speed[i]\n        dist.sort()\n        result = 0\n        for i in xrange(len(dist)):\n            if result > dist[i]:\n                break\n            result += 1\n        return result\n"
    },
    {
        "problem_name": "elimination-game",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def lastRemaining(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        start, step, direction = 1, 2, 1\n        while n > 1:\n            start += direction * (step * (n//2) - step//2)\n            n //= 2\n            step *= 2\n            direction *= -1\n        return start\n"
    },
    {
        "problem_name": "employee-free-time",
        "solution": "# Time:  O(m * logn), m is the number of schedule, n is the number of employees, m >= n\n# Space: O(n)\n\nimport heapq\n\n\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution(object):\n    def employeeFreeTime(self, schedule):\n        \"\"\"\n        :type schedule: List[List[Interval]]\n        :rtype: List[Interval]\n        \"\"\"\n        result = []\n        min_heap = [(emp[0].start, eid, 0) for eid, emp in enumerate(schedule)]\n        heapq.heapify(min_heap)\n        last_end = -1\n        while min_heap:\n            t, eid, i = heapq.heappop(min_heap)\n            if 0 <= last_end < t:\n                result.append(Interval(last_end, t))\n            last_end = max(last_end, schedule[eid][i].end)\n            if i+1 < len(schedule[eid]):\n                heapq.heappush(min_heap, (schedule[eid][i+1].start, eid, i+1))\n        return result\n\n"
    },
    {
        "problem_name": "employee-importance",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nimport collections\n\n\n\"\"\"\n# Employee info\nclass Employee(object):\n    def __init__(self, id, importance, subordinates):\n        # It's the unique id of each node.\n        # unique id of this employee\n        self.id = id\n        # the importance value of this employee\n        self.importance = importance\n        # the id of direct subordinates\n        self.subordinates = subordinates\n\"\"\"\nclass Solution(object):\n    def getImportance(self, employees, id):\n        \"\"\"\n        :type employees: Employee\n        :type id: int\n        :rtype: int\n        \"\"\"\n        if employees[id-1] is None:\n            return 0\n        result = employees[id-1].importance\n        for id in employees[id-1].subordinates:\n            result += self.getImportance(employees, id)\n        return result\n\n\n# Time:  O(n)\n# Space: O(w), w is the max number of nodes in the levels of the tree\nclass Solution2(object):\n    def getImportance(self, employees, id):\n        \"\"\"\n        :type employees: Employee\n        :type id: int\n        :rtype: int\n        \"\"\"\n        result, q = 0, collections.deque([id])\n        while q:\n            curr = q.popleft()\n            employee = employees[curr-1]\n            result += employee.importance\n            for id in employee.subordinates:\n                q.append(id)\n        return result\n\n"
    },
    {
        "problem_name": "encode-and-decode-strings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Codec(object):\n\n    def encode(self, strs):\n        \"\"\"Encodes a list of strings to a single string.\n\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        encoded_str = \"\"\n        for s in strs:\n            encoded_str += \"%0*x\" % (8, len(s)) + s\n        return encoded_str\n\n\n    def decode(self, s):\n        \"\"\"Decodes a single string to a list of strings.\n\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        i = 0\n        strs = []\n        while i < len(s):\n            l = int(s[i:i+8], 16)\n            strs.append(s[i+8:i+8+l])\n            i += 8+l\n        return strs\n\n"
    },
    {
        "problem_name": "encode-and-decode-tinyurl",
        "solution": "# Time:  O(1)\n# Space: O(n)\n\nimport random\n\n\nclass Codec(object):\n    def __init__(self):\n        self.__random_length = 6\n        self.__tiny_url = \"http://tinyurl.com/\"\n        self.__alphabet = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        self.__lookup = {}\n\n    def encode(self, longUrl):\n        \"\"\"Encodes a URL to a shortened URL.\n\n        :type longUrl: str\n        :rtype: str\n        \"\"\"\n        def getRand():\n            rand = []\n            for _ in xrange(self.__random_length):\n                rand += self.__alphabet[random.randint(0, len(self.__alphabet)-1)]\n            return \"\".join(rand)\n\n        key = getRand()\n        while key in self.__lookup:\n            key = getRand()\n        self.__lookup[key] = longUrl\n        return self.__tiny_url + key\n\n    def decode(self, shortUrl):\n        \"\"\"Decodes a shortened URL to its original URL.\n\n        :type shortUrl: str\n        :rtype: str\n        \"\"\"\n        return self.__lookup[shortUrl[len(self.__tiny_url):]]\n\n\nfrom hashlib import sha256\n\n\nclass Codec2(object):\n\n    def __init__(self):\n        self._cache = {}\n        self.url = 'http://tinyurl.com/'\n\n    def encode(self, long_url):\n        \"\"\"Encodes a URL to a shortened URL.\n\n        :type long_url: str\n        :rtype: str\n        \"\"\"\n        key = sha256(long_url.encode()).hexdigest()[:6]\n        self._cache[key] = long_url\n        return self.url + key\n\n    def decode(self, short_url):\n        \"\"\"Decodes a shortened URL to its original URL.\n\n        :type short_url: str\n        :rtype: str\n        \"\"\"\n        key = short_url.replace(self.url, '')\n        return self._cache[key]\n\n\n"
    },
    {
        "problem_name": "encode-n-ary-tree-to-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Codec(object):\n\n    def encode(self, root):\n        \"\"\"Encodes an n-ary tree to a binary tree.\n        \n        :type root: Node\n        :rtype: TreeNode\n        \"\"\"\n        def encodeHelper(root, parent, index):\n            if not root:\n                return None\n            node = TreeNode(root.val)\n            if index+1 < len(parent.children):\n                node.left = encodeHelper(parent.children[index+1], parent, index+1)\n            if root.children:\n                node.right = encodeHelper(root.children[0], root, 0)\n            return node\n\n        if not root:\n            return None\n        node = TreeNode(root.val)\n        if root.children:\n            node.right = encodeHelper(root.children[0], root, 0)\n        return node\n\n    def decode(self, data):\n        \"\"\"Decodes your binary tree to an n-ary tree.\n        \n        :type data: TreeNode\n        :rtype: Node\n        \"\"\"\n        def decodeHelper(root, parent):\n            if not root:\n                return\n            children = []\n            node = Node(root.val, children)\n            decodeHelper(root.right, node)\n            parent.children.append(node)\n            decodeHelper(root.left, parent)\n\n        if not data:\n            return None\n        children = []\n        node = Node(data.val, children)\n        decodeHelper(data.right, node)\n        return node\n        \n\n\n"
    },
    {
        "problem_name": "encode-number",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def encode(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        result = []\n        while num:\n            result.append('0' if num%2 else '1')\n            num = (num-1)//2\n        return \"\".join(reversed(result))\n"
    },
    {
        "problem_name": "encode-string-with-shortest-length",
        "solution": "# Time:  O(n^3) on average\n# Space: O(n^2)\n\nclass Solution(object):\n    def encode(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def encode_substr(dp, s, i, j):\n            temp = s[i:j+1]\n            pos = (temp + temp).find(temp, 1)  # O(n) on average\n            if pos >= len(temp):\n                return temp\n            return str(len(temp)/pos) + '[' + dp[i][i + pos - 1] + ']'\n\n        dp = [[\"\" for _ in xrange(len(s))] for _ in xrange(len(s))]\n        for length in xrange(1, len(s)+1):\n            for i in xrange(len(s)+1-length):\n                j = i+length-1\n                dp[i][j] = s[i:i+length]\n                for k in xrange(i, j):\n                    if len(dp[i][k]) + len(dp[k+1][j]) < len(dp[i][j]):\n                        dp[i][j] = dp[i][k] + dp[k+1][j]\n                encoded_string = encode_substr(dp, s, i, j)\n                if len(encoded_string) < len(dp[i][j]):\n                    dp[i][j] = encoded_string\n        return dp[0][len(s) - 1]\n\n"
    },
    {
        "problem_name": "encrypt-and-decrypt-strings",
        "solution": "# Time:  ctor:    O(m + d), m is len(keys), d is sum(len(x) for x in dictionary)\n#        encrypt: O(n)\n#        decrypt: O(n)\n# Space: O(m + d)\n\nimport collections\nimport itertools\n\n\n# freq table\nclass Encrypter(object):\n\n    def __init__(self, keys, values, dictionary):\n        \"\"\"\n        :type keys: List[str]\n        :type values: List[str]\n        :type dictionary: List[str]\n        \"\"\"\n        self.__lookup = {k: v for k, v in itertools.izip(keys, values)}\n        self.__cnt = collections.Counter(self.encrypt(x) for x in dictionary)\n        \n    def encrypt(self, word1):\n        \"\"\"\n        :type word1: str\n        :rtype: str\n        \"\"\"\n        if any(c not in self.__lookup for c in word1):\n            return \"\"\n        return \"\".join(self.__lookup[c] for c in word1)\n\n    def decrypt(self, word2):\n        \"\"\"\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        return self.__cnt[word2]\n"
    },
    {
        "problem_name": "equal-rational-numbers",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nfrom fractions import Fraction\n\n\nclass Solution(object):\n    def isRationalEqual(self, S, T):\n        \"\"\"\n        :type S: str\n        :type T: str\n        :rtype: bool\n        \"\"\"\n        def frac(S):\n            if '.' not in S:\n                return Fraction(int(S), 1)\n\n            i = S.index('.')\n            result = Fraction(int(S[:i]), 1)\n            non_int_part = S[i+1:]\n            if '(' not in non_int_part:\n                if non_int_part:\n                    result += Fraction(int(non_int_part), 10**len(non_int_part))\n                return result\n\n            i = non_int_part.index('(')\n            if i:\n                result += Fraction(int(non_int_part[:i]), 10**i)\n            repeat_part = non_int_part[i+1:-1]\n            result += Fraction(int(repeat_part), 10**i * (10**len(repeat_part)-1))\n            return result\n\n        return frac(S) == frac(T)\n"
    },
    {
        "problem_name": "equal-row-and-column-pairs",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nimport collections\nimport itertools\n\n\n# hash table\nclass Solution(object):\n    def equalPairs(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        cnt1 = collections.Counter(tuple(row) for row in grid)\n        cnt2 = collections.Counter(tuple(col) for col in itertools.izip(*grid))\n        return sum(cnt1[k]*cnt2[k] for k in cnt1.iterkeys() if k in cnt2)\n"
    },
    {
        "problem_name": "equal-sum-arrays-with-minimum-number-of-operations",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def minOperations(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums1)*6 < len(nums2) or len(nums1) > len(nums2)*6:\n            return -1\n        diff = sum(nums2)-sum(nums1)\n        if diff < 0:\n            nums1, nums2 = nums2, nums1\n            diff = -diff\n        count = collections.Counter(6-num for num in nums1)\n        count += collections.Counter(num-1 for num in nums2)\n        result = 0\n        for i in reversed(xrange(1, 6)):\n            if not count[i]:\n                continue\n            cnt = min(count[i], (diff+i-1)//i)\n            result += cnt\n            diff -= i*cnt\n            if diff <= 0:\n                break\n        return result\n"
    },
    {
        "problem_name": "equal-tree-partition",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def checkEqualTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def getSumHelper(node, lookup):\n            if not node:\n                return 0\n            total = node.val + \\\n                    getSumHelper(node.left, lookup) + \\\n                    getSumHelper(node.right, lookup)\n            lookup[total] += 1\n            return total\n\n        lookup = collections.defaultdict(int)\n        total = getSumHelper(root, lookup)\n        if total == 0:\n            return lookup[total] > 1\n        return total%2 == 0 and (total/2) in lookup\n\n"
    },
    {
        "problem_name": "equalize-strings-by-adding-or-removing-characters-at-ends",
        "solution": "# Time:  O((n + m) * log(min(n, m)))\n# Space: O(min(n, m))\n\n# binary search, rolling hash\nclass Solution(object):\n    def minOperations(self, initial, target):\n        \"\"\"\n        :type initial: str\n        :type target: str\n        :rtype: int\n        \"\"\"\n        def binary_search_right(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if not check( mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return right\n        \n        def rolling_hash(s, l, lookup, check):\n            MOD, P = 10**9+7, 113\n            h = 0\n            pw = pow(P, l-1, MOD)\n            for i in range(len(s)):\n                h = (h*P+(ord(s[i])-ord('a')))%MOD\n                if i < l-1:\n                    continue\n                if not check:\n                    lookup.add(h)\n                elif h in lookup:\n                    return True\n                h = (h-(ord(s[i-(l-1)])-ord('a'))*pw)%MOD\n            return False\n                    \n        def check(l):\n            lookup = set()\n            rolling_hash(target, l, lookup, False)\n            return rolling_hash(initial, l, lookup, True)\n\n        if len(initial) < len(target):\n            initial, target = target, initial\n        return len(initial)+len(target)-2*binary_search_right(1, min(len(initial), min(target)), check)\n\n\n# Time:  O(n * m)\n# Space: O(1)\n# dp\nclass Solution2(object):\n    def minOperations(self, initial, target):\n        \"\"\"\n        :type initial: str\n        :type target: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        for k in range(2):\n            for i in xrange(k, len(initial)):\n                curr = 0\n                for j in xrange(min(len(initial)-i, len(target))):\n                    curr = curr+1 if initial[i+j] == target[j] else 0\n                    result = max(result, curr)\n            initial, target = target, initial\n        return len(initial)+len(target)-2*result\n\n\n# Time:  O(n * m)\n# Space: O(min(n, m))\n# dp\nclass Solution3(object):\n    def minOperations(self, initial, target):\n        \"\"\"\n        :type initial: str\n        :type target: str\n        :rtype: int\n        \"\"\"\n        if len(initial) < len(target):\n            initial, target = target, initial\n        result = 0\n        dp = [0]*(len(target)+1)\n        for i in xrange(len(initial)):\n            for j in reversed(xrange(len(target))):\n                dp[j+1] = dp[j]+1 if initial[i] == target[j] else 0\n            result = max(result, max(dp))\n        return len(initial)+len(target)-2*result\n"
    },
    {
        "problem_name": "erect-the-fence-ii",
        "solution": "# Time:  O(n) on average\n# Space: O(n)\n\nimport random\n\n\n# reference: https://en.wikipedia.org/wiki/Smallest-circle_problem\nclass Solution(object):\n    def outerTrees(self, trees):\n        \"\"\"\n        :type trees: List[List[int]]\n        :rtype: List[float]\n        \"\"\"\n        def dist(a, b):\n            return ((a[0]-b[0])**2 + (a[1]-b[1])**2)**0.5\n\n        def inside(c, p):\n            return dist(c[0], p) < c[1]+EPS\n\n        def circle_center(bx, by, cx, cy):\n            B = bx*bx + by*by\n            C = cx*cx + cy*cy\n            D = bx*cy - by*cx\n            return [float(cy*B - by*C)/(2*D),\n                    float(bx*C - cx*B)/(2*D)]\n\n        def circle_from_2_points(A, B):\n            C = [(A[0]+B[0])/2.0, (A[1]+B[1])/2.0]\n            return [C, dist(A, B)/2.0]\n\n        def circle_from_3_points(A, B, C):\n            I = circle_center(B[0]-A[0], B[1]-A[1],\n                              C[0]-A[0], C[1]-A[1])\n            I[0] += A[0]\n            I[1] += A[1]\n            return [I, dist(I, A)]\n\n        def trivial(boundaries):  # circumscribed circle\n            if not boundaries:\n                return None\n            if len(boundaries) == 1:\n                return [boundaries[0], 0.0]\n            if len(boundaries) == 2:\n                return circle_from_2_points(boundaries[0], boundaries[1])\n            return circle_from_3_points(boundaries[0], boundaries[1], boundaries[2])\n\n        def Welzl(points, boundaries, curr):\n            if curr == len(points) or len(boundaries) == 3:\n                return trivial(boundaries)\n            result = Welzl(points, boundaries, curr+1)\n            if result is not None and inside(result, points[curr]):\n                return result\n            boundaries.append(points[curr])\n            result = Welzl(points, boundaries, curr+1)\n            boundaries.pop()\n            return result\n\n        EPS = 1e-5\n        random.seed(0)\n        random.shuffle(trees)\n        result = Welzl(trees, [], 0)\n        return result[0][0], result[0][1], result[1]\n"
    },
    {
        "problem_name": "erect-the-fence",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# Monotone Chain Algorithm\n# Template: https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#Python\nclass Solution(object):\n    def outerTrees(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        # Sort the points lexicographically (tuples are compared lexicographically).\n        # Remove duplicates to detect the case we have just one unique point.\n        points = sorted(set(tuple(x) for x in points))\n\n        # Boring case: no points or a single point, possibly repeated multiple times.\n        if len(points) <= 1:\n            return points\n\n        # 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.\n        # Returns a positive value, if OAB makes a counter-clockwise turn,\n        # negative for clockwise turn, and zero if the points are collinear.\n        def cross(o, a, b):\n            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n        # Build lower hull \n        lower = []\n        for p in points:\n            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0:  # modified\n                lower.pop()\n            lower.append(p)\n\n        # Build upper hull\n        upper = []\n        for p in reversed(points):\n            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) < 0:  # modified\n                upper.pop()\n            upper.append(p)\n\n        # Concatenation of the lower and upper hulls gives the convex hull.\n        # Last point of each list is omitted because it is repeated at the beginning of the other list. \n        result = lower[:-1] + upper[:-1]\n        return result if result[1] != result[-1] else result[:len(result)//2+1]  # modified\n"
    },
    {
        "problem_name": "escape-a-large-maze",
        "solution": "# Time:  O(n^2), n is the number of blocked\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def isEscapePossible(self, blocked, source, target):\n        \"\"\"\n        :type blocked: List[List[int]]\n        :type source: List[int]\n        :type target: List[int]\n        :rtype: bool\n        \"\"\"\n        R, C = 10**6, 10**6\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def bfs(blocks, source, target):\n            max_area_surrounded_by_blocks = len(blocks)*(len(blocks)-1)//2\n            lookup = set([source])\n            if len(lookup) > max_area_surrounded_by_blocks:\n                return True\n            q = collections.deque([source])\n            while q:\n                source = q.popleft()\n                if source == target:\n                    return True\n                for direction in directions:\n                    nr, nc = source[0]+direction[0], source[1]+direction[1]\n                    if not ((0 <= nr < R) and\n                            (0 <= nc < C) and \n                            (nr, nc) not in lookup and\n                            (nr, nc) not in blocks):\n                        continue\n                    lookup.add((nr, nc))\n                    if len(lookup) > max_area_surrounded_by_blocks:\n                        return True\n                    q.append((nr, nc))\n            return False\n        \n        return bfs(set(map(tuple, blocked)), tuple(source), tuple(target)) and \\\n               bfs(set(map(tuple, blocked)), tuple(target), tuple(source))\n"
    },
    {
        "problem_name": "escape-the-ghosts",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def escapeGhosts(self, ghosts, target):\n        \"\"\"\n        :type ghosts: List[List[int]]\n        :type target: List[int]\n        :rtype: bool\n        \"\"\"\n        total = abs(target[0])+abs(target[1])\n        return all(total < abs(target[0]-i)+abs(target[1]-j) for i, j in ghosts)\n\n"
    },
    {
        "problem_name": "escape-the-spreading-fire",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nimport collections\n\n\n# bfs\nclass Solution(object):\n    def maximumMinutes(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        GRASS, FIRE, WALL, PERSON = range(4)\n        INF = 10**9\n        def bfs(grid):\n            time = collections.defaultdict(int)\n            d = 0\n            q = [(r, c, FIRE) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c] == FIRE]\n            q.append((0, 0, PERSON))\n            while q:\n                new_q = []\n                for r, c, t in q:\n                    for dr, dc in DIRECTIONS:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and\n                                grid[nr][nc] != WALL and\n                                ((t == FIRE and grid[nr][nc] != FIRE) or\n                                 (t == PERSON and (grid[nr][nc] == GRASS or (grid[nr][nc] == FIRE and (nr, nc) == (len(grid)-1, len(grid[0])-1) and d+1 == time[FIRE, nr, nc]))))):\n                            continue\n                        if grid[nr][nc] != FIRE:\n                            grid[nr][nc] = t\n                        if (nr, nc) in ((len(grid)-1, len(grid[0])-1), (len(grid)-1, len(grid[0])-2), (len(grid)-2, len(grid[0])-1)):\n                            time[t, nr, nc] = d+1\n                        new_q.append((nr, nc, t))\n                q = new_q\n                d += 1\n            return time\n\n        time = bfs(grid)\n        if not time[PERSON, len(grid)-1, len(grid[0])-1]:\n            return -1\n        if not time[FIRE, len(grid)-1, len(grid[0])-1]:\n            return INF\n        diff = time[FIRE, len(grid)-1, len(grid[0])-1]-time[PERSON, len(grid)-1, len(grid[0])-1]\n        return diff if diff+2 in (time[FIRE, len(grid)-1, len(grid[0])-2]-time[PERSON, len(grid)-1, len(grid[0])-2],\n                                  time[FIRE, len(grid)-2, len(grid[0])-1]-time[PERSON, len(grid)-2, len(grid[0])-1]) else diff-1\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\n# bfs\nclass Solution2(object):\n    def maximumMinutes(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        FIRE, WALL, PERSON = range(1, 4)\n        INF = 10**9\n        def bfs(grid):\n            time = {FIRE:[[INF]*len(grid[0]) for _ in xrange(len(grid))],\n                    PERSON:[[INF]*len(grid[0]) for _ in xrange(len(grid))]}\n            d = 0\n            q = [(r, c, FIRE) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c] == FIRE]\n            q.append((0, 0, PERSON))\n            for r, c, t in q:\n                time[t][r][c] = d\n            while q:\n                new_q = []\n                for r, c, t in q:\n                    for dr, dc in DIRECTIONS:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and\n                                grid[nr][nc] != WALL and time[t][nr][nc] == INF and\n                                (t == FIRE or\n                                 d+1 < time[FIRE][nr][nc] or (d+1 == time[FIRE][nr][nc] and (nr, nc) == (len(grid)-1, len(grid[0])-1)))):\n                            continue\n                        time[t][nr][nc] = d+1\n                        new_q.append((nr, nc, t))\n                q = new_q\n                d += 1\n            return time\n\n        time = bfs(grid)\n        if time[PERSON][-1][-1] == INF:\n            return -1\n        if time[FIRE][-1][-1] == INF:\n            return INF\n        diff = time[FIRE][-1][-1]-time[PERSON][-1][-1]\n        return diff if diff+2 in (time[FIRE][-1][-2]-time[PERSON][-1][-2], time[FIRE][-2][-1]-time[PERSON][-2][-1]) else diff-1\n"
    },
    {
        "problem_name": "evaluate-boolean-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\n# dfs with stack\nclass Solution(object):\n    def evaluateTree(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        INF = float(\"inf\")\n        OP = {\n            2: lambda x, y: x or y,\n            3: lambda x, y: x and y\n        }\n        \n        def iter_dfs(root):\n            ret = [0]\n            stk = [(1, (root, ret))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    node, ret = args\n                    if node.left == node.right:\n                        ret[0] = node.val\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, (node, ret1, ret2, ret)))\n                    stk.append((1, (node.right, ret2)))\n                    stk.append((1, (node.left, ret1)))\n                elif step == 2:\n                    node, ret1, ret2, ret = args\n                    ret[0] = OP[node.val](ret1[0], ret2[0])\n            return ret[0]\n\n        return iter_dfs(root)\n\n\n# Time:  O(n)\n# Space: O(h)\n# dfs with recursion\nclass Solution2(object):\n    def evaluateTree(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        INF = float(\"inf\")\n        OP = {\n            2: lambda x, y: x or y,\n            3: lambda x, y: x and y,\n        }\n        \n        def dfs(node):\n            if node.left == node.right:\n                return node.val\n            return OP[node.val](dfs(node.left), dfs(node.right))\n\n        return dfs(root)\n"
    },
    {
        "problem_name": "evaluate-division",
        "solution": "# Time:  O((e + q) * \u03b1(n)) ~= O(e + q), using either one of \"path compression\" and \"union by rank\" results in amortized O(logn)\n#                                     , using  both results in \u03b1(n) ~= O(1)\n# Space: O(n)\n\nimport collections\nimport itertools\n\n\nclass UnionFind(object):\n    def __init__(self):\n        self.set = {}\n        self.rank = collections.Counter()\n\n    def find_set(self, x):\n        xp, xr = self.set.setdefault(x, (x, 1.0))\n        if x != xp:\n            pp, pr = self.find_set(xp)  # path compression.\n            self.set[x] = (pp, xr*pr)  # x/pp = xr*pr\n        return self.set[x]\n\n    def union_set(self, x, y, r):\n        (xp, xr), (yp, yr) =  map(self.find_set, (x, y))\n        if xp == yp:\n            return False\n        if self.rank[xp] < self.rank[yp]:  # union by rank\n            # to make x/yp = r*yr and merge xp into yp\n            # => since x/xp = xr, we can merge with xp/yp = r*yr/xr \n            self.set[xp] = (yp, r*yr/xr)\n        elif self.rank[xp] > self.rank[yp]:\n            # to make y/xp = 1/r*xr and merge xp into yp\n            # => since y/yp = yr, we can merge with yp/xp = 1/r*xr/yr \n            self.set[yp] = (xp, 1.0/r*xr/yr)\n        else:\n            # to make y/xp = 1/r*xr and merge xp into yp\n            # => since y/yp = yr, we can merge with yp/xp = 1/r*xr/yr \n            self.set[yp] = (xp, 1.0/r*xr/yr)\n            self.rank[xp] += 1 \n        return True\n\n    def query_set(self, x, y):\n        if x not in self.set or y not in self.set:\n            return -1.0\n        (xp, xr), (yp, yr) = map(self.find_set, (x, y))\n        return xr/yr if xp == yp else -1.0\n\n\nclass UnionFindPathCompressionOnly(object):\n    def __init__(self):\n        self.set = {}\n\n    def find_set(self, x):\n        xp, xr = self.set.setdefault(x, (x, 1.0))\n        if x != xp:\n            pp, pr = self.find_set(xp)  # path compression.\n            self.set[x] = (pp, xr*pr)  # x/pp = xr*pr\n        return self.set[x]\n\n    def union_set(self, x, y, r):\n        (xp, xr), (yp, yr) =  map(self.find_set, (x, y))\n        if xp == yp:\n            return False\n        # to make x/yp = r*yr and merge xp into yp\n        # => since x/xp = xr, we can merge with xp/yp = r*yr/xr \n        self.set[xp] = (yp, r*yr/xr)\n        return True\n\n    def query_set(self, x, y):\n        if x not in self.set or y not in self.set:\n            return -1.0\n        (xp, xr), (yp, yr) = map(self.find_set, (x, y))\n        return xr/yr if xp == yp else -1.0\n\n\nclass Solution(object):\n    def calcEquation(self, equations, values, queries):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type queries: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        union_find = UnionFind()\n        for (a, b), k in itertools.izip(equations, values):\n            union_find.union_set(a, b, k)\n        return [union_find.query_set(a, b) for a, b in queries]\n\n\n# Time:  O(e + q * n), at most O(n^3 + q)\n# Space: O(n^2)\n# bfs solution\nimport collections\nimport itertools\n\n\nclass Solution2(object):\n    def calcEquation(self, equations, values, queries):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type queries: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        adj = collections.defaultdict(dict)\n        for (a, b), k in itertools.izip(equations, values):\n            adj[a][b] = k\n            adj[b][a] = 1.0/k\n\n        def bfs(adj, a, b, lookup):\n            if a not in adj or b not in adj:\n                return -1.0\n            if (a, b) in lookup:\n                return lookup[a, b]\n            visited = {a}\n            q = collections.deque([(a, 1.0)])\n            while q:\n                u, val = q.popleft()\n                if u == b:\n                    lookup[a, b] = val\n                    return val\n                for v, k in adj[u].iteritems():\n                    if v in visited:\n                        continue                    \n                    visited.add(v)\n                    q.append((v, val*k))\n            lookup[a, b] = -1.0\n            return -1.0\n\n        lookup = {}\n        return [bfs(adj, a, b, lookup) for a, b in queries]\n\n\n# Time:  O(n^3 + q)\n# Space: O(n^2)\nimport collections\nimport itertools\n\n\n# variant of floyd\u2013warshall algorithm solution\nclass Solution3(object):\n    def calcEquation(self, equations, values, queries):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type queries: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        adj = collections.defaultdict(dict)\n        for (a, b), k in itertools.izip(equations, values):\n            adj[a][a] = adj[b][b] = 1.0\n            adj[a][b] = k\n            adj[b][a] = 1.0/k\n        for k in adj:\n            for i in adj[k]:\n                for j in adj[k]:\n                    adj[i][j] = adj[i][k]*adj[k][j]\n        return [adj[a].get(b, -1.0) for a, b in queries]\n\n    \n# Time:  O(e + q * n), at most O(n^3 + q)\n# Space: O(e)\nimport collections\n\n\nclass Solution4(object):\n    def calcEquation(self, equations, values, query):\n        \"\"\"\n        :type equations: List[List[str]]\n        :type values: List[float]\n        :type query: List[List[str]]\n        :rtype: List[float]\n        \"\"\"\n        def check(up, down, lookup, visited):\n            if up in lookup and down in lookup[up]:\n                return (True, lookup[up][down])\n            for k, v in lookup[up].iteritems():\n                if k not in visited:\n                    visited.add(k)\n                    tmp = check(k, down, lookup, visited)\n                    if tmp[0]:\n                        return (True, v * tmp[1])\n            return (False, 0)\n\n        lookup = collections.defaultdict(dict)\n        for i, e in enumerate(equations):\n            lookup[e[0]][e[1]] = values[i]\n            if values[i]:\n                lookup[e[1]][e[0]] = 1.0 / values[i]\n\n        result = []\n        for q in query:\n            visited = set()\n            tmp = check(q[0], q[1], lookup, visited)\n            result.append(tmp[1] if tmp[0] else -1)\n        return result\n"
    },
    {
        "problem_name": "evaluate-reverse-polish-notation",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport operator\n\nclass Solution(object):\n    # @param tokens, a list of string\n    # @return an integer\n    def evalRPN(self, tokens):\n        numerals, operators = [], {\"+\": operator.add, \"-\": operator.sub, \"*\": operator.mul, \"/\": operator.div}\n        for token in tokens:\n            if token not in operators:\n                numerals.append(int(token))\n            else:\n                y, x = numerals.pop(), numerals.pop()\n                numerals.append(int(operators[token](x * 1.0, y)))\n        return numerals.pop()\n\n"
    },
    {
        "problem_name": "evaluate-the-bracket-pairs-of-a-string",
        "solution": "# Time:  O(n + m)\n# Space: O(n + m)\n\nclass Solution(object):\n    def evaluate(self, s, knowledge):\n        \"\"\"\n        :type s: str\n        :type knowledge: List[List[str]]\n        :rtype: str\n        \"\"\"\n        lookup = {k: v for k, v in knowledge}\n        result, curr = [], []\n        has_pair = False\n        for c in s:\n            if c == '(':\n                has_pair = True\n            elif c == ')':\n                has_pair = False\n                result.append(lookup.get(\"\".join(curr), '?'))\n                curr = []\n            elif has_pair:\n                curr.append(c)\n            else:\n                result.append(c)\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "even-odd-tree",
        "solution": "# Time:  O(n)\n# Space: O(w)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def isEvenOddTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        q = [root]\n        is_odd = False\n        while q:\n            new_q = []\n            prev = None\n            for node in q:\n                if is_odd:\n                    if node.val%2 or (prev and prev.val <= node.val):\n                        return False\n                else:\n                    if not node.val%2 or (prev and prev.val >= node.val):\n                        return False\n                if node.left:\n                    new_q.append(node.left)\n                if node.right:\n                    new_q.append(node.right)\n                prev = node\n            q = new_q\n            is_odd = not is_odd\n        return True\n"
    },
    {
        "problem_name": "exam-room",
        "solution": "# Time:  seat:  O(logn), amortized\n#        leave: O(logn)\n# Space: O(n)\n\nimport heapq\n\n\nclass ExamRoom(object):\n\n    def __init__(self, N):\n        \"\"\"\n        :type N: int\n        \"\"\"\n        self.__num = N\n        self.__seats = {-1: [-1, self.__num], self.__num: [-1, self.__num]}\n        self.__max_heap = [(-self.__distance((-1, self.__num)), -1, self.__num)]\n\n    def seat(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.__max_heap[0][1] not in self.__seats or \\\n              self.__max_heap[0][2] not in self.__seats or \\\n              self.__seats[self.__max_heap[0][1]][1] != self.__max_heap[0][2] or \\\n              self.__seats[self.__max_heap[0][2]][0] !=  self.__max_heap[0][1]:\n            heapq.heappop(self.__max_heap)  # lazy deletion\n\n        _, left, right = heapq.heappop(self.__max_heap)\n        mid = 0 if left == -1 \\\n              else self.__num-1 if right == self.__num \\\n              else (left+right) // 2\n        self.__seats[mid] = [left, right]\n        heapq.heappush(self.__max_heap, (-self.__distance((left, mid)), left, mid))\n        heapq.heappush(self.__max_heap, (-self.__distance((mid, right)), mid, right))\n        self.__seats[left][1] = mid\n        self.__seats[right][0] = mid\n        return mid\n\n    def leave(self, p):\n        \"\"\"\n        :type p: int\n        :rtype: void\n        \"\"\"\n        left, right = self.__seats[p]\n        self.__seats.pop(p)\n        self.__seats[left][1] = right\n        self.__seats[right][0] = left\n        heapq.heappush(self.__max_heap, (-self.__distance((left, right)), left, right))\n        \n    def __distance(self, segment):\n        return segment[1]-segment[0]-1 if segment[0] == -1 or segment[1] == self.__num \\\n               else (segment[1]-segment[0]) // 2\n\n"
    },
    {
        "problem_name": "excel-sheet-column-number",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def titleToNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(len(s)):\n            result *= 26\n            result += ord(s[i]) - ord('A') + 1\n        return result\n\n\n"
    },
    {
        "problem_name": "excel-sheet-column-title",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def convertToTitle(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        result = []\n        while n:\n            result += chr((n-1)%26 + ord('A'))\n            n = (n-1)//26\n        result.reverse()\n        return \"\".join(result)\n\n"
    },
    {
        "problem_name": "exclusive-time-of-functions",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def exclusiveTime(self, n, logs):\n        \"\"\"\n        :type n: int\n        :type logs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * n\n        stk, prev = [], 0\n        for log in logs:\n            tokens = log.split(\":\")\n            if tokens[1] == \"start\":\n                if stk:\n                    result[stk[-1]] += int(tokens[2]) - prev\n                stk.append(int(tokens[0]))\n                prev = int(tokens[2])\n            else:\n                result[stk.pop()] += int(tokens[2]) - prev + 1\n                prev = int(tokens[2]) + 1\n        return result\n\n"
    },
    {
        "problem_name": "execution-of-all-suffix-instructions-staying-in-a-grid",
        "solution": "# Time:  O(m)\n# Space: O(m)\n\nimport collections\n\n\nclass Solution(object):\n    def executeInstructions(self, n, startPos, s):\n        \"\"\"\n        :type n: int\n        :type startPos: List[int]\n        :type s: str\n        :rtype: List[int]\n        \"\"\"\n        directions = {'U':(-1, 0), 'R':(0, 1), 'D':(1, 0), 'L':(0, -1)}\n        (x0, y0), (x, y) = startPos, (0, 0)\n        result = range(len(s), 0, -1)\n        lookup_x = collections.defaultdict(list)\n        lookup_y = collections.defaultdict(list)\n        lookup_x[x0-x].append(0)\n        lookup_y[y0-y].append(0)\n        for i, d in enumerate(s):\n            dx, dy = directions[d]\n            x, y = x+dx, y+dy\n            for k in n-x, -x-1:\n                if k not in lookup_x:\n                    continue\n                for j in lookup_x[k]:\n                    result[j] = min(result[j], i-j)\n                lookup_x[k] = []\n            for k in n-y, -y-1:\n                if k not in lookup_y:\n                    continue\n                for j in lookup_y[k]:\n                    result[j] = min(result[j], i-j)\n                lookup_y[k] = []\n            lookup_x[x0-x].append(i+1)\n            lookup_y[y0-y].append(i+1)\n        return result\n"
    },
    {
        "problem_name": "existence-of-a-substring-in-a-string-and-its-reverse",
        "solution": "# Time:  O(n)\n# Space: O(min(n, 26^2))\n\n# hash table\nclass Solution(object):\n    def isSubstringPresent(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        lookup = [[False]*26 for _ in xrange(26)]\n        for i in xrange(len(s)-1):\n            lookup[ord(s[i])-ord('a')][ord(s[i+1])-ord('a')] = True\n        return any(lookup[ord(s[i+1])-ord('a')][ord(s[i])-ord('a')]  for i in xrange(len(s)-1))\n    \n\n# Time:  O(n)\n# Space: O(min(n, 26^2))\nimport collections\n\n\n# hash table\nclass Solution2(object):\n    def isSubstringPresent(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        lookup = collections.defaultdict(set)\n        for i in xrange(len(s)-1):\n            lookup[s[i]].add(s[i+1])\n        return any(s[i] in lookup[s[i+1]] for i in xrange(len(s)-1))\n"
    },
    {
        "problem_name": "expression-add-operators",
        "solution": "# Time:  O(4^n)\n# Space: O(n)\n\nclass Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        result, expr = [], []\n        val, i = 0, 0\n        val_str = \"\"\n        while i < len(num):\n            val = val * 10 + ord(num[i]) - ord('0')\n            val_str += num[i]\n            # Avoid \"00...\".\n            if str(val) != val_str:\n                break\n            expr.append(val_str)\n            self.addOperatorsDFS(num, target, i + 1, 0, val, expr, result)\n            expr.pop()\n            i += 1\n        return result\n\n    def addOperatorsDFS(self, num, target, pos, operand1, operand2, expr, result):\n        if pos == len(num) and operand1 + operand2 == target:\n            result.append(\"\".join(expr))\n        else:\n            val, i = 0, pos\n            val_str = \"\"\n            while i < len(num):\n                val = val * 10 + ord(num[i]) - ord('0')\n                val_str += num[i]\n                # Avoid \"00...\".\n                if str(val) != val_str:\n                    break\n\n                # Case '+':\n                expr.append(\"+\" + val_str)\n                self.addOperatorsDFS(num, target, i + 1, operand1 + operand2, val, expr, result)\n                expr.pop()\n\n                # Case '-':\n                expr.append(\"-\" + val_str)\n                self.addOperatorsDFS(num, target, i + 1, operand1 + operand2, -val, expr, result)\n                expr.pop()\n\n                # Case '*':\n                expr.append(\"*\" + val_str)\n                self.addOperatorsDFS(num, target, i + 1, operand1, operand2 * val, expr, result)\n                expr.pop()\n\n                i += 1\n\n\n"
    },
    {
        "problem_name": "expressive-words",
        "solution": "# Time:  O(n + s), n is the sum of all word lengths, s is the length of S\n# Space: O(l + s), l is the max word length\n\nimport itertools\n\n\nclass Solution(object):\n    def expressiveWords(self, S, words):\n        \"\"\"\n        :type S: str\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        # Run length encoding\n        def RLE(S):\n            return itertools.izip(*[(k, len(list(grp)))\n                                  for k, grp in itertools.groupby(S)])\n\n        R, count = RLE(S)\n        result = 0\n        for word in words:\n            R2, count2 = RLE(word)\n            if R2 != R:\n                continue\n            result += all(c1 >= max(c2, 3) or c1 == c2\n                          for c1, c2 in itertools.izip(count, count2))\n        return result\n\n"
    },
    {
        "problem_name": "extra-characters-in-a-string",
        "solution": "# Time:  O((n + m) * l), l is max(len(w) for w in dictionary)\n# Space: O(n + t)\n\nimport collections\n\n\n# trie, dp\nclass Solution(object):\n    def minExtraChar(self, s, dictionary):\n        \"\"\"\n        :type s: str\n        :type dictionary: List[str]\n        :rtype: int\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        for word in dictionary:\n            reduce(dict.__getitem__, word, trie).setdefault(\"_end\")\n        dp = [float(\"inf\")]*(len(s)+1)\n        dp[0] = 0\n        for i in xrange(len(s)):\n            dp[i+1] = min(dp[i+1], dp[i]+1)\n            curr = trie\n            for j in xrange(i, len(s)):\n                if s[j] not in curr:\n                    break\n                curr = curr[s[j]]\n                if \"_end\" in curr:\n                    dp[j+1] = min(dp[j+1], dp[i])\n        return dp[-1]\n"
    },
    {
        "problem_name": "extract-kth-character-from-the-rope-tree",
        "solution": "# Time:  O(h)\n# Space: O(1)\n\n# Definition for a rope tree node.\nclass RopeTreeNode(object):\n    def __init__(self, len=0, val=\"\", left=None, right=None):\n        pass\n\n\n# binary search tree\nclass Solution(object):\n    def getKthCharacter(self, root, k):\n        \"\"\"\n        :type root: Optional[RopeTreeNode]\n        :type k: int\n        :rtype: str\n        \"\"\"\n        while root.len:\n            l = max(root.left.len, len(root.left.val)) if root.left else 0\n            if k <= l:\n                root = root.left\n            else:\n                k -= l\n                root = root.right\n        return root.val[k-1]\n"
    },
    {
        "problem_name": "factor-combinations",
        "solution": "# Time:  O(nlogn)\n# Space: O(logn)\n\nclass Solution(object):\n    # @param {integer} n\n    # @return {integer[][]}\n    def getFactors(self, n):\n        result = []\n        factors = []\n        self.getResult(n, result, factors)\n        return result\n\n    def getResult(self, n, result, factors):\n        i = 2 if not factors else factors[-1]\n        while i <= n / i:\n            if n % i == 0:\n                factors.append(i)\n                factors.append(n / i)\n                result.append(list(factors))\n                factors.pop()\n                self.getResult(n / i, result, factors)\n                factors.pop()\n            i += 1\n\n"
    },
    {
        "problem_name": "factorial-trailing-zeroes",
        "solution": "# Time:  O(logn) = O(1)\n# Space: O(1)\n\nclass Solution(object):\n    # @return an integer\n    def trailingZeroes(self, n):\n        result = 0\n        while n > 0:\n            result += n / 5\n            n /= 5\n        return result\n\n"
    },
    {
        "problem_name": "fair-candy-swap",
        "solution": "# Time:  O(m + n)\n# Space: O(m + n)\n\nclass Solution(object):\n    def fairCandySwap(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: List[int]\n        \"\"\"\n        diff = (sum(A)-sum(B))//2\n        setA = set(A)\n        for b in set(B):\n            if diff+b in setA:\n                return [diff+b, b]\n        return []\n\n"
    },
    {
        "problem_name": "fair-distribution-of-cookies",
        "solution": "# Time:  O(k * 3^n)\n# Space: O(2^n)\n\n# dp, submask enumeration\nclass Solution(object):\n    def distributeCookies(self, cookies, k):\n        \"\"\"\n        :type cookies: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        total = [0]*(1<<len(cookies))\n        for mask in xrange(1<<len(cookies)):\n            total[mask] = sum(cookies[i] for i in xrange(len(cookies)) if mask&(1<<i))\n        dp = [[float(\"inf\")]*(1<<len(cookies)) for _ in xrange(2)]\n        dp[0][0] = 0\n        for i in xrange(k):\n            for mask in xrange(1<<len(cookies)):\n                submask = mask\n                while submask:\n                    dp[(i+1)%2][mask] = min(dp[(i+1)%2][mask], max(total[submask], dp[i%2][mask^submask]))\n                    submask = (submask-1)&mask\n        return dp[k%2][-1]\n"
    },
    {
        "problem_name": "falling-squares",
        "solution": "# Time:  O(n^2), could be improved to O(nlogn) in cpp by ordered map (bst)\n# Space: O(n)\n\nimport bisect\n\n\nclass Solution(object):\n    def fallingSquares(self, positions):\n        result = []\n        pos = [-1]\n        heights = [0]\n        maxH = 0\n        for left, side in positions:\n            l = bisect.bisect_right(pos, left)\n            r = bisect.bisect_left(pos, left+side)\n            high = max(heights[l-1:r] or [0]) + side\n            pos[l:r] = [left, left+side]         # Time: O(n)\n            heights[l:r] = [high, heights[r-1]]  # Time: O(n)\n            maxH = max(maxH, high)\n            result.append(maxH)\n        return result\n\n\nclass SegmentTree(object):\n    def __init__(self, N,\n                 query_fn=min,\n                 update_fn=lambda x, y: y,\n                 default_val=float(\"inf\")):\n        self.N = N\n        self.H = (N-1).bit_length()\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        self.default_val = default_val\n        self.tree = [default_val] * (2 * N)\n        self.lazy = [None] * N\n\n    def __apply(self, x, val):\n        self.tree[x] = self.update_fn(self.tree[x], val)\n        if x < self.N:\n            self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n    def update(self, L, R, h):\n        def pull(x):\n            while x > 1:\n                x //= 2\n                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2 + 1])\n                if self.lazy[x] is not None:\n                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\n\n        L += self.N\n        R += self.N\n        L0, R0 = L, R\n        while L <= R:\n            if L & 1:\n                self.__apply(L, h)\n                L += 1\n            if R & 1 == 0:\n                self.__apply(R, h)\n                R -= 1\n            L //= 2\n            R //= 2\n        pull(L0)\n        pull(R0)\n\n    def query(self, L, R):\n        def push(x):\n            n = 2**self.H\n            while n != 1:\n                y = x // n\n                if self.lazy[y] is not None:\n                    self.__apply(y*2, self.lazy[y])\n                    self.__apply(y*2 + 1, self.lazy[y])\n                    self.lazy[y] = None\n                n //= 2\n\n        result = self.default_val\n        if L > R:\n            return result\n\n        L += self.N\n        R += self.N\n        push(L)\n        push(R)\n        while L <= R:\n            if L & 1:\n                result = self.query_fn(result, self.tree[L])\n                L += 1\n            if R & 1 == 0:\n                result = self.query_fn(result, self.tree[R])\n                R -= 1\n            L //= 2\n            R //= 2\n        return result\n    \n    def data(self):\n        showList = []\n        for i in xrange(self.N):\n            showList.append(self.query(i, i))\n        return showList\n\n\nclass SegmentTree2(object):\n    def __init__(self, nums,\n                 query_fn=min,\n                 update_fn=lambda x, y: y,\n                 default_val=float(\"inf\")):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        N = len(nums)\n        self.__original_length = N\n        self.__tree_length = 2**(N.bit_length() + (N&(N-1) != 0))-1\n        self.__query_fn = query_fn\n        self.__update_fn = update_fn\n        self.__default_val = default_val\n        self.__tree = [default_val for _ in range(self.__tree_length)]\n        self.__lazy = [None for _ in range(self.__tree_length)]\n        self.__constructTree(nums, 0, self.__original_length-1, 0)\n\n    def update(self, i, j, val):\n        self.__updateTree(val, i, j, 0, self.__original_length-1, 0)\n\n    def query(self, i, j):\n        return self.__queryRange(i, j, 0, self.__original_length-1, 0)\n\n    def __constructTree(self, nums, left, right, idx):\n        if left > right:\n             return\n        if left == right:\n            self.__tree[idx] = self.__update_fn(self.__tree[idx], nums[left])\n            return \n        mid = left + (right-left)//2\n        self.__constructTree(nums, left, mid, idx*2 + 1)\n        self.__constructTree(nums, mid+1, right, idx*2 + 2)\n        self.__tree[idx] = self.__query_fn(self.__tree[idx*2 + 1], self.__tree[idx*2 + 2])\n\n    def __apply(self, left, right, idx, val):\n        self.__tree[idx] = self.__update_fn(self.__tree[idx], val)\n        if left != right:\n            self.__lazy[idx*2 + 1] = self.__update_fn(self.__lazy[idx*2 + 1], val)\n            self.__lazy[idx*2 + 2] = self.__update_fn(self.__lazy[idx*2 + 2], val)\n\n    def __updateTree(self, val, range_left, range_right, left, right, idx):\n        if left > right:\n            return\n        if self.__lazy[idx] is not None:\n            self.__apply(left, right, idx, self.__lazy[idx])\n            self.__lazy[idx] = None\n        if range_left > right or range_right < left:\n            return\n        if range_left <= left and right <= range_right:\n            self.__apply(left, right, idx, val)\n            return\n        mid = left + (right-left)//2\n        self.__updateTree(val, range_left, range_right, left, mid, idx*2 + 1)\n        self.__updateTree(val, range_left, range_right, mid+1, right, idx*2 + 2)\n        self.__tree[idx] = self.__query_fn(self.__tree[idx*2 + 1],\n                                           self.__tree[idx*2 + 2])\n\n    def __queryRange(self, range_left, range_right, left, right, idx):\n        if left > right:\n            return self.__default_val\n        if self.__lazy[idx] is not None:\n            self.__apply(left, right, idx, self.__lazy[idx])\n            self.__lazy[idx] = None\n        if right < range_left or left > range_right:\n            return self.__default_val\n        if range_left <= left and right <= range_right:\n            return self.__tree[idx]\n        mid = left + (right-left)//2\n        return self.__query_fn(self.__queryRange(range_left, range_right, left, mid, idx*2 + 1), \n                               self.__queryRange(range_left, range_right, mid + 1, right, idx*2 + 2))\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# Segment Tree solution.\nclass Solution2(object):\n    def fallingSquares(self, positions):\n        index = set()\n        for left, size in positions:\n            index.add(left)\n            index.add(left+size-1)\n        index = sorted(list(index))\n        tree = SegmentTree(len(index), max, max, 0)\n        # tree = SegmentTree2([0]*len(index), max, max, 0)\n        max_height = 0\n        result = []\n        for left, size in positions:\n            L, R = bisect.bisect_left(index, left), bisect.bisect_left(index, left+size-1)\n            h = tree.query(L, R) + size\n            tree.update(L, R, h)\n            max_height = max(max_height, h)\n            result.append(max_height)\n        return result\n\n\n# Time:  O(n * sqrt(n))\n# Space: O(n)\nclass Solution3(object):\n    def fallingSquares(self, positions):\n        def query(heights, left, right, B, blocks, blocks_read):\n            result = 0\n            while left % B and left <= right:\n                result = max(result, heights[left], blocks[left//B])\n                left += 1\n            while right % B != B-1 and left <= right:\n                result = max(result, heights[right], blocks[right//B])\n                right -= 1\n            while left <= right:\n                result = max(result, blocks[left//B], blocks_read[left//B])\n                left += B\n            return result\n\n        def update(heights, left, right, B, blocks, blocks_read, h):\n            while left % B and left <= right:\n                heights[left] = max(heights[left], h)\n                blocks_read[left//B] = max(blocks_read[left//B], h)\n                left += 1\n            while right % B != B-1 and left <= right:\n                heights[right] = max(heights[right], h)\n                blocks_read[right//B] = max(blocks_read[right//B], h)\n                right -= 1\n            while left <= right:\n                blocks[left//B] = max(blocks[left//B], h)\n                left += B\n\n        index = set()\n        for left, size in positions:\n            index.add(left)\n            index.add(left+size-1)\n        index = sorted(list(index))\n        W = len(index)\n        B = int(W**.5)\n        heights = [0] * W\n        blocks = [0] * (B+2)\n        blocks_read = [0] * (B+2)\n\n        max_height = 0\n        result = []\n        for left, size in positions:\n            L, R = bisect.bisect_left(index, left), bisect.bisect_left(index, left+size-1)\n            h = query(heights, L, R, B, blocks, blocks_read) + size\n            update(heights, L, R, B, blocks, blocks_read, h)\n            max_height = max(max_height, h)\n            result.append(max_height)\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution4(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        heights = [0] * len(positions)\n        for i in xrange(len(positions)):\n            left_i, size_i = positions[i]\n            right_i = left_i + size_i\n            heights[i] += size_i\n            for j in xrange(i+1, len(positions)):\n                left_j, size_j = positions[j]\n                right_j = left_j + size_j\n                if left_j < right_i and left_i < right_j:  # intersect\n                    heights[j] = max(heights[j], heights[i])\n\n        result = []\n        for height in heights:\n            result.append(max(result[-1], height) if result else height)\n        return result\n\n"
    },
    {
        "problem_name": "fancy-sequence",
        "solution": "# Time:  O(1)\n# Space: O(n)\n\nMOD = 10**9+7\n\nclass Fancy(object):\n\n    def __init__(self):\n        self.__arr = []\n        self.__ops = [[1, 0]]\n\n    def append(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: None\n        \"\"\"\n        self.__arr.append(val)\n        self.__ops.append(self.__ops[-1][:])\n\n    def addAll(self, inc):\n        \"\"\"\n        :type inc: int\n        :rtype: None\n        \"\"\"\n        self.__ops[-1][1] = (self.__ops[-1][1]+inc) % MOD\n\n    def multAll(self, m):\n        \"\"\"\n        :type m: int\n        :rtype: None\n        \"\"\"\n        self.__ops[-1] = [(self.__ops[-1][0]*m) % MOD, (self.__ops[-1][1]*m) % MOD]\n\n    def getIndex(self, idx):\n        \"\"\"\n        :type idx: int\n        :rtype: int\n        \"\"\"\n        if idx >= len(self.__arr):\n            return -1\n        a1, b1 = self.__ops[idx]\n        a2, b2 = self.__ops[-1]\n        a = a2*pow(a1, MOD-2, MOD)%MOD  # O(logMOD), we treat it as O(1) here\n        b = (b2 - b1*a) % MOD\n        return (self.__arr[idx]*a + b) % MOD\n\n\n# Time:  O(1)\n# Space: O(n)\nclass Fancy2(object):\n\n    def __init__(self):\n        self.__arr = []\n        self.__op = [1, 0]\n\n    def append(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: None\n        \"\"\"\n        self.__arr.append((val-self.__op[1])*pow(self.__op[0], MOD-2, MOD)%MOD)  # O(logMOD), we treat it as O(1) here\n\n    def addAll(self, inc):\n        \"\"\"\n        :type inc: int\n        :rtype: None\n        \"\"\"\n        self.__op[1] = (self.__op[1]+inc) % MOD\n\n    def multAll(self, m):\n        \"\"\"\n        :type m: int\n        :rtype: None\n        \"\"\"\n        self.__op = [(self.__op[0]*m) % MOD, (self.__op[1]*m) % MOD]\n\n    def getIndex(self, idx):\n        \"\"\"\n        :type idx: int\n        :rtype: int\n        \"\"\"\n        if idx >= len(self.__arr):\n            return -1\n        a, b = self.__op\n        return (self.__arr[idx]*a + b) % MOD\n"
    },
    {
        "problem_name": "faulty-keyboard",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# deque\nclass Solution(object):\n    def finalString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        dq = collections.deque()\n        parity = 0\n        for x in s:\n            if x == 'i':\n                parity ^= 1\n            else:\n                dq.appendleft(x) if parity else dq.append(x)\n        if parity:\n            dq.reverse()\n        return \"\".join(dq)\n"
    },
    {
        "problem_name": "faulty-sensor",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def badSensor(self, sensor1, sensor2):\n        \"\"\"\n        :type sensor1: List[int]\n        :type sensor2: List[int]\n        :rtype: int\n        \"\"\"\n        for i in xrange(len(sensor1)-1):\n            if sensor1[i] == sensor2[i]:\n                continue\n            while i+1 < len(sensor2) and sensor2[i+1] == sensor1[i]:\n                i += 1\n            return 1 if i+1 == len(sensor2) else 2\n        return -1\n"
    },
    {
        "problem_name": "fibonacci-number",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def fib(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 1],\n             [1, 0]]\n        return matrix_mult([[1, 0]], matrix_expo(T, N))[0][1]  # [a1, a0] * T^N\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def fib(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        prev, current = 0, 1\n        for i in xrange(N):\n            prev, current = current, prev + current,\n        return prev\n"
    },
    {
        "problem_name": "filling-bookcase-shelves",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def minHeightShelves(self, books, shelf_width):\n        \"\"\"\n        :type books: List[List[int]]\n        :type shelf_width: int\n        :rtype: int\n        \"\"\"\n        dp = [float(\"inf\") for _ in xrange(len(books)+1)]\n        dp[0] = 0\n        for i in xrange(1, len(books)+1):\n            max_width = shelf_width\n            max_height = 0\n            for j in reversed(xrange(i)):\n                if max_width-books[j][0] < 0:\n                    break\n                max_width -= books[j][0]\n                max_height = max(max_height, books[j][1])\n                dp[i] = min(dp[i], dp[j]+max_height)\n        return dp[len(books)]\n"
    },
    {
        "problem_name": "filter-restaurants-by-vegan-friendly-price-and-distance",
        "solution": "# Time:  O(rlogr), r is the number of result\n# Space: O(r)\n\nclass Solution(object):\n    def filterRestaurants(self, restaurants, veganFriendly, maxPrice, maxDistance):\n        \"\"\"\n        :type restaurants: List[List[int]]\n        :type veganFriendly: int\n        :type maxPrice: int\n        :type maxDistance: int\n        :rtype: List[int]\n        \"\"\"\n        result, lookup = [], {}\n        for j, (i, _, v, p, d) in enumerate(restaurants):\n            if v >= veganFriendly and p <= maxPrice and d <= maxDistance:\n                lookup[i] = j\n                result.append(i)\n        result.sort(key=lambda i: (-restaurants[lookup[i]][1], -restaurants[lookup[i]][0]))\n        return result\n"
    },
    {
        "problem_name": "final-prices-with-a-special-discount-in-a-shop",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def finalPrices(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: List[int]\n        \"\"\"\n        stk = []\n        for i, p in enumerate(prices):\n            while stk and prices[stk[-1]] >= p:\n                prices[stk.pop()] -= p\n            stk.append(i)\n        return prices\n"
    },
    {
        "problem_name": "final-value-of-variable-after-performing-operations",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def finalValueAfterOperations(self, operations):\n        \"\"\"\n        :type operations: List[str]\n        :rtype: int\n        \"\"\"\n        return sum(1 if '+' == op[1] else -1 for op in operations)\n"
    },
    {
        "problem_name": "find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nimport itertools\n\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def getTargetCopy(self, original, cloned, target):\n        \"\"\"\n        :type original: TreeNode\n        :type cloned: TreeNode\n        :type target: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        def preorder_gen(node):\n            stk = [node]\n            while stk:\n                node = stk.pop()\n                if not node:\n                    continue\n                yield node\n                stk.append(node.right)\n                stk.append(node.left)\n            \n        for node1, node2 in itertools.izip(preorder_gen(original),\n                                           preorder_gen(cloned)):\n            if node1 == target:\n                return node2\n"
    },
    {
        "problem_name": "find-a-good-subset-of-the-matrix",
        "solution": "# Time:  O(m * 2^n)\n# Space: O(2^n)\n\n# bitmasks, constructive algorithms, greedy\nclass Solution(object):\n    def goodSubsetofBinaryMatrix(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        lookup = {}\n        for i in xrange(len(grid)):\n            mask = reduce(lambda mask, j: mask|(grid[i][j]<<j), xrange(len(grid[0])), 0)\n            if not mask:\n                return [i]\n            for mask2, j in lookup.iteritems():\n                if mask2&mask == 0:\n                    return [j, i]\n            lookup[mask] = i\n        return []\n"
    },
    {
        "problem_name": "find-a-peak-element-ii",
        "solution": "# Time:  O(min(n, m) * log(max(n, m)))\n# Space: O(1)\n\nclass Solution(object):\n    def findPeakGrid(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def get_vec(mat, i):\n            return mat[i] if len(mat) > len(mat[0]) else (mat[j][i] for j in xrange(len(mat)))\n\n        def check(mat, x):\n            return max(get_vec(mat, x)) > max(get_vec(mat, x+1))\n\n        left, right = 0, (max(len(mat), len(mat[0]))-1)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(mat, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        mav_val = max(get_vec(mat, left))\n        result = [left, next(i for i, x in enumerate(get_vec(mat, left)) if x == mav_val)]\n        return result if len(mat) > len(mat[0]) else result[::-1]\n"
    },
    {
        "problem_name": "find-a-value-of-a-mysterious-function-closest-to-target",
        "solution": "# Time:  O(nlogm), m is the max value of arr\n# Space: O(logm)\n\nclass BitCount(object):\n    def __init__(self, n):\n        self.__l = 0\n        self.__n = n\n        self.__count = [0]*n\n    \n    def __iadd__(self, num):\n        self.__l += 1\n        base = 1\n        for i in xrange(self.__n):\n            if num&base:\n                self.__count[i] += 1\n            base <<= 1\n        return self\n\n    def __isub__(self, num):\n        self.__l -= 1\n        base = 1\n        for i in xrange(self.__n):\n            if num&base:\n                self.__count[i] -= 1\n            base <<= 1\n        return self\n            \n    def bit_and(self):\n        num, base = 0, 1\n        for i in xrange(self.__n):\n            if self.__count[i] == self.__l:\n                num |= base\n            base <<= 1\n        return num\n\n\nclass Solution(object):\n    def closestToTarget(self, arr, target):\n        \"\"\"\n        :type arr: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        count = BitCount(max(arr).bit_length())\n        result, left = float(\"inf\"), 0\n        for right in xrange(len(arr)):\n            count += arr[right]\n            while left <= right:\n                f = count.bit_and()\n                result = min(result, abs(f-target))\n                if f >= target:\n                    break\n                count -= arr[left]\n                left += 1\n        return result\n                    \n  \n# Time:  O(nlogm), m is the max value of arr\n# Space: O(logm)\nclass Solution2(object):\n    def closestToTarget(self, arr, target):\n        \"\"\"\n        :type arr: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        result, dp = float(\"inf\"), set()  # at most O(logm) dp states\n        for x in arr:\n            dp = {x}|{f&x for f in dp}\n            for f in dp:\n                result = min(result, abs(f-target))\n        return result\n"
    },
    {
        "problem_name": "find-all-anagrams-in-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[int]\n        \"\"\"\n        result = []\n\n        cnts = [0] * 26\n        for c in p:\n            cnts[ord(c) - ord('a')] += 1\n\n        left, right = 0, 0\n        while right < len(s):\n            cnts[ord(s[right]) - ord('a')] -= 1\n            while left <= right and cnts[ord(s[right]) - ord('a')] < 0:\n                cnts[ord(s[left]) - ord('a')] += 1\n                left += 1\n            if right - left + 1 == len(p):\n                result.append(left)\n            right += 1\n\n        return result\n\n"
    },
    {
        "problem_name": "find-all-duplicates-in-an-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in nums:\n            if nums[abs(i)-1] < 0:\n                result.append(abs(i))\n            else:\n                nums[abs(i)-1] *= -1\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def findDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        i = 0\n        while i < len(nums):\n            if nums[i] != nums[nums[i]-1]:\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\n            else:\n                i += 1\n\n        for i in xrange(len(nums)):\n            if i != nums[i]-1:\n                result.append(nums[i])\n        return result\n\n\n# Time:  O(n)\n# Space: O(n), this doesn't satisfy the question\nfrom collections import Counter\nclass Solution3(object):\n    def findDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [elem for elem, count in Counter(nums).items() if count == 2]\n\n"
    },
    {
        "problem_name": "find-all-good-indices",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# prefix sum\nclass Solution(object):\n    def goodIndices(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        left = [1]*len(nums)\n        for i in xrange(1, len(nums)-1):\n            if nums[i] <= nums[i-1]:\n                left[i] = left[i-1]+1\n        right = [1]*len(nums)\n        for i in reversed(xrange(1, len(nums)-1)):\n            if nums[i] <= nums[i+1]:\n                right[i] = right[i+1]+1\n        return [i for i in xrange(k, len(nums)-k) if min(left[i-1], right[i+1]) >= k]\n"
    },
    {
        "problem_name": "find-all-good-strings",
        "solution": "# Time:  O(m * n)\n# Space: O(m)\n\nclass Solution(object):\n    def findGoodStrings(self, n, s1, s2, evil):\n        \"\"\"\n        :type n: int\n        :type s1: str\n        :type s2: str\n        :type evil: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j != -1 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n    \n        prefix = getPrefix(evil)\n        dp = [[[[0]*len(evil) for _ in xrange(2)] for _ in xrange(2)] for _ in xrange(2)]\n        dp[0][0][0][0] = 1\n        for i in xrange(n):\n            dp[(i+1)%2] = [[[0]*len(evil) for _ in xrange(2)] for _ in xrange(2)]\n            for j in xrange(2):\n                for k in xrange(2):\n                    min_c = 'a' if j else s1[i]\n                    max_c = 'z' if k else s2[i]\n                    for l in xrange(len(evil)):\n                        if not dp[i%2][j][k][l]:\n                            continue\n                        for c in xrange(ord(min_c)-ord('a'), ord(max_c)-ord('a')+1):\n                            c = chr(c+ord('a'))\n                            m = l-1\n                            while m != -1 and evil[m+1] != c:\n                                m = prefix[m]\n                            if evil[m+1] == c:\n                                m += 1\n                            if m+1 == len(evil):\n                                continue\n                            dp[(i+1)%2][j or (s1[i] != c)][k or (s2[i] != c)][m+1] = \\\n                                (dp[(i+1)%2][j or (s1[i] != c)][k or (s2[i] != c)][m+1] + dp[i%2][j][k][l]) % MOD\n        result = 0\n        for j in xrange(2):\n            for k in xrange(2):\n                for l in xrange(len(evil)):\n                    result = (result + dp[n%2][j][k][l]) % MOD\n        return result\n"
    },
    {
        "problem_name": "find-all-groups-of-farmland",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def findFarmland(self, land):\n        \"\"\"\n        :type land: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        for i in xrange(len(land)):\n            for j in xrange(len(land[0])):\n                if land[i][j] != 1:\n                    continue\n                ni, nj = i, j\n                while ni+1 < len(land) and land[ni+1][j] == 1:\n                    ni += 1\n                while nj+1 < len(land[0]) and land[i][nj+1] == 1:\n                    nj += 1\n                for r in xrange(i, ni+1):\n                    for c in xrange(j, nj+1):\n                        land[r][c] = -1\n                result.append([i, j, ni, nj])\n        return result\n"
    },
    {
        "problem_name": "find-all-k-distant-indices-in-an-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers\nclass Solution(object):\n    def findKDistantIndices(self, nums, key, k):\n        \"\"\"\n        :type nums: List[int]\n        :type key: int\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        prev = -1\n        for i, x in enumerate(nums):\n            if x != key:\n                continue\n            for j in xrange(max(i-k, prev+1), min(i+k+1, len(nums))):\n                result.append(j)\n            prev = min(i+k, len(nums)-1)\n        return result\n"
    },
    {
        "problem_name": "find-all-lonely-numbers-in-the-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# freq table\nclass Solution(object):\n    def findLonely(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        cnt = collections.Counter(nums)\n        return [x for x in nums if cnt[x] == 1 and x-1 not in cnt and x+1 not in cnt]\n"
    },
    {
        "problem_name": "find-all-numbers-disappeared-in-an-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in xrange(len(nums)):\n            if nums[abs(nums[i]) - 1] > 0:\n                nums[abs(nums[i]) - 1] *= -1\n\n        result = []\n        for i in xrange(len(nums)):\n            if nums[i] > 0:\n                result.append(i+1)\n            else:\n                nums[i] *= -1\n        return result\n\n    def findDisappearedNumbers2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return list(set(range(1, len(nums) + 1)) - set(nums))\n\n    def findDisappearedNumbers3(self, nums):\n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            nums[index] = - abs(nums[index])\n\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]\n\n\n"
    },
    {
        "problem_name": "find-all-people-with-secret",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def findAllPeople(self, n, meetings, firstPerson):\n        \"\"\"\n        :type n: int\n        :type meetings: List[List[int]]\n        :type firstPerson: int\n        :rtype: List[int]\n        \"\"\"\n        meetings.sort(key=lambda x: x[2])\n        result = {0, firstPerson}\n        adj = collections.defaultdict(list)\n        for i, (x, y, _) in enumerate(meetings):\n            adj[x].append(y)\n            adj[y].append(x)\n            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:\n                continue\n            q = [i for i in adj.iterkeys() if i in result]\n            while q:\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if v in result:\n                            continue\n                        result.add(v)\n                        new_q.append(v)\n                q = new_q\n            adj = collections.defaultdict(list)\n        return list(result)\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport collections\n\n\nclass Solution2(object):\n    def findAllPeople(self, n, meetings, firstPerson):\n        \"\"\"\n        :type n: int\n        :type meetings: List[List[int]]\n        :type firstPerson: int\n        :rtype: List[int]\n        \"\"\"\n        meetings.sort(key=lambda x: x[2])\n        result = {0, firstPerson}\n        adj = collections.defaultdict(list)\n        for i, (x, y, _) in enumerate(meetings):\n            adj[x].append(y)\n            adj[y].append(x)\n            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:\n                continue\n            stk = [i for i in adj.iterkeys() if i in result]\n            while stk:\n                u = stk.pop()\n                for v in adj[u]:\n                    if v in result:\n                        continue\n                    result.add(v)\n                    stk.append(v)\n            adj = collections.defaultdict(list)\n        return list(result)\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nclass UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x, y = self.find_set(x), self.find_set(y)\n        if x == y:\n            return False\n        if self.rank[x] > self.rank[y]:  # union by rank\n            x, y = y, x\n        self.set[x] = self.set[y]\n        if self.rank[x] == self.rank[y]:\n            self.rank[y] += 1\n        return True\n\n    def reset(self, x):\n        self.set[x] = x\n        self.rank[x] = 0\n\n\nclass Solution3(object):\n    def findAllPeople(self, n, meetings, firstPerson):\n        \"\"\"\n        :type n: int\n        :type meetings: List[List[int]]\n        :type firstPerson: int\n        :rtype: List[int]\n        \"\"\"\n        meetings.sort(key=lambda x: x[2])\n        uf = UnionFind(n)\n        uf.union_set(0, firstPerson)\n        group = set()\n        for i, (x, y, _) in enumerate(meetings):\n            group.add(x)\n            group.add(y)\n            uf.union_set(x, y)\n            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:\n                continue\n            while group:\n                x = group.pop()\n                if uf.find_set(x) != uf.find_set(0):\n                    uf.reset(x)\n        return [i for i in xrange(n) if uf.find_set(i) == uf.find_set(0)]\n"
    },
    {
        "problem_name": "find-all-possible-recipes-from-given-supplies",
        "solution": "# Time:  O(|E|)\n# Space: O(|E|)\n\nimport collections\nimport itertools\n\nclass Solution(object):\n    def findAllRecipes(self, recipes, ingredients, supplies):\n        \"\"\"\n        :type recipes: List[str]\n        :type ingredients: List[List[str]]\n        :type supplies: List[str]\n        :rtype: List[str]\n        \"\"\"\n        indegree = collections.defaultdict(int)\n        adj = collections.defaultdict(list)\n        for r, ingredient in itertools.izip(recipes, ingredients): \n            indegree[r] = len(ingredient)\n            for ing in ingredient:\n                adj[ing].append(r)\n        result = []\n        recipes = set(recipes)\n        q = supplies\n        while q: \n            new_q = []\n            for u in q:\n                if u in recipes:\n                    result.append(u)\n                for v in adj[u]:\n                    indegree[v] -= 1\n                    if not indegree[v]:\n                        new_q.append(v)\n            q = new_q\n        return result \n"
    },
    {
        "problem_name": "find-all-possible-stable-binary-arrays-i",
        "solution": "# Time:  O(n * m)\n# Space: O(n * m)\n\n# dp\nclass Solution(object):\n    def numberOfStableArrays(self, zero, one, limit):\n        \"\"\"\n        :type zero: int\n        :type one: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [[[0]*2 for _ in xrange(one+1)] for _ in xrange(zero+1)]\n        for i in xrange(zero+1):\n            dp[i][0][0] = 1 if i <= limit else 0\n        for j in xrange(one+1):\n            dp[0][j][1] = 1 if j <= limit else 0\n        for i in xrange(1, zero+1):\n            for j in xrange(1, one+1):\n                dp[i][j][0] = (dp[i-1][j][0]+dp[i-1][j][1])%MOD\n                dp[i][j][1] = (dp[i][j-1][0]+dp[i][j-1][1])%MOD\n                if i-limit-1 >= 0:\n                    dp[i][j][0] = (dp[i][j][0]-dp[i-limit-1][j][1])%MOD\n                if j-limit-1 >= 0:\n                    dp[i][j][1] = (dp[i][j][1]-dp[i][j-limit-1][0])%MOD\n        return (dp[-1][-1][0]+dp[-1][-1][1])%MOD\n\n\n# Time:  O(n * m * l)\n# Space: O(n * m)\n# dp\nclass Solution2(object):\n    def numberOfStableArrays(self, zero, one, limit):\n        \"\"\"\n        :type zero: int\n        :type one: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [[[0]*2 for _ in xrange(one+1)] for _ in xrange(zero+1)]\n        dp[0][0][0] = dp[0][0][1] = 1\n        for i in xrange(zero+1):\n            for j in xrange(one+1):\n                for k in xrange(1, limit+1):\n                    if i-k >= 0:\n                        dp[i][j][0] = (dp[i][j][0]+dp[i-k][j][1])%MOD\n                    if j-k >= 0:\n                        dp[i][j][1] = (dp[i][j][1]+dp[i][j-k][0])%MOD\n        return (dp[-1][-1][0]+dp[-1][-1][1])%MOD\n"
    },
    {
        "problem_name": "find-all-possible-stable-binary-arrays-ii",
        "solution": "# Time:  O(n * m)\n# Space: O(n * m)\n\n# dp\nclass Solution(object):\n    def numberOfStableArrays(self, zero, one, limit):\n        \"\"\"\n        :type zero: int\n        :type one: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [[[0]*2 for _ in xrange(one+1)] for _ in xrange(zero+1)]\n        for i in xrange(zero+1):\n            dp[i][0][0] = 1 if i <= limit else 0\n        for j in xrange(one+1):\n            dp[0][j][1] = 1 if j <= limit else 0\n        for i in xrange(1, zero+1):\n            for j in xrange(1, one+1):\n                dp[i][j][0] = (dp[i-1][j][0]+dp[i-1][j][1])%MOD\n                dp[i][j][1] = (dp[i][j-1][0]+dp[i][j-1][1])%MOD\n                if i-limit-1 >= 0:\n                    dp[i][j][0] = (dp[i][j][0]-dp[i-limit-1][j][1])%MOD\n                if j-limit-1 >= 0:\n                    dp[i][j][1] = (dp[i][j][1]-dp[i][j-limit-1][0])%MOD\n        return (dp[-1][-1][0]+dp[-1][-1][1])%MOD\n"
    },
    {
        "problem_name": "find-all-the-lonely-nodes",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def getLonelyNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        stk = [root]\n        while stk:\n            node = stk.pop()\n            if not node:\n                continue\n            if node.left and not node.right:\n                result.append(node.left.val)\n            elif node.right and not node.left:\n                result.append(node.right.val)\n            stk.append(node.right)\n            stk.append(node.left)\n        return result\n\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def getLonelyNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        def dfs(node, result):\n            if not node:\n                return\n            if node.left and not node.right:\n                result.append(node.left.val)\n            elif node.right and not node.left:\n                result.append(node.right.val)\n            dfs(node.left, result)\n            dfs(node.right, result)\n\n        result = []\n        dfs(root, result)\n        return result\n"
    },
    {
        "problem_name": "find-anagram-mappings",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def anagramMappings(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: List[int]\n        \"\"\"\n        lookup = collections.defaultdict(collections.deque)\n        for i, n in enumerate(B):\n            lookup[n].append(i)\n        result = []\n        for n in A:\n            result.append(lookup[n].popleft())\n        return result\n\n"
    },
    {
        "problem_name": "find-and-replace-in-string",
        "solution": "# Time:  O(n + m), m is the number of targets\n# Space: O(n)\n\nclass Solution(object):\n    def findReplaceString(self, S, indexes, sources, targets):\n        \"\"\"\n        :type S: str\n        :type indexes: List[int]\n        :type sources: List[str]\n        :type targets: List[str]\n        :rtype: str\n        \"\"\"\n        bucket = [None] * len(S)\n        for i in xrange(len(indexes)):\n            if all(indexes[i]+k < len(S) and S[indexes[i]+k] == sources[i][k]\n                   for k in xrange(len(sources[i]))):\n                bucket[indexes[i]] = (len(sources[i]), list(targets[i]))\n        result = []\n        i = 0\n        while i < len(S):\n            if bucket[i]:\n                result.extend(bucket[i][1])\n                i += bucket[i][0]\n            else:\n                result.append(S[i])\n                i += 1\n        return \"\".join(result)\n\n\n# Time:  O(mlogm + m * n)\n# Space: O(n + m)\nclass Solution2(object):\n    def findReplaceString(self, S, indexes, sources, targets):\n        \"\"\"\n        :type S: str\n        :type indexes: List[int]\n        :type sources: List[str]\n        :type targets: List[str]\n        :rtype: str\n        \"\"\"\n        for i, s, t in sorted(zip(indexes, sources, targets), reverse=True):\n            if S[i:i+len(s)] == s:\n                S = S[:i] + t + S[i+len(s):]\n\n        return S\n"
    },
    {
        "problem_name": "find-and-replace-pattern",
        "solution": "# Time:  O(n * l)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def findAndReplacePattern(self, words, pattern):\n        \"\"\"\n        :type words: List[str]\n        :type pattern: str\n        :rtype: List[str]\n        \"\"\"\n        def match(word):\n            lookup = {}\n            for x, y in itertools.izip(pattern, word):\n                if lookup.setdefault(x, y) != y:\n                    return False\n            return len(set(lookup.values())) == len(lookup.values())\n\n        return filter(match, words)\n\n"
    },
    {
        "problem_name": "find-array-given-subset-sums",
        "solution": "# Time:  O(n * 2^n), len(sums) = 2^n\n# Space: O(1)\n\n# [proof]\n# - let d = sorted_sums[0]-sorted_sums[1] and d != -d (d = 0 is trival), where one of +d/-d is the smallest positive or largest negative number of the original solution of [S1, ..., S(2^n)]\n# - given Sp-d = 0 for some p in [1, 2^n] and Sq-(-d) = 0 for some q in [1, 2^n]\n#   assume d is a number of the original solution of [S1, ..., S(2^n)] (the proof where -d is a number of the original solution is vice versa)\n#   let Sq = x1+...+xi where 1 <= i <= n-1\n#   let [d]+[x1, ..., xi]+[x(i+1), ..., x(n-1)] be the original solution\n#   => new_sums([S1, ..., S(2^n)], d)\n#      = subset_sums([x1, ..., xi]+[x(i+1), ..., x(n-1)])\n#   if we choose -d as a number of a solution of [S1, ..., S(2^n)]\n#   => new_sums([S1, ..., S(2^n)], -d)\n#      = new_sums([S1, ..., S(2^n)], -(x1+...+xi))\n#      = subset_sums([(-x1), ..., (-xi)]+[x(i+1), ..., x(n-1)])\n#      => [-d]+[(-x1), ..., (-xi)]+[x(i+1), ..., x(n-1)] is also a solution\n#\n# [conclusion]\n# - if new_sums with +d/-d (including d = 0) both contain zero, we can choose either one\n# - if only one of new_sums with +d/-d contains zero, we can only choose the one with zero since subset_sums must contain zero\n\n# optimized from solution4 (not using dict), runtime: 1040 ms\nclass Solution(object):\n    def recoverArray(self, n, sums):\n        \"\"\"\n        :type n: int\n        :type sums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        sums.sort()  # Time: O(2^n * log(2^n)) = O(n * 2^n)\n        shift, l = 0, len(sums)\n        result = []\n        for _ in xrange(n):  # log(2^n) times, each time costs O(2^(n-len(result))), Total Time: O(2^n)\n            new_shift = sums[0]-sums[1]\n            assert(new_shift <= 0)\n            has_zero, j, k = False, 0, 0\n            for i in xrange(l):\n                if k < j and sums[k] == sums[i]:  # skip shifted one\n                    k += 1\n                else:\n                    if shift == sums[i]-new_shift:\n                        has_zero = True\n                    sums[j] = sums[i]-new_shift\n                    j += 1\n            if has_zero:  # contain 0, choose this side\n                result.append(new_shift)\n            else:  # contain no 0, choose another side and shift 0 offset\n                result.append(-new_shift)\n                shift -= new_shift\n            l //= 2\n        return result\n\n\n# Time:  O(2^n + n * r), len(sums) = 2^n\n#                      , r = max(sums)-min(sums)\n# Space: O(2^n + r)\nimport collections\n\n\n# optimized from solution4 (not using dict), runtime: 968 ms\nclass Solution2(object):\n    def recoverArray(self, n, sums):\n        \"\"\"\n        :type n: int\n        :type sums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        min_sum, max_sum = min(sums), max(sums)\n        dp = [0]*(max_sum-min_sum+1)\n        for x in sums:\n            dp[x-min_sum] += 1\n        sorted_sums = [x for x in xrange(min_sum, max_sum+1) if dp[x-min_sum]]  # Time: O(r)\n        shift = 0\n        result = []\n        for _ in xrange(n):  # log(2^n) times, each time costs O(2^(n-len(result)))+O(r), Total Time: O(2^n + n * r)\n            new_dp = [0]*(max_sum-min_sum+1)\n            new_sorted_sums = []\n            new_shift = sorted_sums[0]-sorted_sums[1] if dp[sorted_sums[0]-min_sum] == 1 else 0\n            assert(new_shift <= 0)\n            for x in sorted_sums:\n                if not dp[x-min_sum]:\n                    continue\n                dp[(x-new_shift)-min_sum] -= dp[x-min_sum] if new_shift else dp[x-min_sum]//2\n                new_dp[(x-new_shift)-min_sum] = dp[x-min_sum]\n                new_sorted_sums.append(x-new_shift)\n            dp = new_dp\n            sorted_sums = new_sorted_sums\n            if dp[shift-min_sum]:  # contain 0, choose this side\n                result.append(new_shift)\n            else:  # contain no 0, choose another side and shift 0 offset\n                result.append(-new_shift)\n                shift -= new_shift\n        return result\n\n\n# Time:  O(n * 2^n), len(sums) = 2^n\n# Space: O(2^n)\nimport collections\nimport operator\n\n\n# optimized from solution4, runtime: 1044 ms\nclass Solution3(object):\n    def recoverArray(self, n, sums):\n        \"\"\"\n        :type n: int\n        :type sums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        dp = {k: v for k, v in collections.Counter(sums).iteritems()}\n        total = reduce(operator.ior, dp.itervalues(), 0)\n        basis = total&-total  # find rightmost bit 1\n        if basis > 1:\n            for k in dp.iterkeys():\n                dp[k] //= basis\n        sorted_sums = sorted(dp.iterkeys())  # Time: O(2^n * log(2^n)) = O(n * 2^n)\n        shift = 0\n        result = [0]*(basis.bit_length()-1)\n        for _ in xrange(n-len(result)):  # log(2^n) times, each time costs O(2^(n-len(result))), Total Time: O(2^n)\n            new_dp = {}\n            new_sorted_sums = []\n            new_shift = sorted_sums[0]-sorted_sums[1]\n            assert(new_shift < 0)\n            for x in sorted_sums:\n                if not dp[x]:\n                    continue\n                dp[x-new_shift] -= dp[x]\n                new_dp[x-new_shift] = dp[x]\n                new_sorted_sums.append(x-new_shift)\n            dp = new_dp\n            sorted_sums = new_sorted_sums\n            if shift in dp:  # contain 0, choose this side\n                result.append(new_shift)\n            else:  # contain no 0, choose another side and shift 0 offset\n                result.append(-new_shift)\n                shift -= new_shift\n        return result\n\n\n# Time:  O(n * 2^n), len(sums) = 2^n\n# Space: O(2^n)\nimport collections\n\n\n# optimized from solution4 (not using OrderedDict), runtime: 1024 ms\nclass Solution4(object):\n    def recoverArray(self, n, sums):\n        \"\"\"\n        :type n: int\n        :type sums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        dp = {k: v for k, v in collections.Counter(sums).iteritems()}\n        sorted_sums = sorted(dp.iterkeys())  # Time: O(2^n * log(2^n)) = O(n * 2^n)\n        shift = 0\n        result = []\n        for _ in xrange(n):  # log(2^n) times, each time costs O(2^(n-len(result))), Total Time: O(2^n)\n            new_dp = {}\n            new_sorted_sums = []\n            new_shift = sorted_sums[0]-sorted_sums[1] if dp[sorted_sums[0]] == 1 else 0\n            assert(new_shift <= 0)\n            for x in sorted_sums:\n                if not dp[x]:\n                    continue\n                dp[x-new_shift] -= dp[x] if new_shift else dp[x]//2\n                new_dp[x-new_shift] = dp[x]\n                new_sorted_sums.append(x-new_shift)\n            dp = new_dp\n            sorted_sums = new_sorted_sums\n            if shift in dp:  # contain 0, choose this side\n                result.append(new_shift)\n            else:  # contain no 0, choose another side and shift 0 offset\n                result.append(-new_shift)\n                shift -= new_shift\n        return result\n\n\n# Time:  O(n * 2^n), len(sums) = 2^n\n# Space: O(2^n)\nimport collections\n\n\n# runtime: 1720 ms\nclass Solution5(object):\n    def recoverArray(self, n, sums):\n        \"\"\"\n        :type n: int\n        :type sums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        dp = OrderedDict(sorted(collections.Counter(sums).iteritems()))  # Time: O(2^n * log(2^n)) = O(n * 2^n)\n        shift = 0\n        result = []\n        for _ in xrange(n):  # log(2^n) times, each time costs O(2^(n-len(result))), Total Time: O(2^n)\n            new_dp = OrderedDict()\n            it = iter(dp)\n            min_sum = next(it)\n            new_shift = min_sum-next(it) if dp[min_sum] == 1 else 0\n            assert(new_shift <= 0)\n            for x in dp.iterkeys():\n                if not dp[x]:\n                    continue\n                dp[x-new_shift] -= dp[x] if new_shift else dp[x]//2\n                new_dp[x-new_shift] = dp[x]\n            dp = new_dp\n            if shift in dp:  # contain 0, choose this side\n                result.append(new_shift)\n            else:  # contain no 0, choose another side and shift 0 offset\n                result.append(-new_shift)\n                shift -= new_shift\n        return result\n"
    },
    {
        "problem_name": "find-beautiful-indices-in-the-given-array-i",
        "solution": "# Time:  O(n), x = len(KMP(s, a)), y = len(KMP(s, b))\n# Space: O(min(a + b + x + y, n))\n\n# kmp, two pointers\nclass Solution(object):\n    def beautifulIndices(self, s, a, b, k):\n        \"\"\"\n        :type s: str\n        :type a: str\n        :type b: str\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j+1 > 0 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        def KMP(text, pattern):\n            prefix = getPrefix(pattern)\n            j = -1\n            for i in xrange(len(text)):\n                while j+1 > 0 and pattern[j+1] != text[i]:\n                    j = prefix[j]\n                if pattern[j+1] == text[i]:\n                    j += 1\n                if j+1 == len(pattern):\n                    yield i-j\n                    j = prefix[j]\n\n        result = []\n        if not (len(a) <= len(s) and len(b) <= len(s)):\n            return result\n        lookup = list(KMP(s, b))\n        j = 0\n        for i in KMP(s, a):\n            while j < len(lookup) and lookup[j] < i-k:\n                j += 1\n            if j < len(lookup) and lookup[j] <= i+k:\n                result.append(i)\n        return result\n\n\n# Time:  O(n + xlogy), x = len(KMP(s, a)), y = len(KMP(s, b))\n# Space: O(n)\nimport bisect\n\n\n# kmp, binary search\nclass Solution2(object):\n    def beautifulIndices(self, s, a, b, k):\n        \"\"\"\n        :type s: str\n        :type a: str\n        :type b: str\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j+1 > 0 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        def KMP(text, pattern):\n            prefix = getPrefix(pattern+'#'+text)\n            return ((i-(len(pattern)+1))-(len(pattern)-1) for i in xrange((len(pattern)+1)+(len(pattern)-1) , len(prefix)) if prefix[i]+1 == len(pattern))\n    \n        result = []\n        if not (len(a) <= len(s) and len(b) <= len(s)):\n            return result\n        lookup = list(KMP(s, b))\n        j = 0\n        for i in KMP(s, a):\n            j = bisect.bisect_left(lookup, i-k)\n            if j < len(lookup) and lookup[j] <= i+k:\n                result.append(i)\n        return result\n"
    },
    {
        "problem_name": "find-beautiful-indices-in-the-given-array-ii",
        "solution": "# Time:  O(n), x = len(KMP(s, a)), y = len(KMP(s, b))\n# Space: O(min(a + b + x + y, n))\n\n# kmp, two pointers\nclass Solution(object):\n    def beautifulIndices(self, s, a, b, k):\n        \"\"\"\n        :type s: str\n        :type a: str\n        :type b: str\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j+1 > 0 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        def KMP(text, pattern):\n            prefix = getPrefix(pattern)\n            j = -1\n            for i in xrange(len(text)):\n                while j+1 > 0 and pattern[j+1] != text[i]:\n                    j = prefix[j]\n                if pattern[j+1] == text[i]:\n                    j += 1\n                if j+1 == len(pattern):\n                    yield i-j\n                    j = prefix[j]\n\n        result = []\n        if not (len(a) <= len(s) and len(b) <= len(s)):\n            return result\n        lookup = list(KMP(s, b))\n        j = 0\n        for i in KMP(s, a):\n            while j < len(lookup) and lookup[j] < i-k:\n                j += 1\n            if j < len(lookup) and lookup[j] <= i+k:\n                result.append(i)\n        return result\n\n\n# Time:  O(n + xlogy), x = len(KMP(s, a)), y = len(KMP(s, b))\n# Space: O(n)\nimport bisect\n\n\n# kmp, binary search\nclass Solution2(object):\n    def beautifulIndices(self, s, a, b, k):\n        \"\"\"\n        :type s: str\n        :type a: str\n        :type b: str\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j+1 > 0 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        def KMP(text, pattern):\n            prefix = getPrefix(pattern+'#'+text)\n            return ((i-(len(pattern)+1))-(len(pattern)-1) for i in xrange((len(pattern)+1)+(len(pattern)-1) , len(prefix)) if prefix[i]+1 == len(pattern))\n    \n        result = []\n        if not (len(a) <= len(s) and len(b) <= len(s)):\n            return result\n        lookup = list(KMP(s, b))\n        j = 0\n        for i in KMP(s, a):\n            j = bisect.bisect_left(lookup, i-k)\n            if j < len(lookup) and lookup[j] <= i+k:\n                result.append(i)\n        return result\n"
    },
    {
        "problem_name": "find-bottom-left-tree-value",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def findBottomLeftValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def findBottomLeftValueHelper(root, curr_depth, max_depth, bottom_left_value):\n            if not root:\n                return max_depth, bottom_left_value\n            if not root.left and not root.right and curr_depth+1 > max_depth:\n                return curr_depth+1, root.val\n            max_depth, bottom_left_value = findBottomLeftValueHelper(root.left, curr_depth+1, max_depth, bottom_left_value)\n            max_depth, bottom_left_value = findBottomLeftValueHelper(root.right, curr_depth+1, max_depth, bottom_left_value)\n            return max_depth, bottom_left_value\n\n        result, max_depth = 0, 0\n        return findBottomLeftValueHelper(root, 0, max_depth, result)[1]\n\n\n# Time:  O(n)\n# Space: O()\nimport collections\n\n\nclass Solution2(object):\n    def findBottomLeftValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        last_node, q = None, collections.deque([root])\n        while q:\n            last_node = q.popleft()\n            q.extend([n for n in [last_node.right, last_node.left] if n])\n        return last_node.val\n\n"
    },
    {
        "problem_name": "find-building-where-alice-and-bob-can-meet",
        "solution": "# Time:  O(n + qlogn)\n# Space: O(n)\n\n# online solution, segment tree, binary search\nclass Solution(object):\n    def leftmostBuildingQueries(self, heights, queries):\n        \"\"\"\n        :type heights: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        # Range Maximum Query\n        class SegmentTree(object):\n            def __init__(self, N,\n                         build_fn=lambda _: None,\n                         query_fn=lambda x, y: max(x, y)):\n                self.tree = [None]*(2*2**((N-1).bit_length()))\n                self.build_fn = build_fn\n                self.query_fn = query_fn\n                self.build(0, N-1, 1)\n            \n            def build(self, left, right, idx):\n                if left == right:\n                    self.tree[idx] = self.build_fn(left)\n                    return \n                mid = left + (right-left)//2\n                self.build(left, mid, idx*2)\n                self.build(mid+1, right, idx*2+1)\n                self.tree[idx] = self.query_fn(self.tree[idx*2], self.tree[idx*2+1])\n\n            def binary_search(self, L, R, left, right, idx, h):\n                if right < L or left > R:\n                    return -1\n                if L <= left and right <= R:\n                    if not self.tree[idx] > h:\n                        return -1\n                    if left == right:\n                        return left\n                mid = left + (right-left)//2\n                i = self.binary_search(L, R, left, mid, idx*2, h)\n                return i if i != -1 else self.binary_search(L, R, mid+1, right, idx*2+1, h)\n\n        def build(i):\n            return heights[i]\n\n        result = [-1]*len(queries)\n        st = SegmentTree(len(heights), build_fn=build)\n        for i, (a, b) in enumerate(queries):\n            if a > b:\n                a, b = b, a\n            if a == b or heights[a] < heights[b]:\n                result[i] = b\n                continue\n            result[i] = st.binary_search(b+1, len(heights)-1, 0, len(heights)-1, 1, heights[a])\n        return result\n\n\n# Time:  O(n + qlogq)\n# Space: O(n + q)\nimport heapq\n\n\n# offline solution, heap\nclass Solution2(object):\n    def leftmostBuildingQueries(self, heights, queries):\n        \"\"\"\n        :type heights: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = [-1]*len(queries)\n        qs = [[] for _ in xrange(len(heights))]\n        for i, (a, b) in enumerate(queries):\n            if a > b:\n                a, b = b, a\n            if a == b or heights[a] < heights[b]:\n                result[i] = b\n            else:\n                qs[b].append((heights[a], i))\n        min_heap = []\n        for i, h in enumerate(heights):\n            for q in qs[i]:\n                heapq.heappush(min_heap, q)\n            while min_heap and min_heap[0][0] < h:\n                _, j = heapq.heappop(min_heap)\n                result[j] = i\n        return result\n\n\n# Time:  O(n + qlogn)\n# Space: O(n + q)\n# offline solution, mono stack, binary search\nclass Solution3(object):\n    def leftmostBuildingQueries(self, heights, queries):\n        \"\"\"\n        :type heights: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def binary_search_right(left, right, check):\n            while left <= right:\n                mid = left + (right-left)//2\n                if not check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return right\n\n        result = [-1]*len(queries)\n        qs = [[] for _ in xrange(len(heights))]\n        for i, (a, b) in enumerate(queries):\n            if a > b:\n                a, b = b, a\n            if a == b or heights[a] < heights[b]:\n                result[i] = b\n            else:\n                qs[b].append((heights[a], i))\n        stk = []\n        for b in reversed(xrange(len(heights))):\n            while stk and stk[-1][0] <= heights[b]:\n                stk.pop()\n            stk.append((heights[b], b))\n            for ha, i in qs[b]:\n                j = binary_search_right(0, len(stk)-1, lambda x: stk[x][0] > ha)\n                if j >= 0:\n                    result[i] = stk[j][1]\n        return result\n"
    },
    {
        "problem_name": "find-center-of-star-graph",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def findCenter(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        return edges[0][edges[0][1] in edges[1]]\n"
    },
    {
        "problem_name": "find-champion-i",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def findChampion(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        return next(u for u in xrange(len(grid)) if sum(grid[u]) == len(grid)-1)\n"
    },
    {
        "problem_name": "find-champion-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# graph, hash table\nclass Solution2(object):\n    def findChampion(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = [False]*n\n        for u, v in edges:\n            lookup[v] = True\n        result = -1\n        for u in xrange(n):\n            if lookup[u]:\n                continue\n            if result != -1:\n                return -1\n            result = u\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\n# graph, hash table\nclass Solution2(object):\n    def findChampion(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = {v for _, v in edges}\n        return next(u for u in xrange(n) if u not in lookup) if len(lookup) == n-1 else -1\n"
    },
    {
        "problem_name": "find-closest-node-to-given-two-nodes",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# graph, hash table\nclass Solution(object):\n    def closestMeetingNode(self, edges, node1, node2):\n        \"\"\"\n        :type edges: List[int]\n        :type node1: int\n        :type node2: int\n        :rtype: int\n        \"\"\"\n        def dfs(node):\n            lookup = {}\n            i = 0\n            while node != -1:\n                if node in lookup:\n                    break\n                lookup[node] = i\n                i += 1\n                node = edges[node]\n            return lookup\n        \n        lookup1, lookup2 = dfs(node1), dfs(node2)\n        intersect = set(lookup1.iterkeys())&set(lookup2.iterkeys())\n        return min(intersect, key=lambda x: (max(lookup1[x], lookup2[x]), x)) if intersect else -1\n"
    },
    {
        "problem_name": "find-closest-number-to-zero",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def findClosestNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return max(nums, key=lambda x:(-abs(x), x))\n"
    },
    {
        "problem_name": "find-common-characters",
        "solution": "# Time:  O(n * l)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def commonChars(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: List[str]\n        \"\"\"\n        result = collections.Counter(A[0])\n        for a in A:\n            result &= collections.Counter(a)\n        return list(result.elements())\n"
    },
    {
        "problem_name": "find-common-elements-between-two-arrays",
        "solution": "# Time:  O(n + m)\n# Space: O(n + m)\n\n# hash table\nclass Solution(object):\n    def findIntersectionValues(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        lookup1, lookup2 = set(nums1), set(nums2)\n        return [sum(x in lookup2 for x in nums1), sum(x in lookup1 for x in nums2)]\n"
    },
    {
        "problem_name": "find-consecutive-integers-from-a-data-stream",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# array\nclass DataStream(object):\n\n    def __init__(self, value, k):\n        \"\"\"\n        :type value: int\n        :type k: int\n        \"\"\"\n        self.__value = value\n        self.__k = k\n        self.__cnt = 0\n\n    def consec(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num == self.__value:\n            self.__cnt += 1\n        else:\n            self.__cnt = 0\n        return self.__cnt >= self.__k\n"
    },
    {
        "problem_name": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[max(x_root, y_root)] = min(x_root, y_root)\n        self.count -= 1\n        return True\n\n\nclass Solution(object):\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def MST(n, edges, unused=None, used=None):\n            union_find = UnionFind(n)\n            weight = 0\n            if used is not None:\n                u, v, w, _ = edges[used]\n                if union_find.union_set(u, v):\n                    weight += w\n            for i, (u, v, w, _) in enumerate(edges):\n                if i == unused:\n                    continue\n                if union_find.union_set(u, v):\n                    weight += w\n            return weight if union_find.count == 1 else float(\"inf\")\n        \n        for i, edge in enumerate(edges):\n            edge.append(i)\n        edges.sort(key=lambda x: x[2])\n        mst = MST(n, edges)\n        result = [[], []]\n        for i, edge in enumerate(edges):\n            if mst < MST(n, edges, unused=i):\n                result[0].append(edge[3])\n            elif mst == MST(n, edges, used=i):\n                result[1].append(edge[3])\n        return result\n"
    },
    {
        "problem_name": "find-distance-in-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\nclass Solution(object):\n    def findDistance(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: int\n        :type q: int\n        :rtype: int\n        \"\"\"\n        def iter_dfs(root, p, q):\n            result = 0\n            dist = [-1]\n            stk = [(1, [root, dist])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [-1], [-1]\n                    stk.append((2, [node, ret1, ret2, ret]))\n                    stk.append((1, [node.right, ret2]))\n                    stk.append((1, [node.left, ret1]))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    if node.val in (p, q):\n                        if ret1[0] == ret2[0] == -1:\n                            ret[0] = 0\n                        else:\n                            result = ret1[0]+1 if ret1[0] != -1 else ret2[0]+1\n                    elif ret1[0] != -1 and ret2[0] != -1:\n                        result = ret1[0]+ret2[0]+2\n                    elif ret1[0] != -1:\n                        ret[0] = ret1[0]+1\n                    elif ret2[0] != -1:\n                        ret[0] = ret2[0]+1\n            return result\n        \n        return iter_dfs(root, p, q)\n                    \n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def findDistance(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: int\n        :type q: int\n        :rtype: int\n        \"\"\"\n        def dfs(node, p, q, result):\n            if not node:\n                return -1\n            left = dfs(node.left, p, q, result)\n            right = dfs(node.right, p, q, result)\n            if node.val in (p, q):\n                if left == right == -1:\n                    return 0\n                result[0] = left+1 if left != -1 else right+1\n            if left != -1 and right != -1:\n                result[0] = left+right+2\n            elif left != -1:\n                return left+1\n            elif right != -1:\n                return right+1\n            return -1\n        \n        result = [0]\n        dfs(root, p, q, result)\n        return result[0]\n"
    },
    {
        "problem_name": "find-duplicate-file-in-system",
        "solution": "# Time:  O(n * l), l is the average length of file content\n# Space: O(n * l)\n\nimport collections\n\n\nclass Solution(object):\n    def findDuplicate(self, paths):\n        \"\"\"\n        :type paths: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        files = collections.defaultdict(list)\n        for path in paths:\n           s = path.split(\" \")\n           for i in xrange(1,len(s)):\n               file_name = s[0] + \"/\" + s[i][0:s[i].find(\"(\")]\n               file_content = s[i][s[i].find(\"(\")+1:s[i].find(\")\")]\n               files[file_content].append(file_name)\n\n        result = []\n        for file_content, file_names in files.iteritems():\n            if len(file_names)>1:\n                result.append(file_names)\n        return result\n\n"
    },
    {
        "problem_name": "find-duplicate-subtrees",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def findDuplicateSubtrees(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[TreeNode]\n        \"\"\"\n        def getid(root, lookup, trees):\n            if not root:\n                return -1\n            node_id = lookup[root.val,\n                             getid(root.left, lookup, trees),\n                             getid(root.right, lookup, trees)]\n            trees[node_id].append(root)\n            return node_id\n\n        trees = collections.defaultdict(list)\n        lookup = collections.defaultdict()\n        lookup.default_factory = lookup.__len__\n        getid(root, lookup, trees)\n        return [roots[0] for roots in trees.itervalues() if len(roots) > 1]\n\n\n# Time:  O(n * h)\n# Space: O(n * h)\nclass Solution2(object):\n    def findDuplicateSubtrees(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[TreeNode]\n        \"\"\"\n        def postOrderTraversal(node, lookup, result):\n            if not node:\n                return \"\"\n            s = \"(\" + postOrderTraversal(node.left, lookup, result) + \\\n                str(node.val) + \\\n                postOrderTraversal(node.right, lookup, result) + \\\n                \")\"\n            if lookup[s] == 1:\n                result.append(node)\n            lookup[s] += 1\n            return s\n\n        lookup = collections.defaultdict(int)\n        result = []\n        postOrderTraversal(root, lookup, result)\n        return result\n\n"
    },
    {
        "problem_name": "find-edges-in-shortest-paths",
        "solution": "# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,\n#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport heapq\n\n\n# dijkstra's algorithm\nclass Solution(object):\n    def findAnswer(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        INF = float(\"inf\")\n        def dijkstra(start):\n            best = [INF]*len(adj)\n            best[start] = 0\n            min_heap = [(0, start)]\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if curr > best[u]:\n                    continue\n                for v, w in adj[u]:     \n                    if best[v] <= curr+w:\n                        continue\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (best[v], v))\n            return best\n    \n        adj = [[] for _ in xrange(n)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        dist1 = dijkstra(0)\n        dist2 = dijkstra(n-1)\n        return [(dist1[u] != INF != dist2[v] and dist1[u]+w+dist2[v] == dist1[n-1]) or\n                (dist2[u] != INF != dist1[v] and dist2[u]+w+dist1[v] == dist2[0])\n                for i, (u, v, w) in enumerate(edges)]\n"
    },
    {
        "problem_name": "find-elements-in-a-contaminated-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass FindElements(object):\n\n    def __init__(self, root):\n        \"\"\"\n        :type root: TreeNode\n        \"\"\"\n        def dfs(node, v, lookup):\n            if not node:\n                return\n            node.val = v    \n            lookup.add(v)\n            dfs(node.left, 2*v+1, lookup)\n            dfs(node.right, 2*v+2, lookup)\n\n        self.__lookup = set()\n        dfs(root, 0, self.__lookup)\n\n    def find(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        return target in self.__lookup \n"
    },
    {
        "problem_name": "find-eventual-safe-states",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|V|)\n\nclass Solution(object):\n    def eventualSafeNodes(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        WHITE, GRAY, BLACK = range(3)\n\n        def dfs(graph, node, lookup):\n            if lookup[node] != WHITE:\n                return lookup[node] == BLACK\n            lookup[node] = GRAY\n            if any(not dfs(graph, child, lookup) for child in graph[node]):\n                return False\n            lookup[node] = BLACK\n            return True\n\n        lookup = [WHITE]*len(graph)\n        return filter(lambda node: dfs(graph, node, lookup), xrange(len(graph)))\n"
    },
    {
        "problem_name": "find-first-and-last-position-of-element-in-sorted-array",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        def binarySearch(n, check):  # usually use\n            left, right = 0, n-1  # search in [0, n-1], return n if not found\n            while left <= right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def binarySearch2(n, check):  # frequently use\n            left, right = 0, n  # search in [0, n), return n if not found\n            while left < right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid\n                else:\n                    left = mid+1\n            return left\n\n        def binarySearch3(n, check):  # never use\n            left, right = -1, n-1  # search in (-1, n-1], return n if not found\n            while left < right:\n                mid = right - (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid\n            return left+1\n\n        def binarySearch4(n, check):  # sometimes use\n            left, right = -1, n  # search in (-1, n), return n if not found\n            while right-left >= 2:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid\n                else:\n                    left = mid\n            return right  # right = left+1\n\n        # Find the first idx where nums[idx] >= target\n        left = binarySearch(len(nums), lambda i: nums[i] >= target)\n        if left == len(nums) or nums[left] != target:\n            return [-1, -1]\n        # Find the first idx where nums[idx] > target\n        right = binarySearch(len(nums), lambda i: nums[i] > target)\n        return [left, right-1]\n"
    },
    {
        "problem_name": "find-first-palindromic-string-in-the-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def firstPalindrome(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        def is_palindrome(s):\n            i, j = 0, len(s)-1\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n\n        for w in words:\n            if is_palindrome(w):\n                return w\n        return \"\"\n\n \n# Time:  O(n)\n# Space: O(l), l is the max length of words\nclass Solution2(object):\n    def firstPalindrome(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        return next((x for x in words if x == x[::-1]), \"\")\n"
    },
    {
        "problem_name": "find-good-days-to-rob-the-bank",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def goodDaysToRobBank(self, security, time):\n        \"\"\"\n        :type security: List[int]\n        :type time: int\n        :rtype: List[int]\n        \"\"\"\n        right = [0]\n        for i in reversed(xrange(1, len(security))):\n            right.append(right[-1]+1 if security[i] >= security[i-1] else 0)\n        right.reverse()\n        result = []\n        left = 0\n        for i in xrange(len(security)):\n            if left >= time and right[i] >= time:\n                result.append(i)\n            if i+1 < len(security):\n                left = left+1 if security[i] >= security[i+1] else 0\n        return result\n"
    },
    {
        "problem_name": "find-greatest-common-divisor-of-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport fractions\n\n\nclass Solution(object):\n    def findGCD(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return fractions.gcd(min(nums), max(nums))\n"
    },
    {
        "problem_name": "find-if-array-can-be-sorted",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# sort\nclass Solution(object):\n    def canSortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def popcount(x):\n            return bin(x).count(\"1\")\n    \n        left = mx = 0\n        for right in xrange(len(nums)):\n            if right+1 != len(nums) and popcount(nums[right+1]) == popcount(nums[right]):\n                continue\n            if mx > min(nums[i] for i in xrange(left, right+1)):\n                return False\n            mx = max(nums[i] for i in xrange(left, right+1))\n            left = right+1\n        return True\n\n\n# Time:  O(n)\n# Space: O(n)\nimport itertools\n\n\n# sort\nclass Solution2(object):\n    def canSortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def popcount(x):\n            return bin(x).count(\"1\")\n        \n        def pairwise(it):\n            a, b = tee(it)\n            next(b, None)\n            return itertools.izip(a, b)\n\n        return all(max(a) <= min(b) for a, b in pairwise(list(it) for key, it in groupby(nums, popcount)))\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# sort\nclass Solution3(object):\n    def canSortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def popcount(x):\n            return bin(x).count(\"1\")\n    \n        left = 0\n        for right in xrange(len(nums)):\n            if right+1 != len(nums) and popcount(nums[right+1]) == popcount(nums[right]):\n                continue\n            nums[left:right+1] = sorted(nums[left:right+1])\n            left = right+1\n        return all(nums[i] <= nums[i+1] for i in xrange(len(nums)-1))\n"
    },
    {
        "problem_name": "find-if-path-exists-in-graph",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|V| + |E|)\n\nimport collections\n\n\n# bi-bfs solution\nclass Solution(object):\n    def validPath(self, n, edges, start, end):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type start: int\n        :type end: int\n        :rtype: bool\n        \"\"\"\n        def bi_bfs(adj, start, target):\n            left, right = {start}, {target}\n            lookup = set()\n            steps = 0\n            while left:\n                for pos in left:\n                    lookup.add(pos)\n                new_left = set()\n                for pos in left:\n                    if pos in right: \n                        return steps\n                    for nei in adj[pos]:\n                        if nei in lookup:\n                            continue\n                        new_left.add(nei)\n                left = new_left\n                steps += 1\n                if len(left) > len(right): \n                    left, right = right, left\n            return -1\n\n        adj = collections.defaultdict(list)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return bi_bfs(adj, start, end) >= 0\n\n\n# Time:  O(|V| + |E|)\n# Space: O(|V| + |E|)\n# bfs solution\nclass Solution2(object):\n    def validPath(self, n, edges, start, end):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type start: int\n        :type end: int\n        :rtype: bool\n        \"\"\"\n        def bfs(adj, start, target):\n            q = [start]\n            lookup = set(q)\n            steps = 0\n            while q:\n                new_q = []\n                for pos in q:\n                    if pos == target:\n                        return steps\n                    for nei in adj[pos]:\n                        if nei in lookup:\n                            continue\n                        lookup.add(nei)\n                        new_q.append(nei)\n                q = new_q\n                steps += 1\n            return -1  \n\n        adj = collections.defaultdict(list)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return bfs(adj, start, end) >= 0\n\n\n# Time:  O(|V| + |E|)\n# Space: O(|V| + |E|)\n# dfs solution\nclass Solution3(object):\n    def validPath(self, n, edges, start, end):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type start: int\n        :type end: int\n        :rtype: bool\n        \"\"\"\n        def dfs(adj, start, target):\n            stk = [start]\n            lookup = set(stk)\n            while stk:\n                pos = stk.pop()\n                if pos == target:\n                    return True\n                for nei in reversed(adj[pos]):\n                    if nei in lookup:\n                        continue\n                    lookup.add(nei)\n                    stk.append(nei)\n            return False \n\n        adj = collections.defaultdict(list)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return dfs(adj, start, end)\n"
    },
    {
        "problem_name": "find-in-mountain-array",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# \"\"\"\n# This is MountainArray's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\nclass MountainArray(object):\n   def get(self, index):\n       \"\"\"\n       :type index: int\n       :rtype int\n       \"\"\"\n       pass\n\n   def length(self):\n       \"\"\"\n       :rtype int\n       \"\"\"\n       pass\n\n\nclass Solution(object):\n    def findInMountainArray(self, target, mountain_arr):\n        \"\"\"\n        :type target: integer\n        :type mountain_arr: MountainArray\n        :rtype: integer\n        \"\"\"\n        def binarySearch(A, left, right, check):\n            while left <= right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n        \n        peak = binarySearch(mountain_arr, 0, mountain_arr.length()-1,\n                            lambda x: mountain_arr.get(x) >= mountain_arr.get(x+1))\n        left = binarySearch(mountain_arr, 0, peak,\n                            lambda x: mountain_arr.get(x) >= target)\n        if left <= peak and mountain_arr.get(left) == target:\n            return left\n        right = binarySearch(mountain_arr, peak, mountain_arr.length()-1,\n                             lambda x: mountain_arr.get(x) <= target)\n        if right <= mountain_arr.length()-1 and mountain_arr.get(right) == target:\n            return right\n        return -1\n"
    },
    {
        "problem_name": "find-indices-with-index-and-value-difference-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# prefix sum\nclass Solution(object):\n    def findIndices(self, nums, indexDifference, valueDifference):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDifference: int\n        :type valueDifference: int\n        :rtype: List[int]\n        \"\"\"\n        mx_i = mn_i = 0\n        for i in xrange(len(nums)-indexDifference):\n            if nums[i] > nums[mx_i]:\n                mx_i = i\n            elif nums[i] < nums[mn_i]:\n                mn_i = i\n            # we don't need to add abs for the difference since\n            # - if nums[mx_i]-nums[i+indexDifference] < 0, then checking nums[i+indexDifference]-nums[mn_i] >= -(nums[mx_i]-nums[i+indexDifference]) > 0 can cover the case\n            # - if nums[i+indexDifference]-nums[mn_i] < 0, then checking nums[mx_i]-nums[i+indexDifference] >= -(nums[i+indexDifference]-nums[mn_i]) > 0 can cover the case\n            if nums[mx_i]-nums[i+indexDifference] >= valueDifference:\n                return [mx_i, i+indexDifference]\n            if nums[i+indexDifference]-nums[mn_i] >= valueDifference:\n                return [mn_i, i+indexDifference]\n        return [-1]*2\n"
    },
    {
        "problem_name": "find-indices-with-index-and-value-difference-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# prefix sum\nclass Solution(object):\n    def findIndices(self, nums, indexDifference, valueDifference):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDifference: int\n        :type valueDifference: int\n        :rtype: List[int]\n        \"\"\"\n        mx_i = mn_i = 0\n        for i in xrange(len(nums)-indexDifference):\n            if nums[i] > nums[mx_i]:\n                mx_i = i\n            elif nums[i] < nums[mn_i]:\n                mn_i = i\n            # we don't need to add abs for the difference since\n            # - if nums[mx_i]-nums[i+indexDifference] < 0, then checking nums[i+indexDifference]-nums[mn_i] >= -(nums[mx_i]-nums[i+indexDifference]) > 0 can cover the case\n            # - if nums[i+indexDifference]-nums[mn_i] < 0, then checking nums[mx_i]-nums[i+indexDifference] >= -(nums[i+indexDifference]-nums[mn_i]) > 0 can cover the case\n            if nums[mx_i]-nums[i+indexDifference] >= valueDifference:\n                return [mx_i, i+indexDifference]\n            if nums[i+indexDifference]-nums[mn_i] >= valueDifference:\n                return [mn_i, i+indexDifference]\n        return [-1]*2\n"
    },
    {
        "problem_name": "find-k-closest-elements",
        "solution": "# Time:  O(logn + k)\n# Space: O(1)\n\nimport bisect\n\n\nclass Solution(object):\n    def findClosestElements(self, arr, k, x):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :type x: int\n        :rtype: List[int]\n        \"\"\"\n        i = bisect.bisect_left(arr, x)\n        left, right = i-1, i\n        while k:\n            if right >= len(arr) or \\\n               (left >= 0 and abs(arr[left]-x) <= abs(arr[right]-x)):\n                left -= 1\n            else:\n                right += 1\n            k -= 1\n        return arr[left+1:right]\n\n"
    },
    {
        "problem_name": "find-k-length-substrings-with-no-repeated-characters",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\nclass Solution(object):\n    def numKLenSubstrNoRepeats(self, S, K):\n        \"\"\"\n        :type S: str\n        :type K: int\n        :rtype: int\n        \"\"\"\n        result, i = 0, 0\n        lookup = set()\n        for j in xrange(len(S)):\n            while S[j] in lookup:\n                lookup.remove(S[i])\n                i += 1\n            lookup.add(S[j])\n            result += j-i+1 >= K\n        return result\n"
    },
    {
        "problem_name": "find-k-pairs-with-smallest-sums",
        "solution": "# Time:  O(k * log(min(n, m, k))), where n is the size of num1, and m is the size of num2.\n# Space: O(min(n, m, k))\n\nfrom heapq import heappush, heappop\n\nclass Solution(object):\n    def kSmallestPairs(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        pairs = []\n        if len(nums1) > len(nums2):\n            tmp = self.kSmallestPairs(nums2, nums1, k)\n            for pair in tmp:\n                pairs.append([pair[1], pair[0]])\n            return pairs\n\n        min_heap = []\n        def push(i, j):\n            if i < len(nums1) and j < len(nums2):\n                heappush(min_heap, [nums1[i] + nums2[j], i, j])\n\n        push(0, 0)\n        while min_heap and len(pairs) < k:\n            _, i, j = heappop(min_heap)\n            pairs.append([nums1[i], nums2[j]])\n            push(i, j + 1)\n            if j == 0:\n                push(i + 1, 0)  # at most queue min(n, m) space\n        return pairs\n\n\n# time: O(mn * log k)\n# space: O(k)\nfrom heapq import nsmallest\nfrom itertools import product\n\n\nclass Solution2(object):\n    def kSmallestPairs(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        return nsmallest(k, product(nums1, nums2), key=sum)\n"
    },
    {
        "problem_name": "find-k-th-smallest-pair-distance",
        "solution": "# Time:  O(nlogn + nlogw), n = len(nums), w = max(nums)-min(nums)\n# Space: O(1)\n\nclass Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # Sliding window solution\n        def possible(guess, nums, k):\n            count, left = 0, 0\n            for right, num in enumerate(nums):\n                while num-nums[left] > guess:\n                    left += 1\n                count += right-left\n            return count >= k\n\n        nums.sort()\n        left, right = 0, nums[-1]-nums[0]+1\n        while left < right:\n            mid = left + (right-left)/2\n            if possible(mid, nums, k):\n                right = mid\n            else:\n                left = mid+1\n        return left\n\n"
    },
    {
        "problem_name": "find-kth-bit-in-nth-binary-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findKthBit(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        flip, l = 0, 2**n-1\n        while k > 1:\n            if k == l//2+1:\n                flip ^= 1\n                break\n            if k > l//2:\n                k = l+1-k\n                flip ^= 1\n            l //= 2\n        return str(flip)\n"
    },
    {
        "problem_name": "find-kth-largest-xor-coordinate-value",
        "solution": "# Time:  O(m * n) on average\n# Space: O(m * n)\n\nimport random\n\n\nclass Solution(object):\n    def kthLargestValue(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n        \n        \n        vals = []\n        for r in xrange(len(matrix)):\n            curr = 0\n            for c in xrange(len(matrix[0])):\n                curr = curr^matrix[r][c]\n                if r == 0:\n                    matrix[r][c] = curr\n                else:\n                    matrix[r][c] = curr^matrix[r-1][c]\n                vals.append(matrix[r][c])\n        nth_element(vals, k-1, compare=lambda a, b: a > b)\n        return vals[k-1]\n"
    },
    {
        "problem_name": "find-largest-value-in-each-tree-row",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def largestValues(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        def largestValuesHelper(root, depth, result):\n            if not root:\n                return\n            if depth == len(result):\n                result.append(root.val)\n            else:\n                result[depth] = max(result[depth], root.val)\n            largestValuesHelper(root.left, depth+1, result)\n            largestValuesHelper(root.right, depth+1, result)\n\n        result = []\n        largestValuesHelper(root, 0, result)\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def largestValues(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        curr = [root]\n        while any(curr):\n            result.append(max(node.val for node in curr))\n            curr = [child for node in curr for child in (node.left, node.right) if child]\n        return result\n\n\n"
    },
    {
        "problem_name": "find-latest-group-of-size-m",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def findLatestStep(self, arr, m):\n        \"\"\"\n        :type arr: List[int]\n        :type m: int\n        :rtype: int\n        \"\"\"\n        if m == len(arr):\n            return m\n        length = [0]*(len(arr)+2)\n        result = -1\n        for i, x in enumerate(arr):\n            left, right = length[x-1], length[x+1]\n            if left == m or right == m:\n                result = i\n            length[x-left] = length[x+right] = left+right+1\n        return result\n"
    },
    {
        "problem_name": "find-leaves-of-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def findLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        def findLeavesHelper(node, result):\n            if not node:\n                return -1\n            level = 1 + max(findLeavesHelper(node.left, result), \\\n                            findLeavesHelper(node.right, result))\n            if len(result) < level + 1:\n                result.append([])\n            result[level].append(node.val)\n            return level\n\n        result = []\n        findLeavesHelper(root, result)\n        return result\n\n"
    },
    {
        "problem_name": "find-longest-awesome-substring",
        "solution": "# Time:  O(10 * n)\n# Space: O(1024)\n\nclass Solution(object):\n    def longestAwesome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ALPHABET_SIZE = 10\n        result, mask, lookup = 0, 0, [len(s)]*(2**ALPHABET_SIZE)\n        lookup[0] = -1\n        for i, ch in enumerate(s):\n            mask ^= 2**(ord(ch)-ord('0'))\n            if lookup[mask] == len(s):\n                lookup[mask] = i\n            result = max(result, i - lookup[mask])\n            for d in xrange(ALPHABET_SIZE):\n                result = max(result, i - lookup[mask^(2**d)])\n        return result\n"
    },
    {
        "problem_name": "find-longest-self-contained-substring",
        "solution": "# Time:  O(n + 26^3 * logn)\n# Space: O(n)\n\nimport bisect\n\n\n# hash table, binary search\nclass Solution(object):\n    def maxSubstringLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def check(left, right):\n            for x in idxs:\n                if not x or x[-1] < left or x[0] > right or (left <= x[0] and x[-1] <= right):\n                    continue\n                i = bisect.bisect_left(x, left)\n                if i != len(x) and x[i] <= right:\n                    return False\n            return True\n\n        idxs = [[] for _ in xrange(26)]\n        for i, x in enumerate(s):\n            idxs[ord(x)-ord('a')].append(i)\n        result = -1\n        for x in idxs:\n            if not x:\n                continue\n            left = x[0]\n            for y in idxs:\n                if not y:\n                    continue\n                right = y[-1]\n                if left <= right and result < right-left+1 != len(s) and check(left, right):\n                    result = right-left+1\n        return result\n\n\n# Time:  O(n + 26^3 * logn)\n# Space: O(n)\nimport bisect\n\n\n# hash table, binary search\nclass Solution2(object):\n    def maxSubstringLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def check(left, right):\n            for x in idxs:\n                if not x:\n                    continue\n                l = bisect.bisect_left(x, left)\n                r = bisect.bisect_right(x, right)-1\n                if not (r-l+1 == len(x) or r-l+1 == 0):\n                    return False\n            return True\n\n        idxs = [[] for _ in xrange(26)]\n        for i, x in enumerate(s):\n            idxs[ord(x)-ord('a')].append(i)\n        result = -1\n        for x in idxs:\n            if not x:\n                continue\n            left = x[0]\n            for y in idxs:\n                if not y:\n                    continue\n                right = y[-1]\n                if left <= right and right-left+1 != len(s) and check(left, right):\n                    result = max(result, right-left+1)\n        return result\n\n\n# Time:  O(26 * n)\n# Space: O(26)\n# freq table, two pointers\nclass Solution3(object):\n    def maxSubstringLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def update(x, d, distinct, valid):\n            x = ord(x)-ord('a')\n            if cnt2[x] == cnt[x]:\n                valid -= 1\n            if cnt2[x] == 0:\n                distinct += 1\n            cnt2[x] += d\n            if cnt2[x] == 0:\n                distinct -= 1\n            if cnt2[x] == cnt[x]:\n                valid += 1\n            return distinct, valid\n                \n        cnt = [0]*26\n        for x in s:\n            cnt[ord(x)-ord('a')] += 1\n        result = -1\n        for l in xrange(1, sum(x != 0 for x in cnt)):\n            cnt2 = [0]*26\n            left = distinct = valid = 0\n            for right in xrange(len(s)):\n                distinct, valid = update(s[right], +1, distinct, valid)\n                while distinct == l+1:\n                    distinct, valid = update(s[left], -1, distinct, valid)\n                    left += 1\n                if valid == l:\n                    result = max(result, right-left+1)\n        return result\n\n\n# Time:  O(26^2 * n)\n# Space: O(26)\n# hash table, brute force\nclass Solution5(object):\n    def maxSubstringLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def check(l, r):\n            return all(l <= left[ord(s[i])-ord('a')] and right[ord(s[i])-ord('a')] <= r for i in xrange(l, r+1))\n\n        left, right = [-1]*26, [-1]*26\n        for i, x in enumerate(s):\n            x = ord(x)-ord('a')\n            if left[x] == -1:\n                left[x] = i\n            right[x] = i\n        result = -1\n        for l in left:\n            if l == -1:\n                continue\n            for r in right:\n                if r == -1:\n                    continue\n                if l <= r and result < r-l+1 != len(s) and check(l, r):\n                    result = r-l+1\n        return result\n"
    },
    {
        "problem_name": "find-longest-special-substring-that-occurs-thrice-i",
        "solution": "# Time:  O(26 * 3 + n * 3)\n# Space: O(26 * 3)\n\n# string, hash table\nclass Solution(object):\n    def maximumLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        lookup = [[0]*3 for _ in xrange(26)]\n        result = cnt = 0\n        for i, c in enumerate(s):\n            cnt += 1\n            if i+1 != len(s) and s[i+1] == s[i]:\n                continue\n            curr = lookup[ord(c)-ord('a')]\n            for j in xrange(len(curr)):\n                if curr[j] < cnt:\n                    cnt, curr[j] = curr[j], cnt\n            cnt = 0\n            result = max(result, max(curr[0]-2, min(curr[0]-1, curr[1]), curr[2]))\n        return result if result else -1\n\n\n# Time:  O(26 + n^2)\n# Space: O(26 + n^2)\n# string, brute force, freq table\nclass Solution2(object):\n    def maximumLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        lookup = [[0] for _ in xrange(26)]\n        result = 0\n        for i, c in enumerate(s):\n            curr = lookup[ord(c)-ord('a')]\n            for j in xrange(i, len(s)):\n                if s[j] != s[i]:\n                    break\n                if j-i+1 == len(curr):\n                    curr.append(0)\n                curr[j-i+1] += 1\n                if curr[j-i+1] == 3:\n                    result = max(result, j-i+1)\n        return result if result else -1\n"
    },
    {
        "problem_name": "find-longest-special-substring-that-occurs-thrice-ii",
        "solution": "# Time:  O(26 * 3 + n * 3)\n# Space: O(26 * 3)\n\n# string, hash table\nclass Solution(object):\n    def maximumLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        lookup = [[0]*3 for _ in xrange(26)]\n        result = cnt = 0\n        for i, c in enumerate(s):\n            cnt += 1\n            if i+1 != len(s) and s[i+1] == s[i]:\n                continue\n            curr = lookup[ord(c)-ord('a')]\n            for j in xrange(len(curr)):\n                if curr[j] < cnt:\n                    cnt, curr[j] = curr[j], cnt\n            cnt = 0\n            result = max(result, max(curr[0]-2, min(curr[0]-1, curr[1]), curr[2]))\n        return result if result else -1\n"
    },
    {
        "problem_name": "find-lucky-integer-in-an-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def findLucky(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        count = collections.Counter(arr)\n        result = -1\n        for k, v in count.iteritems():\n            if k == v:\n                result = max(result, k)\n        return result\n"
    },
    {
        "problem_name": "find-maximal-uncovered-ranges",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# sort, line sweep\nclass Solution(object):\n    def findMaximalUncoveredRanges(self, n, ranges):\n        \"\"\"\n        :type n: int\n        :type ranges: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        ranges.sort()\n        covered = [[-1, -1]]\n        for left, right in ranges:\n            if covered[-1][1] < left:\n                covered.append([left, right])\n                continue\n            covered[-1][1] = max(covered[-1][1], right)    \n        covered.append([n, n])        \n        return [[covered[i-1][1]+1, covered[i][0]-1] for i in xrange(1, len(covered)) if covered[i-1][1]+1 <= covered[i][0]-1]\n"
    },
    {
        "problem_name": "find-maximum-non-decreasing-array-length",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# dp, greedy, prefix sum, mono stack, two pointers\nclass Solution(object):\n    def findMaximumLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = prefix = left = 0\n        stk = [(0, 0, 0)]\n        for right in xrange(len(nums)):\n            prefix += nums[right]\n            while left+1 < len(stk) and stk[left+1][0] <= prefix:\n                left += 1\n            last, dp = prefix-stk[left][1], stk[left][2]+1\n            while stk and stk[-1][0] >= last+prefix:\n                stk.pop()\n            stk.append((last+prefix, prefix, dp))\n            left = min(left, len(stk)-1)\n        return dp\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\n# greedy, prefix sum, mono deque\nclass Solution2(object):\n    def findMaximumLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = prefix = prev_prefix = prev_dp = 0\n        dq = collections.deque()\n        for right in xrange(len(nums)):\n            prefix += nums[right]\n            while dq and dq[0][0] <= prefix:\n                _, prev_prefix, prev_dp = dq.popleft()\n            last, dp = prefix-prev_prefix, prev_dp+1\n            while dq and dq[-1][0] >= last+prefix:\n                dq.pop()\n            dq.append((last+prefix, prefix, dp))\n        return dp\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport bisect\n\n\n# dp, greedy, prefix sum, mono stack, binary search\nclass Solution3(object):\n    def findMaximumLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = prefix = left = 0\n        stk = [(0, 0, 0)]\n        for right in xrange(len(nums)):\n            prefix += nums[right]\n            left = bisect.bisect_left(stk, (prefix+1, 0, 0))-1\n            last, dp = prefix-stk[left][1], stk[left][2]+1\n            while stk and stk[-1][0] >= last+prefix:\n                stk.pop()\n            stk.append((last+prefix, prefix, dp))\n        return dp\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport bisect\n\n\n# dp, greedy, prefix sum, binary search\nclass Solution4(object):\n    def findMaximumLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        prefix = [0]*(len(nums)+1)\n        for i in xrange(len(nums)):\n            prefix[i+1] = prefix[i]+nums[i]\n        dp = [float(\"inf\")]*(len(nums)+1)\n        dp[0] = 0\n        prev = [-1]*(len(nums)+1)\n        left = -1\n        for right in xrange(len(nums)):\n            left = max(left, prev[right])\n            dp[right+1] = dp[left+1]+1\n            next_right = bisect.bisect_left(prefix, prefix[right+1]+(prefix[right+1]-prefix[left+1]))-1\n            prev[next_right] = right\n        return dp[-1]\n"
    },
    {
        "problem_name": "find-maximum-number-of-string-pairs",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def maximumNumberOfStringPairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        result = 0\n        cnt = collections.Counter()\n        for w in words:\n            result += cnt[w[::-1]]\n            cnt[w] += 1\n        return result\n"
    },
    {
        "problem_name": "find-median-from-data-stream",
        "solution": "# Time:  O(nlogn) for total n addNums, O(logn) per addNum, O(1) per findMedian.\n# Space: O(n), total space\n\nfrom heapq import heappush, heappop\n\nclass MedianFinder(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__max_heap = []\n        self.__min_heap = []\n\n    def addNum(self, num):\n        \"\"\"\n        Adds a num into the data structure.\n        :type num: int\n        :rtype: void\n        \"\"\"\n        # Balance smaller half and larger half.\n        if not self.__max_heap or num > -self.__max_heap[0]:\n            heappush(self.__min_heap, num)\n            if len(self.__min_heap) > len(self.__max_heap) + 1:\n                heappush(self.__max_heap, -heappop(self.__min_heap))\n        else:\n            heappush(self.__max_heap, -num)\n            if len(self.__max_heap) > len(self.__min_heap):\n                heappush(self.__min_heap, -heappop(self.__max_heap))\n\n    def findMedian(self):\n        \"\"\"\n        Returns the median of current data stream\n        :rtype: float\n        \"\"\"\n        return (-self.__max_heap[0] + self.__min_heap[0]) / 2.0 \\\n               if len(self.__min_heap) == len(self.__max_heap) \\\n               else self.__min_heap[0]\n\n\n"
    },
    {
        "problem_name": "find-minimum-in-rotated-sorted-array-ii",
        "solution": "# Time:  O(logn) ~ O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] == nums[right]:\n                right -= 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]\n\n\nclass Solution2(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            mid = left + (right - left) / 2\n\n            if nums[mid] == nums[left]:\n                left += 1\n            elif nums[mid] < nums[left]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]\n\n\n"
    },
    {
        "problem_name": "find-minimum-in-rotated-sorted-array",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)\n        target = nums[-1]\n\n        while left < right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] <= target:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]\n\n\nclass Solution2(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            mid = left + (right - left) / 2\n\n            if nums[mid] < nums[left]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return nums[left]\n\n\n"
    },
    {
        "problem_name": "find-minimum-time-to-finish-all-jobs-ii",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nimport itertools\n\n\n# greedy\nclass Solution(object):\n    def minimumTime(self, jobs, workers):\n        \"\"\"\n        :type jobs: List[int]\n        :type workers: List[int]\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+(b-1))//b\n\n        jobs.sort()\n        workers.sort()\n        return max(ceil_divide(j, w) for j, w in itertools.izip(jobs, workers))\n"
    },
    {
        "problem_name": "find-minimum-time-to-finish-all-jobs",
        "solution": "# Time:  O(k^n * logr), the real complexity shoud be much less, but hard to analyze\n# Space: O(n + k)\n\nclass Solution(object):\n    def minimumTimeRequired(self, jobs, k):\n        \"\"\"\n        :type jobs: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def backtracking(jobs, i, cap, counts):\n            if i == len(jobs):\n                return True\n            for j in xrange(len(counts)):\n                if counts[j]+jobs[i] <= cap:\n                    counts[j] += jobs[i]\n                    if backtracking(jobs, i+1, cap, counts):\n                        return True\n                    counts[j] -= jobs[i]\n                if counts[j] == 0:\n                    break\n            return False\n\n        jobs.sort(reverse=True)\n        left, right = max(jobs), sum(jobs)\n        while left <= right:\n            mid = left + (right-left)//2\n            if backtracking(jobs, 0, mid, [0]*k):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n\n\n# Time:  O(k * k^n), the real complexity shoud be less, but hard to analyze\n# Space: O(n + k)\nclass Solution2(object):\n    def minimumTimeRequired(self, jobs, k):\n        \"\"\"\n        :type jobs: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def backtracking(jobs, i, counts, result):\n            if i == len(jobs):\n                result[0] = min(result[0], max(counts))\n                return\n            for j in xrange(len(counts)):\n                if counts[j]+jobs[i] <= result[0]:\n                    counts[j] += jobs[i]\n                    backtracking(jobs, i+1, counts, result)\n                    counts[j] -= jobs[i]\n                if counts[j] == 0:\n                    break\n\n        jobs.sort(reverse=False)\n        result = [sum(jobs)]\n        backtracking(jobs, 0, [0]*k, result)\n        return result[0]\n"
    },
    {
        "problem_name": "find-missing-and-repeated-values",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def findMissingAndRepeatedValues(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        n = len(grid)\n        a_xor_b = 0\n        for i in xrange(n**2):\n            r, c = divmod(i, n)\n            a_xor_b ^= grid[r][c]^(i+1)\n        base = a_xor_b&-a_xor_b\n        result = [0]*2\n        for i in xrange(n**2):\n            r, c = divmod(i, len(grid[0]))\n            result[1 if (i+1)&base != 0 else 0] ^= i+1\n            result[1 if grid[r][c]&base != 0 else 0] ^= grid[r][c]\n        if any(x == result[1] for row in grid for x in row):\n            result[0], result[1] = result[1], result[0]\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\nimport collections\n\n\n# freq table\nclass Solution2(object):\n    def findMissingAndRepeatedValues(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        cnt = collections.Counter(x for row in grid for x in row)\n        return [next(k for k, v in cnt.iteritems() if v == 2), next(x for x in xrange(1, len(grid)**2+1) if x not in cnt)]\n"
    },
    {
        "problem_name": "find-missing-observations",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def missingRolls(self, rolls, mean, n):\n        \"\"\"\n        :type rolls: List[int]\n        :type mean: int\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        MAX_V = 6\n        MIN_V = 1\n        total = sum(rolls)\n        missing = mean*(n+len(rolls))-total\n        if missing < MIN_V*n or missing > MAX_V*n:\n            return []\n        q, r = divmod(missing, n)\n        return [q+int(i < r) for i in xrange(n)]\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def missingRolls(self, rolls, mean, n):\n        \"\"\"\n        :type rolls: List[int]\n        :type mean: int\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        MAX_V = 6\n        MIN_V = 1\n        total = sum(rolls)\n        missing = mean*(n+len(rolls))-total\n        if missing < MIN_V*n or missing > MAX_V*n:\n            return []\n        q, r = divmod(missing-MIN_V*n, (MAX_V-MIN_V))\n        return [MAX_V if i < q else MIN_V+r if i == q else MIN_V  for i in xrange(n)]\n"
    },
    {
        "problem_name": "find-mode-in-binary-search-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        def inorder(root, prev, cnt, max_cnt, result):\n            if not root:\n                return prev, cnt, max_cnt\n\n            prev, cnt, max_cnt = inorder(root.left, prev, cnt, max_cnt, result)\n            if prev:\n                if root.val == prev.val:\n                    cnt += 1\n                else:\n                    cnt = 1\n            if cnt > max_cnt:\n                max_cnt = cnt\n                del result[:]\n                result.append(root.val)\n            elif cnt == max_cnt:\n                result.append(root.val)\n            return inorder(root.right, root, cnt, max_cnt, result)\n\n        if not root:\n            return []\n        result = []\n        inorder(root, None, 1, 0, result)\n        return result\n\n"
    },
    {
        "problem_name": "find-n-unique-integers-sum-up-to-zero",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def sumZero(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        return [i for i in xrange(-(n//2), n//2+1) if not (i == 0 and n%2 == 0)]\n"
    },
    {
        "problem_name": "find-nearest-point-that-has-the-same-x-or-y-coordinate",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def nearestValidPoint(self, x, y, points):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        smallest, idx = float(\"inf\"), -1\n        for i, (r, c) in enumerate(points):\n            dx, dy = x-r, y-c\n            if dx*dy == 0 and abs(dx)+abs(dy) < smallest:\n                smallest = abs(dx)+abs(dy)\n                idx = i\n        return idx\n"
    },
    {
        "problem_name": "find-nearest-right-node-in-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(w)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\nclass Solution(object):\n    def findNeartestRightNode(self, root, u):\n        \"\"\"\n        :type root: TreeNode\n        :type u: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        q = [root]\n        while q:\n            new_q = []\n            for i, node in enumerate(q):\n                if node == u:\n                    return q[i+1] if i+1 < len(q) else None\n                if node.left:\n                    new_q.append(node.left)\n                if node.right:\n                    new_q.append(node.right)\n            q = new_q\n        return None\n"
    },
    {
        "problem_name": "find-number-of-coins-to-place-in-tree-nodes",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# iterative dfs\nclass Solution(object):\n    def placedCoins(self, edges, cost):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type cost: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def iter_dfs():\n            result = [0]*len(cost)\n            stk = [(1, (0, -1, [cost[0]]))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    u, p, ret = args\n                    stk.append((4, (u, ret)))\n                    stk.append((2, (u, p, 0, ret)))\n                elif step == 2:\n                    u, p, i, ret = args\n                    if i == len(adj[u]):\n                        continue\n                    v = adj[u][i]\n                    stk.append((2, (u, p, i+1, ret)))\n                    if v == p:\n                        continue\n                    new_ret = [cost[v]]\n                    stk.append((3, (new_ret, ret)))\n                    stk.append((1, (v, u, new_ret)))\n                elif step == 3:\n                    new_ret, ret = args\n                    ret.extend(new_ret)\n                    ret.sort()\n                    if len(ret) > 5:\n                        ret = ret[:2]+ret[-3:]\n                elif step == 4:\n                    u, ret = args\n                    result[u] = 1 if len(ret) < 3 else max(ret[0]*ret[1]*ret[-1], ret[-3]*ret[-2]*ret[-1], 0)\n            return result\n                \n        adj = [[] for _ in xrange(len(cost))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return iter_dfs()\n\n\n# Time:  O(n)\n# Space: O(n)\n# dfs\nclass Solution2(object):\n    def placedCoins(self, edges, cost):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type cost: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def dfs(u, p):\n            arr = [cost[u]]\n            for v in adj[u]:\n                if v == p:\n                    continue\n                arr.extend(dfs(v, u))\n                arr.sort()\n                if len(arr) > 5:\n                    arr = arr[:2]+arr[-3:]\n            result[u] = 1 if len(arr) < 3 else max(arr[0]*arr[1]*arr[-1], arr[-3]*arr[-2]*arr[-1], 0)\n            return arr\n                \n        adj = [[] for _ in xrange(len(cost))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        result = [0]*len(cost)\n        dfs(0, -1)\n        return result\n"
    },
    {
        "problem_name": "find-number-of-ways-to-reach-the-k-th-stair",
        "solution": "# Time:  O(logk)\n# Space: O(logk)\n\n# combinatorics\nclass Solution(object):\n    def waysToReachStair(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def ceil_log2_x(x):\n            return (x-1).bit_length()\n\n        l = ceil_log2_x(k)\n        while (1<<l)-k <= l+1:\n            l += 1\n        fact = [1]*(l+1)\n        for i in xrange(len(fact)-1):\n            fact[i+1] = fact[i]*(i+1)\n        def nCr(n, r):\n            if not (0 <= r <= n):\n                return 0\n            return fact[n]//fact[r]//fact[n-r]\n\n        return sum(nCr(i+1, (1<<i)-k) for i in xrange(l))\n"
    },
    {
        "problem_name": "find-numbers-with-even-number-of-digits",
        "solution": "# Time:  O(nlog(logm)), n the length of nums, m is the max value of nums\n# Space: O(logm)\n\nimport bisect\n\n\nclass Solution(object):\n    def __init__(self):\n        M = 10**5\n        self.__lookup = [0]\n        i = 10\n        while i < M:\n            self.__lookup.append(i)\n            i *= 10\n        self.__lookup.append(i)\n\n    def findNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def digit_count(n):\n            return bisect.bisect_right(self.__lookup, n)\n\n        return sum(digit_count(n) % 2 == 0 for n in nums)\n    \n\n# Time:  O(nlogm), n the length of nums, m is the max value of nums\n# Space: O(logm)\nclass Solution2(object):\n    def findNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def digit_count(n):\n            result = 0\n            while n:\n                n //= 10\n                result += 1\n            return result\n\n        return sum(digit_count(n) % 2 == 0 for n in nums)\n\n\n# Time:  O(nlogm), n the length of nums, m is the max value of nums\n# Space: O(logm)\nclass Solution3(object):\n    def findNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(len(str(n)) % 2 == 0 for n in nums)\n"
    },
    {
        "problem_name": "find-original-array-from-doubled-array",
        "solution": "# Time:  O(n + klogk), k is the distinct number of changed\n# Space: O(k)\n\nclass Solution(object):\n    def findOriginalArray(self, changed):\n        \"\"\"\n        :type changed: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(changed)%2:\n            return []\n        cnts = collections.Counter(changed)\n        for x in sorted(cnts.iterkeys()):\n            if cnts[x] > cnts[2*x]:\n                return []\n            cnts[2*x] -= cnts[x] if x else cnts[x]//2\n        return list(cnts.elements())\n"
    },
    {
        "problem_name": "find-palindrome-with-fixed-length",
        "solution": "# Time:  O(n * l)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def kthPalindrome(self, queries, intLength):\n        \"\"\"\n        :type queries: List[int]\n        :type intLength: int\n        :rtype: List[int]\n        \"\"\"\n        def reverse(x):\n            result = 0\n            while x:\n                result = result*10+x%10\n                x //= 10\n            return result\n\n        def f(l, x):\n            x = 10**((l-1)//2)+(x-1)\n            if x > 10**((l+1)//2)-1:\n                return -1\n            return x*10**(l//2)+reverse(x//10 if l%2 else x)\n\n        return [f(intLength, x) for x in queries]\n\n\n# Time:  O(n * l)\n# Space: O(l)\n# math\nclass Solution2(object):\n    def kthPalindrome(self, queries, intLength):\n        \"\"\"\n        :type queries: List[int]\n        :type intLength: int\n        :rtype: List[int]\n        \"\"\"\n        def f(l, x):\n            if 10**((l-1)//2)+(x-1) > 10**((l+1)//2)-1:\n                return -1\n            s = str(10**((l-1)//2)+(x-1))\n            return int(s+s[::-1][l%2:])\n\n        return [f(intLength, x) for x in queries]\n"
    },
    {
        "problem_name": "find-pattern-in-infinite-stream-i",
        "solution": "# Time:  O(p + n)\n# Space: O(p)\n\nclass InfiniteStream:\n    def next(self):\n        pass\n\n\n# kmp\nclass Solution(object):\n    def findPattern(self, stream, pattern):\n        \"\"\"\n        :type stream: InfiniteStream\n        :type pattern: List[int]\n        :rtype: int\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j+1 > 0 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        prefix = getPrefix(pattern)\n        i = j = -1\n        while True:\n            d = stream.next()\n            i += 1\n            while j+1 > 0 and pattern[j+1] != d:\n                j = prefix[j]\n            if pattern[j+1] == d:\n                j += 1\n            if j+1 == len(pattern):\n                return i-j\n        return -1\n"
    },
    {
        "problem_name": "find-pattern-in-infinite-stream-ii",
        "solution": "# Time:  O(p + n)\n# Space: O(p)\n\n# Definition for an infinite stream.\nclass InfiniteStream:\n    def next(self):\n        pass\n\n\n# kmp\nclass Solution(object):\n    def findPattern(self, stream, pattern):\n        \"\"\"\n        :type stream: InfiniteStream\n        :type pattern: List[int]\n        :rtype: int\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j+1 > 0 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        prefix = getPrefix(pattern)\n        i = j = -1\n        while True:\n            d = stream.next()\n            i += 1\n            while j+1 > 0 and pattern[j+1] != d:\n                j = prefix[j]\n            if pattern[j+1] == d:\n                j += 1\n            if j+1 == len(pattern):\n                return i-j\n        return -1\n"
    },
    {
        "problem_name": "find-peak-element",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def findPeakElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = left + (right - left) / 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left\n\n\n"
    },
    {
        "problem_name": "find-permutation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findPermutation(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in xrange(len(s)+1):\n            if i == len(s) or s[i] == 'I':\n                result += range(i+1, len(result), -1)\n        return result\n\n"
    },
    {
        "problem_name": "find-pivot-index",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def pivotIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        total = sum(nums)\n        left_sum = 0\n        for i, num in enumerate(nums):\n            if left_sum == (total-left_sum-num):\n                return i\n            left_sum += num\n        return -1\n\n\n"
    },
    {
        "problem_name": "find-players-with-zero-or-one-losses",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\n# hash, sort\nclass Solution(object):\n    def findWinners(self, matches):\n        \"\"\"\n        :type matches: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        lose = collections.defaultdict(int)\n        players_set = set()\n        for x, y in matches:\n            lose[y] += 1\n            players_set.add(x)\n            players_set.add(y)\n        return [[x for x in sorted(players_set) if lose[x] == i] for i in xrange(2)]\n"
    },
    {
        "problem_name": "find-polygon-with-the-largest-perimeter",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, prefix sum, greedy\nclass Solution(object):\n    def largestPerimeter(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        prefix = sum(nums)\n        for i in reversed(xrange(2, len(nums))):\n            prefix -= nums[i]\n            if prefix > nums[i]:\n                return prefix+nums[i]\n        return -1\n"
    },
    {
        "problem_name": "find-positive-integer-solution-for-a-given-equation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n\"\"\"\n   This is the custom function interface.\n   You should not implement it, or speculate about its implementation\n   class CustomFunction:\n       # Returns f(x, y) for any given positive integers x and y.\n       # Note that f(x, y) is increasing with respect to both x and y.\n       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n       def f(self, x, y):\n  \n\"\"\"\nclass Solution(object):\n    def findSolution(self, customfunction, z):\n        \"\"\"\n        :type num: int\n        :type z: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        x, y = 1, 1\n        while customfunction.f(x, y) < z:\n            y += 1\n        while y > 0:\n            while y > 0 and customfunction.f(x, y) > z:\n                y -= 1\n            if y > 0 and customfunction.f(x, y) == z:\n                result.append([x, y])\n            x += 1\n        return result\n"
    },
    {
        "problem_name": "find-products-of-elements-of-big-array",
        "solution": "# Time:  O(q * (logr)^2)\n# Space: O(1)\n\n# binary search, combinatorics, bitmasks, fast exponentiation\nclass Solution(object):\n    def findProductsOfElements(self, queries):\n        \"\"\"\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left + ((right-left)>>1)\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n    \n        def f(x):\n            def count1(x):\n                result = i = 0\n                while 1<<i <= x:\n                    mask = (1<<(i+1))-1\n                    result += ((x&~mask)>>1)+max((x&mask)-(1<<i)+1, 0)\n                    i += 1\n                return result\n \n            def count2(x):\n                result = i = 0\n                while 1<<i <= x:\n                    mask = (1<<(i+1))-1\n                    result += (((x&~mask)>>1)+max((x&mask)-(1<<i)+1, 0))*i\n                    i += 1\n                return result\n            \n            y = binary_search(1, x-1, lambda i: count1(i) >= x)\n            result = count2(y-1)\n            x -= count1(y-1)\n            i = 0\n            while 1<<i <= y:\n                if y&(1<<i):\n                    result += i\n                    x -= 1\n                    if x == 0:\n                        break\n                i += 1\n            return result\n        \n        return [pow(2, f(right+1)-f(left), mod) for left, right, mod in queries]\n"
    },
    {
        "problem_name": "find-resultant-array-after-removing-anagrams",
        "solution": "# Time:  O(n * l)\n# Space: O(1)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def removeAnagrams(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        prev = None\n        for x in words:\n            cnt = collections.Counter(x)\n            if prev and prev == cnt:\n                continue\n            prev = cnt\n            result.append(x)\n        return result\n\n\n# Time:  O(n * llogl)\n# Space: O(l)\nimport collections\n\n\n# sort\nclass Solution2(object):\n    def removeAnagrams(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        prev = None\n        for x in words:\n            s = sorted(x)\n            if prev and prev == s:\n                continue\n            prev = s\n            result.append(x)\n        return result\n\n\n# Time:  O(n * llogl)\n# Space: O(l)\nimport collections\n\n\n# sort\nclass Solution3(object):\n    def removeAnagrams(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        return [words[i] for i in xrange(len(words)) if i == 0 or sorted(words[i-1]) != sorted(words[i])]\n"
    },
    {
        "problem_name": "find-right-interval",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport bisect\n\n\nclass Solution(object):\n    def findRightInterval(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[int]\n        \"\"\"\n        sorted_intervals = sorted((interval.start, i) for i, interval in enumerate(intervals))\n        result = []\n        for interval in intervals:\n            idx = bisect.bisect_left(sorted_intervals, (interval.end,))\n            result.append(sorted_intervals[idx][1] if idx < len(sorted_intervals) else -1)\n        return result\n\n"
    },
    {
        "problem_name": "find-root-of-n-ary-tree",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        pass\n\n\nclass Solution(object):\n    def findRoot(self, tree):\n        \"\"\"\n        :type tree: List['Node']\n        :rtype: 'Node'\n        \"\"\"\n        root = 0\n        for node in tree:\n            root ^= id(node)\n            for child in node.children:\n                root ^= id(child)\n        for node in tree:\n            if id(node) == root:\n                return node\n        return None\n\n\nclass Solution2(object):\n    def findRoot(self, tree):\n        \"\"\"\n        :type tree: List['Node']\n        :rtype: 'Node'\n        \"\"\"\n        root = 0\n        for node in tree:\n            root ^= node.val\n            for child in node.children:\n                root ^= child.val\n        for node in tree:\n            if node.val == root:\n                return node\n        return None\n\n\nclass Solution3(object):\n    def findRoot(self, tree):\n        \"\"\"\n        :type tree: List['Node']\n        :rtype: 'Node'\n        \"\"\"\n        root = 0\n        for node in tree:\n            root += node.val-sum(child.val for child in node.children)\n        for node in tree:\n            if node.val == root:\n                return node\n        return None\n"
    },
    {
        "problem_name": "find-score-of-an-array-after-marking-all-elements",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# simulation, sort, hash table\nclass Solution(object):\n    def findScore(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        idxs = range(len(nums))\n        idxs.sort(key=lambda x: (nums[x], x))\n        lookup = [False]*len(nums)\n        result = 0\n        for i in idxs:\n            if lookup[i]:\n                continue\n            lookup[i] = True\n            if i-1 >= 0:\n                lookup[i-1] = True\n            if i+1 < len(lookup):\n                lookup[i+1] = True\n            result += nums[i]\n        return result\n"
    },
    {
        "problem_name": "find-servers-that-handled-most-number-of-requests",
        "solution": "# Time:  O(nlogk)\n# Space: O(k)\n\nimport itertools\nimport heapq\n\n\nclass Solution(object):\n    def busiestServers(self, k, arrival, load):\n        \"\"\"\n        :type k: int\n        :type arrival: List[int]\n        :type load: List[int]\n        :rtype: List[int]\n        \"\"\"\n        count = [0]*k\n        min_heap_of_endtimes = []\n        min_heap_of_nodes_after_curr = []\n        min_heap_of_nodes_before_curr = range(k)\n        for i, (t, l) in enumerate(itertools.izip(arrival, load)):\n            if i % k == 0:\n                min_heap_of_nodes_before_curr, min_heap_of_nodes_after_curr = [], min_heap_of_nodes_before_curr\n            while min_heap_of_endtimes and min_heap_of_endtimes[0][0] <= t:\n                _, free = heapq.heappop(min_heap_of_endtimes)\n                if free < i % k:\n                    heapq.heappush(min_heap_of_nodes_before_curr, free)\n                else:\n                    heapq.heappush(min_heap_of_nodes_after_curr, free)\n            min_heap_of_candidates = min_heap_of_nodes_after_curr if min_heap_of_nodes_after_curr else min_heap_of_nodes_before_curr\n            if not min_heap_of_candidates:\n                continue\n            node = heapq.heappop(min_heap_of_candidates)\n            count[node] += 1\n            heapq.heappush(min_heap_of_endtimes, (t+l, node))\n        max_count = max(count)\n        return [i for i in xrange(k) if count[i] == max_count]\n\n\n# Time:  O(nlogk)\n# Space: O(k)\nimport sortedcontainers  # required to do pip install\nimport itertools\nimport heapq\n\n\n# reference: http://www.grantjenks.com/docs/sortedcontainers/sortedlist.html\nclass Solution2(object):\n    def busiestServers(self, k, arrival, load):\n        \"\"\"\n        :type k: int\n        :type arrival: List[int]\n        :type load: List[int]\n        :rtype: List[int]\n        \"\"\"\n        count = [0]*k \n        min_heap_of_endtimes = []\n        availables = sortedcontainers.SortedList(xrange(k))  # O(klogk)\n        for i, (t, l) in enumerate(itertools.izip(arrival, load)):\n            while min_heap_of_endtimes and min_heap_of_endtimes[0][0] <= t:\n                _, free = heapq.heappop(min_heap_of_endtimes)  # O(logk)\n                availables.add(free)  # O(logk)\n            if not availables: \n                continue\n            idx = availables.bisect_left(i % k) % len(availables)  # O(logk)\n            node = availables.pop(idx)  # O(logk)\n            count[node] += 1\n            heapq.heappush(min_heap_of_endtimes, (t+l, node))  # O(logk)\n        max_count = max(count)\n        return [i for i in xrange(k) if count[i] == max_count]\n"
    },
    {
        "problem_name": "find-shortest-path-with-k-hops",
        "solution": "# Time:  O(n * k + (e * k) * log(n * k))\n# Space: O(n * k + e)\n\nimport heapq\n\n\n# dijkstra's algorithm\nclass Solution(object):\n    def shortestPathWithHops(self, n, edges, s, d, k):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type s: int\n        :type d: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def modified_dijkstra():\n            best = [[float(\"inf\")]*(k+1) for _ in xrange(len(adj))]\n            best[s][0] = 0\n            min_heap = [(best[s][0], s, 0)]\n            while min_heap:\n                curr, u, cnt = heapq.heappop(min_heap)\n                if curr > best[u][cnt]:\n                    continue\n                if u == d:\n                    return curr\n                for v, w in adj[u]:\n                    if curr+w < best[v][cnt]:\n                        best[v][cnt] = curr+w\n                        heapq.heappush(min_heap, (best[v][cnt], v, cnt))\n                    if cnt+1 <= k and curr < best[v][cnt+1]:\n                        best[v][cnt+1] = curr\n                        heapq.heappush(min_heap, (best[v][cnt+1], v, cnt+1))\n            return -1\n        \n        adj = [[] for _ in xrange(n)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        return modified_dijkstra()\n"
    },
    {
        "problem_name": "find-smallest-common-element-in-all-rows",
        "solution": "# Time:  O(m * n)\n# Space: O(n)\n\nclass Solution(object):\n    def smallestCommonElement(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # values could be duplicated in each row\n        intersections = set(mat[0])\n        for i in xrange(1, len(mat)):\n            intersections &= set(mat[i])\n            if not intersections:\n                return -1\n        return min(intersections)\n\n\n# Time:  O(m * n)\n# Space: O(n)\nimport collections\n\n\nclass Solution2(object):\n    def smallestCommonElement(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # assumed value is unique in each row\n        counter = collections.Counter()\n        for row in mat:\n            for c in row:\n                counter[c] += 1\n                if counter[c] == len(mat):\n                    return c\n        return -1\n"
    },
    {
        "problem_name": "find-smallest-letter-greater-than-target",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport bisect\n\n\nclass Solution(object):\n    def nextGreatestLetter(self, letters, target):\n        \"\"\"\n        :type letters: List[str]\n        :type target: str\n        :rtype: str\n        \"\"\"\n        i = bisect.bisect_right(letters, target)\n        return letters[0] if i == len(letters) else letters[i]\n\n"
    },
    {
        "problem_name": "find-subarrays-with-equal-sum",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table\nclass Solution(object):\n    def findSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        lookup = set()\n        for i in xrange(len(nums)-1):\n            if nums[i]+nums[i+1] in lookup:\n                return True\n            lookup.add(nums[i]+nums[i+1])\n        return False\n"
    },
    {
        "problem_name": "find-subsequence-of-length-k-with-the-largest-sum",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport random\n\n\n# quick select solution\nclass Solution(object):\n    def maxSubsequence(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        partition = nums[:]\n        nth_element(partition, k-1, compare=lambda a, b: a > b)\n        cnt = sum(partition[i] == partition[k-1] for i in xrange(k))\n        result = []\n        for x in nums:\n            if x > partition[k-1]:\n                result.append(x)\n            elif x == partition[k-1] and cnt > 0:\n                cnt -= 1\n                result.append(x)\n        return result\n"
    },
    {
        "problem_name": "find-substring-with-given-hash-value",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# rolling hash\nclass Solution(object):\n    def subStrHash(self, s, power, modulo, k, hashValue):\n        \"\"\"\n        :type s: str\n        :type power: int\n        :type modulo: int\n        :type k: int\n        :type hashValue: int\n        :rtype: str\n        \"\"\"\n        h, idx = 0, -1\n        pw = pow(power, k-1, modulo)\n        for i in reversed(xrange(len(s))):\n            if i+k < len(s):\n                h = (h-(ord(s[i+k])-ord('a')+1)*pw)%modulo\n            h = (h*power+(ord(s[i])-ord('a')+1))%modulo\n            if h == hashValue:\n                idx = i\n        return s[idx:idx+k]\n"
    },
    {
        "problem_name": "find-target-indices-after-sorting-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def targetIndices(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        less = sum(x < target for x in nums)\n        return range(less, less+sum(x == target for x in nums))\n"
    },
    {
        "problem_name": "find-the-array-concatenation-value",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\nimport math\n\n\n# math\nclass Solution(object):\n    def findTheArrayConcVal(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum((nums[i]*10**(int(math.log10(nums[~i]))+1) for i in xrange(len(nums)//2)))+sum(nums[i] for i in xrange(len(nums)//2, len(nums)))\n"
    },
    {
        "problem_name": "find-the-celebrity",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findCelebrity(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        candidate = 0\n        # Find the candidate.\n        for i in xrange(1, n):\n            if knows(candidate, i):  # noqa\n                candidate = i        # All candidates < i are not celebrity candidates.\n        # Verify the candidate.\n        for i in xrange(n):\n            candidate_knows_i = knows(candidate, i) # noqa\n            i_knows_candidate = knows(i, candidate) # noqa\n            if i != candidate and (candidate_knows_i or\n                                   not i_knows_candidate):\n                return -1\n        return candidate\n\n"
    },
    {
        "problem_name": "find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\nclass Solution(object):\n    def findTheCity(self, n, edges, distanceThreshold):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type distanceThreshold: int\n        :rtype: int\n        \"\"\"\n        dist = [[float(\"inf\")]*n for _ in xrange(n)]\n        for i, j, w in edges:\n            dist[i][j] = dist[j][i] = w\n        for i in xrange(n):\n            dist[i][i] = 0\n        for k in xrange(n): \n            for i in xrange(n): \n                for j in xrange(n): \n                    dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) \n        result = {sum(d <= distanceThreshold for d in dist[i]): i for i in xrange(n)}\n        return result[min(result.iterkeys())]\n"
    },
    {
        "problem_name": "find-the-closest-marked-node",
        "solution": "# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,\n#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport heapq\n\n\n# dijkstra's algorithm\nclass Solution(object):\n    def minimumDistance(self, n, edges, s, marked):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type s: int\n        :type marked: List[int]\n        :rtype: int\n        \"\"\"\n        def dijkstra(start):\n            best = [float(\"inf\")]*len(adj)\n            best[start] = 0\n            min_heap = [(0, start)]\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if curr > best[u]:\n                    continue\n                if u in target:\n                    return curr\n                for v, w in adj[u]:     \n                    if curr+w >= best[v]:\n                        continue\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (best[v], v))\n            return -1\n\n        target = set(marked)\n        adj = [[] for _ in xrange(n)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n        return dijkstra(s)\n"
    },
    {
        "problem_name": "find-the-closest-palindrome",
        "solution": "# Time:  O(l)\n# Space: O(l)\n\nclass Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        l = len(n)\n        candidates = set((str(10**l + 1), str(10**(l - 1) - 1)))\n        prefix = int(n[:(l + 1)/2])\n        for i in map(str, (prefix-1, prefix, prefix+1)):\n            candidates.add(i + [i, i[:-1]][l%2][::-1])\n        candidates.discard(n)\n        return min(candidates, key=lambda x: (abs(int(x) - int(n)), int(x)))\n\n"
    },
    {
        "problem_name": "find-the-derangement-of-an-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findDerangement(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        M = 1000000007\n        mul, total = 1, 0\n        for i in reversed(xrange(n+1)):\n            total = (total + M + (1 if i % 2 == 0 else -1) * mul) % M\n            mul = (mul * i) % M\n        return total\n\n"
    },
    {
        "problem_name": "find-the-difference-of-two-arrays",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table\nclass Solution(object):\n    def findDifference(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        lookup = [set(nums1), set(nums2)]\n        return [list(lookup[0]-lookup[1]), list(lookup[1]-lookup[0])]\n"
    },
    {
        "problem_name": "find-the-difference",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport operator\nimport collections\nfrom functools import reduce\n\n\nclass Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        return chr(reduce(operator.xor, map(ord, s), 0) ^ reduce(operator.xor, map(ord, t), 0))\n\n    def findTheDifference2(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        t = list(t)\n        s = list(s)\n        for i in s:\n            t.remove(i)\n        return t[0]\n\n    def findTheDifference3(self, s, t):\n        return chr(reduce(operator.xor, map(ord, s + t)))\n\n    def findTheDifference4(self, s, t):\n        return list((collections.Counter(t) - collections.Counter(s)))[0]\n\n    def findTheDifference5(self, s, t):\n        s, t = sorted(s), sorted(t)\n        return t[-1] if s == t[:-1] else [x[1] for x in zip(s, t) if x[0] != x[1]][0]\n\n\n"
    },
    {
        "problem_name": "find-the-distance-value-between-two-arrays",
        "solution": "# Time:  O((n + m) * logm)\n# Space: O(1)\n\nimport bisect\n\n\nclass Solution(object):\n    def findTheDistanceValue(self, arr1, arr2, d):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :type d: int\n        :rtype: int\n        \"\"\"\n        arr2.sort()\n        result, i, j = 0, 0, 0\n        for x in arr1:\n            j = bisect.bisect_left(arr2, x)\n            left = arr2[j-1] if j-1 >= 0 else float(\"-inf\")\n            right = arr2[j] if j < len(arr2) else float(\"inf\")\n            result += left+d < x < right-d\n        return result\n\n\n# Time:  O(nlogn + mlogm)\n# Space: O(1)\nclass Solution2(object):\n    def findTheDistanceValue(self, arr1, arr2, d):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :type d: int\n        :rtype: int\n        \"\"\"\n        arr1.sort(), arr2.sort()\n        result, i, j = 0, 0, 0\n        while i < len(arr1) and j < len(arr2):\n            if arr1[i]-arr2[j] > d:\n                j += 1\n                continue\n            result += arr2[j]-arr1[i] > d\n            i += 1\n        return result+len(arr1)-i\n"
    },
    {
        "problem_name": "find-the-distinct-difference-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table, prefix sum\nclass Solution(object):\n    def distinctDifferenceArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(nums)\n        lookup = set()\n        for i in xrange(len(nums)):\n            lookup.add(nums[i])\n            result[i] = len(lookup)\n        lookup.clear()\n        for i in reversed(xrange(len(nums))):\n            result[i] -= len(lookup)\n            lookup.add(nums[i])\n        return result\n"
    },
    {
        "problem_name": "find-the-divisibility-array-of-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# prefix sum\nclass Solution(object):\n    def divisibilityArray(self, word, m):\n        \"\"\"\n        :type word: str\n        :type m: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        curr = 0\n        for c in word:\n            curr = (curr*10+(ord(c)-ord('0')))%m\n            result.append(int(curr == 0))\n        return result\n"
    },
    {
        "problem_name": "find-the-duplicate-number",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # Treat each (key, value) pair of the array as the (pointer, next) node of the linked list,\n        # thus the duplicated number will be the begin of the cycle in the linked list.\n        # Besides, there is always a cycle in the linked list which\n        # starts from the first element of the array.\n        slow = nums[0]\n        fast = nums[nums[0]]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n\n        fast = 0\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# Binary search method.\nclass Solution2(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 1, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n            # Get count of num <= mid.\n            count = 0\n            for num in nums:\n                if num <= mid:\n                    count += 1\n            if count > mid:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution3(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        duplicate = 0\n        # Mark the value as visited by negative.\n        for num in nums:\n            if nums[abs(num) - 1] > 0:\n                nums[abs(num) - 1] *= -1\n            else:\n                duplicate = abs(num)\n                break\n        # Rollback the value.\n        for num in nums:\n            if nums[abs(num) - 1] < 0:\n                nums[abs(num) - 1] *= -1\n            else:\n                break\n        return duplicate\n\n"
    },
    {
        "problem_name": "find-the-grid-of-region-average",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\n# array\nclass Solution(object):\n    def resultGrid(self, image, threshold):\n        \"\"\"\n        :type image: List[List[int]]\n        :type threshold: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def check(i, j):\n            return (all(abs(image[ni][nj]-image[ni+1][nj]) <= threshold for ni in xrange(i-1, i+1) for nj in xrange(j-1, j+2)) and\n                    all(abs(image[ni][nj]-image[ni][nj+1]) <= threshold for ni in xrange(i-1, i+2) for nj in xrange(j-1, j+1)))\n            \n        result = [[0]*len(image[0]) for _ in xrange(len(image))]\n        cnt = [[0]*len(image[0]) for _ in xrange(len(image))]\n        for i in xrange(1, len(image)-1):\n            for j in xrange(1, len(image[0])-1):\n                if not check(i, j):\n                    continue\n                total = sum(image[ni][nj] for ni in xrange(i-1, i+2) for nj in xrange(j-1, j+2))//9\n                for ni in xrange(i-1, i+2):\n                    for nj in xrange(j-1, j+2):\n                        cnt[ni][nj] += 1\n                        result[ni][nj] += total\n        for i in xrange(len(image)):\n            for j in xrange(len(image[0])):\n                if cnt[i][j]:\n                    result[i][j] //= cnt[i][j]\n                else:\n                    result[i][j] = image[i][j]\n        return result\n"
    },
    {
        "problem_name": "find-the-highest-altitude",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def largestAltitude(self, gain):\n        \"\"\"\n        :type gain: List[int]\n        :rtype: int\n        \"\"\"\n        result = curr = 0\n        for g in gain:\n            curr += g\n            result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "find-the-index-of-permutation",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# bit, fenwick tree, combinatorics\nclass Solution(object):\n    def getPermutationIndex(self, perm):\n        \"\"\"\n        :type perm: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n):\n                self.__bit = [0]*(n+1)  # Extra one for dummy node.\n\n            def add(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] = (self.__bit[i]+val) % MOD\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = 0\n                while i > 0:\n                    ret = (ret+self.__bit[i]) % MOD\n                    i -= (i & -i)\n                return ret\n\n        fact = [0]*len(perm)\n        fact[0] = 1\n        for i in xrange(len(fact)-1):\n            fact[i+1] = ((i+1)*fact[i])%MOD\n        result = 0\n        bit = BIT(len(perm))\n        for i, x in enumerate(perm):\n            result = (result+(((((x-1)-bit.query((x-1)-1))%MOD)*fact[(len(perm)-1)-i])%MOD))%MOD\n            bit.add(x-1, +1)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# bit, fenwick tree, combinatorics\nclass Solution2(object):\n    def getPermutationIndex(self, perm):\n        \"\"\"\n        :type perm: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        fact = [1]*2            \n        def factorial(n):\n            while len(fact) <= n:  # lazy initialization\n                fact.append(fact[-1]*len(fact) % MOD)\n            return fact[n]\n\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n):\n                self.__bit = [0]*(n+1)  # Extra one for dummy node.\n\n            def add(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] = (self.__bit[i]+val) % MOD\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = 0\n                while i > 0:\n                    ret = (ret+self.__bit[i]) % MOD\n                    i -= (i & -i)\n                return ret\n\n        result = 0\n        bit = BIT(len(perm))\n        for i, x in enumerate(perm):\n            result = (result+(((((x-1)-bit.query((x-1)-1))%MOD)*factorial((len(perm)-1)-i))%MOD))%MOD\n            bit.add(x-1, +1)\n        return result\n"
    },
    {
        "problem_name": "find-the-index-of-the-large-integer",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass ArrayReader(object):\n   def compareSub(self, l, r, x, y):\n       pass\n\n   def length(self):\n       pass\n\nclass Solution(object):\n    def getIndex(self, reader):\n        \"\"\"\n        :type reader: ArrayReader\n        :rtype: integer\n        \"\"\"\n        left, right = 0, reader.length()-1\n        while left < right:\n            mid = left + (right-left)//2\n            if reader.compareSub(left, mid, mid if (right-left+1)%2 else mid+1, right) >= 0:\n                right = mid\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "find-the-integer-added-to-array-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def addedInteger(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        return max(nums2)-max(nums1)\n"
    },
    {
        "problem_name": "find-the-integer-added-to-array-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport heapq\nimport collections\n\n\n# partial sort, freq table\nclass Solution(object):\n    def minimumAddedInteger(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        def check(cnt2, cnt1):\n            # return cnt2 <= cnt1  # for python3\n            return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.iteritems())  # for python2\n            \n        mx = max(nums2)\n        cnt2 = collections.Counter(nums2)\n        return next(d for d in [mx-x for x in heapq.nlargest(3, nums1)] if check(cnt2, collections.Counter(x+d for x in nums1)))\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\n# partial sort, freq table\nclass Solution2(object):\n    def minimumAddedInteger(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        def check(cnt2, cnt1):\n            # return cnt2 <= cnt1  # for python3\n            return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.iteritems())  # for python2\n        \n        def topk(a, k):  # Time: O(k * n)\n            result = [float(\"-inf\")]*k\n            for x in a:\n                for i in xrange(len(result)):\n                    if x > result[i]:\n                        result[i], x = x, result[i]\n            return result\n    \n        mx = max(nums2)\n        cnt2 = collections.Counter(nums2)\n        return next(d for d in [mx-x for x in topk(nums1, 3)] if check(cnt2, collections.Counter(x+d for x in nums1)))\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# sort\nclass Solution3(object):\n    def minimumAddedInteger(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        for i in xrange(3):\n            d = nums2[-1]-nums1[~i]\n            cnt = 0\n            for j in xrange(len(nums2)):\n                while j+cnt < len(nums1) and nums1[j+cnt]+d != nums2[j]:\n                    cnt += 1\n            if cnt <= 2:\n                return d\n        return -1\n"
    },
    {
        "problem_name": "find-the-k-beauty-of-a-number",
        "solution": "# Time:  O(logn)\n# Space: O(logn)\n\n# sliding window\nclass Solution(object):\n    def divisorSubstrings(self, num, k):\n        \"\"\"\n        :type num: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = curr = 0\n        s = map(int, str(num))\n        base = 10**(k-1)\n        for i, x in enumerate(s):\n            if i-k >= 0:\n                curr -= s[i-k]*base\n            curr = curr*10+x\n            if i+1 >= k:\n                result += int(curr and num%curr == 0)\n        return result\n"
    },
    {
        "problem_name": "find-the-k-or-of-an-array",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def findKOr(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return sum(1<<i for i in xrange(max(nums).bit_length()) if sum((x&(1<<i)) != 0 for x in nums) >= k)\n"
    },
    {
        "problem_name": "find-the-k-sum-of-an-array",
        "solution": "# Time:  O(nlogn + klogk)\n# Space: O(n + k)\n\nimport heapq\n\n\n# bfs, heap\nclass Solution(object):\n    def kSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        total = sum(x for x in nums if x > 0)\n        sorted_vals = sorted(abs(x) for x in nums)\n        max_heap = [(-total, 0)]\n        for _ in xrange(k):\n            result, i = heapq.heappop(max_heap)\n            result = -result\n            if i == len(sorted_vals):\n                continue\n            heapq.heappush(max_heap, (-(result-sorted_vals[i]), i+1))\n            if i-1 >= 0:\n                heapq.heappush(max_heap, (-(result+sorted_vals[i-1]-sorted_vals[i]), i+1))\n        return result\n"
    },
    {
        "problem_name": "find-the-k-th-lucky-number",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# math, bitmasks\nclass Solution(object):\n    def kthLuckyNumber(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: str\n        \"\"\"\n        result = []\n        k += 1\n        while k != 1:\n            result.append('7' if k&1 else '4')\n            k >>= 1\n        result.reverse()\n        return \"\".join(result)\n\n\n# Time:  O(logn)\n# Space: O(1)\n# math, bitmasks\nclass Solution2(object):\n    def kthLuckyNumber(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: str\n        \"\"\"\n        return bin(k+1)[3:].replace('1', '7').replace('0', '4')\n"
    },
    {
        "problem_name": "find-the-kth-largest-integer-in-the-array",
        "solution": "# Time:  O(n) ~ O(n^2), O(n) on average\n# Space: O(1)\n\nimport random\n\n\nclass Solution(object):\n    def kthLargestNumber(self, nums, k):\n        \"\"\"\n        :type nums: List[str]\n        :type k: int\n        :rtype: str\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n        \n        nth_element(nums, k-1, compare=lambda a, b: a > b if len(a) == len(b) else len(a) > len(b))\n        return nums[k-1]\n"
    },
    {
        "problem_name": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows",
        "solution": "# Time:  O(m * klogk)\n# Space: O(k)\n\nimport heapq\n\n\nclass Solution(object):\n    def kthSmallest(self, mat, k):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def kSmallestPairs(nums1, nums2, k):\n            result, min_heap = [], []\n            for c in xrange(min(len(nums1), k)):\n                heapq.heappush(min_heap, (nums1[c]+nums2[0], 0))\n                c += 1\n            while len(result) != k and min_heap:\n                total, c = heapq.heappop(min_heap)\n                result.append(total)\n                if c+1 == len(nums2):\n                    continue\n                heapq.heappush(min_heap, (total-nums2[c]+nums2[c+1], c+1))\n            return result\n\n        result = mat[0]\n        for r in xrange(1, len(mat)):\n            result = kSmallestPairs(result, mat[r], k)\n        return result[k-1]\n\n\n# Time:  O((k + m) * log(m * MAX_NUM)) ~ O(k * m * log(m * MAX_NUM))\n# Space: O(m)\nclass Solution2(object):\n    def kthSmallest(self, mat, k):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"        \n        def countArraysHaveSumLessOrEqual(mat, k, r, target):  # Time: O(k + m) ~ O(k * m)\n            if target < 0:\n                return 0\n            if r == len(mat):\n                return 1\n            result = 0\n            for c in xrange(len(mat[0])):\n                cnt = countArraysHaveSumLessOrEqual(mat, k-result, r+1, target-mat[r][c])\n                if not cnt:\n                    break\n                result += cnt\n                if result > k:\n                    break\n            return result\n        \n        max_num = max(x for row in mat for x in row)\n        left, right = len(mat), len(mat)*max_num\n        while left <= right:\n            mid = left + (right-left)//2\n            cnt = countArraysHaveSumLessOrEqual(mat, k, 0, mid)\n            if cnt >= k:\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n\n"
    },
    {
        "problem_name": "find-the-largest-area-of-square-inside-two-rectangles",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n# brute force, math\nclass Solution(object):\n    def largestSquareArea(self, bottomLeft, topRight):\n        \"\"\"\n        :type bottomLeft: List[List[int]]\n        :type topRight: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(len(bottomLeft)):\n            for j in xrange(i+1, len(bottomLeft)):\n                max_x = max(bottomLeft[i][0], bottomLeft[j][0])\n                min_x = min(topRight[i][0], topRight[j][0])\n                max_y = max(bottomLeft[i][1], bottomLeft[j][1])\n                min_y = min(topRight[i][1], topRight[j][1])\n                result = max(result, min(min_x-max_x, min_y-max_y))\n        return result**2\n\n\n# Time:  O(n^2)\n# Space: O(1)\n# brute force, math\nclass Solution2(object):\n    def largestSquareArea(self, bottomLeft, topRight):\n        \"\"\"\n        :type bottomLeft: List[List[int]]\n        :type topRight: List[List[int]]\n        :rtype: int\n        \"\"\"\n        return max(max(min(min(topRight[i][0], topRight[j][0])-max(bottomLeft[i][0], bottomLeft[j][0]), min(topRight[i][1], topRight[j][1])-max(bottomLeft[i][1], bottomLeft[j][1])) for i in xrange(len(bottomLeft)) for j in xrange(i+1, len(bottomLeft))), 0)**2\n"
    },
    {
        "problem_name": "find-the-length-of-the-longest-common-prefix",
        "solution": "# Time:  O((n + m) * l)\n# Space: O(t)\n\n# trie\nclass Solution(object):\n    def longestCommonPrefix(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: int\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        for x in arr1:\n            reduce(dict.__getitem__, str(x), trie)\n        result = 0\n        for x in arr2:\n            curr = trie\n            for i, c in enumerate(str(x)):\n                if c not in curr:\n                    break\n                curr = curr[c]\n            else:\n                i += 1\n            result = max(result, i)\n        return result\n\n\n# Time:  O((n + m) * l)\n# Space: O(n)\n# hash table\nclass Solution2(object):\n    def longestCommonPrefix(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = {0}\n        for x in arr1:\n            while x not in lookup:\n                lookup.add(x)\n                x //= 10\n        result = 0\n        for x in arr2:\n            l = len(str(x))\n            while x not in lookup:\n                x //= 10\n                l -= 1\n            result = max(result, l)\n        return result\n"
    },
    {
        "problem_name": "find-the-longest-balanced-substring-of-a-binary-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers\nclass Solution(object):\n    def findTheLongestBalancedSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(len(s)):\n            left, right = i+1, i\n            while left-1 >= 0 and right+1 < len(s) and s[left-1] == '0' and s[right+1] == '1':\n                left -= 1\n                right += 1\n            result = max(result, right-left+1)\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\n# string\nclass Solution2(object):\n    def findTheLongestBalancedSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        prev, cnt = [0]*2, [0]*2\n        for c in s:\n            cnt[int(c)] += 1\n            if cnt[int(c)^1]:\n                prev[int(c)^1], cnt[int(c)^1] = cnt[int(c)^1], 0\n            result = max(result, 2*min(prev[0], cnt[1]))\n        return result\n"
    },
    {
        "problem_name": "find-the-longest-equal-subarray",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table, two pointers, sliding window\nclass Solution(object):\n    def longestEqualSubarray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter()\n        result = left = 0\n        for right in xrange(len(nums)):\n            cnt[nums[right]] += 1\n            result = max(result, cnt[nums[right]])\n            if right-left+1 > result+k:\n                cnt[nums[left]] -= 1\n                left += 1\n        return result\n"
    },
    {
        "problem_name": "find-the-longest-semi-repetitive-substring",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers\nclass Solution(object):\n    def longestSemiRepetitiveSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = left = prev = 0\n        for right in xrange(len(s)):\n            if right-1 >= 0 and s[right-1] == s[right]:\n                left, prev = prev, right\n            result = max(result, right-left+1)\n        return result\n"
    },
    {
        "problem_name": "find-the-longest-substring-containing-vowels-in-even-counts",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findTheLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        VOWELS = \"aeiou\"\n        result, mask, lookup = 0, 0, [-2]*(2**len(VOWELS))\n        lookup[0] = -1\n        for i, c in enumerate(s):\n            index = VOWELS.find(c)\n            mask ^= (1 << index) if index >= 0 else 0\n            if lookup[mask] == -2:\n                lookup[mask] = i\n            result = max(result, i-lookup[mask])\n        return result\n"
    },
    {
        "problem_name": "find-the-longest-valid-obstacle-course-at-each-position",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport bisect\n\n\n# binary search solution\nclass Solution(object):\n    def longestObstacleCourseAtEachPosition(self, obstacles):\n        \"\"\"\n        :type obstacles: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result, stk = [], []\n        for x in obstacles:\n            i = bisect.bisect_right(stk, x)\n            result.append(i+1)\n            if i == len(stk):\n                stk.append(0)\n            stk[i] = x\n        return result\n    \n\n# Range Maximum Query\nclass SegmentTree(object):  # 0-based index\n    def __init__(self, N,\n                 build_fn=lambda x, y: [y]*(2*x),\n                 query_fn=lambda x, y: y if x is None else max(x, y),  # (lambda x, y: y if x is None else min(x, y))\n                 update_fn=lambda x, y: y,\n                 default_val=0):\n        self.N = N\n        self.H = (N-1).bit_length()\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        self.default_val = default_val\n        self.tree = build_fn(N, default_val)\n        self.lazy = [None]*N\n\n    def __apply(self, x, val):\n        self.tree[x] = self.update_fn(self.tree[x], val)\n        if x < self.N:\n            self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n    def update(self, L, R, h):  # Time: O(logN), Space: O(N)\n        def pull(x):\n            while x > 1:\n                x //= 2\n                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n                if self.lazy[x] is not None:\n                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\n\n        L += self.N\n        R += self.N\n        L0, R0 = L, R\n        while L <= R:\n            if L & 1:  # is right child\n                self.__apply(L, h) \n                L += 1\n            if R & 1 == 0:  # is left child\n                self.__apply(R, h)\n                R -= 1\n            L //= 2\n            R //= 2\n        pull(L0)\n        pull(R0)\n\n    def query(self, L, R):  # Time: O(logN), Space: O(N)\n        def push(x):\n            n = 2**self.H\n            while n != 1:\n                y = x // n\n                if self.lazy[y] is not None:\n                    self.__apply(y*2, self.lazy[y])\n                    self.__apply(y*2 + 1, self.lazy[y])\n                    self.lazy[y] = None\n                n //= 2\n\n        result = None\n        if L > R:\n            return result\n\n        L += self.N\n        R += self.N\n        push(L)\n        push(R)\n        while L <= R:\n            if L & 1:  # is right child\n                result = self.query_fn(result, self.tree[L])\n                L += 1\n            if R & 1 == 0:  # is left child\n                result = self.query_fn(result, self.tree[R])\n                R -= 1\n            L //= 2\n            R //= 2\n        return result\n    \n    def __str__(self):\n        showList = []\n        for i in xrange(self.N):\n            showList.append(self.query(i, i))\n        return \",\".join(map(str, showList))\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# segment tree solution\nclass Solution2_TLE(object):\n    def longestObstacleCourseAtEachPosition(self, obstacles):\n        \"\"\"\n        :type obstacles: List[int]\n        :rtype: List[int]\n        \"\"\"\n        sorted_obstacles = sorted(set(obstacles))\n        lookup = {x:i for i, x in enumerate(sorted_obstacles)}\n        segment_tree = SegmentTree(len(lookup))\n        result = []\n        for x in obstacles:\n            cnt = segment_tree.query(0, lookup[x])+1\n            result.append(cnt)\n            segment_tree.update(lookup[x], lookup[x], cnt)\n        return result\n"
    },
    {
        "problem_name": "find-the-losers-of-the-circular-game",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table, simulation\nclass Solution(object):\n    def circularGameLosers(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        lookup = [False]*n\n        idx = 0\n        for i in xrange(n):\n            if lookup[idx]:\n                break\n            lookup[idx] = True\n            idx = (idx+(i+1)*k)%n\n        return [i+1 for i in xrange(n) if not lookup[i]]\n"
    },
    {
        "problem_name": "find-the-maximum-achievable-number",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def theMaximumAchievableX(self, num, t):\n        \"\"\"\n        :type num: int\n        :type t: int\n        :rtype: int\n        \"\"\"\n        return num+2*t\n"
    },
    {
        "problem_name": "find-the-maximum-divisibility-score",
        "solution": "# Time:  O(n * d)\n# Space: O(1)\n\n# brute force\nclass Solution(object):\n    def maxDivScore(self, nums, divisors):\n        \"\"\"\n        :type nums: List[int]\n        :type divisors: List[int]\n        :rtype: int\n        \"\"\"\n        return max(divisors, key=lambda d: (sum(x%d == 0 for x in nums), -d))\n"
    },
    {
        "problem_name": "find-the-maximum-number-of-elements-in-subset",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table, dp\nclass Solution(object):\n    def maximumLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(nums)\n        dp = {}\n        result = 0\n        for x in cnt.iterkeys():\n            if x == 1:\n                result = max(result, cnt[x]-(1 if cnt[x]%2 == 0 else 0))\n                continue\n            stk = []\n            while x not in dp and x in cnt and cnt[x] >= 2:\n                stk.append(x)\n                x *= x\n            if x not in dp:\n                if x not in cnt:\n                    x = stk.pop()\n                dp[x] = 1\n            l = dp[x]\n            while stk:\n                l += 2\n                dp[stk.pop()] = l\n            result = max(result, l)\n        return result \n        \n\n# Time:  O(n * log(logr)) = O(9 * n)\n# Space: O(n)\nimport collections\n\n\n# freq table\nclass Solution2(object):\n    def maximumLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(nums)\n        result = 0\n        for x in cnt.iterkeys():\n            if x == 1:\n                result = max(result, cnt[x]-(1 if cnt[x]%2 == 0 else 0))\n                continue\n            l = 0\n            while x in cnt and cnt[x] >= 2:\n                l += 2\n                x *= x\n            l += 1 if x in cnt else -1\n            result = max(result, l)\n        return result \n        \n"
    },
    {
        "problem_name": "find-the-maximum-number-of-marked-indices",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, greedy, two pointers\nclass Solution(object):\n    def maxNumOfMarkedIndices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        left = 0\n        for right in xrange((len(nums)+1)//2, len(nums)):\n            if nums[right] >= 2*nums[left]:\n                left += 1\n        return left*2\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# sort, greedy, two pointers\nclass Solution2(object):\n    def maxNumOfMarkedIndices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        left = 0\n        for right in xrange(len(nums)):\n            if nums[right] >= 2*nums[left]:\n                left += 1\n        return min(left, len(nums)//2)*2\n"
    },
    {
        "problem_name": "find-the-maximum-sum-of-node-values",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def maximumValueSum(self, nums, k, edges):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result = parity = 0\n        diff = float(\"inf\")\n        for x in nums:\n            y = x^k\n            result += max(x, y)\n            parity ^= int(x < y)\n            diff = min(diff, abs(x-y))\n        return result-parity*diff\n"
    },
    {
        "problem_name": "find-the-median-of-the-uniqueness-array",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\n# binary search, two pointers, sliding window\nclass Solution(object):\n    def medianOfUniquenessArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def check(k):\n            result = 0\n            cnt = collections.Counter()\n            left = 0\n            for right in xrange(len(nums)):\n                cnt[nums[right]] += 1\n                while len(cnt) == k+1:\n                    cnt[nums[left]] -= 1\n                    if cnt[nums[left]] == 0:\n                        del cnt[nums[left]]\n                    left += 1\n                result += right-left+1\n            return result >= total-result\n\n        total = (len(nums)+1)*len(nums)//2\n        return binary_search(1, len(set(nums)), check)\n"
    },
    {
        "problem_name": "find-the-middle-index-in-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findMiddleIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        total = sum(nums)\n        accu = 0\n        for i, x in enumerate(nums):\n            if accu*2 == total-x:\n                return i\n            accu += x\n        return -1\n"
    },
    {
        "problem_name": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution(object):\n    def nodesBetweenCriticalPoints(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: List[int]\n        \"\"\"\n        first = last = -1\n        result = float(\"inf\")\n        i, prev, head = 0, head.val, head.next\n        while head.next:\n            if max(prev, head.next.val) < head.val or min(prev, head.next.val) > head.val:\n                if first == -1:\n                    first = i\n                if last != -1:\n                    result = min(result, i-last)\n                last = i\n            i += 1\n            prev = head.val\n            head = head.next\n        return [result, last-first] if last != first else [-1, -1]\n"
    },
    {
        "problem_name": "find-the-minimum-cost-array-permutation",
        "solution": "# Time:  O((n-1)^2 * 2^(n-1))\n# Space: O((n-1) * 2^(n-1))\n\n# dp, backtracing\nclass Solution(object):\n    def findPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        INF = float(\"inf\")\n        n = len(nums)\n        dp = [[(INF, -1) for _ in xrange(n-1)] for _ in xrange(1<<(n-1))]\n        for i in xrange(n-1):\n            dp[1<<i][i] = (abs((i+1)-nums[0]), -1)\n        for mask in xrange(1<<(n-1)):\n            for i in xrange(n-1):\n                if mask&(1<<i) == 0:\n                    continue\n                for j in xrange(n-1):\n                    if j == i or mask&(1<<j) == 0:\n                        continue\n                    dp[mask][i] = min(dp[mask][i], (dp[mask^(1<<i)][j][0]+abs((i+1)-nums[j+1]), j))\n        _, i = min((dp[-1][i][0]+abs(0-nums[i+1]), i) for i in xrange(n-1))\n        result = [0]\n        mask = (1<<(n-1))-1\n        while i != -1:\n            result.append(i+1)\n            mask, i = mask^(1<<i), dp[mask][i][1]\n        return result\n"
    },
    {
        "problem_name": "find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k",
        "solution": "# Time:  O(logk)\n# Space: O(1)\n\nclass Solution(object):\n    def findMinFibonacciNumbers(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result, a, b = 0, 1, 1\n        while b <= k:\n            b, a = a+b, b\n        while k:\n            if a <= k:\n                k -= a\n                result += 1\n            a, b = b-a, a\n        return result\n"
    },
    {
        "problem_name": "find-the-minimum-possible-sum-of-a-beautiful-array",
        "solution": "class Solution(object):\n    def minimumPossibleSum(self, n, target):\n        \"\"\"\n        :type n: int\n        :type target: int\n        :rtype: int\n        \"\"\"\n        def arithmetic_progression_sum(a, d, n):\n            return (a+(a+(n-1)*d))*n//2\n    \n        a = min(target//2, n)\n        b = n-a\n        return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(target, 1, b)\n    \n"
    },
    {
        "problem_name": "find-the-most-competitive-subsequence",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\nclass Solution(object):\n    def mostCompetitive(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        stk = []\n        for i, x in enumerate(nums):\n            while stk and stk[-1] > x and len(stk)+(len(nums)-i) > k:\n                stk.pop()\n            if len(stk) < k:\n                stk.append(x)\n        return stk\n"
    },
    {
        "problem_name": "find-the-number-of-subarrays-where-boundary-elements-are-maximum",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# mono stack, combinatorics\nclass Solution(object):\n    def numberOfSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = []\n        for x in nums:\n            while stk and stk[-1][0] < x:\n                stk.pop()\n            if not stk or stk[-1][0] != x:\n                stk.append([x, 0])\n            stk[-1][1] += 1\n            result += stk[-1][1]\n        return result\n"
    },
    {
        "problem_name": "find-the-number-of-ways-to-place-people-i",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n# sort, array\nclass Solution(object):\n    def numberOfPairs(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        points.sort(key=lambda x: (x[0], -x[1]))\n        result = 0\n        for i in xrange(len(points)):\n            y = float(\"-inf\")\n            for j in xrange(i+1, len(points)):\n                if points[i][1] < points[j][1]:\n                    continue\n                if points[j][1] > y:\n                    y = points[j][1]\n                    result += 1\n        return result\n\n\n# Time:  O(n^3)\n# Space: O(1)\n# sort, array\nclass Solution2(object):\n    def numberOfPairs(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        points.sort(key=lambda x: (x[0], -x[1]))\n        return sum(all(not points[i][1] >= points[k][1] >= points[j][1] for k in xrange(i+1, j))\n                   for i in xrange(len(points))\n                   for j in xrange(i+1, len(points)) if points[i][1] >= points[j][1])\n \n"
    },
    {
        "problem_name": "find-the-number-of-ways-to-place-people-ii",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n# sort, array\nclass Solution(object):\n    def numberOfPairs(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        points.sort(key=lambda x: (x[0], -x[1]))\n        result = 0\n        for i in xrange(len(points)):\n            y = float(\"-inf\")\n            for j in xrange(i+1, len(points)):\n                if points[i][1] < points[j][1]:\n                    continue\n                if points[j][1] > y:\n                    y = points[j][1]\n                    result += 1\n        return result\n\n\n# Time:  O(n^3)\n# Space: O(1)\n# sort, array\nclass Solution2(object):\n    def numberOfPairs(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        points.sort(key=lambda x: (x[0], -x[1]))\n        return sum(all(not points[i][1] >= points[k][1] >= points[j][1] for k in xrange(i+1, j))\n                   for i in xrange(len(points))\n                   for j in xrange(i+1, len(points)) if points[i][1] >= points[j][1])\n \n"
    },
    {
        "problem_name": "find-the-original-array-of-prefix-xor",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def findArray(self, pref):\n        \"\"\"\n        :type pref: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in reversed(xrange(1, len(pref))):\n            pref[i] ^= pref[i-1]\n        return pref\n"
    },
    {
        "problem_name": "find-the-peaks",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def findPeaks(self, mountain):\n        \"\"\"\n        :type mountain: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [i for i in xrange(1, len(mountain)-1) if mountain[i-1] < mountain[i] > mountain[i+1]]\n"
    },
    {
        "problem_name": "find-the-pivot-integer",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def pivotInteger(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        x = int(((n+1)*n//2)**0.5+0.5)\n        return x if x**2 == (n+1)*n//2 else -1\n"
    },
    {
        "problem_name": "find-the-prefix-common-array-of-two-arrays",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# freq table\nclass Solution(object):\n    def findThePrefixCommonArray(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(A)\n        cnt = collections.Counter()\n        curr = 0\n        for i, (a, b) in enumerate(itertools.izip(A, B)):\n            cnt[a] += 1\n            if cnt[a] == 2:\n                curr += 1\n            cnt[b] += 1\n            if cnt[b] == 2:\n                curr += 1\n            result[i] = curr\n        return result\n"
    },
    {
        "problem_name": "find-the-punishment-number-of-an-integer",
        "solution": "# Time:  O(n * (logn)^(2*logn))\n# Space: O(2*logn)\n\n# backtracking\nclass Solution(object):\n    def punishmentNumber(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def backtracking(curr, target):\n            if target == 0:\n                return curr == 0\n            base = 10\n            while curr >= base//10:\n                q, r = divmod(curr, base)\n                if target-r < 0:\n                    break\n                if backtracking(q, target-r):\n                    return True\n                base *= 10\n            return False\n    \n        return sum(i**2 for i in xrange(1, n+1) if backtracking(i**2, i))\n"
    },
    {
        "problem_name": "find-the-safest-path-in-a-grid",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nclass UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x, y = self.find_set(x), self.find_set(y)\n        if x == y:\n            return False\n        if self.rank[x] > self.rank[y]:  # union by rank\n            x, y = y, x\n        self.set[x] = self.set[y]\n        if self.rank[x] == self.rank[y]:\n            self.rank[y] += 1\n        return True\n\n\n# bfs, bucket sort, union find\nclass Solution(object):\n    def maximumSafenessFactor(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n        def bfs():\n            dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n            q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n            d = 0\n            while q:\n                new_q = []\n                for r, c in q:\n                    for dr, dc in DIRECTIONS:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] == -1):\n                            continue\n                        dist[nr][nc] = d+1\n                        new_q.append((nr, nc))\n                q = new_q\n                d += 1\n            return dist\n\n        dist = bfs()\n        buckets = [[] for _ in xrange((len(grid)-1)+(len(grid[0])-1)+1)]\n        for r in xrange(len(grid)):\n            for c in xrange(len(grid[0])):\n                buckets[dist[r][c]].append((r, c))\n        lookup = [[False]*len(grid[0]) for _ in xrange(len(grid))]\n        uf = UnionFind(len(grid)*len(grid[0]))\n        for d in reversed(xrange(len(buckets))):\n            for r, c in buckets[d]:\n                for dr, dc in DIRECTIONS:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and lookup[nr][nc] == True):\n                        continue\n                    uf.union_set(nr*len(grid[0])+nc, r*len(grid[0])+c)\n                lookup[r][c] = True\n            if uf.find_set(0*len(grid[0])+0) == uf.find_set((len(grid)-1)*len(grid[0])+(len(grid[0])-1)):\n                break\n        return d\n\n\n# Time:  O(n^2 * logn)\n# Space: O(n^2)\nimport heapq\n\n\n# bfs, dijkstra's algorithm\nclass Solution2(object):\n    def maximumSafenessFactor(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n        def bfs():\n            dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n            q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n            d = 0\n            while q:\n                new_q = []\n                for r, c in q:\n                    for dr, dc in DIRECTIONS:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] == -1):\n                            continue\n                        dist[nr][nc] = d+1\n                        new_q.append((nr, nc))\n                q = new_q\n                d += 1\n            return dist\n\n        def dijkstra(start, target):\n            max_heap = [(-dist[start[0]][start[1]], start)]\n            dist[start[0]][start[1]] = -1\n            while max_heap:\n                curr, u = heapq.heappop(max_heap)\n                curr = -curr\n                if u == target:\n                    return curr\n                for dr, dc in DIRECTIONS:\n                    nr, nc = u[0]+dr, u[1]+dc\n                    if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] != -1):\n                        continue\n                    heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc)))\n                    dist[nr][nc] = -1\n            return -1\n\n        dist = bfs()\n        return dijkstra(dist, (0, 0), (len(grid)-1, len(grid[0])-1)) \n\n\n# Time:  O(n^2 * logn)\n# Space: O(n^2)\nimport heapq\n\n\n# bfs, binary search\nclass Solution3(object):\n    def maximumSafenessFactor(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n        def bfs():\n            dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))]\n            q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]]\n            d = 0\n            while q:\n                new_q = []\n                for r, c in q:\n                    for dr, dc in DIRECTIONS:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] == -1):\n                            continue\n                        dist[nr][nc] = d+1\n                        new_q.append((nr, nc))\n                q = new_q\n                d += 1\n            return dist\n    \n        def check(x):\n            lookup = [[False]*len(dist[0]) for _ in xrange(len(dist))]\n            q = [(0, 0)]\n            lookup[0][0] = True\n            while q:\n                new_q = []\n                for r, c in q:\n                    for dr, dc in DIRECTIONS:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] >= x and not lookup[nr][nc]):\n                            continue\n                        lookup[nr][nc] = True\n                        new_q.append((nr, nc))\n                q = new_q\n            return lookup[-1][-1]\n    \n        dist = bfs()\n        left, right = 0, dist[0][0]\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "find-the-score-of-all-prefixes-of-an-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# prefix sum\nclass Solution(object):\n    def findPrefixScore(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        curr = 0\n        for i in xrange(len(nums)):\n            curr = max(curr, nums[i])\n            nums[i] += (nums[i-1] if i-1 >= 0 else 0)+curr\n        return nums\n"
    },
    {
        "problem_name": "find-the-shortest-superstring",
        "solution": "# Time:  O(n^2 * (l^2 + 2^n))\n# Space: O(n^2)\n\nclass Solution(object):\n    def shortestSuperstring(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: str\n        \"\"\"\n        n = len(A)\n        overlaps = [[0]*n for _ in xrange(n)]\n        for i, x in enumerate(A):\n            for j, y in enumerate(A):\n                for l in reversed(xrange(min(len(x), len(y)))):\n                    if y[:l].startswith(x[len(x)-l:]):\n                        overlaps[i][j] = l\n                        break\n\n        dp = [[0]*n for _ in xrange(1<<n)]\n        prev = [[None]*n for _ in xrange(1<<n)]\n        for mask in xrange(1, 1<<n):\n            for bit in xrange(n):\n                if ((mask>>bit) & 1) == 0:\n                    continue\n                prev_mask = mask^(1<<bit)\n                for i in xrange(n):\n                    if ((prev_mask>>i) & 1) == 0:\n                        continue\n                    value = dp[prev_mask][i] + overlaps[i][bit]\n                    if value > dp[mask][bit]:\n                        dp[mask][bit] = value\n                        prev[mask][bit] = i\n        \n        bit = max(xrange(n), key = dp[-1].__getitem__)\n        words = []\n        mask = (1<<n)-1\n        while bit is not None:\n            words.append(bit)\n            mask, bit = mask^(1<<bit), prev[mask][bit]\n        words.reverse()\n        lookup = set(words)\n        words.extend([i for i in xrange(n) if i not in lookup])\n\n        result = [A[words[0]]]\n        for i in xrange(1, len(words)):\n            overlap = overlaps[words[i-1]][words[i]]\n            result.append(A[words[i]][overlap:])\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "find-the-smallest-divisor-given-a-threshold",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def smallestDivisor(self, nums, threshold):\n        \"\"\"\n        :type nums: List[int]\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        def check(A, d, threshold):\n            return sum((i-1)//d+1 for i in nums) <= threshold\n\n        left, right = 1, max(nums)\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(nums, mid, threshold):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "find-the-string-with-lcp",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n# constructive algorithms, greedy, dp\nclass Solution(object):\n    def findTheString(self, lcp):\n        \"\"\"\n        :type lcp: List[List[int]]\n        :rtype: str\n        \"\"\"\n        result = [-1]*len(lcp)\n        curr = 0\n        for i in xrange(len(lcp)):\n            if result[i] != -1:\n                continue\n            if curr == 26:\n                return \"\"\n            for j in xrange(i, len(lcp[0])):\n                if lcp[i][j]:\n                    result[j] = curr\n            curr += 1\n        for i in reversed(xrange(len(lcp))):\n            for j in reversed(xrange(len(lcp[0]))):\n                if lcp[i][j] != ((lcp[i+1][j+1]+1 if i+1 < len(lcp) and j+1 < len(lcp[0]) else 1) if result[i] == result[j] else 0):\n                    return ''\n        return \"\".join(map(lambda x: chr(ord('a')+x), result))\n"
    },
    {
        "problem_name": "find-the-student-that-will-replace-the-chalk",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def chalkReplacer(self, chalk, k):\n        \"\"\"\n        :type chalk: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        k %= sum(chalk)\n        for i, x in enumerate(chalk):\n            if k < x:\n                return i\n            k -= x\n        return -1\n"
    },
    {
        "problem_name": "find-the-substring-with-maximum-cost",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\n# greedy, kadane's algorithm\nclass Solution(object):\n    def maximumCostSubstring(self, s, chars, vals):\n        \"\"\"\n        :type s: str\n        :type chars: str\n        :type vals: List[int]\n        :rtype: int\n        \"\"\"\n        def kadane(s):\n            result = curr = 0\n            for c in s:\n                curr = max(curr+(lookup[c] if c in lookup else ord(c)-ord('a')+1), 0)\n                result = max(result, curr)\n            return result\n\n        lookup = {}\n        for c, v in itertools.izip(chars, vals):\n            lookup[c] = v\n        return kadane(s)\n"
    },
    {
        "problem_name": "find-the-sum-of-encrypted-integers",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def sumOfEncryptedInt(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def f(x):\n            mx = base = 0\n            while x:\n                mx = max(mx, x%10)\n                x //= 10\n                base = 10*base+1\n            return mx*base\n\n        return sum(f(x) for x in nums)\n"
    },
    {
        "problem_name": "find-the-sum-of-subsequence-powers",
        "solution": "# Time:  O(n^2 + len(diffs) * n * k) = O(n^3 * k) at most\n# Space: O(len(diffs) + n * k) = O(n^2) at most\n\n# sort, dp, prefix sum, two pointers\nclass Solution(object):\n    def sumOfPowers(self, nums, k):\n        MOD = 10**9+7\n        nums.sort()\n        result = prev = 0\n        for mn in sorted({nums[j]-nums[i] for i in xrange(len(nums)) for j in xrange(i+1, len(nums))}, reverse=True):\n            dp = [[0]*(k+1) for _ in xrange(len(nums)+1)]\n            dp[0][0] = 1\n            j = 0\n            for i in xrange(len(nums)):\n                j = next((j for j in xrange(j, len(nums)) if nums[i]-nums[j] < mn), len(nums))\n                for l in xrange(1, k+1):\n                    dp[i+1][l] = (dp[i+1][l]+dp[(j-1)+1][l-1])%MOD  # dp[i+1][l]: count of subsequences of length l ending at i having min diff >= mn\n                for l in xrange(k+1):\n                    dp[i+1][l] = (dp[i+1][l]+dp[i][l])%MOD  # dp[i+1][l]: accumulated count of subsequences of length l ending at [0, i] having min diff >= mn\n            cnt = (dp[-1][k]-prev)%MOD\n            result = (result+mn*cnt)%MOD\n            prev = dp[-1][k]\n        return result\n\n\n# Time:  O(n^3 * len(diffs)) = O(n^5) at most\n# Space: O(n^2 * len(diffs)) = O(n^4) at most\nimport collections\n\n\n# sort, dp\nclass Solution2(object):\n    def sumOfPowers(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        nums.sort()\n        dp = [[collections.defaultdict(int) for _ in xrange(len(nums)+1)] for _ in xrange(len(nums))]        \n        for i in xrange(len(nums)):\n            for j in xrange(max(k-(len(nums)-i+1)-1, 0), i):\n                diff = nums[i]-nums[j]\n                dp[i][2][diff] += 1\n                for l in xrange(max(k-(len(nums)-i+1), 0), i+1):\n                    for mn, cnt in dp[j][l].iteritems():\n                        dp[i][l+1][min(diff, mn)] = (dp[i][l+1][min(diff, mn)]+cnt)%MOD\n        return reduce(lambda accu, x: (accu+x)%MOD, ((mn*cnt)%MOD for i in xrange(k-1, len(dp)) for mn, cnt in dp[i][k].iteritems()))\n"
    },
    {
        "problem_name": "find-the-sum-of-the-power-of-all-subsequences",
        "solution": "# Time:  O(n * k)\n# Space: O(k)\n\n# dp, combinatorics\nclass Solution(object):\n    def sumOfPower(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [0]*(k+1)\n        dp[0] = 1\n        for x in nums:\n            for i in reversed(xrange(k+1)):\n                dp[i] = (dp[i]+(dp[i]+(dp[i-x] if i-x >= 0 else 0)))%MOD\n        return dp[k]\n"
    },
    {
        "problem_name": "find-the-town-judge",
        "solution": "# Time:  O(t + n)\n# Space: O(n)\n\nclass Solution(object):\n    def findJudge(self, N, trust):\n        \"\"\"\n        :type N: int\n        :type trust: List[List[int]]\n        :rtype: int\n        \"\"\"\n        degrees = [0]*N\n        for i, j in trust:\n            degrees[i-1] -= 1\n            degrees[j-1] += 1\n        for i in xrange(len(degrees)):\n            if degrees[i] == N-1:\n                return i+1\n        return -1\n"
    },
    {
        "problem_name": "find-the-value-of-the-partition",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort\nclass Solution(object):\n    def findValueOfPartition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return min(nums[i+1]-nums[i] for i in xrange(len(nums)-1))\n"
    },
    {
        "problem_name": "find-the-width-of-columns-of-a-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def findColumnWidth(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def length(x):\n            l = 1\n            if x < 0:\n                x = -x\n                l += 1\n            while x >= 10:\n                x //= 10\n                l += 1\n            return l\n\n        return [max(length(grid[i][j]) for i in xrange(len(grid))) for j in xrange(len(grid[0]))]\n\n\n# Time:  O(m * n)\n# Space: O(logr)\n# array\nclass Solution2(object):\n    def findColumnWidth(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        return [max(len(str(grid[i][j])) for i in xrange(len(grid))) for j in xrange(len(grid[0]))]\n\n\n# Time:  O(m * n)\n# Space: O(m + logr)\nimport itertools\n\n\n# array\nclass Solution3(object):\n    def findColumnWidth(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        return [max(len(str(x)) for x in col) for col in itertools.izip(*grid)]\n"
    },
    {
        "problem_name": "find-the-winner-of-an-array-game",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def getWinner(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = arr[0]\n        count = 0\n        for i in xrange(1, len(arr)):\n            if arr[i] > result:\n                result = arr[i]\n                count = 0\n            count += 1\n            if (count == k):\n                break\n        return result\n"
    },
    {
        "problem_name": "find-the-winner-of-the-circular-game",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# bottom-up solution\nclass Solution(object):\n    def findTheWinner(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return reduce(lambda idx, n:(idx+k)%(n+1), xrange(1, n), 0)+1\n\n\n# Time:  O(n)\n# Space: O(n)\n# top-down solution\nclass Solution2(object):\n    def findTheWinner(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def f(idx, n, k):\n            if n == 1:\n                return 0\n            return (k+f((idx+k)%n, n-1, k))%n\n        \n        return f(0, n, k)+1\n"
    },
    {
        "problem_name": "find-three-consecutive-integers-that-sum-to-a-given-number",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def sumOfThree(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[int]\n        \"\"\"\n        return [num//3-1, num//3, num//3+1] if num%3 == 0 else []\n"
    },
    {
        "problem_name": "find-triangular-sum-of-an-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# combinatorics, number theory\nclass Solution(object):\n    def triangularSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def exp_mod(p, mod):\n            result = [p]\n            while result[-1]*p%10 != result[0]:\n                 result.append(result[-1]*p%10)\n            return [result[-1]]+result[:-1]\n\n        def inv_mod(x, mod):\n            y = x\n            while y*x%10 != 1:\n                y = y*x%10\n            return y\n\n        def factor_p(x, p, cnt, diff):\n            if x == 0:\n                return x, cnt\n            while x%p == 0:\n                x //= p\n                cnt += diff\n            return x, cnt\n    \n        EXP = {p:exp_mod(p, 10) for p in (2, 5)}  # {2:[6, 2, 4, 8], 5:[5]}           \n        INV = {i:inv_mod(i, 10) for i in xrange(1, 10) if i%2 and i%5}  # {1:1, 3:7, 7:3, 9:9}\n        result = 0\n        nCr = 1\n        cnt = {2:0, 5:0}\n        for i in xrange(len(nums)):\n            if not cnt[2] and not cnt[5]:\n                result = (result + nCr*nums[i])%10\n            elif cnt[2] and not cnt[5]:\n                result = (result + nCr*EXP[2][cnt[2]%len(EXP[2])]*nums[i])%10\n            elif not cnt[2] and cnt[5]:\n                result = (result + nCr*EXP[5][cnt[5]%len(EXP[5])]*nums[i])%10\n            mul, cnt[2] = factor_p((len(nums)-1)-i, 2, cnt[2], 1)\n            mul, cnt[5] = factor_p(mul, 5, cnt[5], 1)\n            div, cnt[2] = factor_p(i+1, 2, cnt[2], -1)\n            div, cnt[5] = factor_p(div, 5, cnt[5], -1)\n            nCr = nCr*mul%10\n            nCr = nCr*INV[div%10]%10\n        return result\n\n    \n# Time:  O(n^2)\n# Space: O(n)\n# combinatorics\nclass Solution2(object):\n    def triangularSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        nCr = 1\n        for i in xrange(len(nums)):\n            result = (result+nCr*nums[i])%10\n            nCr *= (len(nums)-1)-i\n            nCr //= i+1\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(1)\n# simulation\nclass Solution3(object):\n    def triangularSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        for i in reversed(xrange(len(nums))):\n            for j in xrange(i):\n                nums[j] = (nums[j]+nums[j+1])%10\n        return nums[0]\n"
    },
    {
        "problem_name": "find-two-non-overlapping-sub-arrays-each-with-target-sum",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def minSumOfLengths(self, arr, target):\n        \"\"\"\n        :type arr: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        prefix, dp = {0: -1}, [0]*len(arr)  # dp[i], min len of target subarray until i\n        result = min_len = float(\"inf\")\n        accu = 0\n        for right in xrange(len(arr)):\n            accu += arr[right]\n            prefix[accu] = right\n            if accu-target in prefix:\n                left = prefix[accu-target]\n                min_len = min(min_len, right-left)\n                if left != -1:\n                    result = min(result, dp[left] + (right-left))\n            dp[right] = min_len\n        return result if result != float(\"inf\") else -1\n"
    },
    {
        "problem_name": "find-unique-binary-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findDifferentBinaryString(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: str\n        \"\"\"\n        return \"\".join(\"01\"[nums[i][i] == '0'] for i in xrange(len(nums)))\n\n\n# Time:  O(k * n) = O(n^2), k is len(nums)\n#                         , n is len(nums[0])\n# Space: O(k) = O(n)\nclass Solution2(object):\n    def findDifferentBinaryString(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: str\n        \"\"\"\n        lookup = set(map(lambda x: int(x, 2), nums))  # Time: O(k * n) = O(n^2)\n        return next(bin(i)[2:].zfill(len(nums[0])) for i in xrange(2**len(nums[0])) if i not in lookup)  # Time: O(k + n) = O(n)\n\n\n# Time:  O(k * n + n * 2^n) = O(n * 2^n), k is len(nums)\n#                                       , n is len(nums[0])\n# Space: O(k) = O(1) ~ O(2^n)\nclass Solution_Extra(object):\n    def findAllDifferentBinaryStrings(self, nums):\n        \"\"\"\n        :type nums: List[str]\n        :rtype: List[str]\n        \"\"\"\n        lookup = set(map(lambda x: int(x, 2), nums))  # Time: O(k * n) = O(n * 2^n)\n        return [bin(i)[2:].zfill(len(nums[0])) for i in xrange(2**len(nums[0])) if i not in lookup]  # Time: O(2^n + n * (2^n - k))\n"
    },
    {
        "problem_name": "find-valid-matrix-given-row-and-column-sums",
        "solution": "# Time:  O(m + n), excluding ctor of result\n# Space: O(1)\n\n# optimized from Solution2 since we can find next i, j pair without nested loops\nclass Solution(object):\n    def restoreMatrix(self, rowSum, colSum):\n        \"\"\"\n        :type rowSum: List[int]\n        :type colSum: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        matrix = [[0]*len(colSum) for _ in xrange(len(rowSum))]\n        i = j = 0\n        while i < len(matrix) and j < len(matrix[0]):\n            matrix[i][j] = min(rowSum[i], colSum[j])  # greedily used\n            rowSum[i] -= matrix[i][j]\n            colSum[j] -= matrix[i][j]\n            if not rowSum[i]:  # won't be used in row i, ++i\n                i += 1\n            if not colSum[j]:  # won't be used in col j, ++j\n                j += 1\n        return matrix\n\n\n# Time:  O(m * n)\n# Space: O(1)\nclass Solution2(object):\n    def restoreMatrix(self, rowSum, colSum):\n        \"\"\"\n        :type rowSum: List[int]\n        :type colSum: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        matrix = [[0]*len(colSum) for _ in xrange(len(rowSum))]\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[i])):\n                matrix[i][j] = min(rowSum[i], colSum[j])  # greedily used\n                rowSum[i] -= matrix[i][j]\n                colSum[j] -= matrix[i][j]\n        return matrix\n"
    },
    {
        "problem_name": "find-winner-on-a-tic-tac-toe-game",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def tictactoe(self, moves):\n        \"\"\"\n        :type moves: List[List[int]]\n        :rtype: str\n        \"\"\"\n        row, col = [[0]*3 for _ in xrange(2)], [[0]*3 for _ in xrange(2)]\n        diag, anti_diag = [0]*2, [0]*2\n        p = 0\n        for r, c in moves:\n            row[p][r] += 1\n            col[p][c] += 1\n            diag[p] += r == c\n            anti_diag[p] += r+c == 2\n            if 3 in (row[p][r], col[p][c], diag[p], anti_diag[p]):\n                return \"AB\"[p]\n            p ^= 1\n        return \"Draw\" if len(moves) == 9 else \"Pending\"\n"
    },
    {
        "problem_name": "find-words-containing-character",
        "solution": "# Time:  O(n * l)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def findWordsContaining(self, words, x):\n        \"\"\"\n        :type words: List[str]\n        :type x: str\n        :rtype: List[int]\n        \"\"\"\n        return [i for i, w in enumerate(words) if x in w]\n"
    },
    {
        "problem_name": "find-words-that-can-be-formed-by-characters",
        "solution": "# Time:  O(m * n), m is the length of chars, n is the number of words\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def countCharacters(self, words, chars):\n        \"\"\"\n        :type words: List[str]\n        :type chars: str\n        :rtype: int\n        \"\"\"\n        def check(word, chars, count):\n            if len(word) > len(chars):\n                return False\n            curr_count = collections.Counter()\n            for c in word:\n                curr_count[c] += 1\n                if c not in count or count[c] < curr_count[c]:\n                    return False\n            return True\n        \n        count = collections.Counter(chars)\n        return sum(len(word) for word in words if check(word, chars, count))\n\n"
    },
    {
        "problem_name": "find-xor-beauty-of-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport operator\n\n\n# bit manipulation, math\nclass Solution(object):\n    def xorBeauty(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return reduce(operator.xor, nums)\n"
    },
    {
        "problem_name": "find-xor-sum-of-all-pairs-bitwise-and",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport operator\n\n\nclass Solution(object):\n    def getXORSum(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: int\n        \"\"\"\n        return reduce(operator.xor, arr1) & reduce(operator.xor, arr2)\n"
    },
    {
        "problem_name": "finding-3-digit-even-numbers",
        "solution": "# Time:  O(1) ~ O(n), n is 10^3\n# Space: O(1)\n\nclass Solution(object):\n    def findEvenNumbers(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        k = 3\n        def backtracking(curr, cnt, result):\n            if len(curr) == k:\n                result.append(reduce(lambda x, y: x*10+y, curr))\n                return\n            for i, c in enumerate(cnt):\n                if c == 0 or (not curr and i == 0) or (len(curr) == k-1 and i%2 != 0):\n                    continue\n                cnt[i] -= 1\n                curr.append(i)\n                backtracking(curr, cnt, result)\n                curr.pop()\n                cnt[i] += 1\n\n        cnt = [0]*10\n        for d in digits:\n            cnt[d] += 1\n        result = []\n        backtracking([], cnt, result)\n        return result\n\n\n# Time:  O(n), n is 10^3\n# Space: O(1)\nimport collections\n\n\nclass Solution2(object):\n    def findEvenNumbers(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result, cnt = [], collections.Counter(digits)\n        for i in xrange(1, 10):\n            for j in xrange(10):\n                for k in xrange(0, 10, 2):\n                    if cnt[i] > 0 and cnt[j] > (j == i) and cnt[k] > (k == i) + (k == j):\n                        result.append(i*100 + j*10 + k)\n        return result\n\n\n# Time:  O(1) ~ O(n), n is 10^3\n# Space: O(1)\nimport collections\n\n\nclass Node(object):\n    def __init__(self, val=None, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution3(object):\n    def findEvenNumbers(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        k = 3\n        def backtracking(curr, dummy, result):\n            if len(curr) == k:\n                result.append(reduce(lambda x, y: x*10+y, curr))\n                return\n            node = dummy.right\n            while node:\n                if (not curr and node.val[0] == 0) or (len(curr) == k-1 and node.val[0]%2 != 0):\n                    node = node.right\n                    continue\n                node.val[1] -= 1\n                if node.val[1] == 0:\n                    if node.left:\n                        node.left.right = node.right\n                    if node.right:\n                        node.right.left = node.left\n                curr.append(node.val[0])\n                backtracking(curr, dummy, result)\n                curr.pop()\n                if node.val[1] == 0:\n                    if node.left:\n                        node.left.right = node\n                    if node.right:\n                        node.right.left = node\n                node.val[1] += 1\n                node = node.right\n\n        prev = dummy = Node()\n        for digit, cnt in sorted(map(list, collections.Counter(digits).iteritems())):\n            prev.right = Node(val=[digit, cnt], left=prev)\n            prev = prev.right\n        result = []\n        backtracking([], dummy, result)\n        return result\n\n\n# Time:  O(1) ~ O(nlogn), n is 10^3\n# Space: O(1)\nimport collections\n\n\nclass Solution4(object):\n    def findEvenNumbers(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        k = 3\n        def backtracking(curr, digit_cnt, result):\n            if len(curr) == k:\n                result.append(reduce(lambda x, y: x*10+y, curr))\n                return\n            for i, (digit, cnt) in enumerate(digit_cnt):\n                if (not curr and digit == 0) or (len(curr) == k-1 and digit%2 != 0):\n                    continue\n                digit_cnt[i][1] -= 1\n                digit_cnt[i], digit_cnt[-1] = digit_cnt[-1], digit_cnt[i]\n                removed = []\n                if digit_cnt[-1][1] == 0:\n                    removed = digit_cnt.pop()\n                curr.append(digit)\n                backtracking(curr, digit_cnt, result)\n                curr.pop()\n                if removed:\n                    digit_cnt.append(removed)\n                digit_cnt[i], digit_cnt[-1] = digit_cnt[-1], digit_cnt[i]\n                digit_cnt[i][1] += 1\n\n        cnt = collections.Counter(digits)\n        digit_cnt = map(list, cnt.iteritems())\n        result = []\n        backtracking([], digit_cnt, result)\n        result.sort()\n        return result\n"
    },
    {
        "problem_name": "finding-mk-average",
        "solution": "# Time:  ctor:           O(1)\n#        add_element:    O(logn)\n#        calc_mkaverage: O(1)\n# Space: O(m)\n\nimport collections\nfrom sortedcontainers import SortedList\n\n\nclass MKAverage(object):\n\n    def __init__(self, m, k):\n        \"\"\"\n        :type m: int\n        :type k: int\n        \"\"\"\n        self.__m = m\n        self.__k = k\n        self.__dq = collections.deque()\n        self.__sl = SortedList()\n        self.__total = self.__first_k = self.__last_k = 0\n\n    def addElement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: None\n        \"\"\"\n        if len(self.__dq) == self.__m:\n            self.__remove(self.__dq.popleft())\n        self.__dq.append(num)\n        self.__add(num)\n\n    def calculateMKAverage(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.__sl) < self.__m:\n            return -1\n        return (self.__total-self.__first_k-self.__last_k)//(self.__m-2*self.__k)\n\n    def __add(self, num):\n        self.__total += num\n        idx = self.__sl.bisect_left(num)\n        if idx < self.__k:\n            self.__first_k += num\n            if len(self.__sl) >= self.__k:\n                self.__first_k -= self.__sl[self.__k-1]\n        if idx > len(self.__sl)-self.__k:\n            self.__last_k += num\n            if len(self.__sl) >= self.__k:\n                self.__last_k -= self.__sl[-self.__k]\n        self.__sl.add(num)\n\n    def __remove(self, num):\n        self.__total -= num\n        idx = self.__sl.index(num)\n        if idx < self.__k:\n            self.__first_k -= num\n            self.__first_k += self.__sl[self.__k]\n        elif idx > (len(self.__sl)-1)-self.__k:\n            self.__last_k -= num\n            self.__last_k += self.__sl[-1-self.__k]\n        self.__sl.remove(num)\n"
    },
    {
        "problem_name": "finding-pairs-with-a-certain-sum",
        "solution": "# Time:  ctor:  O(n1 + n2)\n#        add:   O(1)\n#        count: O(n1)\n# Space: O(n1 + n2)\n\nimport collections\n\n\nclass FindSumPairs(object):\n\n    def __init__(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        \"\"\"\n        self.__nums2 = nums2\n        self.__count1 = collections.Counter(nums1)\n        self.__count2 = collections.Counter(nums2)\n\n    def add(self, index, val):\n        \"\"\"\n        :type index: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        self.__count2[self.__nums2[index]] -= 1\n        self.__nums2[index] += val\n        self.__count2[self.__nums2[index]] += 1\n\n\n    def count(self, tot):\n        \"\"\"\n        :type tot: int\n        :rtype: int\n        \"\"\"\n        return sum(cnt * self.__count2[tot-x] for x, cnt in self.__count1.iteritems())\n"
    },
    {
        "problem_name": "finding-the-number-of-visible-mountains",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# math, sort\nclass Solution(object):\n    def visibleMountains(self, peaks):\n        \"\"\"\n        :type peaks: List[List[int]]\n        :rtype: int\n        \"\"\"\n        peaks.sort(key=lambda x: (x[0]-x[1], -(x[0]+x[1])))  # rotate points by 45 degrees and we only care the largest new y in the same new x\n        result = mx = 0\n        for i in xrange(len(peaks)):\n            if peaks[i][0]+peaks[i][1] <= mx:\n                continue\n            mx = peaks[i][0]+peaks[i][1]\n            if i+1 == len(peaks) or peaks[i+1] != peaks[i]:\n                result += 1\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# sort, mono stack\nclass Solution2(object):\n    def visibleMountains(self, peaks):\n        \"\"\"\n        :type peaks: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def is_covered(a, b):\n            x1, y1 = a\n            x2, y2 = b\n            return x2-y2 <= x1-y1 and x1+y1 <= x2+y2\n\n        peaks.sort()\n        stk = []\n        for i in xrange(len(peaks)):\n            while stk and is_covered(peaks[stk[-1]], peaks[i]):\n                stk.pop()\n            if (i-1 == -1 or peaks[i-1] != peaks[i]) and (not stk or not is_covered(peaks[i], peaks[stk[-1]])):  # not duplicted and not covered\n                stk.append(i)\n        return len(stk)\n            \n"
    },
    {
        "problem_name": "finding-the-users-active-minutes",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def findingUsersActiveMinutes(self, logs, k):\n        \"\"\"\n        :type logs: List[List[int]]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        lookup = collections.defaultdict(set)\n        for u, t in logs:\n            lookup[u].add(t)\n        result = [0]*k\n        for _, ts in lookup.iteritems():\n            result[len(ts)-1] += 1\n        return result\n"
    },
    {
        "problem_name": "first-bad-version",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def firstBadVersion(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) / 2\n            if isBadVersion(mid): # noqa\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n"
    },
    {
        "problem_name": "first-completely-painted-row-or-column",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\n# hash table\nclass Solution(object):\n    def firstCompleteIndex(self, arr, mat):\n        \"\"\"\n        :type arr: List[int]\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = {mat[i][j]: (i, j) for i in xrange(len(mat)) for j in xrange(len(mat[0]))}\n        row = [0]*len(mat)\n        col = [0]*len(mat[0])\n        for idx, x in enumerate(arr):\n            i, j = lookup[x]\n            row[i] += 1\n            col[j] += 1\n            if row[i] == len(mat[0]) or col[j] == len(mat):\n                return idx\n        return -1\n"
    },
    {
        "problem_name": "first-day-where-you-have-been-in-all-the-rooms",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def firstDayBeenInAllRooms(self, nextVisit):\n        \"\"\"\n        :type nextVisit: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        dp = [0]*len(nextVisit)\n        for i in xrange(1, len(dp)):\n            dp[i] = (dp[i-1]+1+(dp[i-1]-dp[nextVisit[i-1]])+1)%MOD\n        return dp[-1]\n"
    },
    {
        "problem_name": "first-letter-to-appear-twice",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# hash table\nclass Solution(object):\n    def repeatedCharacter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        lookup = set()\n        for c in s:\n            if c in lookup:\n                break\n            lookup.add(c)\n        return c\n"
    },
    {
        "problem_name": "first-missing-positive",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param A, a list of integers\n    # @return an integer\n    def firstMissingPositive(self, A):\n        i = 0\n        while i < len(A):\n            if A[i] > 0 and A[i] - 1 < len(A) and A[i] != A[A[i]-1]:\n                A[A[i]-1], A[i] = A[i], A[A[i]-1]\n            else:\n                i += 1\n\n        for i, integer in enumerate(A):\n            if integer != i + 1:\n                return i + 1\n        return len(A) + 1\n\n"
    },
    {
        "problem_name": "first-unique-character-in-a-string",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nfrom collections import defaultdict\n\nclass Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        lookup = defaultdict(int)\n        candidtates = set()\n        for i, c in enumerate(s):\n            if lookup[c]:\n                candidtates.discard(lookup[c])\n            else:\n                lookup[c] = i+1\n                candidtates.add(i+1)\n\n        return min(candidtates)-1 if candidtates else -1\n\n"
    },
    {
        "problem_name": "first-unique-number",
        "solution": "# Time:  ctor: O(k)\n#        add: O(1)\n#        showFirstUnique: O(1)\n# Space: O(n)\n\nimport collections\n\n\nclass FirstUnique(object):\n\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.__q = collections.OrderedDict()\n        self.__dup = set()\n        for num in nums:\n            self.add(num)\n\n    def showFirstUnique(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.__q:\n            return next(iter(self.__q))\n        return -1\n    \n    def add(self, value):\n        \"\"\"\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if value not in self.__dup and value not in self.__q:\n            self.__q[value] = None\n            return\n        if value in self.__q:\n            self.__q.pop(value)\n            self.__dup.add(value)\n\n"
    },
    {
        "problem_name": "fixed-point",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def fixedPoint(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(A)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if A[mid] >= mid:\n                right = mid-1\n            else:\n                left = mid+1\n        return left if A[left] == left else -1\n"
    },
    {
        "problem_name": "fizz-buzz-multithreaded",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport threading\n\n\nclass FizzBuzz(object):\n    def __init__(self, n):\n        self.__n = n\n        self.__curr = 0\n        self.__cv = threading.Condition()\n\n    # printFizz() outputs \"fizz\"\n    def fizz(self, printFizz):\n        \"\"\"\n        :type printFizz: method\n        :rtype: void\n        \"\"\"\n        for i in xrange(1, self.__n+1):\n            with self.__cv:\n                while self.__curr % 4 != 0:\n                    self.__cv.wait()\n                self.__curr += 1\n                if i % 3 == 0 and i % 5 != 0:\n                    printFizz()\n                self.__cv.notify_all()\n\n    # printBuzz() outputs \"buzz\"\n    def buzz(self, printBuzz):\n        \"\"\"\n        :type printBuzz: method\n        :rtype: void\n        \"\"\"\n        for i in xrange(1, self.__n+1):\n            with self.__cv:\n                while self.__curr % 4 != 1:\n                    self.__cv.wait()\n                self.__curr += 1\n                if i % 3 != 0 and i % 5 == 0:\n                    printBuzz()\n                self.__cv.notify_all()\n\n    # printFizzBuzz() outputs \"fizzbuzz\"\n    def fizzbuzz(self, printFizzBuzz):\n        \"\"\"\n        :type printFizzBuzz: method\n        :rtype: void\n        \"\"\"\n        for i in xrange(1, self.__n+1):\n            with self.__cv:\n                while self.__curr % 4 != 2:\n                    self.__cv.wait()\n                self.__curr += 1\n                if i % 3 == 0 and i % 5 == 0:\n                    printFizzBuzz()\n                self.__cv.notify_all()\n\n    # printNumber(x) outputs \"x\", where x is an integer.\n    def number(self, printNumber):\n        \"\"\"\n        :type printNumber: method\n        :rtype: void\n        \"\"\"\n        for i in xrange(1, self.__n+1):\n            with self.__cv:\n                while self.__curr % 4 != 3:\n                    self.__cv.wait()\n                self.__curr += 1\n                if i % 3 != 0 and i % 5 != 0:\n                    printNumber(i)\n                self.__cv.notify_all()\n"
    },
    {
        "problem_name": "fizz-buzz",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n\n        for i in xrange(1, n+1):\n            if i % 15 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            else:\n                result.append(str(i))\n\n        return result\n\n    def fizzBuzz2(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        l = [str(x) for x in range(n + 1)]\n        l3 = range(0, n + 1, 3)\n        l5 = range(0, n + 1, 5)\n        for i in l3:\n            l[i] = 'Fizz'\n        for i in l5:\n            if l[i] == 'Fizz':\n                l[i] += 'Buzz'\n            else:\n                l[i] = 'Buzz'\n        return l[1:]\n\n    def fizzBuzz3(self, n):\n        return ['Fizz' * (not i % 3) + 'Buzz' * (not i % 5) or str(i) for i in range(1, n + 1)]\n\n    def fizzBuzz4(self, n):\n        return ['FizzBuzz'[i % -3 & -4:i % -5 & 8 ^ 12] or repr(i) for i in range(1, n + 1)]\n\n"
    },
    {
        "problem_name": "flatten-2d-vector",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nfrom collections import deque\n\n\nclass Vector2D(object):\n\n    def __init__(self, vec2d):\n        \"\"\"\n        Initialize your data structure here.\n        :type vec2d: List[List[int]]\n        \"\"\"\n        self.stack = deque((len(v), iter(v)) for v in vec2d if v)\n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        length, iterator = self.stack.popleft()\n        if length > 1:\n            self.stack.appendleft((length-1, iterator))\n        return next(iterator)\n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return bool(self.stack)\n"
    },
    {
        "problem_name": "flatten-a-multilevel-doubly-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Node(object):\n    def __init__(self, val, prev, next, child):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\n\nclass Solution(object):\n    def flatten(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: Node\n        \"\"\"\n        curr = head\n        while curr:\n            if curr.child:\n                curr_next = curr.next\n                curr.child.prev = curr\n                curr.next = curr.child\n                last_child = curr\n                while last_child.next:\n                    last_child = last_child.next\n                if curr_next:\n                    last_child.next = curr_next\n                    curr_next.prev = last_child\n                curr.child = None\n            curr = curr.next\n        return head\n\n"
    },
    {
        "problem_name": "flatten-binary-tree-to-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(h), h is height of binary tree\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return nothing, do it in place\n    def flatten(self, root):\n        self.flattenRecu(root, None)\n\n    def flattenRecu(self, root, list_head):\n        if root:\n            list_head = self.flattenRecu(root.right, list_head)\n            list_head = self.flattenRecu(root.left, list_head)\n            root.right = list_head\n            root.left = None\n            return root\n        else:\n            return list_head\n\nclass Solution2(object):\n    list_head = None\n    # @param root, a tree node\n    # @return nothing, do it in place\n    def flatten(self, root):\n        if root:\n            self.flatten(root.right)\n            self.flatten(root.left)\n            root.right = self.list_head\n            root.left = None\n            self.list_head = root\n"
    },
    {
        "problem_name": "flatten-nested-list-iterator",
        "solution": "# Time:  O(n), n is the number of the integers.\n# Space: O(h), h is the depth of the nested lists.\n\nclass NestedIterator(object):\n\n    def __init__(self, nestedList):\n        \"\"\"\n        Initialize your data structure here.\n        :type nestedList: List[NestedInteger]\n        \"\"\"\n        self.__depth = [[nestedList, 0]]\n\n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        nestedList, i = self.__depth[-1]\n        self.__depth[-1][1] += 1\n        return nestedList[i].getInteger()\n\n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        while self.__depth:\n            nestedList, i = self.__depth[-1]\n            if i == len(nestedList):\n                self.__depth.pop()\n            elif nestedList[i].isInteger():\n                    return True\n            else:\n                self.__depth[-1][1] += 1\n                self.__depth.append([nestedList[i].getList(), 0])\n        return False\n\n\n\n"
    },
    {
        "problem_name": "flip-binary-tree-to-match-preorder-traversal",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n        \nclass Solution(object):\n    def flipMatchVoyage(self, root, voyage):\n        \"\"\"\n        :type root: TreeNode\n        :type voyage: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def dfs(root, voyage, i, result):\n            if not root:\n                return True\n            if root.val != voyage[i[0]]:\n                return False\n            i[0] += 1\n            if root.left and root.left.val != voyage[i[0]]:\n                result.append(root.val)\n                return dfs(root.right, voyage, i, result) and \\\n                       dfs(root.left, voyage, i, result)\n            return dfs(root.left, voyage, i, result) and \\\n                   dfs(root.right, voyage, i, result)\n        \n        result = []\n        return result if dfs(root, voyage, [0], result) else [-1]\n"
    },
    {
        "problem_name": "flip-columns-for-maximum-number-of-equal-rows",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nimport collections\n\n\nclass Solution(object):\n    def maxEqualRowsAfterFlips(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        count = collections.Counter(tuple(x^row[0] for x in row)\n                                          for row in matrix)\n        return max(count.itervalues())\n"
    },
    {
        "problem_name": "flip-equivalent-binary-trees",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nimport collections\n\n\n# bfs solution\nclass Solution(object):\n    def flipEquiv(self, root1, root2):\n        \"\"\"\n        :type root1: TreeNode\n        :type root2: TreeNode\n        :rtype: bool\n        \"\"\"\n        dq1, dq2 = collections.deque([root1]), collections.deque([root2])\n        while dq1 and dq2:\n            node1, node2 = dq1.pop(), dq2.pop()\n            if not node1 and not node2:\n                continue \n            if not node1 or not node2 or node1.val != node2.val:\n                return False\n            if (not node1.left and not node2.right) or \\\n               (node1.left and node2.right and node1.left.val == node2.right.val):\n                dq1.extend([node1.right, node1.left])\n            else:\n                dq1.extend([node1.left, node1.right])\n            dq2.extend([node2.left, node2.right])\n        return not dq1 and not dq2\n\n\n# Time:  O(n)\n# Space: O(h)\n# iterative dfs solution\nclass Solution2(object):\n    def flipEquiv(self, root1, root2):\n        \"\"\"\n        :type root1: TreeNode\n        :type root2: TreeNode\n        :rtype: bool\n        \"\"\"\n        stk1, stk2 = [root1], [root2]\n        while stk1 and stk2:\n            node1, node2 = stk1.pop(), stk2.pop()\n            if not node1 and not node2:\n                continue \n            if not node1 or not node2 or node1.val != node2.val:\n                return False\n            if (not node1.left and not node2.right) or \\\n               (node1.left and node2.right and node1.left.val == node2.right.val):\n                stk1.extend([node1.right, node1.left])\n            else:\n                stk1.extend([node1.left, node1.right])\n            stk2.extend([node2.left, node2.right])\n        return not stk1 and not stk2\n\n\n# Time:  O(n)\n# Space: O(h)\n# recursive dfs solution\nclass Solution3(object):\n    def flipEquiv(self, root1, root2):\n        \"\"\"\n        :type root1: TreeNode\n        :type root2: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root1 and not root2:\n            return True\n        if not root1 or not root2 or root1.val != root2.val:\n            return False\n\n        return (self.flipEquiv(root1.left, root2.left) and\n                self.flipEquiv(root1.right, root2.right) or\n                self.flipEquiv(root1.left, root2.right) and\n                self.flipEquiv(root1.right, root2.left))\n"
    },
    {
        "problem_name": "flip-game-ii",
        "solution": "# Time:  O(n + c^2)\n# Space: O(c)\n\nimport itertools\nimport re\n\n\n# The best theory solution (DP, O(n + c^2)) could be seen here:\n# https://leetcode.com/problems/flip-game-ii/discuss/73954/theory-matters-from-backtracking128ms-to-dp-0ms\nclass Solution(object):\n    def canWin(self, s):\n        g, g_final = [0], 0\n        for p in itertools.imap(len, re.split('-+', s)):\n            while len(g) <= p:\n                # Theorem 2: g[game] = g[subgame1]^g[subgame2]^g[subgame3]...\n                # and find first missing number.\n                g += min(set(xrange(p)) - {x^y for x, y in itertools.izip(g[:len(g)/2], g[-2:-len(g)/2-2:-1])}),\n            g_final ^= g[p]\n        return g_final > 0  # Theorem 1: First player must win iff g(current_state) != 0\n\n\n# Time:  O(n + c^3 * 2^c * logc), n is length of string, c is count of \"++\"\n# Space: O(c * 2^c)\n# hash solution.\n# We have total O(2^c) game strings,\n# and each hash key in hash table would cost O(c),\n# each one has O(c) choices to the next one,\n# and each one would cost O(clogc) to sort,\n# so we get O((c * 2^c) * (c * clogc)) = O(c^3 * 2^c * logc) time.\n# To cache the results of all combinations, thus O(c * 2^c) space.\nclass Solution2(object):\n    def canWin(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        lookup = {}\n\n        def canWinHelper(consecutives):                                         # O(2^c) time\n            consecutives = tuple(sorted(c for c in consecutives if c >= 2))     # O(clogc) time\n            if consecutives not in lookup:\n                lookup[consecutives] = any(not canWinHelper(consecutives[:i] + (j, c-2-j) + consecutives[i+1:])  # O(c) time\n                                           for i, c in enumerate(consecutives)  # O(c) time\n                                           for j in xrange(c - 1))              # O(c) time\n            return lookup[consecutives]                                         # O(c) time\n\n        # re.findall: O(n) time, canWinHelper: O(c) in depth\n        return canWinHelper(map(len, re.findall(r'\\+\\++', s)))\n\n\n# Time:  O(c * n * c!), n is length of string, c is count of \"++\"\n# Space: O(c * n), recursion would be called at most c in depth.\n#                  Besides, it costs n space for modifying string at each depth.\nclass Solution3(object):\n    def canWin(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        i, n = 0, len(s) - 1\n        is_win = False\n        while not is_win and i < n:                                     # O(n) time\n            if s[i] == '+':\n                while not is_win and i < n and s[i+1] == '+':           # O(c) time\n                     # t(n, c) = c * (t(n, c-1) + n) + n = ...\n                     # = c! * t(n, 0) + n * c! * (c + 1) * (1/0! + 1/1! + ... 1/c!)\n                     # = n * c! + n * c! * (c + 1) * O(e) = O(c * n * c!)\n                    is_win = not self.canWin(s[:i] + '--' + s[i+2:])    # O(n) space\n                    i += 1\n            i += 1\n        return is_win\n\n"
    },
    {
        "problem_name": "flip-game",
        "solution": "# Time:  O(c * n + n) = O(n * (c+1))\n# Space: O(n)\n\nclass Solution(object):\n    def generatePossibleNextMoves(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        i, n = 0, len(s) - 1\n        while i < n:                                    # O(n) time\n            if s[i] == '+':\n                while i < n and s[i+1] == '+':          # O(c) time\n                    res.append(s[:i] + '--' + s[i+2:])  # O(n) time and space\n                    i += 1\n            i += 1\n        return res\n\n\n# Time:  O(c * m * n + n) = O(c * n + n), where m = 2 in this question\n# Space: O(n)\n# This solution compares O(m) = O(2) times for two consecutive \"+\", where m is length of the pattern\nclass Solution2(object):\n  def generatePossibleNextMoves(self, s):\n      \"\"\"\n      :type s: str\n      :rtype: List[str]\n      \"\"\"\n      return [s[:i] + \"--\" + s[i+2:] for i in xrange(len(s) - 1) if s[i:i+2] == \"++\"]\n\n\n"
    },
    {
        "problem_name": "flip-string-to-monotone-increasing",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minFlipsMonoIncr(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        flip0, flip1 = 0, 0\n        for c in S:\n            flip0 += int(c == '1')\n            flip1 = min(flip0, flip1 + int(c == '0'))\n        return flip1\n"
    },
    {
        "problem_name": "flipping-an-image",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n\nclass Solution(object):\n    def flipAndInvertImage(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        for row in A:\n            for i in xrange((len(row)+1) // 2):\n                row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1\n        return A\n\n"
    },
    {
        "problem_name": "flood-fill",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nclass Solution(object):\n    def floodFill(self, image, sr, sc, newColor):\n        \"\"\"\n        :type image: List[List[int]]\n        :type sr: int\n        :type sc: int\n        :type newColor: int\n        :rtype: List[List[int]]\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def dfs(image, r, c, newColor, color):\n            if not (0 <= r < len(image) and \\\n                    0 <= c < len(image[0]) and \\\n                    image[r][c] == color):\n                return\n\n            image[r][c] = newColor\n            for d in directions:\n                dfs(image, r+d[0], c+d[1], newColor, color)\n\n        color = image[sr][sc]\n        if color == newColor: return image\n        dfs(image, sr, sc, newColor, color)\n        return image\n\n"
    },
    {
        "problem_name": "flower-planting-with-no-adjacent",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def gardenNoAdj(self, N, paths):\n        \"\"\"\n        :type N: int\n        :type paths: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*N\n        G = [[] for i in xrange(N)]\n        for x, y in paths:\n            G[x-1].append(y-1)\n            G[y-1].append(x-1)\n        for i in xrange(N):\n            result[i] = ({1, 2, 3, 4} - {result[j] for j in G[i]}).pop()\n        return result\n"
    },
    {
        "problem_name": "form-array-by-concatenating-subarrays-of-another-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def canChoose(self, groups, nums):\n        \"\"\"\n        :type groups: List[List[int]]\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j+1 > 0 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n        \n        def KMP(text, pattern, start):\n            prefix = getPrefix(pattern)\n            j = -1\n            for i in xrange(start, len(text)):\n                while j+1 > 0 and pattern[j+1] != text[i]:\n                    j = prefix[j]\n                if pattern[j+1] == text[i]:\n                    j += 1\n                if j+1 == len(pattern):\n                    return i-j\n            return -1\n\n        pos = 0\n        for group in groups:\n            pos = KMP(nums, group, pos)\n            if pos == -1:\n                return False\n            pos += len(group)\n        return True\n\n"
    },
    {
        "problem_name": "form-largest-integer-with-digits-that-add-up-to-target",
        "solution": "# Time:  O(t)\n# Space: O(t)\n\nclass Solution(object):\n    def largestNumber(self, cost, target):\n        \"\"\"\n        :type cost: List[int]\n        :type target: int\n        :rtype: str\n        \"\"\"\n        dp = [0]\n        for t in xrange(1, target+1):\n            dp.append(-1)\n            for i, c in enumerate(cost):\n                if t-c < 0 or dp[t-c] < 0:\n                    continue\n                dp[t] = max(dp[t], dp[t-c]+1)\n        if dp[target] < 0:\n            return \"0\"\n        result = []\n        for i in reversed(xrange(9)):\n            while target >= cost[i] and dp[target] == dp[target-cost[i]]+1:\n                target -= cost[i]\n                result.append(i+1)\n        return \"\".join(map(str, result))\n\n\n# Time:  O(t)\n# Space: O(t)\nclass Solution2(object):\n    def largestNumber(self, cost, target):\n        \"\"\"\n        :type cost: List[int]\n        :type target: int\n        :rtype: str\n        \"\"\"\n        def key(bag):\n            return sum(bag), bag\n        \n        dp = [[0]*9]\n        for t in xrange(1, target+1):\n            dp.append([])\n            for d, c in enumerate(cost):\n                if t < c or not dp[t-c]:\n                    continue\n                curr = dp[t-c][:]\n                curr[~d] += 1\n                if key(curr) > key(dp[t]):\n                    dp[-1] = curr        \n        if not dp[-1]:\n            return \"0\"\n        return \"\".join(str(9-i)*c for i, c in enumerate(dp[-1]))\n\n\n# Time:  O(t^2)\n# Space: O(t^2)\nclass Solution3(object):\n    def largestNumber(self, cost, target):\n        \"\"\"\n        :type cost: List[int]\n        :type target: int\n        :rtype: str\n        \"\"\"\n        dp = [0]\n        for t in xrange(1, target+1):\n            dp.append(-1)\n            for i, c in enumerate(cost):\n                if t-c < 0:\n                    continue\n                dp[t] = max(dp[t], dp[t-c]*10 + i+1)\n        return str(max(dp[t], 0))\n"
    },
    {
        "problem_name": "form-smallest-number-from-two-digit-arrays",
        "solution": "# Time:  O(m + n)\n# Space: O(m + n)\n\n# hash table\nclass Solution(object):\n    def minNumber(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        common = set(nums1)&set(nums2)\n        if common:\n            return min(common)\n        mn1, mn2 = min(nums1), min(nums2)\n        if mn1 > mn2:\n            mn1, mn2 = mn2, mn1\n        return 10*mn1+mn2\n"
    },
    {
        "problem_name": "four-divisors",
        "solution": "# Time:  O(n * sqrt(n))\n# Space: O(1)\n\nclass Solution(object):\n    def sumFourDivisors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for num in nums:\n            facs, i = [], 1\n            while i*i <= num:\n                if num % i:\n                    i+= 1\n                    continue\n                facs.append(i)\n                if i != num//i:\n                    facs.append(num//i)\n                    if len(facs) > 4:\n                        break\n                i += 1\n            if len(facs) == 4:            \n                result += sum(facs)\n        return result \n\n\n# Time:  O(n * sqrt(n))\n# Space: O(sqrt(n))\nimport itertools\n\n\nclass Solution2(object):\n    def sumFourDivisors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def factorize(x):\n            result = []\n            d = 2\n            while d*d <= x:\n                e = 0\n                while x%d == 0:\n                    x //= d\n                    e += 1\n                if e:\n                    result.append([d, e])\n                d += 1 if d == 2 else 2\n            if x > 1:\n                result.append([x, 1])\n            return result\n       \n        result = 0\n        for facs in itertools.imap(factorize, nums):\n            if len(facs) == 1 and facs[0][1] == 3:\n                p = facs[0][0]\n                result += (p**4-1)//(p-1)  # p^0 + p^1 +p^2 +p^3\n            elif len(facs) == 2 and facs[0][1] == facs[1][1] == 1:\n                p, q = facs[0][0], facs[1][0]\n                result += (1 + p) * (1 + q)\n        return result\n"
    },
    {
        "problem_name": "fraction-addition-and-subtraction",
        "solution": "# Time:  O(nlogx), x is the max denominator\n# Space: O(n)\n\nimport re\n\n\nclass Solution(object):\n    def fractionAddition(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: str\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        ints = map(int, re.findall('[+-]?\\d+', expression))\n        A, B = 0, 1\n        for i in xrange(0, len(ints), 2):\n            a, b = ints[i], ints[i+1]\n            A = A * b + a * B\n            B *= b\n            g = gcd(A, B)\n            A //= g\n            B //= g\n        return '%d/%d' % (A, B)\n\n"
    },
    {
        "problem_name": "fraction-to-recurring-decimal",
        "solution": "# Time:  O(logn), where logn is the length of result strings\n# Space: O(1)\n\nclass Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        result = \"\"\n        if (numerator > 0 and denominator < 0) or (numerator < 0 and denominator > 0):\n            result = \"-\"\n\n        dvd, dvs = abs(numerator), abs(denominator)\n        result += str(dvd / dvs)\n        dvd %= dvs\n\n        if dvd > 0:\n            result += \".\"\n\n        lookup = {}\n        while dvd and dvd not in lookup:\n            lookup[dvd] = len(result)\n            dvd *= 10\n            result += str(dvd / dvs)\n            dvd %= dvs\n\n        if dvd in lookup:\n            result = result[:lookup[dvd]] + \"(\" + result[lookup[dvd]:] + \")\"\n\n        return result\n\n\n"
    },
    {
        "problem_name": "freedom-trail",
        "solution": "# Time:  O(k) ~ O(k * r^2)\n# Space: O(r)\n\nimport collections\n\n\nclass Solution(object):\n    def findRotateSteps(self, ring, key):\n        \"\"\"\n        :type ring: str\n        :type key: str\n        :rtype: int\n        \"\"\"\n        lookup = collections.defaultdict(list)\n        for i in xrange(len(ring)):\n            lookup[ring[i]].append(i)\n\n        dp = [[0] * len(ring) for _ in xrange(2)]\n        prev = [0]\n        for i in xrange(1, len(key)+1):\n            dp[i%2] = [float(\"inf\")] * len(ring)\n            for j in lookup[key[i-1]]:\n                for k in prev:\n                    dp[i%2][j] = min(dp[i%2][j],\n                                     min((k+len(ring)-j) % len(ring), \\\n                                         (j+len(ring)-k) % len(ring)) + \\\n                                     dp[(i-1) % 2][k])\n            prev = lookup[key[i-1]]\n        return min(dp[len(key)%2]) + len(key)\n\n"
    },
    {
        "problem_name": "frequency-of-the-most-frequent-element",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def maxFrequency(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        left = 0\n        nums.sort()\n        for right in xrange(len(nums)):\n            k += nums[right]\n            if k < nums[right]*(right-left+1):\n                k -= nums[left]\n                left += 1\n        return right-left+1\n"
    },
    {
        "problem_name": "frequency-tracker",
        "solution": "# Time:  ctor:         O(1)\n#        add:          O(1)\n#        deleteOne:    O(1)\n#        hasFrequency: O(1)\n# Space: O(min(n, r))\n\n# freq table\nclass FrequencyTracker(object):\n\n    def __init__(self):\n        self.__cnt = collections.Counter()\n        self.__freq = collections.Counter()\n\n    def add(self, number):\n        \"\"\"\n        :type number: int\n        :rtype: None\n        \"\"\"\n        self.__freq[self.__cnt[number]] -= 1\n        if self.__freq[self.__cnt[number]] == 0:\n            del self.__freq[self.__cnt[number]]\n        self.__cnt[number] += 1\n        self.__freq[self.__cnt[number]] += 1\n        \n\n    def deleteOne(self, number):\n        \"\"\"\n        :type number: int\n        :rtype: None\n        \"\"\"\n        if self.__cnt[number] == 0:\n            return\n        self.__freq[self.__cnt[number]] -= 1\n        if self.__freq[self.__cnt[number]] == 0:\n            del self.__freq[self.__cnt[number]]\n        self.__cnt[number] -= 1\n        self.__freq[self.__cnt[number]] += 1\n        if self.__cnt[number] == 0:\n            del self.__cnt[number]\n        \n\n    def hasFrequency(self, frequency):\n        \"\"\"\n        :type frequency: int\n        :rtype: bool\n        \"\"\"\n        return frequency in self.__freq\n"
    },
    {
        "problem_name": "friend-circles",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def findCircleNum(self, M):\n        \"\"\"\n        :type M: List[List[int]]\n        :rtype: int\n        \"\"\"\n\n        class UnionFind(object):\n            def __init__(self, n):\n                self.set = range(n)\n                self.count = n\n\n            def find_set(self, x):\n               if self.set[x] != x:\n                   self.set[x] = self.find_set(self.set[x])  # path compression.\n               return self.set[x]\n\n            def union_set(self, x, y):\n                x_root, y_root = map(self.find_set, (x, y))\n                if x_root != y_root:\n                    self.set[min(x_root, y_root)] = max(x_root, y_root)\n                    self.count -= 1\n\n        circles = UnionFind(len(M))\n        for i in xrange(len(M)):\n            for j in xrange(len(M)):\n                if M[i][j] and i != j:\n                    circles.union_set(i, j)\n        return circles.count\n\n\n"
    },
    {
        "problem_name": "friends-of-appropriate-ages",
        "solution": "# Time:  O(a^2 + n), a is the number of ages,\n#                    n is the number of people\n# Space: O(a)\n\nimport collections\n\n\nclass Solution(object):\n    def numFriendRequests(self, ages):\n        \"\"\"\n        :type ages: List[int]\n        :rtype: int\n        \"\"\"\n        def request(a, b):\n            return 0.5*a+7 < b <= a\n\n        c = collections.Counter(ages)\n        return sum(int(request(a, b)) * c[a]*(c[b]-int(a == b))\n                   for a in c\n                   for b in c)\n\n"
    },
    {
        "problem_name": "frog-jump-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def maxJump(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: int\n        \"\"\"\n        return stones[1]-stones[0] if len(stones) == 2 else max(stones[i+2]-stones[i] for i in xrange(len(stones)-2))\n"
    },
    {
        "problem_name": "frog-jump",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nclass Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        if stones[1] != 1:\n            return False\n\n        last_jump_units = {s: set() for s in stones}\n        last_jump_units[1].add(1)\n        for s in stones[:-1]:\n            for j in last_jump_units[s]:\n                for k in (j-1, j, j+1):\n                    if k > 0 and s+k in last_jump_units:\n                        last_jump_units[s+k].add(k)\n        return bool(last_jump_units[stones[-1]])\n\n"
    },
    {
        "problem_name": "frog-position-after-t-seconds",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# bfs solution with better precision\nclass Solution(object):\n    def frogPosition(self, n, edges, t, target):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type t: int\n        :type target: int\n        :rtype: float\n        \"\"\"                \n        G = collections.defaultdict(list)\n        for u, v in edges:\n            G[u].append(v)\n            G[v].append(u)\n\n        stk = [(t, 1, 0, 1)]\n        while stk:\n            new_stk = []\n            while stk:\n                t, node, parent, choices = stk.pop()\n                if not t or not (len(G[node])-(parent != 0)):\n                    if node == target:\n                        return 1.0/choices\n                    continue\n                for child in G[node]:\n                    if child == parent:\n                        continue\n                    new_stk.append((t-1, child, node,\n                                    choices*(len(G[node])-(parent != 0))))\n            stk = new_stk\n        return 0.0\n\n\n# Time:  O(n)\n# Space: O(n)\n# dfs solution with stack with better precision\nclass Solution2(object):\n    def frogPosition(self, n, edges, t, target):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type t: int\n        :type target: int\n        :rtype: float\n        \"\"\"                \n        G = collections.defaultdict(list)\n        for u, v in edges:\n            G[u].append(v)\n            G[v].append(u)\n\n        stk = [(t, 1, 0, 1)]\n        while stk:\n            t, node, parent, choices = stk.pop()\n            if not t or not (len(G[node])-(parent != 0)):\n                if node == target:\n                    return 1.0/choices\n                continue\n            for child in G[node]:\n                if child == parent:\n                    continue\n                stk.append((t-1, child, node,\n                            choices*(len(G[node])-(parent != 0))))\n        return 0.0\n\n\n# Time:  O(n)\n# Space: O(n)\n# dfs solution with recursion with better precision\nclass Solution3(object):\n    def frogPosition(self, n, edges, t, target):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type t: int\n        :type target: int\n        :rtype: float\n        \"\"\"        \n        def dfs(G, target, t, node, parent):\n            if not t or not (len(G[node])-(parent != 0)):\n                return int(node == target)\n            result = 0\n            for child in G[node]:\n                if child == parent:\n                    continue\n                result = dfs(G, target, t-1, child, node)\n                if result:\n                    break\n            return result*(len(G[node])-(parent != 0))\n        \n        G = collections.defaultdict(list)\n        for u, v in edges:\n            G[u].append(v)\n            G[v].append(u)\n        choices = dfs(G, target, t, 1, 0)\n        return 1.0/choices if choices else 0.0\n\n\n# Time:  O(n)\n# Space: O(n)\n# dfs solution with recursion\nclass Solution4(object):\n    def frogPosition(self, n, edges, t, target):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type t: int\n        :type target: int\n        :rtype: float\n        \"\"\"        \n        def dfs(G, target, t, node, parent):\n            if not t or not (len(G[node])-(parent != 0)):\n                return float(node == target)\n            for child in G[node]:\n                if child == parent:\n                    continue\n                result = dfs(G, target, t-1, child, node)\n                if result:\n                    break\n            return result/(len(G[node])-(parent != 0))\n        \n        G = collections.defaultdict(list)\n        for u, v in edges:\n            G[u].append(v)\n            G[v].append(u)\n        return dfs(G, target, t, 1, 0)\n"
    },
    {
        "problem_name": "fruit-into-baskets",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def totalFruit(self, tree):\n        \"\"\"\n        :type tree: List[int]\n        :rtype: int\n        \"\"\"\n        count = collections.defaultdict(int)\n        result, i = 0, 0\n        for j, v in enumerate(tree):\n            count[v] += 1\n            while len(count) > 2:\n                count[tree[i]] -= 1\n                if count[tree[i]] == 0:\n                    del count[tree[i]]\n                i += 1\n            result = max(result, j-i+1)\n        return result\n \n\n"
    },
    {
        "problem_name": "furthest-building-you-can-reach",
        "solution": "# Time:  O(nlogk)\n# Space: O(k)\n\nimport heapq\n\n\nclass Solution(object):\n    def furthestBuilding(self, heights, bricks, ladders):\n        \"\"\"\n        :type heights: List[int]\n        :type bricks: int\n        :type ladders: int\n        :rtype: int\n        \"\"\"\n        min_heap = []\n        for i in xrange(len(heights)-1):\n            diff = heights[i+1]-heights[i]\n            if diff > 0:\n                heapq.heappush(min_heap, diff)\n            if len(min_heap) <= ladders:  # ladders are reserved for largest diffs\n                continue\n            bricks -= heapq.heappop(min_heap)  # use bricks if ladders are not enough\n            if bricks < 0:  # not enough bricks\n                return i\n        return len(heights)-1\n"
    },
    {
        "problem_name": "furthest-point-from-origin",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def furthestDistanceFromOrigin(self, moves):\n        \"\"\"\n        :type moves: str\n        :rtype: int\n        \"\"\"\n        curr = cnt = 0\n        for x in moves:\n            if x == 'L':\n                curr -= 1\n            elif x == 'R':\n                curr += 1\n            else:\n                cnt += 1\n        return abs(curr)+cnt\n"
    },
    {
        "problem_name": "game-of-life",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def gameOfLife(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: void Do not return anything, modify board in-place instead.\n        \"\"\"\n        m = len(board)\n        n = len(board[0]) if m else 0\n        for i in xrange(m):\n            for j in xrange(n):\n                count = 0\n                ## Count live cells in 3x3 block.\n                for I in xrange(max(i-1, 0), min(i+2, m)):\n                    for J in xrange(max(j-1, 0), min(j+2, n)):\n                        count += board[I][J] & 1\n\n                # if (count == 4 && board[i][j]) means:\n                #     Any live cell with three live neighbors lives.\n                # if (count == 3) means:\n                #     Any live cell with two live neighbors.\n                #     Any dead cell with exactly three live neighbors lives.\n                if (count == 4 and board[i][j]) or count == 3:\n                    board[i][j] |= 2  # Mark as live.\n\n        for i in xrange(m):\n            for j in xrange(n):\n                board[i][j] >>= 1  # Update to the next state.\n\n"
    },
    {
        "problem_name": "game-of-nim",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport operator\n\n\nclass Solution(object):\n    def nimGame(self, piles):\n        \"\"\"\n        :type piles: List[int]\n        :rtype: bool\n        \"\"\"\n        return reduce(operator.xor, piles, 0)\n"
    },
    {
        "problem_name": "gas-station",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param gas, a list of integers\n    # @param cost, a list of integers\n    # @return an integer\n    def canCompleteCircuit(self, gas, cost):\n        start, total_sum, current_sum = 0, 0, 0\n        for i in xrange(len(gas)):\n            diff = gas[i] - cost[i]\n            current_sum += diff\n            total_sum += diff\n            if current_sum < 0:\n                start = i + 1\n                current_sum = 0\n        if total_sum >= 0:\n            return start\n\n        return -1\n\n"
    },
    {
        "problem_name": "gcd-sort-of-an-array",
        "solution": "# Time:  O(nlogn + n * \u03b1(n) + m * log(logm)) ~= O(nlogn + m), m is the max of nums\n# Space: O(n + m)\n\nimport itertools\n\n\nclass UnionFind(object):  # Time: O(n * \u03b1(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:  # union by rank\n            self.set[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.set[y_root] = x_root\n        else:\n            self.set[y_root] = x_root\n            self.rank[x_root] += 1\n        return True\n\n\nclass Solution(object):\n    def gcdSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def modified_sieve_of_eratosthenes(n, lookup, uf):  # Time: O(n * log(logn)), Space: O(n)\n            if n < 2:\n                return\n            is_prime = [True]*(n+1)\n            for i in xrange(2, len(is_prime)):\n                if not is_prime[i]:\n                    continue\n                for j in xrange(i+i, len(is_prime), i):\n                    is_prime[j] = False\n                    if j in lookup:  # modified\n                        uf.union_set(i-1, j-1)\n\n        max_num = max(nums)\n        uf = UnionFind(max_num)\n        modified_sieve_of_eratosthenes(max_num, set(nums), uf)\n        return all(uf.find_set(a-1) == uf.find_set(b-1) for a, b in itertools.izip(nums, sorted(nums)))\n"
    },
    {
        "problem_name": "generalized-abbreviation",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(n)\n\nclass Solution(object):\n    def generateAbbreviations(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: List[str]\n        \"\"\"\n        def generateAbbreviationsHelper(word, i, cur, res):\n            if i == len(word):\n                res.append(\"\".join(cur))\n                return\n            cur.append(word[i])\n            generateAbbreviationsHelper(word, i + 1, cur, res)\n            cur.pop()\n            if not cur or not cur[-1][-1].isdigit():\n                for l in xrange(1, len(word) - i + 1):\n                    cur.append(str(l))\n                    generateAbbreviationsHelper(word, i + l, cur, res)\n                    cur.pop()\n\n        res, cur = [], []\n        generateAbbreviationsHelper(word, 0, cur, res)\n        return res\n\n\n"
    },
    {
        "problem_name": "generate-a-string-with-characters-that-have-odd-counts",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def generateTheString(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        result = ['a']*(n-1)\n        result.append('a' if n%2 else 'b')\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "generate-parentheses",
        "solution": "# Time:  O(4^n / n^(3/2)) ~= Catalan numbers\n# Space: O(n)\n\n# iterative solution\nclass Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result, curr = [], []\n        stk = [(1, (n, n))]\n        while stk:\n            step, args = stk.pop()\n            if step == 1:\n                left, right = args\n                if left == 0 and right == 0:\n                    result.append(\"\".join(curr))\n                if left < right:\n                    stk.append((3, tuple()))\n                    stk.append((1, (left, right-1)))\n                    stk.append((2, (')')))\n                if left > 0:\n                    stk.append((3, tuple()))\n                    stk.append((1, (left-1, right)))\n                    stk.append((2, ('(')))\n            elif step == 2:\n                curr.append(args[0])\n            elif step == 3:\n                curr.pop()\n        return result\n\n\n# Time:  O(4^n / n^(3/2)) ~= Catalan numbers\n# Space: O(n)\n# recursive solution\nclass Solution2(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        def generateParenthesisRecu(left, right, curr, result):\n            if left == 0 and right == 0:\n                result.append(\"\".join(curr))\n            if left > 0:\n                curr.append('(')\n                generateParenthesisRecu(left-1, right, curr, result)\n                curr.pop()\n            if left < right:\n                curr.append(')')\n                generateParenthesisRecu(left, right-1, curr, result)\n                curr.pop()\n\n        result = []\n        generateParenthesisRecu(n, n, [], result)\n        return result\n"
    },
    {
        "problem_name": "generate-random-point-in-a-circle",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nimport random\nimport math\n\nclass Solution(object):\n\n    def __init__(self, radius, x_center, y_center):\n        \"\"\"\n        :type radius: float\n        :type x_center: float\n        :type y_center: float\n        \"\"\"\n        self.__radius = radius\n        self.__x_center = x_center\n        self.__y_center = y_center\n        \n\n    def randPoint(self):\n        \"\"\"\n        :rtype: List[float]\n        \"\"\"\n        r = (self.__radius) * math.sqrt(random.uniform(0, 1))\n        theta = (2*math.pi) * random.uniform(0, 1)\n        return (r*math.cos(theta) + self.__x_center,\n                r*math.sin(theta) + self.__y_center)\n\n\n\n"
    },
    {
        "problem_name": "get-biggest-three-rhombus-sums-in-a-grid",
        "solution": "# Time:  O(m * n * min(m, n))\n# Space: O(m * n)\n\nimport heapq\n\n\nclass Solution(object):\n    def getBiggestThree(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\t\n        K = 3\n        left = [[grid[i][j] for j in xrange(len(grid[i]))] for i in xrange(len(grid))]\n        right = [[grid[i][j] for j in xrange(len(grid[i]))] for i in xrange(len(grid))]\n        for i in xrange(1, len(grid)):\n            for j in xrange(len(grid[0])-1):\n                left[i][j] += left[i-1][j+1]\n        for i in xrange(1, len(grid)):\n            for j in xrange(1, len(grid[0])):\n                right[i][j] += right[i-1][j-1]\n        min_heap = []\n        lookup = set()\n        for k in xrange((min(len(grid), len(grid[0]))+1)//2):\n            for i in xrange(k, len(grid)-k):\n                for j in xrange(k, len(grid[0])-k):\n                    total = (((left[i][j-k]-left[i-k][j])+(right[i][j+k]-right[i-k][j])+grid[i-k][j]) +  \n                             ((left[i+k][j]-left[i][j+k])+(right[i+k][j]-right[i][j-k])-grid[i+k][j])) if k else grid[i][j]\n                    if total in lookup:\n                        continue\n                    lookup.add(total)\n                    heapq.heappush(min_heap, total)\n                    if len(min_heap) == K+1:                        \n                        lookup.remove(heapq.heappop(min_heap))\n        min_heap.sort(reverse=True)\n        return min_heap\n"
    },
    {
        "problem_name": "get-equal-substrings-within-budget",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def equalSubstring(self, s, t, maxCost):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :type maxCost: int\n        :rtype: int\n        \"\"\"\n        left = 0\n        for right in xrange(len(s)):\n            maxCost -= abs(ord(s[right])-ord(t[right]))\n            if maxCost < 0:\n                maxCost += abs(ord(s[left])-ord(t[left]))\n                left += 1\n        return (right+1)-left\n"
    },
    {
        "problem_name": "get-maximum-in-generated-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nnums = [0, 1]\ndp = [0, 1]\nclass Solution(object):\n    def getMaximumGenerated(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n+1 > len(dp):\n            for i in xrange(len(nums), n+1):\n                if i%2 == 0:\n                    nums.append(nums[i//2])\n                else:\n                    nums.append(nums[i//2] + nums[i//2+1])\n                dp.append(max(dp[-1], nums[-1]))\n        return dp[n]\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def getMaximumGenerated(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        nums = [0]*(n+1)\n        nums[1] = 1\n        result = 1\n        for i in xrange(2, n+1):\n            if i%2 == 0:\n                nums[i] = nums[i//2]\n            else:\n                nums[i] = nums[i//2] + nums[i//2+1]\n            result = max(result, nums[i])\n        return result\n"
    },
    {
        "problem_name": "get-the-maximum-score",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxSum(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        i, j = 0, 0\n        result, sum1, sum2 = 0, 0, 0,\n        while i != len(nums1) or j != len(nums2):\n            if i != len(nums1) and (j == len(nums2) or nums1[i] < nums2[j]):\n                sum1 += nums1[i]\n                i += 1\n            elif j != len(nums2) and (i == len(nums1) or nums1[i] > nums2[j]):\n                sum2 += nums2[j]\n                j += 1\n            else:\n                result = (result + (max(sum1, sum2) + nums1[i])) % MOD\n                sum1, sum2 = 0, 0\n                i += 1\n                j += 1\n        return (result + max(sum1, sum2)) % MOD\n"
    },
    {
        "problem_name": "get-watched-videos-by-your-friends",
        "solution": "# Time:  O(n + vlogv), v is the number of the level videos\n# Space: O(w)\n\nimport collections\n\n\nclass Solution(object):\n    def watchedVideosByFriends(self, watchedVideos, friends, id, level):\n        \"\"\"\n        :type watchedVideos: List[List[str]]\n        :type friends: List[List[int]]\n        :type id: int\n        :type level: int\n        :rtype: List[str]\n        \"\"\"\n        curr_level, lookup = set([id]), set([id])\n        for _ in xrange(level):\n            curr_level = set(j for i in curr_level for j in friends[i] if j not in lookup)\n            lookup |= curr_level\n        count = collections.Counter([v for i in curr_level for v in watchedVideos[i]])\n        return sorted(count.keys(), key=lambda x: (count[x], x))\n"
    },
    {
        "problem_name": "global-and-local-inversions",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isIdealPermutation(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: bool\n        \"\"\"\n        return all(abs(v-i) <= 1 for i,v in enumerate(A))\n\n\n"
    },
    {
        "problem_name": "goal-parser-interpretation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def interpret(self, command):\n        \"\"\"\n        :type command: str\n        :rtype: str\n        \"\"\"\n        result, i = [], 0\n        while i < len(command):\n            if command[i] == 'G':\n                result += [\"G\"]\n                i += 1\n            elif command[i] == '(' and command[i+1] == ')':\n                result += [\"o\"]\n                i += 2\n            else:\n                result += [\"al\"]\n                i += 4\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "goat-latin",
        "solution": "# Time:  O(n + w^2), n = w * l,\n#                    n is the length of S,\n#                    w is the number of word,\n#                    l is the average length of word\n# Space: O(n)\n\nclass Solution(object):\n    def toGoatLatin(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        def convert(S):\n            vowel = set('aeiouAEIOU')\n            for i, word in enumerate(S.split(), 1):\n                if word[0] not in vowel:\n                    word = word[1:] + word[:1]\n                yield word + 'ma' + 'a'*i\n        return \" \".join(convert(S))\n\n"
    },
    {
        "problem_name": "graph-connectivity-with-threshold",
        "solution": "# Time:  O((nlogn + q) * \u03b1(n)) ~= O(nlogn + q)\n# Space: O(n)\n\nclass UnionFind(object):  # Time: O(n * \u03b1(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:  # union by rank\n            self.set[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.set[y_root] = x_root\n        else:\n            self.set[y_root] = x_root\n            self.rank[x_root] += 1\n        return True\n\n\nclass Solution(object):\n    def areConnected(self, n, threshold, queries):\n        \"\"\"\n        :type n: int\n        :type threshold: int\n        :type queries: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        union_find = UnionFind(n)\n        for i in xrange(threshold+1, n+1):\n            # https://stackoverflow.com/questions/25905118/finding-big-o-of-the-harmonic-series\n            # sum of harmonic series is O(logn)\n            for j in xrange(2*i, n+1, i):  # step by i\n                union_find.union_set(i-1, j-1)\n        return [union_find.find_set(q[0]-1) == union_find.find_set(q[1]-1) for q in queries]\n"
    },
    {
        "problem_name": "graph-valid-tree",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|V| + |E|)\n\nimport collections\n\n\n# BFS solution. Same complexity but faster version.\nclass Solution(object):\n    # @param {integer} n\n    # @param {integer[][]} edges\n    # @return {boolean}\n    def validTree(self, n, edges):\n        if len(edges) != n - 1:  # Check number of edges.\n            return False\n\n        # init node's neighbors in dict\n        neighbors = collections.defaultdict(list)\n        for u, v in edges:\n            neighbors[u].append(v)\n            neighbors[v].append(u)\n\n        # BFS to check whether the graph is valid tree.\n        q = collections.deque([0])\n        visited = set([0])\n        while q:\n            curr = q.popleft()\n            for node in neighbors[curr]:\n                if node not in visited:\n                    visited.add(node)\n                    q.append(node)\n\n        return len(visited) == n\n\n\n# Time:  O(|V| + |E|)\n# Space: O(|V| + |E|)\n# BFS solution.\nclass Solution2(object):\n    # @param {integer} n\n    # @param {integer[][]} edges\n    # @return {boolean}\n    def validTree(self, n, edges):\n        # A structure to track each node's [visited_from, neighbors]\n        visited_from = [-1] * n\n        neighbors = collections.defaultdict(list)\n        for u, v in edges:\n            neighbors[u].append(v)\n            neighbors[v].append(u)\n\n        # BFS to check whether the graph is valid tree.\n        q = collections.deque([0])\n        visited = set([0])\n        while q:\n            i = q.popleft()\n            for node in neighbors[i]:\n                if node != visited_from[i]:\n                    if node in visited:\n                        return False\n                    else:\n                        visited.add(node)\n                        visited_from[node] = i\n                        q.append(node)\n        return len(visited) == n\n\n"
    },
    {
        "problem_name": "gray-code",
        "solution": "# Time:  O(2^n)\n# Space: O(1)\n\nclass Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        result = [0]\n        for i in xrange(n):\n            for n in reversed(result):\n                result.append(1 << i | n)\n        return result\n\n\n# Proof of closed form formula could be found here:\n# http://math.stackexchange.com/questions/425894/proof-of-closed-form-formula-to-convert-a-binary-number-to-its-gray-code\nclass Solution2(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        return [i >> 1 ^ i for i in xrange(1 << n)]\n\n\n"
    },
    {
        "problem_name": "greatest-common-divisor-of-strings",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nclass Solution(object):\n    def gcdOfStrings(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        def check(s, common):\n            i = 0\n            for c in s:\n                if c != common[i]:\n                    return False\n                i = (i+1)%len(common)\n            return True\n    \n        def gcd(a, b):  # Time: O(log(min(a, b)))\n            while b:\n                a, b = b, a % b\n            return a\n        \n        if not str1 or not str2:\n            return \"\"\n        c = gcd(len(str1), len(str2))\n        result = str1[:c]\n        return result if check(str1, result) and check(str2, result) else \"\"\n"
    },
    {
        "problem_name": "greatest-common-divisor-traversal",
        "solution": "# Time:  precompute: O(sqrt(r)), r = max(nums)\n#        runtime:    O(n * (logr + pi(sqrt(r))) = O(n * (logr + sqrt(r)/log(sqrt(r)))), pi(n) = number of primes in a range [1, n] = O(n/logn) by prime number theorem, see https://en.wikipedia.org/wiki/Prime_number_theorem\n# Space: O(sqrt(r) + nlogr)\n\n# linear sieve of eratosthenes, number theory, bfs\ndef linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)\n    primes = []\n    spf = [-1]*(n+1)  # the smallest prime factor\n    for i in xrange(2, n+1):\n        if spf[i] == -1:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if i*p > n or p > spf[i]:\n                break\n            spf[i*p] = p\n    return primes\n\n\nMAX_NUM = 10**5\nPRIMES = linear_sieve_of_eratosthenes(int(MAX_NUM**0.5))\nclass Solution(object):\n    def canTraverseAllPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def prime_factors(x):\n            factors = collections.Counter()\n            for p in PRIMES:\n                if p*p > x:\n                    break\n                while x%p == 0:\n                    factors[p] += 1\n                    x //= p\n            if x != 1:\n                factors[x] += 1\n            return factors\n\n        def bfs():\n            lookup = [False]*len(nums)\n            lookup[0] = True\n            q = [0]\n            while q:\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if lookup[v]:\n                            continue\n                        lookup[v] = True\n                        new_q.append(v)\n                q = new_q\n            return all(lookup)\n\n        adj = [[] for _ in xrange(len(nums))]\n        lookup = {}\n        for i, x in enumerate(nums):\n            for p in prime_factors(x):\n                if p not in lookup:\n                    lookup[p] = i\n                    continue\n                adj[i].append(lookup[p])\n                adj[lookup[p]].append(i)\n        return bfs()\n"
    },
    {
        "problem_name": "greatest-english-letter-in-upper-and-lower-case",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string, hash table\nclass Solution(object):\n    def greatestLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        lookup = set(s)\n        result = \"\"\n        for c in s:\n            if c.isupper() and lower(c) in s:\n                if c > result:\n                    result = c\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\nimport itertools\nimport string\n\n\n# string, hash table\nclass Solution2(object):\n    def greatestLetter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        lookup = set(s)\n        return next((C for c, C in itertools.izip(reversed(string.ascii_lowercase), reversed(string.ascii_uppercase)) if c in lookup and C in lookup), \"\")\n   \n"
    },
    {
        "problem_name": "greatest-sum-divisible-by-three",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxSumDivThree(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [0, 0, 0]\n        for num in nums:\n            for i in [num+x for x in dp]:\n                dp[i%3] = max(dp[i%3], i)\n        return dp[0]\n"
    },
    {
        "problem_name": "grid-game",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def gridGame(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result = float(\"inf\")\n        left, right = 0, sum(grid[0])\n        for a, b in itertools.izip(grid[0], grid[1]):\n            right -= a\n            result = min(result, max(left, right))\n            left += b\n        return result\n"
    },
    {
        "problem_name": "grid-illumination",
        "solution": "# Time:  O(l + q)\n# Space: O(l)\n\nimport collections\n\n\nclass Solution(object):\n    def gridIllumination(self, N, lamps, queries):\n        \"\"\"\n        :type N: int\n        :type lamps: List[List[int]]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        lookup = set()\n        row = collections.defaultdict(int)\n        col = collections.defaultdict(int)\n        diag = collections.defaultdict(int)\n        anti = collections.defaultdict(int)\n        \n        for r, c in lamps:\n            if (r, c) in lookup:\n                continue\n            lookup.add((r, c))\n            row[r] += 1\n            col[c] += 1\n            diag[r-c] += 1\n            anti[r+c] += 1\n        \n        result = []\n        for r, c in queries:\n            if not (row[r] or col[c] or diag[r-c] or anti[r+c]):\n                result.append(0)\n                continue\n            result.append(1)                \n            for nr in xrange(max(r-1, 0), min(r+1, N-1)+1):\n                for nc in xrange(max(c-1, 0), min(c+1, N-1)+1):\n                    if (nr, nc) not in lookup:\n                        continue\n                    lookup.remove((nr, nc))\n                    row[nr] -= 1\n                    col[nc] -= 1\n                    diag[nr-nc] -= 1\n                    anti[nr+nc] -= 1\n        return result\n"
    },
    {
        "problem_name": "group-anagrams",
        "solution": "# Time:  O(n * glogg), g is the max size of groups.\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams_map, result = collections.defaultdict(list), []\n        for s in strs:\n            sorted_str = (\"\").join(sorted(s))\n            anagrams_map[sorted_str].append(s)\n        for anagram in anagrams_map.values():\n            anagram.sort()\n            result.append(anagram)\n        return result\n\n\n"
    },
    {
        "problem_name": "group-shifted-strings",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    # @param {string[]} strings\n    # @return {string[][]}\n    def groupStrings(self, strings):\n        groups = collections.defaultdict(list)\n        for s in strings:  # Grouping.\n            groups[self.hashStr(s)].append(s)\n\n        result = []\n        for key, val in groups.iteritems():\n            result.append(sorted(val))\n\n        return result\n\n    def hashStr(self, s):\n        base = ord(s[0])\n        hashcode = \"\"\n        for i in xrange(len(s)):\n            if ord(s[i]) - base >= 0:\n                hashcode += unichr(ord('a') + ord(s[i]) - base)\n            else:\n                hashcode += unichr(ord('a') + ord(s[i]) - base + 26)\n        return hashcode\n\n"
    },
    {
        "problem_name": "group-the-people-given-the-group-size-they-belong-to",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def groupThePeople(self, groupSizes):\n        \"\"\"\n        :type groupSizes: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        groups, result = collections.defaultdict(list), []\n        for i, size in enumerate(groupSizes):\n            groups[size].append(i)\n            if len(groups[size]) == size:\n                result.append(groups.pop(size))\n        return result\n"
    },
    {
        "problem_name": "groups-of-special-equivalent-strings",
        "solution": "# Time:  O(n * l)\n# Space: O(n)\n\nclass Solution(object):\n    def numSpecialEquivGroups(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: int\n        \"\"\"\n        def count(word):\n            result = [0]*52\n            for i, letter in enumerate(word):\n                result[ord(letter)-ord('a') + 26*(i%2)] += 1\n            return tuple(result)\n\n        return len({count(word) for word in A})\n\n"
    },
    {
        "problem_name": "groups-of-strings",
        "solution": "# Time:  O(26 * n)\n# Space: O(26 * n)\n\nclass UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n        self.size = [1]*n\n        self.total = n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x, y = self.find_set(x), self.find_set(y)\n        if x == y:\n            return False\n        if self.rank[x] > self.rank[y]:  # union by rank\n            x, y = y, x\n        self.set[x] = self.set[y]\n        if self.rank[x] == self.rank[y]:\n            self.rank[y] += 1\n        self.size[y] += self.size[x]\n        self.total -= 1\n        return True\n\n\n# bitmasks, union find\nclass Solution(object):\n    def groupStrings(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        uf = UnionFind(len(words))\n        lookup = {}\n        for i, x in enumerate(words):\n            mask = reduce(lambda x, y: x|(1<<(ord(y)-ord('a'))), x, 0)\n            if mask not in lookup:\n                lookup[mask] = i\n            uf.union_set(i, lookup[mask])\n            bit = 1\n            while bit <= mask:\n                if mask&bit:\n                    if mask^bit not in lookup:\n                        lookup[mask^bit] = i\n                    uf.union_set(i, lookup[mask^bit])\n                bit <<= 1\n        return [uf.total, max(uf.size)]\n"
    },
    {
        "problem_name": "grumpy-bookstore-owner",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxSatisfied(self, customers, grumpy, X):\n        \"\"\"\n        :type customers: List[int]\n        :type grumpy: List[int]\n        :type X: int\n        :rtype: int\n        \"\"\"\n        result, max_extra, extra = 0, 0, 0\n        for i in xrange(len(customers)):\n            result += 0 if grumpy[i] else customers[i]\n            extra += customers[i] if grumpy[i] else 0\n            if i >= X:\n                extra -= customers[i-X] if grumpy[i-X] else 0\n            max_extra = max(max_extra, extra)\n        return result + max_extra\n"
    },
    {
        "problem_name": "guess-number-higher-or-lower-ii",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\nclass Solution(object):\n    def getMoneyAmount(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [[0]*(n+1) for _ in xrange(n+1)]  # dp[i][j]: min pay in [i+1, j+1)\n        for j in xrange(n+1):\n            for i in reversed(xrange(j-1)):\n                dp[i][j] = min((k+1) + max(dp[i][k], dp[k+1][j]) for k in xrange(i, j))\n        return dp[0][n]\n\n\n# Time:  O(n^3)\n# Space: O(n^2)\nclass Solution2(object):\n    def getMoneyAmount(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [[0]*(n+1) for _ in xrange(n+1)]  # dp[i][j]: min pay in [i+1, j+1)\n        for i in reversed(xrange(n)):\n            for j in xrange(i+2, n+1):\n                dp[i][j] = min((k+1) + max(dp[i][k], dp[k+1][j]) for k in xrange(i, j))\n        return dp[0][n]\n"
    },
    {
        "problem_name": "guess-number-higher-or-lower",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def guessNumber(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) / 2\n            if guess(mid) <= 0: # noqa\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n"
    },
    {
        "problem_name": "guess-the-majority-in-a-hidden-array",
        "solution": "# Time:  O(n), n queries\n# Space: O(1)\n\nclass ArrayReader(object):\n    def query(self, a, b, c, d):\n        \"\"\"\n        :type a, b, c, d: int\n        :rtype int\n        \"\"\"\n        pass\n\n    def length(self):\n        \"\"\"\n        :rtype int\n        \"\"\"\n        pass\n    \n\nclass Solution(object):\n    def guessMajority(self, reader):\n        \"\"\"\n        :type reader: ArrayReader\n        :rtype: integer\n        \"\"\"\n        count_a, count_b, idx_b = 1, 0, None\n        value_0_1_2_3 = reader.query(0, 1, 2, 3)\n        for i in reversed(xrange(4, reader.length())):\n            value_0_1_2_i = reader.query(0, 1, 2, i)\n            if value_0_1_2_i == value_0_1_2_3:  # nums[i] == nums[3]\n                count_a = count_a+1\n            else:\n                count_b, idx_b = count_b+1, i\n        value_0_1_2_4 = value_0_1_2_i\n        for i in xrange(3):\n            value_a_b_3_4 = reader.query(*[v for v in [0, 1, 2, 3, 4] if v != i])\n            if value_a_b_3_4 == value_0_1_2_4:  # nums[i] == nums[3]\n                count_a = count_a+1\n            else:\n                count_b, idx_b = count_b+1, i\n        if count_a == count_b:\n            return -1\n        return 3 if count_a > count_b else idx_b\n"
    },
    {
        "problem_name": "guess-the-number-using-bitwise-questions-i",
        "solution": "# Time:  O(logn):\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def findNumber(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return reduce(lambda accu, x: accu|x, (1<<i for i in xrange(30) if commonSetBits(1<<i)))\n"
    },
    {
        "problem_name": "guess-the-number-using-bitwise-questions-ii",
        "solution": "# Time:  O(logr)\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def findNumber(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        BIT_COUNT = 30\n        result = 0\n        prev = commonBits(0)\n        for i in xrange(BIT_COUNT):\n            curr = commonBits(1<<i)\n            if curr-prev == 1:\n                result |= 1<<i\n            prev = curr\n        return result\n\n\n# Time:  O(logr)\n# Space: O(1)\n# bit manipulation\nclass Solution2(object):\n    def findNumber(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        BIT_COUNT = 30\n        return reduce(lambda accu, i: accu|(1<<i if commonBits(1<<i)-commonBits(1<<i) == 1 else 0), xrange(BIT_COUNT), 0)\n"
    },
    {
        "problem_name": "guess-the-word",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\nimport itertools\n\n\nclass Solution(object):\n    def findSecretWord(self, wordlist, master):\n        \"\"\"\n        :type wordlist: List[Str]\n        :type master: Master\n        :rtype: None\n        \"\"\"\n        possible = range(len(wordlist))\n        n = 0\n        while n < 6:\n            count = [collections.Counter(w[i] for w in wordlist) for i in xrange(6)]\n            guess = max(possible, key=lambda x: sum(count[i][c] for i, c in enumerate(wordlist[x])))\n            n = master.guess(wordlist[guess])\n            possible = [j for j in possible if sum(a == b for a, b in itertools.izip(wordlist[guess], wordlist[j])) == n]\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution2(object):\n    def findSecretWord(self, wordlist, master):\n        \"\"\"\n        :type wordlist: List[Str]\n        :type master: Master\n        :rtype: None\n        \"\"\"\n        def solve(H, possible):\n            min_max_group, best_guess = possible, None\n            for guess in possible:\n                groups = [[] for _ in xrange(7)]\n                for j in possible:\n                    if j != guess:\n                        groups[H[guess][j]].append(j)\n                max_group = max(groups, key=len)\n                if len(max_group) < len(min_max_group):\n                    min_max_group, best_guess = max_group, guess\n            return best_guess\n\n        H = [[sum(a == b for a, b in itertools.izip(wordlist[i], wordlist[j]))\n                  for j in xrange(len(wordlist))]\n                  for i in xrange(len(wordlist))]\n        possible = range(len(wordlist))\n        n = 0\n        while n < 6:\n            guess = solve(H, possible)\n            n = master.guess(wordlist[guess])\n            possible = [j for j in possible if H[guess][j] == n]\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution3(object):\n    def findSecretWord(self, wordlist, master):\n        \"\"\"\n        :type wordlist: List[Str]\n        :type master: Master\n        :rtype: None\n        \"\"\"\n        def solve(H, possible):\n            min_max_group, best_guess = possible, None\n            for guess in possible:\n                groups = [[] for _ in xrange(7)]\n                for j in possible:\n                    if j != guess:\n                        groups[H[guess][j]].append(j)\n                max_group = groups[0]\n                if len(max_group) < len(min_max_group):\n                    min_max_group, best_guess = max_group, guess\n            return best_guess\n\n        H = [[sum(a == b for a, b in itertools.izip(wordlist[i], wordlist[j]))\n                  for j in xrange(len(wordlist))]\n                  for i in xrange(len(wordlist))]\n        possible = range(len(wordlist))\n        n = 0\n        while n < 6:\n            guess = solve(H, possible)\n            n = master.guess(wordlist[guess])\n            possible = [j for j in possible if H[guess][j] == n]\n\n"
    },
    {
        "problem_name": "h-index-ii",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def hIndex(self, citations):\n        \"\"\"\n        :type citations: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(citations)\n        left, right = 0, n - 1\n        while left <= right:\n            mid = (left + right) / 2\n            if citations[mid] >= n - mid:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return n - left\n\n"
    },
    {
        "problem_name": "h-index",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def hIndex(self, citations):\n        \"\"\"\n        :type citations: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(citations)\n        count = [0] * (n + 1)\n        for x in citations:\n            # Put all x >= n in the same bucket.\n            if x >= n:\n                count[n] += 1\n            else:\n                count[x] += 1\n\n        h = 0\n        for i in reversed(xrange(0, n + 1)):\n            h += count[i]\n            if h >= i:\n                return i\n        return h\n\n# Time:  O(nlogn)\n# Space: O(1)\nclass Solution2(object):\n    def hIndex(self, citations):\n        \"\"\"\n        :type citations: List[int]\n        :rtype: int\n        \"\"\"\n        citations.sort(reverse=True)\n        h = 0\n        for x in citations:\n            if x >= h + 1:\n                h += 1\n            else:\n                break\n        return h\n\n# Time:  O(nlogn)\n# Space: O(n)\nclass Solution3(object):\n    def hIndex(self, citations):\n        \"\"\"\n        :type citations: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(x >= i + 1 for i, x in enumerate(sorted(citations, reverse=True)))\n\n\n"
    },
    {
        "problem_name": "hamming-distance",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        distance = 0\n        z = x ^ y\n        while z:\n            distance += 1\n            z &= z - 1\n        return distance\n\n    def hammingDistance2(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        return bin(x ^ y).count('1')\n\n"
    },
    {
        "problem_name": "hand-of-straights",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nfrom collections import Counter\nfrom heapq import heapify, heappop\n\n\nclass Solution(object):\n    def isNStraightHand(self, hand, W):\n        \"\"\"\n        :type hand: List[int]\n        :type W: int\n        :rtype: bool\n        \"\"\"\n        if len(hand) % W:\n            return False\n\n        counts = Counter(hand)\n        min_heap = list(hand)\n        heapify(min_heap)\n        for _ in xrange(len(min_heap)//W):\n            while counts[min_heap[0]] == 0:\n                heappop(min_heap)\n            start = heappop(min_heap)\n            for _ in xrange(W):\n                counts[start] -= 1\n                if counts[start] < 0:\n                    return False\n                start += 1\n        return True\n"
    },
    {
        "problem_name": "handling-sum-queries-after-update",
        "solution": "# Time:  O(nlogn + m + qlogn)\n# Space: O(n)\n\n# segment tree\nclass Solution(object):\n    def handleQuery(self, nums1, nums2, queries):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        class SegmentTree(object):  # 0-based index\n            def __init__(self, N,\n                        build_fn=lambda _: 0,\n                        query_fn=lambda x, y: y if x is None else max(x, y),\n                        update_fn=lambda x, y: y if x is None else x+y):\n                self.base = N\n                self.H = (N-1).bit_length()\n                self.query_fn = query_fn\n                self.update_fn = update_fn\n                self.tree = [None]*(2*N)\n                self.lazy = [None]*N\n                for i in xrange(self.base, self.base+N):\n                    self.tree[i] = build_fn(i-self.base)\n                for i in reversed(xrange(1, self.base)):\n                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n\n            def __apply(self, x, val):\n                self.tree[x] = self.update_fn(self.tree[x], val)\n                if x < self.base:\n                    self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n            def update(self, L, R, h):  # Time: O(logN), Space: O(N)\n                def pull(x):\n                    while x > 1:\n                        x >>= 1\n                        self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])\n                        if self.lazy[x] is not None:\n                            self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\n\n                if L > R:\n                    return\n                L += self.base\n                R += self.base\n                L0, R0 = L, R\n                while L <= R:\n                    if L & 1:  # is right child\n                        self.__apply(L, h)\n                        L += 1\n                    if R & 1 == 0:  # is left child\n                        self.__apply(R, h)\n                        R -= 1\n                    L >>= 1\n                    R >>= 1\n                pull(L0)\n                pull(R0)\n\n            def query(self, L, R):  # Time: O(logN), Space: O(N)\n                def push(x):\n                    n = self.H\n                    while n:\n                        y = x >> n\n                        if self.lazy[y] is not None:\n                            self.__apply(y<<1, self.lazy[y])\n                            self.__apply((y<<1)+1, self.lazy[y])\n                            self.lazy[y] = None\n                        n -= 1\n\n                result = None\n                if L > R:\n                    return result\n\n                L += self.base\n                R += self.base\n                push(L)\n                push(R)\n                while L <= R:\n                    if L & 1:  # is right child\n                        result = self.query_fn(result, self.tree[L])\n                        L += 1\n                    if R & 1 == 0:  # is left child\n                        result = self.query_fn(result, self.tree[R])\n                        R -= 1\n                    L >>= 1\n                    R >>= 1\n                return result\n\n        st = SegmentTree(len(nums1),\n                         build_fn=lambda i: (nums1[i], nums1[i]^1),\n                         query_fn=lambda x, y: y if x is None else (x[0]+y[0], x[1]+y[1]),\n                         update_fn=lambda x, y: y if x is None else (x[1], x[0]) if y == (1, 0) else x)\n        result = []\n        total = sum(nums2)\n        for t, a, b in queries:\n            if t == 1:\n                st.update(a, b, (1, 0))\n            elif t == 2:\n                total += st.query(0, len(nums1)-1)[0]*a\n            elif t == 3:\n                result.append(total)\n        return result\n"
    },
    {
        "problem_name": "handshakes-that-dont-cross",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfWays(self, num_people):\n        \"\"\"\n        :type num_people: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def inv(x, m):  # Euler's Theorem\n            return pow(x, m-2, m)  # O(logMOD) = O(1)\n\n        def nCr(n, k, m):\n            if n-k < k:\n                return nCr(n, n-k, m)\n            result = 1\n            for i in xrange(1, k+1):\n                result = result*(n-k+i)*inv(i, m)%m\n            return result\n\n        n = num_people//2\n        return nCr(2*n, n, MOD)*inv(n+1, MOD) % MOD  # Catalan number\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution2(object):\n    def numberOfWays(self, num_people):\n        \"\"\"\n        :type num_people: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [0]*(num_people//2+1)\n        dp[0] = 1\n        for k in xrange(1, num_people//2+1):\n            for i in xrange(k):\n                dp[k] = (dp[k] + dp[i]*dp[k-1-i]) % MOD\n        return dp[num_people//2]\n"
    },
    {
        "problem_name": "happy-number",
        "solution": "# Time:  O(k), where k is the steps to be happy number\n# Space: O(k)\n\nclass Solution(object):\n    # @param {integer} n\n    # @return {boolean}\n    def isHappy(self, n):\n        lookup = {}\n        while n != 1 and n not in lookup:\n            lookup[n] = True\n            n = self.nextNumber(n)\n        return n == 1\n\n    def nextNumber(self, n):\n        new = 0\n        for char in str(n):\n            new += int(char)**2\n        return new\n\n"
    },
    {
        "problem_name": "happy-students",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# codeforce, https://codeforces.com/contest/1782/problem/B\n# freq table\nclass Solution(object):\n    def countWays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = [0]*(len(nums)+1)\n        for x in nums:\n            cnt[x] += 1\n        result = prefix = 0\n        for i in xrange(len(nums)+1):\n            if prefix == i and cnt[i] == 0:\n                result += 1\n            prefix += cnt[i]\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# codeforce, https://codeforces.com/contest/1782/problem/B\n# sort, greedy\nclass Solution2(object):\n    def countWays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return sum((i == 0 or nums[i-1] < i) and (i == len(nums) or nums[i] > i) for i in xrange(len(nums)+1))\n"
    },
    {
        "problem_name": "harshad-number",
        "solution": "# Time:  O(logx)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def sumOfTheDigitsOfHarshadNumber(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        y = x\n        while y:\n            y, r = divmod(y, 10)\n            result += r\n        return result if x%result == 0 else -1\n"
    },
    {
        "problem_name": "heaters",
        "solution": "# Time:  O((m + n) * logn), m is the number of the houses, n is the number of the heaters.\n# Space: O(1)\n\nimport bisect\n\n\nclass Solution(object):\n    def findRadius(self, houses, heaters):\n        \"\"\"\n        :type houses: List[int]\n        :type heaters: List[int]\n        :rtype: int\n        \"\"\"\n        heaters.sort()\n        min_radius = 0\n        for house in houses:\n        \tequal_or_larger = bisect.bisect_left(heaters, house)\n        \tcurr_radius = float(\"inf\")\n        \tif equal_or_larger != len(heaters):\n        \t    curr_radius = heaters[equal_or_larger] - house\n        \tif equal_or_larger != 0:\n        \t    smaller = equal_or_larger-1\n        \t    curr_radius = min(curr_radius, house - heaters[smaller])\n        \tmin_radius = max(min_radius, curr_radius)\n        return min_radius\n\n"
    },
    {
        "problem_name": "height-checker",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport itertools\n\n\nclass Solution(object):\n    def heightChecker(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(i != j for i, j in itertools.izip(heights, sorted(heights)))\n"
    },
    {
        "problem_name": "height-of-binary-tree-after-subtree-removal-queries",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\n# iterative dfs\nclass Solution(object):\n    def treeQueries(self, root, queries):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def iter_dfs(root):\n            top = collections.defaultdict(lambda: [0]*2)\n            depth, height = {}, {}\n            stk = [(1, (root, 0))]\n            while stk:\n                step, (curr, d) = stk.pop()\n                if step == 1:\n                    if not curr:\n                        continue\n                    stk.append((2, (curr, d)))\n                    stk.append((1, (curr.right, d+1)))\n                    stk.append((1, (curr.left, d+1)))\n                elif step == 2:\n                    h = 1+max((height[curr.left.val] if curr.left else 0), \n                              (height[curr.right.val] if curr.right else 0))\n                    if h > top[d][0]:\n                        top[d][0], top[d][1] = h, top[d][0]\n                    elif h > top[d][1]:\n                        top[d][1] = h\n                    depth[curr.val], height[curr.val] = d, h\n            return top, depth, height\n\n        top, depth, height = iter_dfs(root)\n        return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\n# dfs\nclass Solution2(object):\n    def treeQueries(self, root, queries):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def dfs(curr, d):\n            if not curr:\n                return 0\n            h = 1+max(dfs(curr.left, d+1), dfs(curr.right, d+1))\n            if h > top[d][0]:\n                top[d][0], top[d][1] = h, top[d][0]\n            elif h > top[d][1]:\n                top[d][1] = h\n            depth[curr.val], height[curr.val] = d, h\n            return h\n        \n        top = collections.defaultdict(lambda: [0]*2)\n        depth, height = {}, {}\n        dfs(root, 0)\n        return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries]\n"
    },
    {
        "problem_name": "height-of-special-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\n# dfs\nclass Solution(object):\n    def heightOfTree(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        result = -1\n        stk = [(root, 0)]\n        while stk:\n            u, d = stk.pop()\n            result = max(result, d)\n            if u.right and u.right.left != u:\n                stk.append((u.right, d+1))\n            if u.left and u.left.right != u:\n                stk.append((u.left, d+1))\n        return result\n\n\n# Time:  O(n)\n# Space: O(w)\n# bfs\nclass Solution2(object):\n    def heightOfTree(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        result = -1\n        q = [root]\n        while q:\n            new_q = []\n            for u in q:\n                if u.left and u.left.right != u:\n                    new_q.append(u.left)\n                if u.right and u.right.left != u:\n                    new_q.append(u.right)\n            q = new_q\n            result += 1\n        return result\n"
    },
    {
        "problem_name": "hexspeak",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def toHexspeak(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        lookup = {0:'O', 1:'I'}\n        for i in xrange(6):\n            lookup[10+i] = chr(ord('A')+i)\n        result = []\n        n = int(num)\n        while n:\n            n, r = divmod(n, 16)\n            if r not in lookup:\n                return \"ERROR\"\n            result.append(lookup[r])\n        return \"\".join(reversed(result))\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def toHexspeak(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        result = hex(int(num)).upper()[2:].replace('0', 'O').replace('1', 'I')\n        return result if all(c in \"ABCDEFOI\" for c in result) else \"ERROR\"\n"
    },
    {
        "problem_name": "high-access-employees",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\n# sort, two pointers, sliding window\nclass Solution(object):\n    def findHighAccessEmployees(self, access_times):\n        \"\"\"\n        :type access_times: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        LIMIT_COUNT = 2\n        LIMIT_MINUTE = 60\n        def to_minute(x):\n            return int(x[:2])*60+int(x[2:])\n    \n        lookup = collections.defaultdict(list)\n        for x, t in access_times:\n            lookup[x].append(to_minute(t))\n        result = []\n        for x, ts in lookup.iteritems():\n            ts.sort()\n            if not all(ts[i]+LIMIT_MINUTE <= ts[i+LIMIT_COUNT] for i in xrange(len(ts)-LIMIT_COUNT)):\n                result.append(x)\n        return result\n"
    },
    {
        "problem_name": "high-five",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\nimport heapq\n\n\nclass Solution(object):\n    def highFive(self, items):\n        \"\"\"\n        :type items: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        min_heaps = collections.defaultdict(list)\n        for i, val in items:\n            heapq.heappush(min_heaps[i], val)\n            if len(min_heaps[i]) > 5:\n                heapq.heappop(min_heaps[i])\n        return [[i, sum(min_heaps[i]) // len(min_heaps[i])] for i in sorted(min_heaps)]\n"
    },
    {
        "problem_name": "house-robber-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {integer[]} nums\n    # @return {integer}\n    def rob(self, nums):\n        if len(nums) == 0:\n            return 0\n\n        if len(nums) == 1:\n            return nums[0]\n\n        return max(self.robRange(nums, 0, len(nums) - 1),\\\n                   self.robRange(nums, 1, len(nums)))\n\n    def robRange(self, nums, start, end):\n        num_i, num_i_1 = nums[start], 0\n        for i in xrange(start + 1, end):\n            num_i_1, num_i_2 = num_i, num_i_1\n            num_i = max(nums[i] + num_i_2, num_i_1)\n\n        return num_i\n\n"
    },
    {
        "problem_name": "house-robber-iii",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def rob(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def robHelper(root):\n            if not root:\n                return (0, 0)\n            left, right = robHelper(root.left), robHelper(root.right)\n            return (root.val + left[1] + right[1], max(left) + max(right))\n\n        return max(robHelper(root))\n\n"
    },
    {
        "problem_name": "house-robber-iv",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# binary search, greedy\nclass Solution(object):\n    def minCapability(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(x):\n            cnt = i = 0\n            while i < len(nums):\n                if nums[i] <= x:\n                    cnt += 1\n                    i += 2\n                else:\n                    i += 1\n            return cnt >= k\n\n        sorted_nums = sorted(set(nums))\n        left, right = 0, len(sorted_nums)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(sorted_nums[mid]):\n                right = mid-1\n            else:\n                left = mid+1\n        return sorted_nums[left]\n\n\n# Time:  O(nlogr)\n# Space: O(1)\n# binary search, greedy\nclass Solution2(object):\n    def minCapability(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(x):\n            cnt = i = 0\n            while i < len(nums):\n                if nums[i] <= x:\n                    cnt += 1\n                    i += 2\n                else:\n                    i += 1\n            return cnt >= k\n    \n        left, right = min(nums), max(nums)\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "house-robber",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param num, a list of integer\n    # @return an integer\n    def rob(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        last, now = 0, 0\n        for i in nums:\n            last, now = now, max(last + i, now)\n        return now\n\n\n"
    },
    {
        "problem_name": "how-many-apples-can-you-put-into-the-basket",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def maxNumberOfApples(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        LIMIT = 5000\n        arr.sort()\n        result, total = 0, 0\n        for x in arr:\n            if total+x > LIMIT:\n                break\n            total += x\n            result += 1\n        return result\n"
    },
    {
        "problem_name": "how-many-numbers-are-smaller-than-the-current-number",
        "solution": "# Time:  O(n + m), m is the max number of nums\n# Space: O(m)\n\nimport collections\n\n\nclass Solution(object):\n    def smallerNumbersThanCurrent(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        count = collections.Counter(nums)\n        for i in xrange(max(nums)+1):\n            count[i] += count[i-1]\n        return [count[i-1] for i in nums]\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport bisect\n\n\nclass Solution2(object):\n    def smallerNumbersThanCurrent(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        sorted_nums = sorted(nums)\n        return [bisect.bisect_left(sorted_nums, i) for i in nums]\n"
    },
    {
        "problem_name": "html-entity-parser",
        "solution": "# Time:  O(n + m + z) = O(m), n is the total size of patterns\n#                           , m is the total size of query string\n#                           , z is the number of all matched strings\n#                           , O(n) = O(1), O(z) = O(m) in this problem\n# Space: O(t) = O(1), t is the total size of ac automata trie\n#                   , O(t) = O(1) in this problem\n\nimport collections\n\n\nclass AhoNode(object):\n    def __init__(self):\n        self.children = collections.defaultdict(AhoNode)\n        self.indices = []\n        self.suffix = None\n        self.output = None\n\n\nclass AhoTrie(object):\n\n    def step(self, letter):\n        while self.__node and letter not in self.__node.children:\n            self.__node = self.__node.suffix\n        self.__node = self.__node.children[letter] if self.__node else self.__root\n        return self.__get_ac_node_outputs(self.__node)\n    \n    def __init__(self, patterns):\n        self.__root = self.__create_ac_trie(patterns)\n        self.__node = self.__create_ac_suffix_and_output_links(self.__root)\n    \n    def __create_ac_trie(self, patterns):  # Time:  O(n), Space: O(t)\n        root = AhoNode()\n        for i, pattern in enumerate(patterns):\n            node = root\n            for c in pattern:\n                node = node.children[c]\n            node.indices.append(i)\n        return root\n\n    def __create_ac_suffix_and_output_links(self, root):  # Time:  O(n), Space: O(t)\n        queue = collections.deque()\n        for node in root.children.itervalues():\n            queue.append(node)\n            node.suffix = root\n\n        while queue:\n            node = queue.popleft()\n            for c, child in node.children.iteritems():\n                queue.append(child)\n                suffix = node.suffix\n                while suffix and c not in suffix.children:\n                    suffix = suffix.suffix\n                child.suffix = suffix.children[c] if suffix else root\n                child.output = child.suffix if child.suffix.indices else child.suffix.output\n                \n        return root\n\n    def __get_ac_node_outputs(self, node):  # Time:  O(z)\n        result = []\n        for i in node.indices:\n            result.append(i)\n        output = node.output\n        while output:\n            for i in output.indices:\n                result.append(i)\n            output = output.output\n        return result\n\n\nclass Solution(object):\n    def entityParser(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: str\n        \"\"\"\n        patterns = [\"&quot;\", \"&apos;\", \"&amp;\", \"&gt;\", \"&lt;\", \"&frasl;\"]\n        chars = [\"\\\"\", \"'\", \"&\", \">\", \"<\", \"/\"]\n        trie = AhoTrie(patterns)\n        positions = []\n        for i in xrange(len(text)):\n            for j in trie.step(text[i]):\n                positions.append([i-len(patterns[j])+1, j])\n        result = []\n        i, j = 0, 0\n        while i != len(text):\n            if j == len(positions) or i != positions[j][0]:                    \n                result.append(text[i])\n                i += 1\n            else:\n                result.append(chars[positions[j][1]])\n                i += len(patterns[positions[j][1]])\n                j += 1\n        return \"\".join(result)\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def entityParser(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: str\n        \"\"\"\n        patterns = [\"&quot;\", \"&apos;\", \"&amp;\", \"&gt;\", \"&lt;\", \"&frasl;\"]\n        chars = [\"\\\"\", \"'\", \"&\", \">\", \"<\", \"/\"]\n        result = []\n        i, j = 0, 0\n        while i != len(text):\n            if text[i] != '&':                    \n                result.append(text[i])\n                i += 1\n            else:\n                for j, pattern in enumerate(patterns):\n                    if pattern == text[i:i+len(pattern)]:\n                        result.append(chars[j])\n                        i += len(pattern)\n                        break\n                else:\n                    result.append(text[i])\n                    i += 1\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "image-overlap",
        "solution": "# Time:  O(n^4)\n# Space: O(n^2)\n\nclass Solution(object):\n    def largestOverlap(self, A, B):\n        \"\"\"\n        :type A: List[List[int]]\n        :type B: List[List[int]]\n        :rtype: int\n        \"\"\"\n        count = [0] * (2*len(A)-1)**2\n        for i, row in enumerate(A):\n            for j, v in enumerate(row):\n                if not v:\n                    continue\n                for i2, row2 in enumerate(B):\n                    for j2, v2 in enumerate(row2):\n                        if not v2:\n                            continue\n                        count[(len(A)-1+i-i2)*(2*len(A)-1) +\n                              len(A)-1+j-j2] += 1\n        return max(count)\n\n"
    },
    {
        "problem_name": "image-smoother",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def imageSmoother(self, M):\n        \"\"\"\n        :type M: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def getGray(M, i, j):\n            total, count = 0, 0.0\n            for r in xrange(-1, 2):\n                for c in xrange(-1, 2):\n                    ii, jj = i + r, j + c\n                    if 0 <= ii < len(M) and 0 <= jj < len(M[0]):\n                        total += M[ii][jj]\n                        count += 1.0\n            return int(total / count)\n\n        result = [[0 for _ in xrange(len(M[0]))] for _ in xrange(len(M))]\n        for i in xrange(len(M)):\n            for j in xrange(len(M[0])):\n                result[i][j] = getGray(M, i, j)\n        return result\n\n"
    },
    {
        "problem_name": "implement-magic-dictionary",
        "solution": "# Time:  O(n), n is the length of the word\n# Space: O(d)\n\nimport collections\n\n\nclass MagicDictionary(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        self.trie = _trie()\n\n\n    def buildDict(self, dictionary):\n        \"\"\"\n        Build a dictionary through a list of words\n        :type dictionary: List[str]\n        :rtype: void\n        \"\"\"\n        for word in dictionary:\n            reduce(dict.__getitem__, word, self.trie).setdefault(\"_end\")\n\n\n    def search(self, word):\n        \"\"\"\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def find(word, curr, i, mistakeAllowed):\n            if i == len(word):\n                return \"_end\" in curr and not mistakeAllowed\n\n            if word[i] not in curr:\n                return any(find(word, curr[c], i+1, False) for c in curr if c != \"_end\") \\\n                           if mistakeAllowed else False\n\n            if mistakeAllowed:\n                return find(word, curr[word[i]], i+1, True) or \\\n                       any(find(word, curr[c], i+1, False) \\\n                           for c in curr if c not in (\"_end\", word[i]))\n            return find(word, curr[word[i]], i+1, False)\n\n        return find(word, self.trie, 0, True)\n\n\n\n\n"
    },
    {
        "problem_name": "implement-queue-using-stacks",
        "solution": "# Time:  O(1), amortized\n# Space: O(n)\n\nclass MyQueue(object):\n\n    def __init__(self):\n        self.A, self.B = [], []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.A.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.peek()\n        return self.B.pop()\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.B:\n            while self.A:\n                self.B.append(self.A.pop())\n        return self.B[-1]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return not self.A and not self.B\n"
    },
    {
        "problem_name": "implement-rand10-using-rand7",
        "solution": "# Time:  O(1.189), counted by statistics, limit would be O(log10/log7) = O(1.183)\n# Space: O(1)\n\nimport random\n\n\ndef rand7():\n    return random.randint(1, 7)\n\n\n# Reference: https://leetcode.com/problems/implement-rand10-using-rand7/discuss/151567/C++JavaPython-Average-1.199-Call-rand7-Per-rand10\nclass Solution(object):\n    def __init__(self):\n        self.__cache = []\n\n    def rand10(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        def generate(cache):\n            n = 32\n            curr = sum((rand7()-1) * (7**i) for i in xrange(n))\n            rang = 7**n\n            while curr < rang//10*10:\n                cache.append(curr%10+1)\n                curr /= 10\n                rang /= 10\n\n        while not self.__cache:\n            generate(self.__cache)\n        return self.__cache.pop()\n\n\n# Time:  O(2 * (1 + (9/49) + (9/49)^2 + ...)) = O(2/(1-(9/49)) = O(2.45)\n# Space: O(1)\nclass Solution2(object):\n    def rand10(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while True:\n            x = (rand7()-1)*7 + (rand7()-1)\n            if x < 40:\n                return x%10 + 1\n\n"
    },
    {
        "problem_name": "implement-stack-using-queues",
        "solution": "# Time: push: O(n), pop: O(1), top: O(1)\n# Space: O(n)\n\nimport collections\n\n\nclass Queue(object):\n    def __init__(self):\n        self.data = collections.deque()\n\n    def push(self, x):\n        self.data.append(x)\n\n    def peek(self):\n        return self.data[0]\n\n    def pop(self):\n        return self.data.popleft()\n\n    def size(self):\n        return len(self.data)\n\n    def empty(self):\n        return len(self.data) == 0\n\n\nclass Stack(object):\n    # initialize your data structure here.\n    def __init__(self):\n        self.q_ = Queue()\n\n    # @param x, an integer\n    # @return nothing\n    def push(self, x):\n        self.q_.push(x)\n        for _ in xrange(self.q_.size() - 1):\n            self.q_.push(self.q_.pop())\n\n    # @return nothing\n    def pop(self):\n        self.q_.pop()\n\n    # @return an integer\n    def top(self):\n        return self.q_.peek()\n\n    # @return an boolean\n    def empty(self):\n        return self.q_.empty()\n\n\n# Time: push: O(1), pop: O(n), top: O(1)\n# Space: O(n)\nclass Stack2(object):\n    # initialize your data structure here.\n    def __init__(self):\n        self.q_ = Queue()\n        self.top_ = None\n\n    # @param x, an integer\n    # @return nothing\n    def push(self, x):\n        self.q_.push(x)\n        self.top_ = x\n\n    # @return nothing\n    def pop(self):\n        for _ in xrange(self.q_.size() - 1):\n            self.top_ = self.q_.pop()\n            self.q_.push(self.top_)\n        self.q_.pop()\n\n    # @return an integer\n    def top(self):\n        return self.top_\n\n    # @return an boolean\n    def empty(self):\n        return self.q_.empty()\n\n"
    },
    {
        "problem_name": "implement-strstr",
        "solution": "# Time:  O(n + k)\n# Space: O(k)\n\nclass Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if not needle:\n            return 0\n\n        return self.KMP(haystack, needle)\n\n    def KMP(self, text, pattern):\n        prefix = self.getPrefix(pattern)\n        j = -1\n        for i in xrange(len(text)):\n            while j > -1 and pattern[j + 1] != text[i]:\n                j = prefix[j]\n            if pattern[j + 1] == text[i]:\n                j += 1\n            if j == len(pattern) - 1:\n                return i - j\n        return -1\n\n    def getPrefix(self, pattern):\n        prefix = [-1] * len(pattern)\n        j = -1\n        for i in xrange(1, len(pattern)):\n            while j > -1 and pattern[j + 1] != pattern[i]:\n                j = prefix[j]\n            if pattern[j + 1] == pattern[i]:\n                j += 1\n            prefix[i] = j\n        return prefix\n\n\n# Time:  O(n * k)\n# Space: O(k)\nclass Solution2(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        for i in xrange(len(haystack) - len(needle) + 1):\n            if haystack[i : i + len(needle)] == needle:\n                return i\n        return -1\n\n\n"
    },
    {
        "problem_name": "implement-trie-ii-prefix-tree",
        "solution": "# Time:  ctor:         O(1)\n#        insert:       O(n)\n#        count_word:   O(n)\n#        count_prefix: O(n)\n#        erase:        O(n)\n# Space: O(t), t is the number of nodes in trie\n\nclass Node:\n    def __init__(self):\n        self.children = [None]*26\n        self.pcnt = 0\n        self.cnt = 0\n\nclass Trie(object):\n\n    def __init__(self):\n        self.__trie = Node()\n\n    def insert(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        curr = self.__trie\n        curr.pcnt += 1\n        for c in word:\n            if curr.children[ord(c)-ord('a')] is None:\n                curr.children[ord(c)-ord('a')] = Node()\n            curr = curr.children[ord(c)-ord('a')]\n            curr.pcnt += 1\n        curr.cnt += 1\n\n    def countWordsEqualTo(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        curr = self.__trie\n        for c in word:\n            if curr.children[ord(c)-ord('a')] is None:\n                return 0\n            curr = curr.children[ord(c)-ord('a')]\n        return curr.cnt\n\n    def countWordsStartingWith(self, prefix):\n        \"\"\"\n        :type prefix: str\n        :rtype: int\n        \"\"\"\n        curr = self.__trie\n        for c in prefix:\n            if curr.children[ord(c)-ord('a')] is None:\n                return 0\n            curr = curr.children[ord(c)-ord('a')]\n        return curr.pcnt\n\n    def erase(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        cnt = self.countWordsEqualTo(word)\n        if not cnt:\n            return\n        curr = self.__trie\n        curr.pcnt -= 1\n        for c in word:\n            if curr.children[ord(c)-ord('a')].pcnt == 1:\n                curr.children[ord(c)-ord('a')] = None  # delete all unused nodes\n                return\n            curr = curr.children[ord(c)-ord('a')]\n            curr.pcnt -= 1\n        curr.cnt -= 1\n"
    },
    {
        "problem_name": "implement-trie-prefix-tree",
        "solution": "# Time:  O(n), per operation\n# Space: O(1)\n\nclass TrieNode(object):\n    # Initialize your data structure here.\n    def __init__(self):\n        self.is_string = False\n        self.leaves = {}\n\n\nclass Trie(object):\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    # @param {string} word\n    # @return {void}\n    # Inserts a word into the trie.\n    def insert(self, word):\n        cur = self.root\n        for c in word:\n            if not c in cur.leaves:\n                cur.leaves[c] = TrieNode()\n            cur = cur.leaves[c]\n        cur.is_string = True\n\n    # @param {string} word\n    # @return {boolean}\n    # Returns if the word is in the trie.\n    def search(self, word):\n        node = self.childSearch(word)\n        if node:\n            return node.is_string\n        return False\n\n    # @param {string} prefix\n    # @return {boolean}\n    # Returns if there is any word in the trie\n    # that starts with the given prefix.\n    def startsWith(self, prefix):\n        return self.childSearch(prefix) is not None\n\n    def childSearch(self, word):\n        cur = self.root\n        for c in word:\n            if c in cur.leaves:\n                cur = cur.leaves[c]\n            else:\n                return None\n        return cur\n\n\n"
    },
    {
        "problem_name": "increasing-decreasing-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def sortString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        result, count = [], [0]*26\n        for c in s:\n            count[ord(c)-ord('a')] += 1\n        while len(result) != len(s):\n            for c in xrange(len(count)):\n                if not count[c]:\n                    continue\n                result.append(chr(ord('a')+c))\n                count[c] -= 1\n            for c in reversed(xrange(len(count))):\n                if not count[c]:\n                    continue\n                result.append(chr(ord('a')+c))\n                count[c] -= 1\n        return \"\".join(result)\n\n\n# Time:  O(n)\n# Space: O(1)\nimport collections\n\n\nclass Solution2(object):\n    def sortString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        result, count, desc = [], collections.Counter(s), False\n        while count:\n            for c in sorted(count.keys(), reverse=desc):\n                result.append(c)\n                count[c] -= 1\n                if not count[c]:\n                    del count[c]\n            desc = not desc\n        return \"\".join(result)\n\n"
    },
    {
        "problem_name": "increasing-order-search-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def increasingBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        def increasingBSTHelper(root, tail):\n            if not root:\n                return tail\n            result = increasingBSTHelper(root.left, root)\n            root.left = None\n            root.right = increasingBSTHelper(root.right, tail)\n            return result\n        return increasingBSTHelper(root, None)\n\n"
    },
    {
        "problem_name": "increasing-subsequences",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(n), longest possible path in tree, which is if all numbers are increasing.\n\nclass Solution(object):\n    def findSubsequences(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        def findSubsequencesHelper(nums, pos, seq, result):\n            if len(seq) >= 2:\n                result.append(list(seq))\n            lookup = set()\n            for i in xrange(pos, len(nums)):\n                if (not seq or nums[i] >= seq[-1]) and \\\n                   nums[i] not in lookup:\n                    lookup.add(nums[i])\n                    seq.append(nums[i])\n                    findSubsequencesHelper(nums, i+1, seq, result)\n                    seq.pop()\n\n        result, seq = [], []\n        findSubsequencesHelper(nums, 0, seq, result)\n        return result\n\n"
    },
    {
        "problem_name": "increasing-triplet-subsequence",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport bisect\n\n\nclass Solution(object):\n    def increasingTriplet(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        min_num, a, b = float(\"inf\"), float(\"inf\"), float(\"inf\")\n        for c in nums:\n            if min_num >= c:\n                min_num = c\n            elif b >= c:\n                a, b = min_num, c\n            else:  # a < b < c\n                return True\n        return False\n\n# Time:  O(n * logk)\n# Space: O(k)\n# Generalization of k-uplet.\nclass Solution_Generalization(object):\n    def increasingTriplet(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        def increasingKUplet(nums, k):\n            inc = [float('inf')] * (k - 1)\n            for num in nums:\n                i = bisect.bisect_left(inc, num)\n                if i >= k - 1:\n                    return True\n                inc[i] = num\n            return k == 0\n\n        return increasingKUplet(nums, 3)\n\n"
    },
    {
        "problem_name": "increment-submatrices-by-one",
        "solution": "# Time:  O(q + n^2)\n# Space: O(1)\n\n# line sweep, difference matrix (2d difference array)\nclass Solution(object):\n    def rangeAddQueries(self, n, queries):\n        \"\"\"\n        :type n: int\n        :type queries: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = [[0]*n for _ in xrange(n)]\n        for r1, c1, r2, c2 in queries:\n            result[r1][c1] += 1\n            if c2+1 < len(result[0]):\n                result[r1][c2+1] -= 1\n            if r2+1 < len(result):\n                result[r2+1][c1] -= 1\n            if r2+1 < len(result) and c2+1 < len(result[0]):\n                result[r2+1][c2+1] += 1\n        for r in xrange(len(result)):\n            for c in xrange(len(result[0])-1):\n                result[r][c+1] += result[r][c]\n        for r in xrange(len(result)-1):\n            for c in xrange(len(result[0])):\n                result[r+1][c] += result[r][c]\n        return result\n"
    },
    {
        "problem_name": "incremental-memory-leak",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# Same problem from https://codingcompetitions.withgoogle.com/codejam/round/000000000019ffb9/00000000003384ea\nclass Solution(object):\n    def memLeak(self, memory1, memory2):\n        \"\"\"\n        :type memory1: int\n        :type memory2: int\n        :rtype: List[int]\n        \"\"\"\n        def s(a, d, n):\n            return (2*a + (n-1)*d)*n//2\n\n        def f(a, d, x):\n            r = int((-(2*a-d)+((2*a-d)**2+8*d*x)**0.5)/(2*d))\n            if s(a, d, r) > x:  # adjust float accuracy\n                r -= 1\n            return r\n\n        is_swapped = False\n        if memory1 < memory2:\n            memory1, memory2 = memory2, memory1\n            is_swapped = True\n        n = f(1, 1, memory1-memory2)\n        memory1 -= s(1, 1, n)\n        if memory1 == memory2:\n            is_swapped = False\n        l = f(n+1, 2, memory1)\n        r = f(n+2, 2, memory2)\n        memory1 -= s(n+1, 2, l)\n        memory2 -= s(n+2, 2, r)\n        if is_swapped:\n            memory1, memory2 = memory2, memory1\n        return [n+l+r+1, memory1, memory2]\n"
    },
    {
        "problem_name": "index-pairs-of-a-string",
        "solution": "# Time:  O(n + m + z), n is the total size of patterns\n#                    , m is the total size of query string\n#                    , z is the number of all matched strings\n# Space: O(t), t is the total size of ac automata trie\n\nimport collections\n\n\nclass AhoNode(object):\n    def __init__(self):\n        self.children = collections.defaultdict(AhoNode)\n        self.indices = []\n        self.suffix = None\n        self.output = None\n\n\nclass AhoTrie(object):\n\n    def step(self, letter):\n        while self.__node and letter not in self.__node.children:\n            self.__node = self.__node.suffix\n        self.__node = self.__node.children[letter] if self.__node else self.__root\n        return self.__get_ac_node_outputs(self.__node)\n    \n    def __init__(self, patterns):\n        self.__root = self.__create_ac_trie(patterns)\n        self.__node = self.__create_ac_suffix_and_output_links(self.__root)\n    \n    def __create_ac_trie(self, patterns):  # Time:  O(n), Space: O(t)\n        root = AhoNode()\n        for i, pattern in enumerate(patterns):\n            node = root\n            for c in pattern:\n                node = node.children[c]\n            node.indices.append(i)\n        return root\n\n    def __create_ac_suffix_and_output_links(self, root):  # Time:  O(n), Space: O(t)\n        queue = collections.deque()\n        for node in root.children.itervalues():\n            queue.append(node)\n            node.suffix = root\n\n        while queue:\n            node = queue.popleft()\n            for c, child in node.children.iteritems():\n                queue.append(child)\n                suffix = node.suffix\n                while suffix and c not in suffix.children:\n                    suffix = suffix.suffix\n                child.suffix = suffix.children[c] if suffix else root\n                child.output = child.suffix if child.suffix.indices else child.suffix.output\n                \n        return root\n\n    def __get_ac_node_outputs(self, node):  # Time:  O(z)\n        result = []\n        for i in node.indices:\n            result.append(i)\n        output = node.output\n        while output:\n            for i in output.indices:\n                result.append(i)\n            output = output.output\n        return result\n    \n\nclass Solution(object):\n    def indexPairs(self, text, words):\n        \"\"\"\n        :type text: str\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        reversed_words = [w[::-1] for w in words]\n        trie = AhoTrie(reversed_words)\n        for i in reversed(xrange(len(text))):\n            for j in trie.step(text[i]):\n                result.append([i, i+len(reversed_words[j])-1])\n        result.reverse()\n        return result\n"
    },
    {
        "problem_name": "inorder-successor-in-bst-ii",
        "solution": "# Time:  O(h)\n# Space: O(1)\n\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, left, right, parent):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.parent = parent\n\n        \nclass Solution(object):\n    def inorderSuccessor(self, node):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n        if not node:\n            return None\n        \n        if node.right:\n            node = node.right\n            while node.left:\n                node = node.left\n            return node\n        \n        while node.parent and node.parent.right is node:\n            node = node.parent\n        return node.parent\n"
    },
    {
        "problem_name": "inorder-successor-in-bst",
        "solution": "# Time:  O(h)\n# Space: O(1)\n\nclass Solution(object):\n    def inorderSuccessor(self, root, p):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        # If it has right subtree.\n        if p and p.right:\n            p = p.right\n            while p.left:\n                p = p.left\n            return p\n\n        # Search from root.\n        successor = None\n        while root and root != p:\n            if root.val > p.val:\n                successor = root\n                root = root.left\n            else:\n                root = root.right\n\n        return successor\n\n"
    },
    {
        "problem_name": "insert-delete-getrandom-o1-duplicates-allowed",
        "solution": "# Time:  O(1)\n# Space: O(n)\n\nfrom random import randint\nfrom collections import defaultdict\n\nclass RandomizedCollection(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__list = []\n        self.__used = defaultdict(list)\n\n\n    def insert(self, val):\n        \"\"\"\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        has = val in self.__used\n\n        self.__list += (val, len(self.__used[val])),\n        self.__used[val] += len(self.__list)-1,\n\n        return not has\n\n\n    def remove(self, val):\n        \"\"\"\n        Removes a value from the collection. Returns true if the collection contained the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val not in self.__used:\n            return False\n\n        self.__used[self.__list[-1][0]][self.__list[-1][1]] = self.__used[val][-1]\n        self.__list[self.__used[val][-1]], self.__list[-1] = self.__list[-1], self.__list[self.__used[val][-1]]\n\n        self.__used[val].pop()\n        if not self.__used[val]:\n            self.__used.pop(val)\n        self.__list.pop()\n\n        return True\n\n    def getRandom(self):\n        \"\"\"\n        Get a random element from the collection.\n        :rtype: int\n        \"\"\"\n        return self.__list[randint(0, len(self.__list)-1)][0]\n"
    },
    {
        "problem_name": "insert-delete-getrandom-o1",
        "solution": "# Time:  O(1)\n# Space: O(n)\n\nfrom random import randint\n\nclass RandomizedSet(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__set = []\n        self.__used = {}\n\n\n    def insert(self, val):\n        \"\"\"\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val in self.__used:\n            return False\n\n        self.__set += val,\n        self.__used[val] = len(self.__set)-1\n\n        return True\n\n\n    def remove(self, val):\n        \"\"\"\n        Removes a value from the set. Returns true if the set contained the specified element.\n        :type val: int\n        :rtype: bool\n        \"\"\"\n        if val not in self.__used:\n            return False\n\n        self.__used[self.__set[-1]] = self.__used[val]\n        self.__set[self.__used[val]], self.__set[-1] = self.__set[-1], self.__set[self.__used[val]]\n\n        self.__used.pop(val)\n        self.__set.pop()\n\n        return True\n\n    def getRandom(self):\n        \"\"\"\n        Get a random element from the set.\n        :rtype: int\n        \"\"\"\n        return self.__set[randint(0, len(self.__set)-1)]\n\n\n\n"
    },
    {
        "problem_name": "insert-greatest-common-divisors-in-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# linked list\nclass Solution(object):\n    def insertGreatestCommonDivisors(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        curr = head\n        while curr.next:\n            curr.next = ListNode(gcd(curr.val, curr.next.val), curr.next)\n            curr = curr.next.next\n        return head\n"
    },
    {
        "problem_name": "insert-interval",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i = 0\n        while i < len(intervals) and newInterval[0] > intervals[i][1]:\n            result += intervals[i],\n            i += 1\n        while i < len(intervals) and newInterval[1] >= intervals[i][0]:\n            newInterval = [min(newInterval[0], intervals[i][0]),\n                           max(newInterval[1], intervals[i][1])]\n            i += 1\n        result.append(newInterval)\n        result.extend(intervals[i:])\n        return result\n"
    },
    {
        "problem_name": "insert-into-a-binary-search-tree",
        "solution": "# Time:  O(h)\n# Space: O(1)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def insertIntoBST(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        curr, parent = root, None\n        while curr:\n            parent = curr\n            if val <= curr.val:\n                curr = curr.left\n            else:\n                curr = curr.right\n        if not parent:\n            root = TreeNode(val)\n        elif val <= parent.val:\n            parent.left = TreeNode(val)\n        else:\n            parent.right = TreeNode(val)\n        return root\n\n\n# Time:  O(h)\n# Space: O(h)\nclass Solution2(object):\n    def insertIntoBST(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            root = TreeNode(val)\n        else:\n            if val <= root.val:\n                root.left = self.insertIntoBST(root.left, val)\n            else:\n                root.right = self.insertIntoBST(root.right, val)\n        return root\n\n"
    },
    {
        "problem_name": "insert-into-a-sorted-circular-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Node(object):\n    def __init__(self, val, next):\n        self.val = val\n        self.next = next\n\n\nclass Solution(object):\n    def insert(self, head, insertVal):\n        \"\"\"\n        :type head: Node\n        :type insertVal: int\n        :rtype: Node\n        \"\"\"\n        def insertAfter(node, val):\n            node.next = Node(val, node.next)\n        \n        if not head:\n            node = Node(insertVal, None)\n            node.next = node\n            return node\n\n        curr = head\n        while True:\n            if curr.val < curr.next.val:\n                if curr.val <= insertVal and \\\n                   insertVal <= curr.next.val:\n                    insertAfter(curr, insertVal)\n                    break\n            elif curr.val > curr.next.val:\n                if curr.val <= insertVal or \\\n                   insertVal <= curr.next.val:\n                    insertAfter(curr, insertVal)\n                    break\n            else:\n                if curr.next == head:\n                    insertAfter(curr, insertVal)\n                    break\n            curr = curr.next\n        return head\n\n"
    },
    {
        "problem_name": "insertion-sort-list",
        "solution": "# Time:  O(n ^ 2)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n        else:\n            return \"Nil\"\n\nclass Solution(object):\n    # @param head, a ListNode\n    # @return a ListNode\n    def insertionSortList(self, head):\n        if head is None or self.isSorted(head):\n            return head\n\n        dummy = ListNode(-2147483648)\n        dummy.next = head\n        cur, sorted_tail = head.next, head\n        while cur:\n            prev = dummy\n            while prev.next.val < cur.val:\n                prev = prev.next\n            if prev == sorted_tail:\n                cur, sorted_tail = cur.next, cur\n            else:\n                cur.next, prev.next, sorted_tail.next = prev.next, cur, cur.next\n                cur = sorted_tail.next\n\n        return dummy.next\n\n    def isSorted(self, head):\n        while head and head.next:\n            if head.val > head.next.val:\n                return False\n            head = head.next\n        return True\n\n"
    },
    {
        "problem_name": "insufficient-nodes-in-root-to-leaf-paths",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def sufficientSubset(self, root, limit):\n        \"\"\"\n        :type root: TreeNode\n        :type limit: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n        if not root.left and not root.right:\n            return None if root.val < limit else root\n        root.left = self.sufficientSubset(root.left, limit-root.val)\n        root.right = self.sufficientSubset(root.right, limit-root.val)\n        if not root.left and not root.right:\n            return None\n        return root\n"
    },
    {
        "problem_name": "integer-break",
        "solution": "# Time:  O(logn), pow is O(logn).\n# Space: O(1)\n\nclass Solution(object):\n    def integerBreak(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n < 4:\n            return n - 1\n\n        #  Proof.\n        #  1. Let n = a1 + a2 + ... + ak, product = a1 * a2 * ... * ak\n        #      - For each ai >= 4, we can always maximize the product by:\n        #        ai <= 2 * (ai - 2)\n        #      - For each aj >= 5, we can always maximize the product by:\n        #        aj <= 3 * (aj - 3)\n        #\n        #     Conclusion 1:\n        #      - For n >= 4, the max of the product must be in the form of\n        #        3^a * 2^b, s.t. 3a + 2b = n\n        #\n        #  2. To maximize the product = 3^a * 2^b s.t. 3a + 2b = n\n        #      - For each b >= 3, we can always maximize the product by:\n        #        3^a * 2^b <= 3^(a+2) * 2^(b-3) s.t. 3(a+2) + 2(b-3) = n\n        #\n        #     Conclusion 2:\n        #      - For n >= 4, the max of the product must be in the form of\n        #        3^Q * 2^R, 0 <= R < 3 s.t. 3Q + 2R = n\n        #        i.e.\n        #          if n = 3Q + 0,   the max of the product = 3^Q * 2^0\n        #          if n = 3Q + 2,   the max of the product = 3^Q * 2^1\n        #          if n = 3Q + 2*2, the max of the product = 3^Q * 2^2\n\n        res = 0\n        if n % 3 == 0:            #  n = 3Q + 0, the max is 3^Q * 2^0\n            res = 3 ** (n // 3)\n        elif n % 3 == 2:          #  n = 3Q + 2, the max is 3^Q * 2^1\n            res = 3 ** (n // 3) * 2\n        else:                     #  n = 3Q + 4, the max is 3^Q * 2^2\n            res = 3 ** (n // 3 - 1) * 4\n        return res\n\n\n# Time:  O(n)\n# Space: O(1)\n# DP solution.\nclass Solution2(object):\n    def integerBreak(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n < 4:\n            return n - 1\n\n        # integerBreak(n) = max(integerBreak(n - 2) * 2, integerBreak(n - 3) * 3)\n        res = [0, 1, 2, 3]\n        for i in xrange(4, n + 1):\n            res[i % 4] = max(res[(i - 2) % 4] * 2, res[(i - 3) % 4] * 3)\n        return res[n % 4]\n\n"
    },
    {
        "problem_name": "integer-replacement",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def integerReplacement(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while n != 1:\n            b = n & 3\n            if n == 3:\n                n -= 1\n            elif b == 3:\n                n += 1\n            elif b == 1:\n                n -= 1\n            else:\n                n /= 2\n            result += 1\n\n        return result\n\n\n# Time:  O(logn)\n# Space: O(logn)\n# Recursive solution.\nclass Solution2(object):\n    def integerReplacement(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n < 4:\n            return [0, 0, 1, 2][n]\n        if n % 4 in (0, 2):\n            return self.integerReplacement(n / 2) + 1\n        elif n % 4 == 1:\n            return self.integerReplacement((n - 1) / 4) + 3\n        else:\n            return self.integerReplacement((n + 1) / 4) + 3\n\n\n"
    },
    {
        "problem_name": "integer-to-english-words",
        "solution": "# Time:  O(logn) = O(1), n is the value of the integer, which is less than 2^31 - 1\n# Space: O(1)\n\nclass Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"Zero\"\n\n        lookup = {0: \"Zero\", 1:\"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", \\\n                  5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\", \\\n                  10: \"Ten\", 11: \"Eleven\", 12: \"Twelve\", 13: \"Thirteen\", 14: \"Fourteen\", \\\n                  15: \"Fifteen\", 16: \"Sixteen\", 17: \"Seventeen\", 18: \"Eighteen\", 19: \"Nineteen\", \\\n                  20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\", 50: \"Fifty\", 60: \"Sixty\", \\\n                  70: \"Seventy\", 80: \"Eighty\", 90: \"Ninety\"}\n        unit = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        res, i = [], 0\n        while num:\n            cur = num % 1000\n            if num % 1000:\n                res.append(self.threeDigits(cur, lookup, unit[i]))\n            num //= 1000\n            i += 1\n        return \" \".join(res[::-1])\n\n    def threeDigits(self, num, lookup, unit):\n        res = []\n        if num / 100:\n            res = [lookup[num / 100] + \" \" + \"Hundred\"]\n        if num % 100:\n            res.append(self.twoDigits(num % 100, lookup))\n        if unit != \"\":\n            res.append(unit)\n        return \" \".join(res)\n\n    def twoDigits(self, num, lookup):\n        if num in lookup:\n            return lookup[num]\n        return lookup[(num / 10) * 10] + \" \" + lookup[num % 10]\n\n"
    },
    {
        "problem_name": "integer-to-roman",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        numeral_map = {1: \"I\", 4: \"IV\", 5: \"V\", 9: \"IX\", \\\n                       10: \"X\", 40: \"XL\", 50: \"L\", 90: \"XC\", \\\n                       100: \"C\", 400: \"CD\", 500: \"D\", 900: \"CM\", \\\n                       1000: \"M\"}\n        keyset, result = sorted(numeral_map.keys()), []\n\n        while num > 0:\n            for key in reversed(keyset):\n                while num / key > 0:\n                    num -= key\n                    result += numeral_map[key]\n\n        return \"\".join(result)\n\n\n"
    },
    {
        "problem_name": "interleaving-string",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nclass Solution(object):\n    # @return a boolean\n    def isInterleave(self, s1, s2, s3):\n        if len(s1) + len(s2) != len(s3):\n            return False\n        if len(s1) > len(s2):\n            return self.isInterleave(s2, s1, s3)\n        match = [False for i in xrange(len(s1) + 1)]\n        match[0] = True\n        for i in xrange(1, len(s1) + 1):\n            match[i] = match[i -1] and s1[i - 1] == s3[i - 1]\n        for j in xrange(1, len(s2) + 1):\n            match[0] = match[0] and s2[j - 1] == s3[j - 1]\n            for i in xrange(1, len(s1) + 1):\n                match[i] = (match[i - 1] and s1[i - 1] == s3[i + j - 1]) \\\n                                       or (match[i] and s2[j - 1] == s3[i + j - 1])\n        return match[-1]\n\n# Time:  O(m * n)\n# Space: O(m * n)\n# Dynamic Programming\nclass Solution2(object):\n    # @return a boolean\n    def isInterleave(self, s1, s2, s3):\n        if len(s1) + len(s2) != len(s3):\n            return False\n        match = [[False for i in xrange(len(s2) + 1)] for j in xrange(len(s1) + 1)]\n        match[0][0] = True\n        for i in xrange(1, len(s1) + 1):\n            match[i][0] = match[i - 1][0] and s1[i - 1] == s3[i - 1]\n        for j in xrange(1, len(s2) + 1):\n            match[0][j] = match[0][j - 1] and s2[j - 1] == s3[j - 1]\n        for i in xrange(1, len(s1) + 1):\n            for j in xrange(1, len(s2) + 1):\n                match[i][j] = (match[i - 1][j] and s1[i - 1] == s3[i + j - 1]) \\\n                                       or (match[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        return match[-1][-1]\n\n# Time:  O(m * n)\n# Space: O(m * n)\n# Recursive + Hash\nclass Solution3(object):\n    # @return a boolean\n    def isInterleave(self, s1, s2, s3):\n        self.match = {}\n        if len(s1) + len(s2) != len(s3):\n            return False\n        return self.isInterleaveRecu(s1, s2, s3, 0, 0, 0)\n\n    def isInterleaveRecu(self, s1, s2, s3, a, b, c):\n        if repr([a, b]) in self.match.keys():\n            return self.match[repr([a, b])]\n\n        if c == len(s3):\n            return True\n\n        result = False\n        if a < len(s1) and s1[a] == s3[c]:\n            result = result or self.isInterleaveRecu(s1, s2, s3, a + 1, b, c + 1)\n        if b < len(s2) and s2[b] == s3[c]:\n            result = result or self.isInterleaveRecu(s1, s2, s3, a, b + 1, c + 1)\n\n        self.match[repr([a, b])] = result\n\n        return result\n\n"
    },
    {
        "problem_name": "intersection-of-multiple-arrays",
        "solution": "# Time:  O(n * l + r), n = len(nums), l = len(nums[0])\n# Space: O(r), r = max(nums)-min(nums)\n\n# freq table, counting sort\nclass Solution(object):\n    def intersection(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        MAX_NUM = 1000\n        cnt = [0]*(MAX_NUM+1)\n        for num in nums:\n            for x in num:\n                cnt[x] += 1\n        return [i for i in xrange(1, MAX_NUM+1) if cnt[i] == len(nums)]\n\n\n# Time:  O(n * l + r), n = len(nums), l = len(nums[0]), r = max(nums)-min(nums)\n# Space: O(l)\n# hash table, counting sort\nclass Solution2(object):\n    def intersection(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = set(nums[0])\n        for i in xrange(1, len(nums)):\n            result = set(x for x in nums[i] if x in result)\n        return [i for i in xrange(min(result), max(result)+1) if i in result] if result else []\n\n\n# Time:  O(n * l + llogl), n = len(nums), l = len(nums[0])\n# Space: O(l)\n# hash table, sort\nclass Solution3(object):\n    def intersection(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = set(nums[0])\n        for i in xrange(1, len(nums)):\n            result = set(x for x in nums[i] if x in result)\n        return sorted(result)\n"
    },
    {
        "problem_name": "intersection-of-three-sorted-arrays",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def arraysIntersection(self, arr1, arr2, arr3):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :type arr3: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        i, j, k = 0, 0, 0\n        while i != len(arr1) and j != len(arr2) and k != len(arr3):\n            if arr1[i] == arr2[j] == arr3[k]:\n                result.append(arr1[i])\n                i += 1\n                j += 1\n                k += 1\n            else:\n                curr = max(arr1[i], arr2[j], arr3[k])\n                while i != len(arr1) and arr1[i] < curr:\n                    i += 1\n                while j != len(arr2) and arr2[j] < curr:\n                    j += 1\n                while k != len(arr3) and arr3[k] < curr:\n                    k += 1\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def arraysIntersection(self, arr1, arr2, arr3):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :type arr3: List[int]\n        :rtype: List[int]\n        \"\"\"\n        intersect = reduce(set.intersection, map(set, [arr2, arr3]))\n        return [x for x in arr1 if x in intersect]\n"
    },
    {
        "problem_name": "intersection-of-two-arrays-ii",
        "solution": "# If the given array is not sorted and the memory is unlimited:\n#   - Time:  O(m + n)\n#   - Space: O(min(m, n))\n# elif the given array is already sorted:\n#   if m << n or m >> n:\n#     - Time:  O(min(m, n) * log(max(m, n)))\n#     - Space: O(1)\n#   else:\n#     - Time:  O(m + n)\n#     - Soace: O(1)\n# else: (the given array is not sorted and the memory is limited)\n#     - Time:  O(max(m, n) * log(max(m, n)))\n#     - Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n\n        lookup = collections.defaultdict(int)\n        for i in nums1:\n            lookup[i] += 1\n\n        res = []\n        for i in nums2:\n            if lookup[i] > 0:\n                res += i,\n                lookup[i] -= 1\n\n        return res\n\n    def intersect2(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        c = collections.Counter(nums1) & collections.Counter(nums2)\n        intersect = []\n        for i in c:\n            intersect.extend([i] * c[i])\n        return intersect\n\n\n# If the given array is already sorted, and the memory is limited, and (m << n or m >> n).\n# Time:  O(min(m, n) * log(max(m, n)))\n# Space: O(1)\n# Binary search solution.\nclass Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n\n        def binary_search(compare, nums, left, right, target):\n            while left < right:\n                mid = left + (right - left) / 2\n                if compare(nums[mid], target):\n                    right = mid\n                else:\n                    left = mid + 1\n            return left\n\n        nums1.sort(), nums2.sort()  # Make sure it is sorted, doesn't count in time.\n\n        res = []\n        left = 0\n        for i in nums1:\n            left = binary_search(lambda x, y: x >= y, nums2, left, len(nums2), i)\n            if left != len(nums2) and nums2[left] == i:\n                res += i,\n                left += 1\n\n        return res\n\n\n# If the given array is already sorted, and the memory is limited or m ~ n.\n# Time:  O(m + n)\n# Space: O(1)\n# Two pointers solution.\nclass Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums1.sort(), nums2.sort()  # Make sure it is sorted, doesn't count in time.\n\n        res = []\n\n        it1, it2 = 0, 0\n        while it1 < len(nums1) and it2 < len(nums2):\n            if nums1[it1] < nums2[it2]:\n                it1 += 1\n            elif nums1[it1] > nums2[it2]:\n                it2 += 1\n            else:\n                res += nums1[it1],\n                it1 += 1\n                it2 += 1\n\n        return res\n\n\n# If the given array is not sorted, and the memory is limited.\n# Time:  O(max(m, n) * log(max(m, n)))\n# Space: O(1)\n# Two pointers solution.\nclass Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums1.sort(), nums2.sort()  # O(max(m, n) * log(max(m, n)))\n\n        res = []\n\n        it1, it2 = 0, 0\n        while it1 < len(nums1) and it2 < len(nums2):\n            if nums1[it1] < nums2[it2]:\n                it1 += 1\n            elif nums1[it1] > nums2[it2]:\n                it2 += 1\n            else:\n                res += nums1[it1],\n                it1 += 1\n                it2 += 1\n\n        return res\n\n"
    },
    {
        "problem_name": "intersection-of-two-arrays",
        "solution": "# Time:  O(m + n)\n# Space: O(min(m, n))\n\nclass Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums1) > len(nums2):\n            return self.intersection(nums2, nums1)\n\n        lookup = set()\n        for i in nums1:\n            lookup.add(i)\n\n        res = []\n        for i in nums2:\n            if i in lookup:\n                res += i,\n                lookup.discard(i)\n\n        return res\n\n    def intersection2(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return list(set(nums1) & set(nums2))\n\n\n# Time:  O(max(m, n) * log(max(m, n)))\n# Space: O(1)\n# Binary search solution.\nclass Solution2(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums1) > len(nums2):\n            return self.intersection(nums2, nums1)\n\n        def binary_search(compare, nums, left, right, target):\n            while left < right:\n                mid = left + (right - left) / 2\n                if compare(nums[mid], target):\n                    right = mid\n                else:\n                    left = mid + 1\n            return left\n\n        nums1.sort(), nums2.sort()\n\n        res = []\n        left = 0\n        for i in nums1:\n            left = binary_search(lambda x, y: x >= y, nums2, left, len(nums2), i)\n            if left != len(nums2) and nums2[left] == i:\n                res += i,\n                left = binary_search(lambda x, y: x > y, nums2, left, len(nums2), i)\n\n        return res\n\n\n# Time:  O(max(m, n) * log(max(m, n)))\n# Space: O(1)\n# Two pointers solution.\nclass Solution3(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums1.sort(), nums2.sort()\n        res = []\n\n        it1, it2 = 0, 0\n        while it1 < len(nums1) and it2 < len(nums2):\n            if nums1[it1] < nums2[it2]:\n                it1 += 1\n            elif nums1[it1] > nums2[it2]:\n                it2 += 1\n            else:\n                if not res or res[-1] != nums1[it1]:\n                    res += nums1[it1],\n                it1 += 1\n                it2 += 1\n\n        return res\n\n"
    },
    {
        "problem_name": "intersection-of-two-linked-lists",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    # @param two ListNodes\n    # @return the intersected ListNode\n    def getIntersectionNode(self, headA, headB):\n        curA, curB = headA, headB\n        while curA != curB:\n            curA = curA.next if curA else headB\n            curB = curB.next if curB else headA\n        return curA\n"
    },
    {
        "problem_name": "interval-list-intersections",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\n# Definition for an interval.\nclass Interval(object):\n    def __init__(self, s=0, e=0):\n        self.start = s\n        self.end = e\n\n\nclass Solution(object):\n    def intervalIntersection(self, A, B):\n        \"\"\"\n        :type A: List[Interval]\n        :type B: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        result = []\n        i, j = 0, 0\n        while i < len(A) and j < len(B):\n            left = max(A[i].start, B[j].start)\n            right = min(A[i].end, B[j].end)\n            if left <= right:\n                result.append(Interval(left, right))\n            if A[i].end < B[j].end:\n                i += 1\n            else:\n                j += 1\n        return result\n"
    },
    {
        "problem_name": "intervals-between-identical-elements",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def getDistances(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        lookup = collections.defaultdict(list)\n        for i, x in enumerate(arr):\n            lookup[x].append(i)\n        result = [0]*len(arr)\n        for idxs in lookup.itervalues():\n            prefix = [0]\n            for i in idxs:\n                prefix.append(prefix[-1]+i)\n            for i, idx in enumerate(idxs):\n                result[idx] = (idx*(i+1)-prefix[i+1]) + ((prefix[len(idxs)]-prefix[i])-idx*(len(idxs)-i))\n        return result\n"
    },
    {
        "problem_name": "invalid-transactions",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n\nimport collections\n\n\nclass Solution:\n    def invalidTransactions(self, transactions):\n        AMOUNT, MINUTES = 1000, 60\n        trans = map(lambda x: (x[0], int(x[1]), int(x[2]), x[3]),\n                    (transaction.split(',') for transaction in transactions))\n        trans.sort(key=lambda t: t[1])\n        trans_indexes = collections.defaultdict(list)\n        for i, t in enumerate(trans):\n            trans_indexes[t[0]].append(i)\n        result = []\n        for name, indexes in trans_indexes.iteritems():\n            left, right = 0, 0\n            for i, t_index in enumerate(indexes):\n                t = trans[t_index]\n                if (t[2] > AMOUNT):\n                    result.append(\"{},{},{},{}\".format(*t))\n                    continue\n                while left+1 < len(indexes) and trans[indexes[left]][1] < t[1]-MINUTES:\n                    left += 1\n                while right+1 < len(indexes) and trans[indexes[right+1]][1] <= t[1]+MINUTES:\n                    right += 1\n                for i in xrange(left, right+1):\n                    if trans[indexes[i]][3] != t[3]:\n                        result.append(\"{},{},{},{}\".format(*t))\n                        break\n        return result\n"
    },
    {
        "problem_name": "invert-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nimport collections\n\n\n# BFS solution.\nclass Queue(object):\n    def __init__(self):\n        self.data = collections.deque()\n\n    def push(self, x):\n        self.data.append(x)\n\n    def peek(self):\n        return self.data[0]\n\n    def pop(self):\n        return self.data.popleft()\n\n    def size(self):\n        return len(self.data)\n\n    def empty(self):\n        return len(self.data) == 0\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n        if root is not None:\n            nodes = Queue()\n            nodes.push(root)\n            while not nodes.empty():\n                node = nodes.pop()\n                node.left, node.right = node.right, node.left\n                if node.left is not None:\n                    nodes.push(node.left)\n                if node.right is not None:\n                    nodes.push(node.right)\n\n        return root\n\n# Time:  O(n)\n# Space: O(h)\n# Stack solution.\nclass Solution2(object):\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n        if root is not None:\n            nodes = []\n            nodes.append(root)\n            while nodes:\n                node = nodes.pop()\n                node.left, node.right = node.right, node.left\n                if node.left is not None:\n                    nodes.append(node.left)\n                if node.right is not None:\n                    nodes.append(node.right)\n\n        return root\n\n# Time:  O(n)\n# Space: O(h)\n# DFS, Recursive solution.\nclass Solution3(object):\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n        if root is not None:\n            root.left, root.right = self.invertTree(root.right), \\\n                                    self.invertTree(root.left)\n\n        return root\n\n"
    },
    {
        "problem_name": "ip-to-cidr",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def ipToCIDR(self, ip, n):\n        \"\"\"\n        :type ip: str\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        def ipToInt(ip):\n            result = 0\n            for i in ip.split('.'):\n                result = 256 * result + int(i)\n            return result\n\n        def intToIP(n):\n            return \".\".join(str((n >> i) % 256) \\\n                            for i in (24, 16, 8, 0))\n\n        start = ipToInt(ip)\n        result = []\n        while n:\n            mask = max(33-(start & ~(start-1)).bit_length(), \\\n                       33-n.bit_length())\n            result.append(intToIP(start) + '/' + str(mask))\n            start += 1 << (32-mask)\n            n -= 1 << (32-mask)\n        return result\n\n"
    },
    {
        "problem_name": "ipo",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def findMaximizedCapital(self, k, W, Profits, Capital):\n        \"\"\"\n        :type k: int\n        :type W: int\n        :type Profits: List[int]\n        :type Capital: List[int]\n        :rtype: int\n        \"\"\"\n        curr = []\n        future = sorted(zip(Capital, Profits), reverse=True)\n        for _ in xrange(k):\n            while future and future[-1][0] <= W:\n                heapq.heappush(curr, -future.pop()[1])\n            if curr:\n                W -= heapq.heappop(curr)\n        return W\n\n"
    },
    {
        "problem_name": "is-array-a-preorder-of-some-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# stack\nclass Solution(object):\n    def isPreorder(self, nodes):\n        \"\"\"\n        :type nodes: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        stk = [nodes[0][0]]\n        for i in xrange(1, len(nodes)):\n            while stk and stk[-1] != nodes[i][1]:\n                stk.pop()                \n            if not stk:\n                return False            \n            stk.append(nodes[i][0])            \n        return True\n"
    },
    {
        "problem_name": "is-graph-bipartite",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|V|)\n\nclass Solution(object):\n    def isBipartite(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        color = {}\n        for node in xrange(len(graph)):\n            if node in color:\n                continue\n            stack = [node]\n            color[node] = 0\n            while stack:\n                curr = stack.pop()\n                for neighbor in graph[curr]:\n                    if neighbor not in color:\n                        stack.append(neighbor)\n                        color[neighbor] = color[curr] ^ 1\n                    elif color[neighbor] == color[curr]:\n                        return False\n        return True\n\n"
    },
    {
        "problem_name": "is-subsequence",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if not s:\n            return True\n\n        i = 0\n        for c in t:\n            if c == s[i]:\n                i += 1\n            if i == len(s):\n                break\n        return i == len(s)\n\n"
    },
    {
        "problem_name": "island-perimeter",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nimport operator\n\n\nclass Solution(object):\n    def islandPerimeter(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        count, repeat = 0, 0\n\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[i])):\n                if grid[i][j] == 1:\n                    count += 1\n                    if i != 0 and grid[i - 1][j] == 1:\n                        repeat += 1\n                    if j != 0 and grid[i][j - 1] == 1:\n                        repeat += 1\n\n        return 4*count - 2*repeat\n\n# Since there are no lakes, every pair of neighbour cells with different values is part of the perimeter\n# (more precisely, the edge between them is). So just count the differing pairs, both horizontally and vertically\n# (for the latter I simply transpose the grid).\n    def islandPerimeter2(self, grid):\n        return sum(sum(map(operator.ne, [0] + row, row + [0])) for row in grid + map(list, zip(*grid)))\n\n"
    },
    {
        "problem_name": "isomorphic-strings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nfrom itertools import izip  # Generator version of zip.\n\nclass Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n\n        s2t, t2s = {}, {}\n        for p, w in izip(s, t):\n            if w not in s2t and p not in t2s:\n                s2t[w] = p\n                t2s[p] = w\n            elif w not in s2t or s2t[w] != p:\n                # Contradict mapping.\n                return False\n        return True\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def isIsomorphic(self, s, t):\n        if len(s) != len(t):\n            return False\n\n        return self.halfIsom(s, t) and self.halfIsom(t, s)\n\n    def halfIsom(self, s, t):\n        lookup = {}\n        for i in xrange(len(s)):\n            if s[i] not in lookup:\n                lookup[s[i]] = t[i]\n            elif lookup[s[i]] != t[i]:\n                return False\n        return True\n\n"
    },
    {
        "problem_name": "iterator-for-combination",
        "solution": "# Time:  O(k), per operation\n# Space: O(k)\n\nimport itertools\n\n\nclass CombinationIterator(object):\n\n    def __init__(self, characters, combinationLength):\n        \"\"\"\n        :type characters: str\n        :type combinationLength: int\n        \"\"\"\n        self.__it = itertools.combinations(characters, combinationLength)\n        self.__curr = None\n        self.__last = characters[-combinationLength:]\n\n    def next(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        self.__curr = \"\".join(self.__it.next())\n        return self.__curr\n    \n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return self.__curr != self.__last\n\n\n# Time:  O(k), per operation\n# Space: O(k)\nimport functools\n\n\nclass CombinationIterator2(object):\n\n    def __init__(self, characters, combinationLength):\n        \"\"\"\n        :type characters: str\n        :type combinationLength: int\n        \"\"\"\n        self.__characters = characters\n        self.__combinationLength = combinationLength\n        self.__it = self.__iterative_backtracking()\n        self.__curr = None\n        self.__last = characters[-combinationLength:]\n        \n    def __iterative_backtracking(self):\n        def conquer():\n            if len(curr) == self.__combinationLength:\n                return curr\n\n        def prev_divide(c):\n            curr.append(c)\n        \n        def divide(i):\n            if len(curr) != self.__combinationLength:\n                for j in reversed(xrange(i, len(self.__characters)-(self.__combinationLength-len(curr)-1))):\n                    stk.append(functools.partial(post_divide))\n                    stk.append(functools.partial(divide, j+1))\n                    stk.append(functools.partial(prev_divide, self.__characters[j]))\n            stk.append(functools.partial(conquer))\n\n        def post_divide():\n            curr.pop()\n            \n        curr = []\n        stk = [functools.partial(divide, 0)]\n        while stk:\n            result = stk.pop()()\n            if result is not None:\n                yield result\n\n    def next(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        self.__curr = \"\".join(next(self.__it))\n        return self.__curr\n        \n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return self.__curr != self.__last\n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n"
    },
    {
        "problem_name": "jewels-and-stones",
        "solution": "# Time:  O(m + n)\n# Space: O(n)\n\nclass Solution(object):\n    def numJewelsInStones(self, J, S):\n        \"\"\"\n        :type J: str\n        :type S: str\n        :rtype: int\n        \"\"\"\n        lookup = set(J)\n        return sum(s in lookup for s in S)\n\n\n"
    },
    {
        "problem_name": "jump-game-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param A, a list of integers\n    # @return an integer\n    def jump(self, A):\n        jump_count = 0\n        reachable = 0\n        curr_reachable = 0\n        for i, length in enumerate(A):\n            if i > reachable:\n                return -1\n            if i > curr_reachable:\n                curr_reachable = reachable\n                jump_count += 1\n            reachable = max(reachable, i + length)\n        return jump_count\n\n\n"
    },
    {
        "problem_name": "jump-game-iii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def canReach(self, arr, start):\n        \"\"\"\n        :type arr: List[int]\n        :type start: int\n        :rtype: bool\n        \"\"\"\n        q, lookup = collections.deque([start]), set([start])\n        while q:\n            i = q.popleft()\n            if not arr[i]:\n                return True\n            for j in [i-arr[i], i+arr[i]]:\n                if 0 <= j < len(arr) and j not in lookup:\n                    lookup.add(j)\n                    q.append(j) \n        return False\n"
    },
    {
        "problem_name": "jump-game-iv",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def minJumps(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        groups = collections.defaultdict(list)\n        for i, x in enumerate(arr):\n            groups[x].append(i)\n        q = collections.deque([(0, 0)])\n        lookup = set([0])\n        while q:\n            pos, step = q.popleft()\n            if pos == len(arr)-1:\n                break\n            neighbors = set(groups[arr[pos]] + [pos-1, pos+1])\n            groups[arr[pos]] = []\n            for p in neighbors:\n                if p in lookup or not 0 <= p < len(arr):\n                    continue\n                lookup.add(p)\n                q.append((p, step+1)) \n        return step\n"
    },
    {
        "problem_name": "jump-game-ix",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp, mono stack\nclass Solution(object):\n    def minCost(self, nums, costs):\n        \"\"\"\n        :type nums: List[int]\n        :type costs: List[int]\n        :rtype: int\n        \"\"\"\n        stk1, stk2 = [], []\n        dp = [float(\"inf\")]*len(nums)\n        dp[0] = 0\n        for i in xrange(len(nums)):\n            while stk1 and nums[stk1[-1]] <= nums[i]:\n                dp[i] = min(dp[i], dp[stk1.pop()]+costs[i])\n            stk1.append(i)\n            while stk2 and nums[stk2[-1]] > nums[i]:\n                dp[i] = min(dp[i], dp[stk2.pop()]+costs[i])\n            stk2.append(i)\n        return dp[-1]\n"
    },
    {
        "problem_name": "jump-game-v",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\nimport itertools\n\n\n# sliding window + top-down dp\nclass Solution(object):\n    def maxJumps(self, arr, d):\n        \"\"\"\n        :type arr: List[int]\n        :type d: int\n        :rtype: int\n        \"\"\"\n        def dp(arr, d, i, left, right, lookup):\n            if lookup[i]:\n                return lookup[i]\n            lookup[i] = 1\n            for j in itertools.chain(left[i], right[i]):\n                # each dp[j] will be visited at most twice \n                lookup[i] = max(lookup[i], dp(arr, d, j, left, right, lookup)+1)\n            return lookup[i]\n\n        left, decreasing_dq = [[] for _ in xrange(len(arr))], collections.deque()\n        for i in xrange(len(arr)):\n            if decreasing_dq and i - decreasing_dq[0] == d+1:\n                decreasing_dq.popleft()\n            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:\n                if left[i] and arr[left[i][-1]] != arr[decreasing_dq[-1]]:\n                    left[i] = []\n                left[i].append(decreasing_dq.pop())\n            decreasing_dq.append(i)\n        right, decreasing_dq = [[] for _ in xrange(len(arr))], collections.deque()\n        for i in reversed(xrange(len(arr))):\n            if decreasing_dq and decreasing_dq[0] - i == d+1:\n                decreasing_dq.popleft()\n            while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:\n                if right[i] and arr[right[i][-1]] != arr[decreasing_dq[-1]]:\n                    right[i] = []\n                right[i].append(decreasing_dq.pop())\n            decreasing_dq.append(i)\n\n        lookup = [0]*len(arr)\n        return max(itertools.imap(lambda x: dp(arr, d, x, left, right, lookup), xrange(len(arr))))\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# mono stack + bottom-up dp\nclass Solution2(object):\n    def maxJumps(self, arr, d):\n        \"\"\"\n        :type arr: List[int]\n        :type d: int\n        :rtype: int\n        \"\"\"\n        left, decreasing_stk = [[] for _ in xrange(len(arr))], []\n        for i in xrange(len(arr)):\n            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:\n                if i - decreasing_stk[-1] <= d:\n                    if left[i] and arr[left[i][-1]] != arr[decreasing_stk[-1]]:\n                        left[i] = []\n                    left[i].append(decreasing_stk[-1])\n                decreasing_stk.pop()\n            decreasing_stk.append(i)\n        right, decreasing_stk = [[] for _ in xrange(len(arr))], []\n        for i in reversed(xrange(len(arr))):\n            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:\n                if decreasing_stk[-1] - i <= d:\n                    if right[i] and arr[right[i][-1]] != arr[decreasing_stk[-1]]:\n                        right[i] = []\n                    right[i].append(decreasing_stk[-1])\n                decreasing_stk.pop()\n            decreasing_stk.append(i)\n\n        dp = [0]*len(arr)\n        for a, i in sorted([a, i] for i, a in enumerate(arr)):\n            dp[i] = 1\n            for j in itertools.chain(left[i], right[i]):\n                # each dp[j] will be visited at most twice \n                dp[i] = max(dp[i], dp[j]+1)\n        return max(dp)\n\n\n# Template:\n# https://github.com/kamyu104/FacebookHackerCup-2018/blob/master/Final%20Round/the_claw.py\nclass SegmentTree(object):\n    def __init__(self, N,\n                 build_fn=lambda x, y: [y]*(2*x),\n                 query_fn=max,\n                 update_fn=lambda x, y: y,\n                 default_val=0):\n        self.N = N\n        self.H = (N-1).bit_length()\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        self.default_val = default_val\n        self.tree = build_fn(N, default_val)\n        self.lazy = [None]*N\n\n    def __apply(self, x, val):\n        self.tree[x] = self.update_fn(self.tree[x], val)\n        if x < self.N:\n            self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n    def update(self, L, R, h):  # Time: O(logN), Space: O(N)\n        def pull(x):\n            while x > 1:\n                x //= 2\n                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n                if self.lazy[x] is not None:\n                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\n        L += self.N\n        R += self.N\n        L0, R0 = L, R\n        while L <= R:\n            if L & 1:  # is right child\n                self.__apply(L, h)\n                L += 1\n            if R & 1 == 0:  # is left child\n                self.__apply(R, h)\n                R -= 1\n            L //= 2\n            R //= 2\n        pull(L0)\n        pull(R0)\n\n    def query(self, L, R):  # Time: O(logN), Space: O(N)\n        def push(x):\n            n = 2**self.H\n            while n != 1:\n                y = x // n\n                if self.lazy[y] is not None:\n                    self.__apply(y*2, self.lazy[y])\n                    self.__apply(y*2 + 1, self.lazy[y])\n                    self.lazy[y] = None\n                n //= 2\n\n        result = self.default_val\n        if L > R:\n            return result\n\n        L += self.N\n        R += self.N\n        push(L)\n        push(R)\n        while L <= R:\n            if L & 1:  # is right child\n                result = self.query_fn(result, self.tree[L])\n                L += 1\n            if R & 1 == 0:  # is left child\n                result = self.query_fn(result, self.tree[R])\n                R -= 1\n            L //= 2\n            R //= 2\n        return result\n    \n    def __str__(self):\n        showList = []\n        for i in xrange(self.N):\n            showList.append(self.query(i, i))\n        return \",\".join(map(str, showList))\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# mono stack + bottom-up dp + segment tree\nclass Solution3(object):\n    def maxJumps(self, arr, d):\n        \"\"\"\n        :type arr: List[int]\n        :type d: int\n        :rtype: int\n        \"\"\"\n        left, decreasing_stk = range(len(arr)), []\n        for i in xrange(len(arr)):\n            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:\n                if i - decreasing_stk[-1] <= d:\n                    left[i] = decreasing_stk[-1]\n                decreasing_stk.pop()\n            decreasing_stk.append(i)\n        right, decreasing_stk = range(len(arr)), []\n        for i in reversed(xrange(len(arr))):\n            while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:\n                if decreasing_stk[-1] - i <= d:\n                    right[i] = decreasing_stk[-1]\n                decreasing_stk.pop()\n            decreasing_stk.append(i)\n\n        segment_tree = SegmentTree(len(arr))\n        for _, i in sorted([x, i] for i, x in enumerate(arr)):\n            segment_tree.update(i, i, segment_tree.query(left[i], right[i]) + 1)\n        return segment_tree.query(0, len(arr)-1)\n"
    },
    {
        "problem_name": "jump-game-vi",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\nimport collections\n\n\nclass Solution(object):\n    def maxResult(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        score = 0\n        dq = collections.deque()\n        for i, num in enumerate(nums):\n            if dq and dq[0][0] == i-k-1:\n                dq.popleft()\n            score = num if not dq else dq[0][1]+num\n            while dq and dq[-1][1] <= score:\n                dq.pop()\n            dq.append((i, score))\n        return score\n"
    },
    {
        "problem_name": "jump-game-vii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# dp with line sweep solution\nclass Solution(object):\n    def canReach(self, s, minJump, maxJump):\n        \"\"\"\n        :type s: str\n        :type minJump: int\n        :type maxJump: int\n        :rtype: bool\n        \"\"\"\n        dp = [False]*len(s)\n        dp[0] = True\n        cnt = 0\n        for i in xrange(1, len(s)):\n            if i >= minJump:\n                cnt += dp[i-minJump]\n            if i > maxJump:\n                cnt -= dp[i-maxJump-1]\n            dp[i] = cnt > 0 and s[i] == '0'\n        return dp[-1]\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\n# bfs solution\nclass Solution2(object):\n    def canReach(self, s, minJump, maxJump):\n        \"\"\"\n        :type s: str\n        :type minJump: int\n        :type maxJump: int\n        :rtype: bool\n        \"\"\"\n        q = collections.deque([0])\n        reachable = 0\n        while q:\n            i = q.popleft()\n            for j in xrange(max(i+minJump, reachable+1), min(i+maxJump+1, len(s))):\n                if s[j] != '0':\n                    continue\n                q.append(j)\n            reachable = i+maxJump\n        return i == len(s)-1\n"
    },
    {
        "problem_name": "jump-game",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param A, a list of integers\n    # @return a boolean\n    def canJump(self, A):\n        reachable = 0\n        for i, length in enumerate(A):\n            if i > reachable:\n                break\n            reachable = max(reachable, i + length)\n        return reachable >= len(A) - 1\n\n"
    },
    {
        "problem_name": "k-closest-points-to-origin",
        "solution": "# Time:  O(n) on average\n# Space: O(1)\n\n# quick select solution\nfrom random import randint\n\n\nclass Solution(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dist(point):\n            return point[0]**2 + point[1]**2\n        \n        def kthElement(nums, k, compare):\n            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == k:\n                    return\n                elif new_pivot_idx > k:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < k.\n                    left = new_pivot_idx + 1\n                    \n        kthElement(points, K-1, lambda a, b: dist(a) < dist(b))\n        return points[:K]\n\n    \n# Time:  O(nlogk)\n# Space: O(k)\nimport heapq\n\n\nclass Solution2(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dist(point):\n            return point[0]**2 + point[1]**2\n        \n        max_heap = []\n        for point in points:\n            heapq.heappush(max_heap, (-dist(point), point))\n            if len(max_heap) > K:\n                heapq.heappop(max_heap)\n        return [heapq.heappop(max_heap)[1] for _ in xrange(len(max_heap))]\n"
    },
    {
        "problem_name": "k-concatenation-maximum-sum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def kConcatenationMaxSum(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def max_sub_k_array(arr, k):\n            result, curr = float(\"-inf\"), float(\"-inf\")\n            for _ in xrange(k):\n                for x in arr:\n                    curr = max(curr+x, x)\n                    result = max(result, curr)\n            return result\n        \n        MOD = 10**9+7\n        if k == 1:\n            return max(max_sub_k_array(arr, 1), 0) % MOD\n        return (max(max_sub_k_array(arr, 2), 0) + (k-2)*max(sum(arr), 0)) % MOD\n"
    },
    {
        "problem_name": "k-diff-pairs-in-an-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def findPairs(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k < 0: return 0\n        result, lookup = set(), set()\n        for num in nums:\n            if num-k in lookup:\n                result.add(num-k)\n            if num+k in lookup:\n                result.add(num)\n            lookup.add(num)\n        return len(result)\n\n"
    },
    {
        "problem_name": "k-divisible-elements-subarrays",
        "solution": "# Time:  O(n^2)\n# Space: O(t), t is the size of trie\n\nimport collections\n\n\n# trie\nclass Solution(object):\n    def countDistinct(self, nums, k, p):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        result = 0\n        for i in xrange(len(nums)):\n            cnt = 0\n            curr = trie\n            for j in xrange(i, len(nums)):\n                cnt += (nums[j]%p == 0)\n                if cnt > k:\n                    break\n                if nums[j] not in curr:\n                    result += 1\n                curr = curr[nums[j]]\n        return result\n\n\n# Time:  O(n^2) on average, worst is O(n^3)\n# Space: O(n)\nimport collections\n\n\n# rolling hash\nclass Solution2(object):\n    def countDistinct(self, nums, k, p):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        MOD, P = 10**9+7, 113\n        def check(nums, lookup, l, i):\n            return all(any(nums[i+k] != nums[j+k] for k in xrange(l)) for j in lookup)\n\n        result = 0\n        cnt, h = [0]*len(nums), [0]*len(nums)\n        for l in xrange(1, len(nums)+1):\n            lookup = collections.defaultdict(list)\n            for i in xrange(len(nums)-l+1):\n                cnt[i] += (nums[i+l-1]%p == 0)\n                if cnt[i] > k:\n                    continue\n                h[i] = (h[i]*P+nums[i+l-1])%MOD\n                if not check(nums, lookup[h[i]], l, i):\n                    continue\n                lookup[h[i]].append(i)\n                result += 1\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# rolling hash\nclass Solution3(object):\n    def countDistinct(self, nums, k, p):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type p: int\n        :rtype: int\n        \"\"\"\n        MOD, P = 10**9+7, 200\n        result = 0\n        cnt, h = [0]*len(nums), [0]*len(nums)\n        for l in xrange(1, len(nums)+1):\n            lookup = set()\n            for i in xrange(len(nums)-l+1):\n                cnt[i] += (nums[i+l-1]%p == 0)\n                if cnt[i] > k:\n                    continue\n                h[i] = (h[i]*P+nums[i+l-1])%MOD\n                lookup.add(h[i])\n            result += len(lookup)\n        return result\n"
    },
    {
        "problem_name": "k-empty-slots",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def kEmptySlots(self, flowers, k):\n        \"\"\"\n        :type flowers: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        days = [0] * len(flowers)\n        for i in xrange(len(flowers)):\n            days[flowers[i]-1] = i\n        result = float(\"inf\")\n        i, left, right = 0, 0, k+1\n        while right < len(days):\n            if days[i] < days[left] or days[i] <= days[right]:\n                if i == right:\n                    result = min(result, max(days[left], days[right]))\n                left, right = i, k+1+i\n            i += 1\n        return -1 if result == float(\"inf\") else result+1\n\n\n"
    },
    {
        "problem_name": "k-highest-ranked-items-within-a-price-range",
        "solution": "# Time:  O(m * n + klogk)\n# Space: O(m * n)\n\nimport random\n\n\n# bfs, quick select\nclass Solution(object):\n    def highestRankedKItems(self, grid, pricing, start, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type pricing: List[int]\n        :type start: List[int]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            right = len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        def get_val(x):\n            return (lookup[x[0]][x[1]], grid[x[0]][x[1]], x[0], x[1])\n    \n        result = []\n        q = [start]\n        lookup = [[-1]*len(grid[0]) for _ in xrange(len(grid))]\n        d = lookup[start[0]][start[1]] = 0\n        while q:\n            if len(result) >= k:\n                if len(result) > k:\n                    nth_element(result, k-1, compare=lambda a, b: get_val(a) < get_val(b))\n                    result = result[:k]\n                break\n            new_q = []\n            for r, c in q:\n                if pricing[0] <= grid[r][c] <= pricing[1]:\n                    result.append([r, c])\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] and lookup[nr][nc] == -1):\n                        continue\n                    lookup[nr][nc] = d+1\n                    new_q.append((nr, nc))\n            q = new_q\n            d += 1\n        result.sort(key=lambda x: get_val(x))\n        return result\n"
    },
    {
        "problem_name": "k-inverse-pairs-array",
        "solution": "# Time:  O(n * k)\n# Space: O(k)\n\nclass Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        M = 1000000007\n        dp = [[0]*(k+1) for _ in xrange(2)]\n        dp[0][0] = 1\n        for i in xrange(1, n+1):\n            dp[i%2] = [0]*(k+1)\n            dp[i%2][0] = 1\n            for j in xrange(1, k+1):\n                dp[i%2][j] = (dp[i%2][j-1] + dp[(i-1)%2][j]) % M\n                if j-i >= 0:\n                    dp[i%2][j] = (dp[i%2][j] - dp[(i-1)%2][j-i]) % M\n        return dp[n%2][k]\n\n"
    },
    {
        "problem_name": "k-items-with-the-maximum-sum",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# greedy, math\nclass Solution(object):\n    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):\n        \"\"\"\n        :type numOnes: int\n        :type numZeros: int\n        :type numNegOnes: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return min(numOnes, k)-max(k-numOnes-numZeros, 0)\n"
    },
    {
        "problem_name": "k-radius-subarray-averages",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def getAverages(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        total, l = 0, 2*k+1\n        result = [-1]*len(nums)\n        for i in xrange(len(nums)):\n            total += nums[i]\n            if i-l >= 0:\n                total -= nums[i-l]\n            if i >= l-1:\n                result[i-k] = total//l\n        return result\n"
    },
    {
        "problem_name": "k-similar-strings",
        "solution": "# Time:  O(n * n!/(c_a!*...*c_z!), n is the length of A, B,\n#                                  c_a...c_z is the count of each alphabet,\n#                                  n = sum(c_a...c_z)\n# Space: O(n * n!/(c_a!*...*c_z!)\n\nimport collections\n\n\nclass Solution(object):\n    def kSimilarity(self, A, B):\n        \"\"\"\n        :type A: str\n        :type B: str\n        :rtype: int\n        \"\"\"\n        def neighbors(s, B):\n            for i, c in enumerate(s):\n                if c != B[i]:\n                    break\n            t = list(s)\n            for j in xrange(i+1, len(s)):\n                if t[j] == B[i]:\n                    t[i], t[j] = t[j], t[i]\n                    yield \"\".join(t)\n                    t[j], t[i] = t[i], t[j]\n\n        q = collections.deque([A])\n        lookup = set()\n        result = 0\n        while q:\n            for _ in xrange(len(q)):\n                s = q.popleft()\n                if s == B:\n                    return result\n                for t in neighbors(s, B):\n                    if t not in lookup:\n                        lookup.add(t)\n                        q.append(t)\n            result += 1\n\n"
    },
    {
        "problem_name": "k-th-smallest-in-lexicographical-order",
        "solution": "# Time:  O(logn)\n# Space: O(logn)\n\nclass Solution(object):\n    def findKthNumber(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n\n        cnts = [0] * 10\n        for i in xrange(1, 10):\n            cnts[i] = cnts[i - 1] * 10 + 1\n\n        nums = []\n        i = n\n        while i:\n            nums.append(i % 10)\n            i /= 10\n\n        total, target = n, 0\n        i = len(nums) - 1\n        while i >= 0 and k > 0:\n            target = target*10 + nums[i]\n            start = int(i == len(nums)-1)\n            for j in xrange(start, 10):\n                candidate = result*10 + j\n                if candidate < target:\n                    num = cnts[i+1]\n                elif candidate > target:\n                    num = cnts[i]\n                else:\n                    num = total - cnts[i + 1]*(j-start) - cnts[i]*(9-j)\n                if k > num:\n                    k -= num\n                else:\n                    result = candidate\n                    k -= 1\n                    total = num-1\n                    break\n            i -= 1\n\n        return result\n\n\n# Time:  O(logn * logn)\n# Space: O(logn)\nclass Solution2(object):\n    def findKthNumber(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def count(n, prefix):\n            result, number = 0, 1\n            while prefix <= n:\n                result += number\n                prefix *= 10\n                number *= 10\n            result -= max(number/10 - (n - prefix/10 + 1), 0)\n            return result\n\n        def findKthNumberHelper(n, k, cur, index):\n            if cur:\n                index += 1\n                if index == k:\n                    return (cur, index)\n\n            i = int(cur == 0)\n            while i <= 9:\n                cur = cur * 10 + i\n                cnt = count(n, cur)\n                if k > cnt + index:\n                    index += cnt\n                elif cur <= n:\n                    result = findKthNumberHelper(n, k, cur, index)\n                    if result[0]:\n                        return result\n                i += 1\n                cur /= 10\n            return (0, index)\n\n        return findKthNumberHelper(n, k, 0, 0)[0]\n\n"
    },
    {
        "problem_name": "k-th-smallest-prime-fraction",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\nclass Solution(object):\n    def kthSmallestPrimeFraction(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: List[int]\n        \"\"\"\n        def check(mid, A, K, result):\n            tmp = [0]*2\n            count = 0\n            j = 0\n            for i in xrange(len(A)):\n                while j < len(A):\n                    if i < j and A[i] < A[j]*mid:\n                        if tmp[0] == 0 or \\\n                           tmp[0]*A[j] < tmp[1]*A[i]:\n                            tmp[0] = A[i]\n                            tmp[1] = A[j]\n                        break\n                    j += 1\n                count += len(A)-j\n            if count == K:\n                result[:] = tmp\n            return count >= K\n\n        result = []\n        left, right = 0.0, 1.0\n        while right-left > 1e-8:\n            mid = left + (right-left) / 2.0\n            if check(mid, A, K, result):\n                right = mid\n            else:\n                left = mid\n            if result:\n                break\n        return result\n\n"
    },
    {
        "problem_name": "k-th-symbol-in-grammar",
        "solution": "# Time:  O(logn) = O(1) because n is 32-bit integer\n# Space: O(1)\n\nclass Solution(object):\n    def kthGrammar(self, N, K):\n        \"\"\"\n        :type N: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n        def bitCount(n):\n            result = 0\n            while n:\n                n &= n - 1\n                result += 1\n            return result\n\n        return bitCount(K-1) % 2\n\n"
    },
    {
        "problem_name": "keep-multiplying-found-values-by-two",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table\nclass Solution(object):\n    def findFinalValue(self, nums, original):\n        \"\"\"\n        :type nums: List[int]\n        :type original: int\n        :rtype: int\n        \"\"\"\n        lookup = set(nums)\n        while original in lookup:\n            original *= 2\n        return original\n"
    },
    {
        "problem_name": "keyboard-row",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        rows = [set(['q', 'w', 'e', 'r', 't', 'y','u', 'i', 'o', 'p']),\n                set(['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l']),\n                set(['z', 'x', 'c', 'v', 'b' ,'n', 'm'])]\n\n        result = []\n        for word in words:\n            k = 0\n            for i in xrange(len(rows)):\n                if word[0].lower() in rows[i]:\n                    k = i\n                    break\n            for c in word:\n                if c.lower() not in rows[k]:\n                    break\n            else:\n                result.append(word)\n        return result\n\n\nclass Solution2(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        keyboard_rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']\n        single_row_words = []\n        for word in words:\n            for row in keyboard_rows:\n                if all(letter in row for letter in word.lower()):\n                    single_row_words.append(word)\n        return single_row_words\n\n"
    },
    {
        "problem_name": "keys-and-rooms",
        "solution": "# Time:  O(n!)\n# Space: O(n)\n\nclass Solution(object):\n    def canVisitAllRooms(self, rooms):\n        \"\"\"\n        :type rooms: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        lookup = set([0])\n        stack = [0]\n        while stack:\n            node = stack.pop()\n            for nei in rooms[node]:\n                if nei not in lookup:\n                    lookup.add(nei)\n                    if len(lookup) == len(rooms):\n                        return True\n                    stack.append(nei)\n        return len(lookup) == len(rooms)\n\n"
    },
    {
        "problem_name": "kids-with-the-greatest-number-of-candies",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def kidsWithCandies(self, candies, extraCandies):\n        \"\"\"\n        :type candies: List[int]\n        :type extraCandies: int\n        :rtype: List[bool]\n        \"\"\"\n        max_num = max(candies)\n        return [x + extraCandies >= max_num for x in candies]\n"
    },
    {
        "problem_name": "kill-process",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# DFS solution.\nclass Solution(object):\n    def killProcess(self, pid, ppid, kill):\n        \"\"\"\n        :type pid: List[int]\n        :type ppid: List[int]\n        :type kill: int\n        :rtype: List[int]\n        \"\"\"\n        def killAll(pid, children, killed):\n            killed.append(pid)\n            for child in children[pid]:\n                killAll(child, children, killed)\n\n        result = []\n        children = collections.defaultdict(set)\n        for i in xrange(len(pid)):\n            children[ppid[i]].add(pid[i])\n        killAll(kill, children, result)\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\n# BFS solution.\nclass Solution2(object):\n    def killProcess(self, pid, ppid, kill):\n        \"\"\"\n        :type pid: List[int]\n        :type ppid: List[int]\n        :type kill: int\n        :rtype: List[int]\n        \"\"\"\n        def killAll(pid, children, killed):\n            killed.append(pid)\n            for child in children[pid]:\n                killAll(child, children, killed)\n\n        result = []\n        children = collections.defaultdict(set)\n        for i in xrange(len(pid)):\n            children[ppid[i]].add(pid[i])\n        q = collections.deque()\n        q.append(kill)\n        while q:\n            p = q.popleft()\n            result.append(p)\n            for child in children[p]:\n                q.append(child)\n        return result\n\n"
    },
    {
        "problem_name": "knight-dialer",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def knightDialer(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) % M \\\n                     for col in ZB] for row in A]\n        \n        M = 10**9 + 7\n        T = [[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\n             [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],\n             [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n             [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\n             [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n             [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n             [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\n             [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],\n             [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]]\n        return sum(map(sum, matrix_expo(T, N-1))) % M\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def knightDialer(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        M = 10**9 + 7\n        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [],\n                 [1, 7, 0], [2, 6], [1, 3], [2, 4]]\n\n        dp = [[1 for _ in xrange(10)] for _ in xrange(2)]\n        for i in xrange(N-1):\n            dp[(i+1) % 2] = [0] * 10\n            for j in xrange(10):\n                for nei in moves[j]:\n                    dp[(i+1) % 2][nei] += dp[i % 2][j]\n                    dp[(i+1) % 2][nei] %= M\n        return sum(dp[(N-1) % 2]) % M\n"
    },
    {
        "problem_name": "knight-probability-in-chessboard",
        "solution": "# Time:  O(k * n^2)\n# Space: O(n^2)\n\nclass Solution(object):\n    def knightProbability(self, N, K, r, c):\n        \"\"\"\n        :type N: int\n        :type K: int\n        :type r: int\n        :type c: int\n        :rtype: float\n        \"\"\"\n        directions = \\\n            [[ 1, 2], [ 1, -2], [ 2, 1], [ 2, -1], \\\n             [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n        dp = [[[1 for _ in xrange(N)] for _ in xrange(N)] for _ in xrange(2)]\n        for step in xrange(1, K+1):\n            for i in xrange(N):\n                for j in xrange(N):\n                    dp[step%2][i][j] = 0\n                    for direction in directions:\n                        rr, cc = i+direction[0], j+direction[1]\n                        if 0 <= cc < N and 0 <= rr < N:\n                            dp[step%2][i][j] += 0.125 * dp[(step-1)%2][rr][cc]\n\n        return dp[K%2][r][c]\n\n"
    },
    {
        "problem_name": "koko-eating-bananas",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\nclass Solution(object):\n    def minEatingSpeed(self, piles, H):\n        \"\"\"\n        :type piles: List[int]\n        :type H: int\n        :rtype: int\n        \"\"\"\n        def possible(piles, H, K):\n            return sum((pile-1)//K+1 for pile in piles) <= H\n\n        left, right = 1, max(piles)\n        while left <= right:\n            mid = left + (right-left)//2\n            if possible(piles, H, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n\n"
    },
    {
        "problem_name": "kth-ancestor-of-a-tree-node",
        "solution": "# Time:  ctor: O(n * logh)\n#        get:  O(logh)\n# Space: O(n * logh)\n\n# binary jump solution (frequently used in competitive programming)\n# Template:\n# https://github.com/kamyu104/FacebookHackerCup-2019/blob/master/Final%20Round/little_boat_on_the_sea.py\nclass TreeAncestor(object):\n\n    def __init__(self, n, parent):\n        \"\"\"\n        :type n: int\n        :type parent: List[int]\n        \"\"\"\n        par = [[p] if p != -1 else [] for p in parent]\n        q = [par[i] for i, p in enumerate(parent) if p != -1]\n        i = 0\n        while q:\n            new_q = []\n            for p in q:\n                if not (i < len(par[p[i]])):\n                    continue\n                p.append(par[p[i]][i])\n                new_q.append(p)\n            q = new_q\n            i += 1\n        self.__parent = par\n\n    def getKthAncestor(self, node, k):\n        \"\"\"\n        :type node: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        par, i, pow_i_of_2 = self.__parent, 0, 1\n        while pow_i_of_2 <= k:\n            if k & pow_i_of_2:\n                if not (i < len(par[node])):\n                    return -1\n                node = par[node][i]\n            i += 1\n            pow_i_of_2 *= 2\n        return node\n"
    },
    {
        "problem_name": "kth-distinct-string-in-an-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def kthDistinct(self, arr, k):\n        \"\"\"\n        :type arr: List[str]\n        :type k: int\n        :rtype: str\n        \"\"\"\n        count = collections.Counter(arr)\n        arr = [x for x in arr if count[x] == 1]\n        return arr[k-1] if k-1 < len(arr) else \"\"\n"
    },
    {
        "problem_name": "kth-largest-element-in-a-stream",
        "solution": "# Time:  O(nlogk)\n# Space: O(k)\n\nimport heapq\n\n\nclass KthLargest(object):\n\n    def __init__(self, k, nums):\n        \"\"\"\n        :type k: int\n        :type nums: List[int]\n        \"\"\"\n        self.__k = k\n        self.__min_heap = []\n        for n in nums:\n            self.add(n)\n        \n\n    def add(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: int\n        \"\"\"\n        heapq.heappush(self.__min_heap, val)\n        if len(self.__min_heap) > self.__k:\n            heapq.heappop(self.__min_heap)\n        return self.__min_heap[0]\n\n\n\n"
    },
    {
        "problem_name": "kth-largest-element-in-an-array",
        "solution": "# Time:  O(n) on average, using Median of Medians could achieve O(n) (Intro Select)\n# Space: O(1)\n\nfrom random import randint\n\n\n# optimized for duplicated nums\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        nth_element(nums, k-1, compare=lambda a, b: a > b)\n        return nums[k-1]\n\n\n# Time:  O(n) on average, using Median of Medians could achieve O(n) (Intro Select)\n# Space: O(1)\nclass Solution2(object):\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k - 1:\n                return nums[new_pivot_idx]\n            elif new_pivot_idx > k - 1:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k - 1.\n                left = new_pivot_idx + 1\n\n    def PartitionAroundPivot(self, left, right, pivot_idx, nums):\n        pivot_value = nums[pivot_idx]\n        new_pivot_idx = left\n        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n        for i in xrange(left, right):\n            if nums[i] > pivot_value:\n                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                new_pivot_idx += 1\n\n        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n        return new_pivot_idx\n\n"
    },
    {
        "problem_name": "kth-largest-sum-in-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nimport random\n\n\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\n# bfs, quick select\nclass Solution(object):\n    def kthLargestLevelSum(self, root, k):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n            \n            right = len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n    \n        arr = []\n        q = [root]\n        while q:\n            new_q = []\n            for u in q:\n                if u.left:\n                    new_q.append(u.left)\n                if u.right:\n                    new_q.append(u.right)\n            arr.append(sum(x.val for x in q))\n            q = new_q\n        if k-1 >= len(arr):\n            return -1\n        nth_element(arr, k-1, compare=lambda a, b: a > b)\n        return arr[k-1]\n"
    },
    {
        "problem_name": "kth-missing-positive-number",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def findKthPositive(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(arr, k, x):\n            return arr[x]-(x+1) < k\n\n        left, right = 0, len(arr)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(arr, k, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right+1+k  # arr[right] + (k-(arr[right]-(right+1))) if right >= 0 else k\n"
    },
    {
        "problem_name": "kth-smallest-amount-with-single-denomination-combination",
        "solution": "# Time:  O(n * 2^n * (log(mx) + log(k * mn))) = O(n * 2^n * logk), mn = min(coins), mx = max(coins)\n# Space: O(2^n)\n\nimport itertools\n\n\n# binary search, principle of inclusion and exclusion, number theory\nclass Solution(object):\n    def findKthSmallest(self, coins, k):\n        \"\"\"\n        :type coins: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n        \n        def lcm(a, b):\n            return a//gcd(a, b)*b\n        \n        def check(target):\n            return sum((-1 if (i+1)&1 else +1)*(target//l) for i in xrange(1, len(coins)+1) for l in lookup[i]) >= k\n\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        lookup = [[] for _ in xrange(len(coins)+1)]\n        for i in xrange(1, len(coins)+1):\n            for comb in itertools.combinations(coins, i):\n                lookup[i].append(reduce(lcm, comb))\n        mn = min(coins)\n        l = 1\n        for i in xrange(1, 25+1):\n            l = lcm(l, i)\n        return binary_search(mn, k*mn, check)\n\n\n# Time:  O(n * 2^n * (log(mx) + log(k * mn))) = O(n * 2^n * logk), mn = min(coins), mx = max(coins)\n# Space: O(2^n)\n# binary search, principle of inclusion and exclusion, number theory\nclass Solution2(object):\n    def findKthSmallest(self, coins, k):\n        \"\"\"\n        :type coins: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def popcount(x):\n            return bin(x).count('1')\n\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n        \n        def lcm(a, b):\n            return a//gcd(a, b)*b\n    \n        def check(target):\n            return sum((-1 if (i+1)&1 else +1)*(target//l) for i in xrange(1, len(coins)+1) for l in lookup[i]) >= k\n\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n    \n        lookup = [[] for _ in xrange(len(coins)+1)]\n        for mask in xrange(1, 1<<len(coins)):\n            lookup[popcount(mask)].append(reduce(lcm, (coins[i] for i in xrange(len(coins)) if mask&(1<<i))))\n        mn = min(coins)\n        return binary_search(mn, k*mn, check)\n"
    },
    {
        "problem_name": "kth-smallest-element-in-a-bst",
        "solution": "# Time:  O(max(h, k))\n# Space: O(h)\n\nclass Solution(object):\n    # @param {TreeNode} root\n    # @param {integer} k\n    # @return {integer}\n    def kthSmallest(self, root, k):\n        s, cur, rank = [], root, 0\n\n        while s or cur:\n            if cur:\n                s.append(cur)\n                cur = cur.left\n            else:\n                cur = s.pop()\n                rank += 1\n                if rank == k:\n                    return cur.val\n                cur = cur.right\n\n        return float(\"-inf\")\n\n\n# time: O(max(h, k))\n# space: O(h)\n\nfrom itertools import islice\n\n\nclass Solution2(object):\n    def kthSmallest(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gen_inorder(root):\n            if root:\n                for n in gen_inorder(root.left):\n                    yield n\n\n                yield root.val\n\n                for n in gen_inorder(root.right):\n                    yield n\n\n        return next(islice(gen_inorder(root), k-1, k))\n"
    },
    {
        "problem_name": "kth-smallest-element-in-a-sorted-matrix",
        "solution": "# Time:  O(k * log(min(n, m, k))), with n x m matrix\n# Space: O(min(n, m, k))\n\nfrom heapq import heappush, heappop\n\nclass Solution(object):\n    def kthSmallest(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        kth_smallest = 0\n        min_heap = []\n\n        def push(i, j):\n            if len(matrix) > len(matrix[0]):\n                if i < len(matrix[0]) and j < len(matrix):\n                    heappush(min_heap, [matrix[j][i], i, j])\n            else:\n                if i < len(matrix) and j < len(matrix[0]):\n                    heappush(min_heap, [matrix[i][j], i, j])\n\n        push(0, 0)\n        while min_heap and k > 0:\n            kth_smallest, i, j = heappop(min_heap)\n            push(i, j + 1)\n            if j == 0:\n                push(i + 1, 0)\n            k -= 1\n\n        return kth_smallest\n\n"
    },
    {
        "problem_name": "kth-smallest-instructions",
        "solution": "# Time:  O((m + n)^2)\n# Space: O(1)\n\nclass Solution(object):\n    def kthSmallestPath(self, destination, k):\n        \"\"\"\n        :type destination: List[int]\n        :type k: int\n        :rtype: str\n        \"\"\"\n        def nCr(n, r):  # Time: O(n), Space: O(1)\n            if n < r:\n                return 0\n            if n-r < r:\n                return nCr(n, n-r)\n            c = 1\n            for k in xrange(1, r+1):\n                c *= n-k+1\n                c //= k\n            return c\n\n        r, c = destination        \n        result = []\n        while r+c:\n            count = nCr(r+(c-1), r)  # the number of HX..X combinations\n            if k <= count:  # the kth instruction is one of HX..X combinations, so go right\n                c -= 1\n                result.append('H')\n            else:  # the kth instruction is one of VX..X combinations, so go down\n                k -= count  # the kth one of XX..X combinations is the (k-count)th one of VX..X combinations\n                r -= 1\n                result.append('V')\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "kth-smallest-number-in-multiplication-table",
        "solution": "# Time:  O(m * log(m * n))\n# Space: O(1)\n\nclass Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def count(target, m, n):\n            return sum(min(target//i, n) for i in xrange(1, m+1))\n\n        left, right = 1, m*n\n        while left <= right:\n            mid = left + (right-left)/2\n            if count(mid, m, n) >= k:\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n\n"
    },
    {
        "problem_name": "kth-smallest-product-of-two-sorted-arrays",
        "solution": "# Time:  O((m + n) * logr), r is the range size of [min(products), max(products)]\n# Space: O(1)\n\nclass Solution(object):\n    def kthSmallestProduct(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(nums1, nums2, k, neg_cnt, target):\n            cnt = 0\n            left, right = 0, len(nums2)-1\n            direction = reversed if target >= 0 else lambda x: x\n            for i in direction(xrange(neg_cnt)):\n                while left < len(nums2) and nums1[i]*nums2[left] > target:\n                    left += 1\n                cnt += (len(nums2)-1)-left+1\n            direction = (lambda x: x) if target >= 0 else reversed\n            for i in direction(xrange(neg_cnt, len(nums1))): \n                if nums1[i] == 0: \n                    if target >= 0:\n                        cnt += len(nums2)\n                    continue\n                while right >= 0 and nums1[i]*nums2[right] > target:\n                    right -= 1\n                cnt += right-0+1\n            return cnt >= k\n\n        neg_cnt = sum(x < 0 for x in nums1)\n        left = min(nums1[i]*nums2[j] for i in (0, -1) for j in (0, -1))\n        right = max(nums1[i]*nums2[j] for i in (0, -1) for j in (0, -1))\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(nums1, nums2, k, neg_cnt, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "kth-smallest-subarray-sum",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\nclass Solution(object):\n    def kthSmallestSubarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(nums, k, x):\n            cnt = curr = left = 0\n            for right in xrange(len(nums)):\n                curr += nums[right]\n                while curr > x:\n                    curr -= nums[left]\n                    left += 1\n                cnt += right-left+1\n            return cnt >= k\n\n        left, right = min(nums), sum(nums)\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(nums, k, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "largest-1-bordered-square",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\nclass Solution(object):\n    def largest1BorderedSquare(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        top, left = [a[:] for a in grid], [a[:] for a in grid]\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if not grid[i][j]:\n                    continue\n                if i:\n                    top[i][j] = top[i-1][j] + 1\n                if j:\n                    left[i][j] = left[i][j-1] + 1\n        for l in reversed(xrange(1, min(len(grid), len(grid[0]))+1)):\n            for i in xrange(len(grid)-l+1):\n                for j in xrange(len(grid[0])-l+1):\n                    if min(top[i+l-1][j],\n                           top[i+l-1][j+l-1],\n                           left[i][j+l-1],\n                           left[i+l-1][j+l-1]) >= l:\n                        return l*l\n        return 0\n"
    },
    {
        "problem_name": "largest-3-same-digit-number-in-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def largestGoodInteger(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        result = ''\n        cnt = 0\n        for i, x in enumerate(num):\n            cnt += 1\n            if i+1 < len(num) and num[i] == num[i+1]:\n                continue\n            if cnt >= 3:\n                result = max(result, num[i])\n            cnt = 0\n        return result*3\n\n\n# Time:  O(n)\n# Space: O(1)\n# string\nclass Solution2(object):\n    def largestGoodInteger(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        return max(num[i] if num[i] == num[i+1] == num[i+2] else '' for i in xrange(len(num)-2))*3\n"
    },
    {
        "problem_name": "largest-bst-subtree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def largestBSTSubtree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n\n        max_size = [1]\n        def largestBSTSubtreeHelper(root):\n            if root.left is None and root.right is None:\n                return 1, root.val, root.val\n\n            left_size, left_min, left_max = 0, root.val, root.val\n            if root.left is not None:\n                left_size, left_min, left_max = largestBSTSubtreeHelper(root.left)\n\n            right_size, right_min, right_max = 0, root.val, root.val\n            if root.right is not None:\n                right_size, right_min, right_max = largestBSTSubtreeHelper(root.right)\n\n            size = 0\n            if (root.left is None or left_size > 0) and \\\n               (root.right is None or right_size > 0) and \\\n               left_max <= root.val <= right_min:\n                size = 1 + left_size + right_size\n                max_size[0] = max(max_size[0], size)\n\n            return size, left_min, right_max\n\n        largestBSTSubtreeHelper(root)\n        return max_size[0]\n\n"
    },
    {
        "problem_name": "largest-color-value-in-a-directed-graph",
        "solution": "# Time:  O(n + m)\n# Space: O(n + m)\n\nclass Solution(object):\n    def largestPathValue(self, colors, edges):\n        \"\"\"\n        :type colors: str\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        adj = [[] for _ in xrange(len(colors))]\n        in_degree = [0]*len(colors)\n        for u, v in edges:\n            adj[u].append(v)\n            in_degree[v] += 1\n        q = []\n        for u in xrange(len(colors)):\n            if not in_degree[u]:\n                q.append(u)\n        dp = [[0]*26 for _ in xrange(len(colors))]\n        result, cnt = -1, 0\n        while q:\n            new_q = []\n            for u in q:\n                cnt += 1\n                dp[u][ord(colors[u])-ord('a')] += 1\n                result = max(result, dp[u][ord(colors[u])-ord('a')])\n                for v in adj[u]:\n                    for c in xrange(26):\n                        dp[v][c] = max(dp[v][c], dp[u][c])\n                    in_degree[v] -= 1\n                    if not in_degree[v]:\n                        new_q.append(v)\n            q = new_q\n        return result if cnt == len(colors) else -1\n"
    },
    {
        "problem_name": "largest-combination-with-bitwise-and-greater-than-zero",
        "solution": "# Time:  O(nlogr), r is the max of candidates\n# Space: O(logr)\n\n# bit manipulation, freq table\nclass Solution(object):\n    def largestCombination(self, candidates):\n        \"\"\"\n        :type candidates: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = []\n        base, mx = 1, max(candidates)\n        while base <= mx:\n            cnt.append(sum(x&base > 0 for x in candidates))\n            base <<= 1\n        return max(cnt)\n"
    },
    {
        "problem_name": "largest-component-size-by-common-factor",
        "solution": "# Time:  O(f * n), f is the max number of unique prime factors\n# Space: O(p + n), p is the total number of unique primes\n\nimport collections\n\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.size = [1]*n\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        self.size[max(x_root, y_root)] += self.size[min(x_root, y_root)]\n        return True\n\n\nclass Solution(object):\n    def largestComponentSize(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        def prime_factors(i):  # prime factor decomposition\n            result = []\n            d = 2\n            if i%d == 0:\n                while i%d == 0:\n                    i //= d\n                result.append(d)\n            d = 3\n            while d*d <= i:\n                if i%d == 0:\n                    while i%d == 0:\n                        i //= d\n                    result.append(d)\n                d += 2\n            if i != 1:\n                result.append(i)\n            return result\n        \n        union_find = UnionFind(len(A))\n        nodesWithCommonFactor = collections.defaultdict(int)\n        for i in xrange(len(A)):\n            for factor in prime_factors(A[i]):\n                if factor not in nodesWithCommonFactor:\n                    nodesWithCommonFactor[factor] = i\n                union_find.union_set(nodesWithCommonFactor[factor], i)\n        return max(union_find.size)\n\n\n# Time:  O(f * n), f is the max number of unique prime factors\n# Space: O(p + n), p is the total number of unique primes\nimport collections\n\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.size = [1]*n\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        self.size[max(x_root, y_root)] += self.size[min(x_root, y_root)]\n        return True\n\n\nclass Solution2(object):\n    def largestComponentSize(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        def prime_factors(x):  # prime factor decomposition\n            result = []\n            p = 2\n            while p*p <= x:\n                if x%p == 0:\n                    while x%p == 0:\n                        x //= p\n                    result.append(p)\n                p += 1\n            if x != 1:\n                result.append(x)\n            return result\n        \n        union_find = UnionFind(len(A))\n        nodesWithCommonFactor = collections.defaultdict(int)\n        for i in xrange(len(A)):\n            for factor in prime_factors(A[i]):\n                if factor not in nodesWithCommonFactor:\n                    nodesWithCommonFactor[factor] = i\n                union_find.union_set(nodesWithCommonFactor[factor], i)\n        return max(union_find.size)\n"
    },
    {
        "problem_name": "largest-divisible-subset",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def largestDivisibleSubset(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n\n        nums.sort()\n        dp = [1] * len(nums)\n        prev = [-1] * len(nums)\n        largest_idx = 0\n        for i in xrange(len(nums)):\n            for j in xrange(i):\n                if nums[i] % nums[j] == 0:\n                    if dp[i] < dp[j] + 1:\n                        dp[i] = dp[j] + 1\n                        prev[i] = j\n            if dp[largest_idx] < dp[i]:\n                largest_idx = i\n\n        result = []\n        i = largest_idx\n        while i != -1:\n            result.append(nums[i])\n            i = prev[i]\n        return result[::-1]\n\n"
    },
    {
        "problem_name": "largest-element-in-an-array-after-merge-operations",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def maxArrayValue(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = curr = 0\n        for i in reversed(xrange(len(nums))):\n            if nums[i] > curr:\n                curr = 0\n            curr += nums[i]\n            result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "largest-local-values-in-a-matrix",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def largestLocal(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def find_max(i, j):\n            return max(grid[ni][nj] for ni in xrange(i, i+3) for nj in xrange(j, j+3))\n\n        return [[find_max(i, j) for j in xrange(len(grid[0])-2)] for i in xrange(len(grid)-2)]\n"
    },
    {
        "problem_name": "largest-magic-square",
        "solution": "# Time:  O(max(m, n) * min(m, n)^3)\n# Space: O(m + n)\n\nclass Solution(object):\n    def largestMagicSquare(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def get_sum(prefix, a, b):\n            return prefix[b+1]-prefix[a]\n\n        def check(grid, prefix_row, prefix_col, l, i, j):\n            diag, anti_diag = 0, 0\n            for d in xrange(l):\n                diag += grid[i+d][j+d]\n                anti_diag += grid[i+d][j+l-1-d]\n            if diag != anti_diag:\n                return False\n            for ni in xrange(i, i+l):\n                if diag != get_sum(prefix_row[ni], j, j+l-1):\n                    return False\n            for nj in xrange(j, j+l):\n                if diag != get_sum(prefix_col[nj], i, i+l-1):\n                    return False  \n            return True\n\n        prefix_row = [[0]*(len(grid[0])+1) for _ in xrange(len(grid))]\n        prefix_col = [[0]*(len(grid)+1) for _ in xrange(len(grid[0]))]\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                prefix_row[i][j+1] = prefix_row[i][j] + grid[i][j]\n                prefix_col[j][i+1] = prefix_col[j][i] + grid[i][j]\n        for l in reversed(xrange(1, min(len(grid), len(grid[0]))+1)):\n            for i in xrange(len(grid)-(l-1)):\n                for j in xrange(len(grid[0])-(l-1)):\n                    if check(grid, prefix_row, prefix_col, l, i, j):\n                        return l\n        return 1\n"
    },
    {
        "problem_name": "largest-merge-of-two-strings",
        "solution": "# Time:  O(n * m)\n# Space: O(n + m)\n\nimport collections\n\n\nclass Solution(object):\n    def largestMerge(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: str\n        \"\"\"\n        q1 = collections.deque(word1)\n        q2 = collections.deque(word2)\n        result = []\n        while q1 or q2:\n            if q1 > q2:\n                result.append(q1.popleft())\n            else:\n                result.append(q2.popleft())\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "largest-multiple-of-three",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def largestMultipleOfThree(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: str\n        \"\"\"\n        lookup = {0: [],\n                  1: [(1,), (4,), (7,), (2, 2), (5, 2), (5, 5), (8, 2), (8, 5), (8, 8)],\n                  2: [(2,), (5,), (8,), (1, 1), (4, 1), (4, 4), (7, 1), (7, 4), (7, 7)]}\n        count = collections.Counter(digits)\n        for deletes in lookup[sum(digits)%3]:\n            delete_count = collections.Counter(deletes)\n            if all(count[k] >= v for k, v in delete_count.iteritems()):\n                for k, v in delete_count.iteritems():\n                    count[k] -= v\n                break\n        result = \"\".join(str(d)*count[d] for d in reversed(xrange(10)))\n        return \"0\" if result and result[0] == '0' else result\n    \n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def largestMultipleOfThree(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: str\n        \"\"\"\n        def candidates_gen(r):\n            if r == 0:\n                return\n            for i in xrange(10):\n                yield [i]\n            for i in xrange(10):\n                for j in xrange(i+1):\n                    yield [i, j]\n\n        count, r = collections.Counter(digits), sum(digits)%3\n        for deletes in candidates_gen(r):\n            delete_count = collections.Counter(deletes)\n            if sum(deletes)%3 == r and \\\n               all(count[k] >= v for k, v in delete_count.iteritems()):\n                for k, v in delete_count.iteritems():\n                    count[k] -= v\n                break\n        result = \"\".join(str(d)*count[d] for d in reversed(xrange(10)))\n        return \"0\" if result and result[0] == '0' else result\n"
    },
    {
        "problem_name": "largest-number-after-digit-swaps-by-parity",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# counting sort\nclass Solution(object):\n    def largestInteger(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        def count(num):\n            cnt = [0]*10\n            while num:\n                num, d = divmod(num, 10)\n                cnt[d] += 1\n            return cnt\n\n        cnt = count(num)\n        result = 0\n        digit = [0, 1]\n        base = 1\n        while num:\n            num, d = divmod(num, 10)\n            while not cnt[digit[d%2]]:\n                digit[d%2] += 2\n            cnt[digit[d%2]] -= 1\n            result += digit[d%2]*base\n            base *= 10\n        return result\n"
    },
    {
        "problem_name": "largest-number-after-mutating-substring",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maximumNumber(self, num, change):\n        \"\"\"\n        :type num: str\n        :type change: List[int]\n        :rtype: str\n        \"\"\"\n        mutated = False\n        result = map(int, list(num))\n        for i, d in enumerate(result):\n            if change[d] < d:\n                if mutated:\n                    break\n            elif change[d] > d:\n                result[i] = str(change[d])\n                mutated = True\n        return \"\".join(map(str, result))\n"
    },
    {
        "problem_name": "largest-number-at-least-twice-of-others",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def dominantIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        m = max(nums)\n        if all(m >= 2*x for x in nums if x != m):\n            return nums.index(m)\n        return -1\n\n"
    },
    {
        "problem_name": "largest-number",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    # @param num, a list of integers\n    # @return a string\n    def largestNumber(self, num):\n        num = [str(x) for x in num]\n        num.sort(cmp=lambda x, y: cmp(y + x, x + y))\n        largest = ''.join(num)\n        return largest.lstrip('0') or '0'\n\n"
    },
    {
        "problem_name": "largest-odd-number-in-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def largestOddNumber(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        for i in reversed(xrange(len(num))):\n            if int(num[i])%2:\n                return num[:i+1]\n        return \"\"\n"
    },
    {
        "problem_name": "largest-palindrome-product",
        "solution": "# Time:  O(n * 10^n)\n# Space: O(n)\n\nclass Solution(object):\n    def largestPalindrome(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 9\n        # let x = 10^n-i, y = 10^n-j, s.t. palindrome = x*y\n        # => (10^n-i)*(10^n-j) = (10^n-i-j)*10^n + i*j\n        # assume i*j < 10^n (in fact, it only works for 2 <= n <= 8, not general),\n        # let left = (10^n-i-j), right = i*j, k = i+j\n        # => left = 10^n-k, right = i*(k-i)\n        # => i^2 - k*i + right = 0\n        # => i = (k+(k^2-right*4)^(0.5))/2 or (k+(k^2-right*4)^(0.5))/2 where i is a positive integer\n        upper = 10**n-1\n        for k in xrange(2, upper+1):\n            left = 10**n-k\n            right = int(str(left)[::-1])\n            d = k**2-right*4\n            if d < 0:\n                continue\n            if d**0.5 == int(d**0.5) and k%2 == int(d**0.5)%2:\n                return (left*10**n+right)%1337\n        return -1\n\n\n# Time:  O(10^(2n))\n# Space: O(n)\nclass Solution2(object):\n    def largestPalindrome(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def divide_ceil(a, b):\n            return (a+b-1)//b\n\n        if n == 1:\n            return 9\n        upper, lower = 10**n-1, 10**(n-1)\n        for i in reversed(xrange(lower, upper**2//(10**n)+1)):\n            candidate = int(str(i) + str(i)[::-1])\n            for y in reversed(xrange(divide_ceil(lower, 11)*11, upper+1, 11)):  # y must be divisible by 11 because even-number-length palindrome meets modulo 11 digit check\n                if candidate//y > upper:\n                    break\n                if candidate%y == 0 and lower <= candidate//y:\n                    return candidate%1337\n        return -1\n"
    },
    {
        "problem_name": "largest-palindromic-number",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\n# freq table, greedy\nclass Solution(object):\n    def largestPalindromic(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        cnt = collections.Counter(num)\n        result = []\n        for i in reversed(xrange(10)):\n            if not cnt[str(i)]//2 or (i == 0 and not result):\n                continue\n            for _ in xrange(cnt[str(i)]//2):\n                result.append(str(i))\n        result.append(max([k for k, v in cnt.iteritems() if v%2] or [\"\"]))\n        for i in reversed(xrange(len(result)-1)):\n            result.append(result[i])\n        return \"\".join(result) or \"0\"\n"
    },
    {
        "problem_name": "largest-perimeter-triangle",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def largestPerimeter(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        A.sort()\n        for i in reversed(xrange(len(A) - 2)):\n            if A[i] + A[i+1] > A[i+2]:\n                return A[i] + A[i+1] + A[i+2]\n        return 0\n"
    },
    {
        "problem_name": "largest-plus-sign",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nclass Solution(object):\n    def orderOfLargestPlusSign(self, N, mines):\n        \"\"\"\n        :type N: int\n        :type mines: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = {tuple(mine) for mine in mines}\n        dp = [[0] * N for _ in xrange(N)]\n        result = 0\n        for i in xrange(N):\n            l = 0\n            for j in xrange(N):\n                l = 0 if (i, j) in lookup else l+1\n                dp[i][j] = l\n            l = 0\n            for j in reversed(xrange(N)):\n                l = 0 if (i, j) in lookup else l+1\n                dp[i][j] = min(dp[i][j], l)\n\n        for j in xrange(N):\n            l = 0\n            for i in xrange(N):\n                l = 0 if (i, j) in lookup else l+1\n                dp[i][j] = min(dp[i][j], l)\n            l = 0\n            for i in reversed(xrange(N)):\n                l = 0 if (i, j) in lookup else l+1\n                dp[i][j] = min(dp[i][j], l)\n                result = max(result, dp[i][j])\n        return result\n\n"
    },
    {
        "problem_name": "largest-positive-integer-that-exists-with-its-negative",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table\nclass Solution(object):\n    def findMaxK(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = set(nums)\n        return max([x for x in lookup if x > 0 and -x in lookup] or [-1])\n"
    },
    {
        "problem_name": "largest-rectangle-in-histogram",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stk, result = [-1], 0\n        for i in xrange(len(heights)+1):\n            while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n            stk.append(i) \n        return result\n"
    },
    {
        "problem_name": "largest-subarray-length-k",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def largestSubarray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        left, right, l = 0, 1, 0\n        while right+k-1 < len(nums) and right+l < len(nums):\n            if nums[left+l] == nums[right+l]:\n                l += 1\n                continue\n            if nums[left+l] > nums[right+l]:\n                right += l+1\n            else:\n                left = max(right, min(left+l+1, len(nums)-k))\n                right = left+1\n            l = 0\n        return nums[left:left+k]\n"
    },
    {
        "problem_name": "largest-submatrix-with-rearrangements",
        "solution": "# Time:  O(m * nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def largestSubmatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for c in xrange(len(matrix[0])):\n            h = 0\n            for r in xrange(len(matrix)):\n                h = h+1 if matrix[r][c] == 1 else 0\n                matrix[r][c] = h\n        result = 0\n        for row in matrix:\n            row.sort()\n            for c in xrange(len(row)):\n                result = max(result, (len(row)-c) * row[c])\n        return result\n"
    },
    {
        "problem_name": "largest-substring-between-two-equal-characters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxLengthBetweenEqualCharacters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, lookup = -1, {}\n        for i, c in enumerate(s):\n            result = max(result, i-lookup.setdefault(c, i)-1)\n        return result\n"
    },
    {
        "problem_name": "largest-sum-of-averages",
        "solution": "# Time:  O(k * n^2)\n# Space: O(n)\n\n\nclass Solution(object):\n    def largestSumOfAverages(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: float\n        \"\"\"\n        accum_sum = [A[0]]\n        for i in xrange(1, len(A)):\n            accum_sum.append(A[i]+accum_sum[-1])\n\n        dp = [[0]*len(A) for _ in xrange(2)]\n        for k in xrange(1, K+1):\n            for i in xrange(k-1, len(A)):\n                if k == 1:\n                    dp[k % 2][i] = float(accum_sum[i])/(i+1)\n                else:\n                    for j in xrange(k-2, i):\n                        dp[k % 2][i] = \\\n                            max(dp[k % 2][i],\n                                dp[(k-1) % 2][j] +\n                                float(accum_sum[i]-accum_sum[j])/(i-j))\n        return dp[K % 2][-1]\n\n"
    },
    {
        "problem_name": "largest-time-for-given-digits",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def largestTimeFromDigits(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: str\n        \"\"\"\n        result = \"\"\n        for i in xrange(len(A)):\n            A[i] *= -1\n        A.sort()\n        for h1, h2, m1, m2 in itertools.permutations(A):\n            hours = -(10*h1 + h2)\n            mins = -(10*m1 + m2)\n            if 0 <= hours < 24 and 0 <= mins < 60:\n                result = \"{:02}:{:02}\".format(hours, mins)\n                break\n        return result\n \n"
    },
    {
        "problem_name": "largest-triangle-area",
        "solution": "# Time:  O(n^3)\n# Space: O(1)\n\n\nclass Solution(object):\n    def largestTriangleArea(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: float\n        \"\"\"\n        result = 0\n        for i in xrange(len(points)-2):\n            for j in xrange(i+1, len(points)-1):\n                for k in xrange(j+1, len(points)):\n                    result = max(result,\n                                 0.5 * abs(points[i][0] * points[j][1] +\n                                           points[j][0] * points[k][1] +\n                                           points[k][0] * points[i][1] -\n                                           points[j][0] * points[i][1] -\n                                           points[k][0] * points[j][1] -\n                                           points[i][0] * points[k][1]))\n        return result\n\n"
    },
    {
        "problem_name": "largest-unique-number",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def largestUniqueNumber(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        A.append(-1)\n        return max(k for k,v in collections.Counter(A).items() if v == 1)\n"
    },
    {
        "problem_name": "largest-values-from-labels",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def largestValsFromLabels(self, values, labels, num_wanted, use_limit):\n        \"\"\"\n        :type values: List[int]\n        :type labels: List[int]\n        :type num_wanted: int\n        :type use_limit: int\n        :rtype: int\n        \"\"\"\n        counts = collections.defaultdict(int)\n        val_labs = zip(values,labels)\n        val_labs.sort(reverse=True)\n        result = 0\n        for val, lab in val_labs:\n            if counts[lab] >= use_limit:\n                continue\n            result += val\n            counts[lab] += 1\n            num_wanted -= 1\n            if num_wanted == 0:\n                break\n        return result\n"
    },
    {
        "problem_name": "last-day-where-you-can-still-cross",
        "solution": "# Time:  O(m * n + c *  \u03b1(c)) = O(m * n)\n# Space: O(m * n)\n\nclass UnionFind(object):  # Time: O(n * \u03b1(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:  # union by rank\n            self.set[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.set[y_root] = x_root\n        else:\n            self.set[y_root] = x_root\n            self.rank[x_root] += 1\n        return True\n\n\nclass Solution(object):\n    def latestDayToCross(self, row, col, cells):\n        \"\"\"\n        :type row: int\n        :type col: int\n        :type cells: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def index(n, i, j):\n            return i*n+j\n\n        start, end = row*col, row*col+1\n        uf = UnionFind(row*col+2)\n        lookup = [[False]*col for _ in xrange(row)]\n        for i in reversed(xrange(len(cells))):\n            r, c = cells[i]\n            r, c = r-1, c-1\n            for dr, dc in directions:\n                nr, nc = r+dr, c+dc\n                if not (0 <= nr < row and 0 <= nc < col and lookup[nr][nc]):\n                    continue\n                uf.union_set(index(col, r, c), index(col, nr, nc))\n            if r == 0:\n                uf.union_set(start, index(col, r, c))\n            if r == row-1:\n                uf.union_set(end, index(col, r, c))\n            if uf.find_set(start) == uf.find_set(end):\n                return i\n            lookup[r][c] = True\n        return -1\n"
    },
    {
        "problem_name": "last-moment-before-all-ants-fall-out-of-a-plank",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def getLastMoment(self, n, left, right):\n        \"\"\"\n        :type n: int\n        :type left: List[int]\n        :type right: List[int]\n        :rtype: int\n        \"\"\"\n        return max(max(left or [0]), n-min(right or [n]))\n"
    },
    {
        "problem_name": "last-stone-weight-ii",
        "solution": "# Time:  O(2^n)\n# Space: O(2^n)\n\nclass Solution(object):\n    def lastStoneWeightII(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: int\n        \"\"\"\n        dp = {0}\n        for stone in stones:\n            dp |= {stone+i for i in dp}\n        S = sum(stones)\n        return min(abs(i-(S-i)) for i in dp)\n"
    },
    {
        "problem_name": "last-stone-weight",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def lastStoneWeight(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: int\n        \"\"\"\n        max_heap = [-x for x in stones]\n        heapq.heapify(max_heap)\n        for i in xrange(len(stones)-1):\n            x, y = -heapq.heappop(max_heap), -heapq.heappop(max_heap)\n            heapq.heappush(max_heap, -abs(x-y))\n        return -max_heap[0]\n"
    },
    {
        "problem_name": "last-substring-in-lexicographical-order",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def lastSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        left, right, l = 0, 1, 0\n        while right+l < len(s):\n            if s[left+l] == s[right+l]:\n                l += 1\n                continue\n            if s[left+l] > s[right+l]:\n                right += l+1\n            else:\n                left = max(right, left+l+1)\n                right = left+1\n            l = 0\n        return s[left:]\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\nclass Solution2(object):\n    def lastSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        count = collections.defaultdict(list)\n        for i in xrange(len(s)):\n            count[s[i]].append(i)\n\n        max_c = max(count.iterkeys())\n        starts = {}\n        for i in count[max_c]:\n            starts[i] = i+1\n        while len(starts)-1 > 0:\n            lookup = set()\n            next_count = collections.defaultdict(list)\n            for start, end in starts.iteritems():\n                if end == len(s):  # finished\n                    lookup.add(start)\n                    continue\n                next_count[s[end]].append(start)\t\t\t\t\n                if end in starts:  # overlapped\n                    lookup.add(end)\t\t\t\n            next_starts = {}\n            max_c = max(next_count.iterkeys())\n            for start in next_count[max_c]:\n                if start not in lookup:\n                    next_starts[start] = starts[start]+1\n            starts = next_starts\n        return s[next(starts.iterkeys()):]\n"
    },
    {
        "problem_name": "last-visited-integers",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# stack\nclass Solution(object):\n    def lastVisitedIntegers(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        PREV = \"prev\"\n        result, stk = [], []\n        i = -1\n        for x in words:\n            if x == PREV:\n                result.append(stk[i] if i >= 0 else -1)\n                i -= 1\n                continue\n            stk.append(int(x))\n            i = len(stk)-1\n        return result\n"
    },
    {
        "problem_name": "latest-time-by-replacing-hidden-digits",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def maximumTime(self, time):\n        \"\"\"\n        :type time: str\n        :rtype: str\n        \"\"\"\n        result = list(time)\n        for i, c in enumerate(time): \n            if c != \"?\":\n                continue\n            if i == 0:\n                result[i] = '2' if result[i+1] in \"?0123\" else '1'\n            elif i == 1:\n                result[i] = '3' if result[0] == '2' else '9'\n            elif i == 3:\n                result[i] = '5'\n            elif i == 4:\n                result[i] = '9'\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "latest-time-you-can-obtain-after-replacing-characters",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def findLatestTime(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        result = list(s)\n        if result[0] == '?': \n            result[0] = '1' if result[1] == '?' or result[1] <= '1' else '0'\n        if result[1] == '?': \n            result[1] = '1' if result[0] == '1' else '9'\n        if result[3] == '?':\n            result[3] = '5'\n        if result[4] == '?':\n            result[4] = '9'\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "leaf-similar-trees",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nimport itertools\n\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def leafSimilar(self, root1, root2):\n        \"\"\"\n        :type root1: TreeNode\n        :type root2: TreeNode\n        :rtype: bool\n        \"\"\"\n        def dfs(node):\n            if not node:\n                return\n            if not node.left and not node.right:\n                yield node.val\n            for i in dfs(node.left):\n                yield i\n            for i in dfs(node.right):\n                yield i\n        return all(a == b for a, b in\n                   itertools.izip_longest(dfs(root1), dfs(root2)))\n\n"
    },
    {
        "problem_name": "least-number-of-unique-integers-after-k-removals",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def findLeastNumOfUniqueInts(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        count = collections.Counter(arr)\n        result, count_count = len(count), collections.Counter(count.itervalues())\n        for c in xrange(1, len(arr)+1): \n            if k < c*count_count[c]:\n                result -= k//c\n                break\n            k -= c*count_count[c]\n            result -= count_count[c]                \n        return result\n"
    },
    {
        "problem_name": "least-operators-to-express-number",
        "solution": "# Time:  O(logn/logx) = O(1)\n# Space: O(logn) = O(1)\n\nclass Solution(object):\n    def leastOpsExpressTarget(self, x, target):\n        \"\"\"\n        :type x: int\n        :type target: int\n        :rtype: int\n        \"\"\"\n        pos, neg, k = 0, 0, 0\n        while target:\n            target, r = divmod(target, x)\n            if k:\n                pos, neg = min(r*k + pos, (r+1)*k + neg), \\\n                           min((x-r)*k + pos, (x-r-1)*k + neg)\n            else:\n                pos, neg = r*2, (x-r)*2\n            k += 1\n        return min(pos, k+neg) - 1\n"
    },
    {
        "problem_name": "left-and-right-sum-differences",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# prefix sum\nclass Solution(object):\n    def leftRigthDifference(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        total = sum(nums)\n        result = []\n        curr = 0\n        for x in nums:\n            curr += x\n            result.append(abs((curr-x)-(total-curr)))\n        return result\n"
    },
    {
        "problem_name": "leftmost-column-with-at-least-a-one",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nclass BinaryMatrix(object):\n    def get(self, row, col):\n        pass\n\n    def dimensions(self):\n        pass\n\n\nclass Solution(object):\n    def leftMostColumnWithOne(self, binaryMatrix):\n        \"\"\"\n        :type binaryMatrix: BinaryMatrix\n        :rtype: int\n        \"\"\"\n        m, n = binaryMatrix.dimensions()\n        r, c = 0, n-1\n        while r < m and c >= 0:\n            if not binaryMatrix.get(r, c):\n                r += 1\n            else:\n                c -= 1        \n        return c+1 if c+1 != n else -1\n"
    },
    {
        "problem_name": "lemonade-change",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def lemonadeChange(self, bills):\n        \"\"\"\n        :type bills: List[int]\n        :rtype: bool\n        \"\"\"\n        coins = [20, 10, 5]\n        counts = collections.defaultdict(int)\n        for bill in bills:\n            counts[bill] += 1\n            change = bill - coins[-1]\n            for coin in coins:\n                if change == 0:\n                    break\n                if change >= coin:\n                    count = min(counts[coin], change//coin)\n                    counts[coin] -= count\n                    change -= coin * count\n            if change != 0:\n                return False\n        return True\n\n\nclass Solution2(object):\n    def lemonadeChange(self, bills):\n        \"\"\"\n        :type bills: List[int]\n        :rtype: bool\n        \"\"\"\n        five, ten = 0, 0\n        for bill in bills:\n            if bill == 5:\n                five += 1\n            elif bill == 10:\n                if not five:\n                    return False\n                five -= 1\n                ten += 1\n            else:\n                if ten and five:\n                    ten -= 1\n                    five -= 1\n                elif five >= 3:\n                    five -= 3\n                else:\n                    return False\n        return True\n\n"
    },
    {
        "problem_name": "length-of-last-word",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param s, a string\n    # @return an integer\n    def lengthOfLastWord(self, s):\n        length = 0\n        for i in reversed(s):\n            if i == ' ':\n                if length:\n                    break\n            else:\n                length += 1\n        return length\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    # @param s, a string\n    # @return an integer\n    def lengthOfLastWord(self, s):\n        return len(s.strip().split(\" \")[-1])\n\n"
    },
    {
        "problem_name": "length-of-longest-fibonacci-subsequence",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def lenLongestFibSubseq(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = set(A)\n        result = 2\n        for i in xrange(len(A)):\n            for j in xrange(i+1, len(A)):\n                x, y, l = A[i], A[j], 2\n                while x+y in lookup:\n                    x, y, l = y, x+y, l+1\n                result = max(result, l)\n        return result if result > 2 else 0\n\n"
    },
    {
        "problem_name": "length-of-longest-subarray-with-at-most-k-frequency",
        "solution": "# Time:  O(n)\n# Space: o(n)\n\nimport collections\n\n\n# freq table, two pointers, sliding window\nclass Solution(object):\n    def maxSubarrayLength(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter()\n        result = left = 0\n        for right in xrange(len(nums)):\n            cnt[nums[right]] += 1\n            while not (cnt[nums[right]] <= k):\n                cnt[nums[left]] -= 1\n                left += 1\n            result = max(result, right-left+1)\n        return result\n"
    },
    {
        "problem_name": "length-of-the-longest-alphabetical-continuous-substring",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def longestContinuousSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = l = 0\n        for i in xrange(len(s)):\n            l += 1\n            if i+1 == len(s) or ord(s[i])+1 != ord(s[i+1]):\n                result = max(result, l)\n                l = 0\n        return result\n"
    },
    {
        "problem_name": "length-of-the-longest-subsequence-that-sums-to-target",
        "solution": "# Time:  O(n * t)\n# Space: O(t)\n\n# knapsack dp\nclass Solution(object):\n    def lengthOfLongestSubsequence(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        dp = [-1]*(target+1)\n        dp[0] = 0\n        for x in nums:\n            for i in reversed(xrange(x, len(dp))):\n                if dp[i-x] != -1:\n                    dp[i] = max(dp[i], dp[i-x]+1)\n        return dp[-1]\n"
    },
    {
        "problem_name": "length-of-the-longest-valid-substring",
        "solution": "# Time:  O((m + n) * l), n = len(word), m = len(forbidden), l = max(len(w) for w in forbidden)\n# Space: O(t), t is the size of trie\n\nimport collections\n\n\n# two pointers, sliding window, trie\nclass Solution(object):\n    def longestValidSubstring(self, word, forbidden):\n        \"\"\"\n        :type word: str\n        :type forbidden: List[str]\n        :rtype: int\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        for w in forbidden:\n            reduce(dict.__getitem__, w, trie)[\"_end\"]\n        result = 0\n        right = len(word)-1\n        for left in reversed(xrange(len(word))):\n            node = trie\n            for i in xrange(left, right+1):\n                if word[i] not in node:  # O(l) times\n                    break\n                node = node[word[i]]\n                if \"_end\" in node:\n                    right = i-1\n                    break\n            result = max(result, right-left+1)\n        return result\n"
    },
    {
        "problem_name": "letter-case-permutation",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(n * 2^n)\n\nclass Solution(object):\n    def letterCasePermutation(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        result = [[]]\n        for c in S:\n            if c.isalpha():\n                for i in xrange(len(result)):\n                    result.append(result[i][:])\n                    result[i].append(c.lower())\n                    result[-1].append(c.upper())\n            else:\n                for s in result:\n                    s.append(c)\n        return map(\"\".join, result)\n\n"
    },
    {
        "problem_name": "letter-combinations-of-a-phone-number",
        "solution": "# Time:  O(n * 4^n)\n# Space: O(1)\n\n# iterative solution\nclass Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n\n        lookup = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n        total = 1\n        for digit in digits:\n            total *= len(lookup[int(digit)])\n        result = []\n        for i in xrange(total):\n            base, curr = total, []\n            for digit in digits:\n                choices = lookup[int(digit)]\n                base //= len(choices)\n                curr.append(choices[(i//base)%len(choices)])\n            result.append(\"\".join(curr))\n        return result\n\n\n# Time:  O(n * 4^n)\n# Space: O(1)\n# iterative solution\nclass Solution2(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n\n        result = [\"\"]\n        lookup = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n        for digit in reversed(digits):\n            choices = lookup[int(digit)]\n            m, n = len(choices), len(result)\n            result.extend([result[i % n] for i in xrange(n, m*n)])\n            for i in xrange(m*n):\n                result[i] = choices[i//n] + result[i]\n        return result\n\n\n# Time:  O(n * 4^n)\n# Space: O(n)\n# recursive solution\nclass Solution3(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        lookup = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n\n        def letterCombinationsRecu(result, digits, curr, n):\n            if n == len(digits):\n                result.append(\"\".join(curr))\n                return\n            for choice in lookup[int(digits[n])]:\n                curr.append(choice)\n                letterCombinationsRecu(result, digits, curr, n+1)\n                curr.pop()\n\n        if not digits:\n            return []\n        result = []\n        letterCombinationsRecu(result, digits, [], 0)\n        return result\n\n"
    },
    {
        "problem_name": "letter-tile-possibilities",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def numTilePossibilities(self, tiles):\n        \"\"\"\n        :type tiles: str\n        :rtype: int\n        \"\"\"\n        fact = [0.0]*(len(tiles)+1)\n        fact[0] = 1.0;\n        for i in xrange(1, len(tiles)+1):\n            fact[i] = fact[i-1]*i\n        count = collections.Counter(tiles)\n\n        # 1. we can represent each alphabet 1..26 as generating functions:\n        #    G1(x) = 1 + x^1/1! + x^2/2! + x^3/3! + ... + x^count1/count1!\n        #    G2(x) = 1 + x^1/1! + x^2/2! + x^3/3! + ... + x^count2/count2!\n        #    ...\n        #    G26(x) = 1 + x^1/1! + x^2/2! + x^3/3! + ... + x^count26/count26!\n        #\n        # 2. let G1(x)*G2(x)*...*G26(x) = c0 + c1*x1 + ... + ck*x^k, k is the max number s.t. ck != 0\n        #    => ci (1 <= i <= k) is the number we need to divide when permuting i letters\n        #    => the answer will be : c1*1! + c2*2! + ... + ck*k!\n        \n        coeff = [0.0]*(len(tiles)+1)\n        coeff[0] = 1.0\n        for i in count.itervalues():\n            new_coeff = [0.0]*(len(tiles)+1)\n            for j in xrange(len(coeff)):\n                for k in xrange(i+1):\n                    if k+j >= len(new_coeff):\n                        break\n                    new_coeff[j+k] += coeff[j]*1.0/fact[k]\n            coeff = new_coeff\n\n        result = 0\n        for i in xrange(1, len(coeff)):\n            result += int(round(coeff[i]*fact[i]))\n        return result\n\n\n# Time:  O(r), r is the value of result\n# Space: O(n)\nclass Solution2(object):\n    def numTilePossibilities(self, tiles):\n        \"\"\"\n        :type tiles: str\n        :rtype: int\n        \"\"\"\n        def backtracking(counter):\n            total = 0\n            for k, v in counter.iteritems():\n                if not v:\n                    continue\n                counter[k] -= 1\n                total += 1+backtracking(counter)\n                counter[k] += 1\n            return total\n\n        return backtracking(collections.Counter(tiles))\n"
    },
    {
        "problem_name": "lexicographical-numbers",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def lexicalOrder(self, n):\n        result = []\n\n        i = 1\n        while len(result) < n:\n            k = 0\n            while i * 10**k <= n:\n                result.append(i * 10**k)\n                k += 1\n\n            num = result[-1] + 1\n            while num <= n and num % 10:\n                result.append(num)\n                num += 1\n\n            if not num % 10:\n                num -= 1\n            else:\n                num /= 10\n\n            while num % 10 == 9:\n                num /= 10\n\n            i = num+1\n\n        return result\n\n"
    },
    {
        "problem_name": "lexicographically-smallest-beautiful-string",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# greedy\nclass Solution(object):\n    def smallestBeautifulString(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        def check(i):\n            return (i-1 < 0 or arr[i-1] != arr[i]) and (i-2 < 0 or arr[i-2] != arr[i])\n\n        arr = map(lambda x: ord(x)-ord('a'), s)\n        for i in reversed(xrange(len(arr))):\n            arr[i] += 1\n            while not check(i):\n                arr[i] += 1\n            if arr[i] < k:\n                break\n        else:\n            return \"\"\n        for j in xrange(i+1, len(arr)):\n            arr[j] = 0\n            while not check(j):\n                arr[j] += 1\n        return \"\".join(map(lambda x: chr(ord('a')+x), arr))\n"
    },
    {
        "problem_name": "lexicographically-smallest-equivalent-string",
        "solution": "# Time:  O(nlog*n) ~= O(n), n is the length of S\n# Space: O(n)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[max(x_root, y_root)] = min(x_root, y_root)\n        return True\n    \n\nclass Solution(object):\n    def smallestEquivalentString(self, A, B, S):\n        \"\"\"\n        :type A: str\n        :type B: str\n        :type S: str\n        :rtype: str\n        \"\"\"\n        union_find = UnionFind(26)\n        for i in xrange(len(A)):\n            union_find.union_set(ord(A[i])-ord('a'), ord(B[i])-ord('a'))\n        result = []\n        for i in xrange(len(S)):\n            parent = union_find.find_set(ord(S[i])-ord('a'))\n            result.append(chr(parent+ord('a')))\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "lexicographically-smallest-palindrome",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def makeSmallestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        return \"\".join(min(s[i], s[~i]) for i in xrange(len(s)))\n"
    },
    {
        "problem_name": "lexicographically-smallest-string-after-applying-operations",
        "solution": "# Time:  O(100 * n^2) = O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def findLexSmallestString(self, s, a, b):\n        \"\"\"\n        :type s: str\n        :type a: int\n        :type b: int\n        :rtype: str\n        \"\"\"\n        def less(s, i, j):\n            for k in xrange(len(s)):\n                if s[(k+i)%len(s)] != s[(k+j)%len(s)]:\n                    return s[(k+i)%len(s)] < s[(k+j)%len(s)]\n            return False\n\n        s = list(s)\n        result = s[:]\n        even = [False]*10\n        while not even[int(s[0])]:  # at most O(10) times\n            even[int(s[0])] = True\n            odd = [False]*10\n            while not odd[int(s[1])]:  # at most O(10) times\n                odd[int(s[1])] = True\n                best_rotate = 0\n                lookup = [False]*len(s)\n                i = b\n                while not lookup[i]:  # find best rotation, at most O(n) times\n                    lookup[i] = True\n                    if less(s, i, best_rotate):  # O(n) time\n                        best_rotate = i\n                    i = (i+b)%len(s)\n                result = min(result, s[best_rotate:] + s[:best_rotate])\n                for k in xrange(1, len(s), 2):  # flip odd index\n                    s[k] = str((int(s[k])+a) % 10)\n            if b%2:  # if rotate length is odd, even index could be also flipped\n                for k in xrange(0, len(s), 2):  # flip even index\n                    s[k] = str((int(s[k])+a) % 10)\n        return \"\".join(result)\n\n\n# Time:  O(100 * n^2), at most O(100n) strings and each compare costs O(n)\n# Space: O(n^2)\nimport collections\n\n\nclass Solution2(object):\n    def findLexSmallestString(self, s, a, b):\n        \"\"\"\n        :type s: str\n        :type a: int\n        :type b: int\n        :rtype: str\n        \"\"\"\n        q, lookup, result = collections.deque([s]), {s}, s\n        while q:\n            curr = q.popleft()\n            if curr < result:\n                result = curr\n            add_a = list(curr)    \n            for i, c in enumerate(add_a):\n                if i%2:\n                    add_a[i] = str((int(c)+a) % 10)\n            add_a = \"\".join(add_a)        \n            if add_a not in lookup:\n                lookup.add(add_a);\n                q.append(add_a)\n            rotate_b = curr[b:] + curr[:b]\n            if rotate_b not in lookup:\n                lookup.add(rotate_b)\n                q.append(rotate_b)\n        return result\n"
    },
    {
        "problem_name": "lexicographically-smallest-string-after-operations-with-constraint",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def getSmallestString(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        result = map(lambda x: ord(x)-ord('a'), s)\n        for i in xrange(len(result)):\n            d = min(result[i]-0, 26-result[i])\n            result[i] = 0 if d <= k else result[i]-k\n            k -= min(d, k)\n            if k == 0:\n                break\n        return \"\".join(map(lambda x: chr(x+ord('a')), result))\n"
    },
    {
        "problem_name": "lexicographically-smallest-string-after-substring-operation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def smallestString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        result = list(s)\n        i = next((i for i in xrange(len(s)) if s[i] != 'a'), len(s))\n        if i == len(s):\n            result[-1] = 'z'\n        else:\n            for i in xrange(i, len(s)):\n                if result[i] == 'a':\n                    break\n                result[i] = chr(ord(result[i])-1)\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "lfu-cache",
        "solution": "# Time:  O(1), per operation\n# Space: O(k), k is the capacity of cache\n\nimport collections\n\n\n# using OrderedDict\nclass LFUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.__capa = capacity\n        self.__size = 0\n        self.__min_freq = float(\"inf\")\n        self.__freq_to_nodes = collections.defaultdict(collections.OrderedDict)\n        self.__key_to_freq = {}\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.__key_to_freq:\n            return -1\n        value = self.__freq_to_nodes[self.__key_to_freq[key]][key]\n        self.__update(key, value)\n        return value\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        if self.__capa <= 0:\n            return\n\n        if key not in self.__key_to_freq and self.__size == self.__capa:\n            del self.__key_to_freq[self.__freq_to_nodes[self.__min_freq].popitem(last=False)[0]]\n            if not self.__freq_to_nodes[self.__min_freq]:\n                del self.__freq_to_nodes[self.__min_freq]\n            self.__size -= 1\n        self.__update(key, value)\n        \n    def __update(self, key, value):\n        freq = 0\n        if key in self.__key_to_freq:\n            freq = self.__key_to_freq[key]\n            del self.__freq_to_nodes[freq][key]\n            if not self.__freq_to_nodes[freq]:\n                del self.__freq_to_nodes[freq]\n                if self.__min_freq == freq:\n                    self.__min_freq += 1\n            self.__size -= 1\n\n        freq += 1\n        self.__min_freq = min(self.__min_freq, freq)\n        self.__key_to_freq[key] = freq\n        self.__freq_to_nodes[freq][key] = value\n        self.__size += 1\n\n\n# Time:  O(1), per operation\n# Space: O(k), k is the capacity of cache\nimport collections\n\n\nclass ListNode(object):\n    def __init__(self, key, value, freq):\n        self.key = key\n        self.val = value\n        self.freq = freq\n        self.next = None\n        self.prev = None\n\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def append(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\n\n\nclass LFUCache2(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.__capa = capacity\n        self.__size = 0\n        self.__min_freq = float(\"inf\")\n        self.__freq_to_nodes = collections.defaultdict(LinkedList)\n        self.__key_to_node = {}\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.__key_to_node:\n            return -1\n        value = self.__key_to_node[key].val\n        self.__update(key, value)\n        return value\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        if self.__capa <= 0:\n            return\n\n        if key not in self.__key_to_node and self.__size == self.__capa:\n            del self.__key_to_node[self.__freq_to_nodes[self.__min_freq].head.key]\n            self.__freq_to_nodes[self.__min_freq].delete(self.__freq_to_nodes[self.__min_freq].head)\n            if not self.__freq_to_nodes[self.__min_freq].head:\n                del self.__freq_to_nodes[self.__min_freq]\n            self.__size -= 1\n        self.__update(key, value)\n        \n    def __update(self, key, value):\n        freq = 0\n        if key in self.__key_to_node:\n            old_node = self.__key_to_node[key]\n            freq = old_node.freq\n            self.__freq_to_nodes[freq].delete(old_node)\n            if not self.__freq_to_nodes[freq].head:\n                del self.__freq_to_nodes[freq]\n                if self.__min_freq == freq:\n                    self.__min_freq += 1\n            self.__size -= 1\n\n        freq += 1\n        self.__min_freq = min(self.__min_freq, freq)\n        self.__key_to_node[key] = ListNode(key, value, freq)\n        self.__freq_to_nodes[freq].append(self.__key_to_node[key])\n        self.__size += 1\n"
    },
    {
        "problem_name": "license-key-formatting",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def licenseKeyFormatting(self, S, K):\n        \"\"\"\n        :type S: str\n        :type K: int\n        :rtype: str\n        \"\"\"\n        result = []\n        for i in reversed(xrange(len(S))):\n            if S[i] == '-':\n                continue\n            if len(result) % (K + 1) == K:\n                result += '-'\n            result += S[i].upper()\n        return \"\".join(reversed(result))\n"
    },
    {
        "problem_name": "line-reflection",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# Hash solution.\nclass Solution(object):\n    def isReflected(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not points:\n            return True\n        groups_by_y = collections.defaultdict(set)\n        left, right = float(\"inf\"), float(\"-inf\")\n        for p in points:\n            groups_by_y[p[1]].add(p[0])\n            left, right = min(left, p[0]), max(right, p[0])\n        mid = left + right\n        for group in groups_by_y.values():\n            for x in group:\n                if mid - x not in group:\n                    return False\n        return True\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# Two pointers solution.\nclass Solution2(object):\n    def isReflected(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not points:\n            return True\n        points.sort()\n        # Space: O(n)\n        points[len(points)/2:] = sorted(points[len(points)/2:], \\\n                                        lambda x, y: y[1] - x[1] if x[0] == y[0] else \\\n                                                     x[0] - y[0])\n        mid = points[0][0] + points[-1][0]\n        left, right = 0, len(points) - 1\n        while left <= right:\n            if (mid != points[left][0] + points[right][0]) or \\\n               (points[left][0] != points[right][0] and \\\n                points[left][1] != points[right][1]):\n                return False\n            left += 1\n            right -= 1\n        return True\n\n"
    },
    {
        "problem_name": "linked-list-components",
        "solution": "# Time:  O(m + n), m is the number of G, n is the number of nodes\n# Space: O(m)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def numComponents(self, head, G):\n        \"\"\"\n        :type head: ListNode\n        :type G: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = set(G)\n        dummy = ListNode(-1)\n        dummy.next = head\n        curr = dummy\n        result = 0\n        while curr and curr.next:\n            if curr.val not in lookup and curr.next.val in lookup:\n                result += 1\n            curr = curr.next\n        return result\n\n"
    },
    {
        "problem_name": "linked-list-cycle-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __str__(self):\n        if self:\n            return \"{}\".format(self.val)\n        else:\n            return None\n\nclass Solution(object):\n    # @param head, a ListNode\n    # @return a list node\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while fast and fast.next:\n            fast, slow = fast.next.next, slow.next\n            if fast is slow:\n                fast = head\n                while fast is not slow:\n                    fast, slow = fast.next, slow.next\n                return fast\n        return None\n\n"
    },
    {
        "problem_name": "linked-list-cycle",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    # @param head, a ListNode\n    # @return a boolean\n    def hasCycle(self, head):\n        fast, slow = head, head\n        while fast and fast.next:\n            fast, slow = fast.next.next, slow.next\n            if fast is slow:\n                return True\n        return False\n\n"
    },
    {
        "problem_name": "linked-list-frequency",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# linked list\nclass Solution(object):\n    def frequenciesOfElements(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        curr = dummy = ListNode(0)\n        cnt = 0\n        while head:\n            cnt += 1\n            if not head.next or head.next.val != head.val:\n                curr.next = ListNode(cnt)\n                curr = curr.next\n                cnt = 0\n            head = head.next\n        return dummy.next\n"
    },
    {
        "problem_name": "linked-list-in-binary-tree",
        "solution": "# Time:  O(n + l)\n# Space: O(h + l)\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n# kmp solution\nclass Solution(object):\n    def isSubPath(self, head, root):\n        \"\"\"\n        :type head: ListNode\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def getPrefix(head):\n            pattern, prefix = [head.val], [-1]\n            j = -1\n            node = head.next\n            while node:\n                while j+1 and pattern[j+1] != node.val:\n                    j = prefix[j]\n                if pattern[j+1] == node.val:\n                    j += 1\n                pattern.append(node.val)\n                prefix.append(j)\n                node = node.next\n            return pattern, prefix\n            \n        def dfs(pattern, prefix, root, j):\n            if not root:\n                return False\n            while j+1 and pattern[j+1] != root.val:\n                j = prefix[j]\n            if pattern[j+1] == root.val:\n                j += 1\n            if j+1 == len(pattern):\n                return True\n            return dfs(pattern, prefix, root.left, j) or \\\n                   dfs(pattern, prefix, root.right, j)\n        \n        if not head:\n            return True\n        pattern, prefix = getPrefix(head)\n        return dfs(pattern, prefix, root, -1)\n    \n\n# Time:  O(n * min(h, l))\n# Space: O(h)\n# dfs solution\nclass Solution2(object):\n    def isSubPath(self, head, root):\n        \"\"\"\n        :type head: ListNode\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def dfs(head, root):\n            if not head:\n                return True\n            if not root:\n                return False\n            return root.val == head.val and \\\n                   (dfs(head.next, root.left) or \n                    dfs(head.next, root.right))\n    \n        if not head:\n            return True\n        if not root:\n            return False\n        return dfs(head, root) or \\\n               self.isSubPath(head, root.left) or \\\n               self.isSubPath(head, root.right)\n"
    },
    {
        "problem_name": "linked-list-random-node",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nfrom random import randint\n\nclass Solution(object):\n\n    def __init__(self, head):\n        \"\"\"\n        @param head The linked list's head. Note that the head is guanranteed to be not null, so it contains at least one node.\n        :type head: ListNode\n        \"\"\"\n        self.__head = head\n\n\n    # Proof of Reservoir Sampling:\n    # https://discuss.leetcode.com/topic/53753/brief-explanation-for-reservoir-sampling\n    def getRandom(self):\n        \"\"\"\n        Returns a random node's value.\n        :rtype: int\n        \"\"\"\n        reservoir = -1\n        curr, n = self.__head, 0\n        while curr:\n            reservoir = curr.val if randint(1, n+1) == 1 else reservoir\n            curr, n = curr.next, n+1\n        return reservoir\n\n\n\n"
    },
    {
        "problem_name": "logger-rate-limiter",
        "solution": "# Time:  O(1), amortized\n# Space: O(k), k is the max number of printed messages in last 10 seconds\n\nimport collections\n\n\nclass Logger(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__dq = collections.deque()\n        self.__printed = set()\n\n    def shouldPrintMessage(self, timestamp, message):\n        \"\"\"\n        Returns true if the message should be printed in the given timestamp, otherwise returns false. The timestamp is in seconds granularity.\n        :type timestamp: int\n        :type message: str\n        :rtype: bool\n        \"\"\"\n        while self.__dq and self.__dq[0][0] <= timestamp - 10:\n            self.__printed.remove(self.__dq.popleft()[1])\n        if message in self.__printed:\n            return False\n        self.__dq.append((timestamp, message))\n        self.__printed.add(message)\n        return True\n\n    \n"
    },
    {
        "problem_name": "logical-or-of-two-binary-grids-represented-as-quad-trees",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Node(object):\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\n\nclass Solution(object):\n    def intersect(self, quadTree1, quadTree2):\n        \"\"\"\n        :type quadTree1: Node\n        :type quadTree2: Node\n        :rtype: Node\n        \"\"\"\n        if quadTree1.isLeaf:\n            return quadTree1 if quadTree1.val else quadTree2\n        elif quadTree2.isLeaf:\n            return quadTree2 if quadTree2.val else quadTree1\n        topLeftNode = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\n        topRightNode = self.intersect(quadTree1.topRight, quadTree2.topRight)\n        bottomLeftNode = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\n        bottomRightNode = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\n        if topLeftNode.isLeaf and topRightNode.isLeaf and \\\n           bottomLeftNode.isLeaf and bottomRightNode.isLeaf and \\\n           topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val:\n            return Node(topLeftNode.val, True, None, None, None, None)\n        return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode)\n\n"
    },
    {
        "problem_name": "lonely-pixel-i",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nclass Solution(object):\n    def findLonelyPixel(self, picture):\n        \"\"\"\n        :type picture: List[List[str]]\n        :rtype: int\n        \"\"\"\n        rows, cols = [0] * len(picture),  [0] * len(picture[0])\n        for i in xrange(len(picture)):\n            for j in xrange(len(picture[0])):\n                if picture[i][j] == 'B':\n                    rows[i] += 1\n                    cols[j] += 1\n\n        result = 0\n        for i in xrange(len(picture)):\n            if rows[i] == 1:\n                for j in xrange(len(picture[0])):\n                     result += picture[i][j] == 'B' and cols[j] == 1\n        return result\n\n\nclass Solution2(object):\n    def findLonelyPixel(self, picture):\n        \"\"\"\n        :type picture: List[List[str]]\n        :type N: int\n        :rtype: int\n        \"\"\"\n        return sum(col.count('B') == 1 == picture[col.index('B')].count('B') \\\n               for col in zip(*picture))\n\n"
    },
    {
        "problem_name": "lonely-pixel-ii",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nimport collections\n\n\nclass Solution(object):\n    def findBlackPixel(self, picture, N):\n        \"\"\"\n        :type picture: List[List[str]]\n        :type N: int\n        :rtype: int\n        \"\"\"\n        rows, cols = [0] * len(picture),  [0] * len(picture[0])\n        lookup = collections.defaultdict(int)\n        for i in xrange(len(picture)):\n            for j in xrange(len(picture[0])):\n                if picture[i][j] == 'B':\n                    rows[i] += 1\n                    cols[j] += 1\n            lookup[tuple(picture[i])] += 1\n\n        result = 0\n        for i in xrange(len(picture)):\n            if rows[i] == N and lookup[tuple(picture[i])] == N:\n                for j in xrange(len(picture[0])):\n                     result += picture[i][j] == 'B' and cols[j] == N\n        return result\n\n\nclass Solution2(object):\n    def findBlackPixel(self, picture, N):\n        \"\"\"\n        :type picture: List[List[str]]\n        :type N: int\n        :rtype: int\n        \"\"\"\n        lookup = collections.Counter(map(tuple, picture))\n        cols = [col.count('B') for col in zip(*picture)]\n        return sum(N * zip(row, cols).count(('B', N)) \\\n                   for row, cnt in lookup.iteritems() \\\n                   if cnt == N == row.count('B'))\n\n"
    },
    {
        "problem_name": "long-pressed-name",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isLongPressedName(self, name, typed):\n        \"\"\"\n        :type name: str\n        :type typed: str\n        :rtype: bool\n        \"\"\"\n        i = 0\n        for j in xrange(len(typed)):\n            if i < len(name) and name[i] == typed[j]:\n                i += 1\n            elif j == 0 or typed[j] != typed[j-1]:\n                return False\n        return i == len(name)\n"
    },
    {
        "problem_name": "longer-contiguous-segments-of-ones-than-zeros",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def checkZeroOnes(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        max_cnt = [0]*2\n        cnt = 0\n        for i in xrange(len(s)+1):\n            if i == len(s) or (i >= 1 and s[i] != s[i-1]):\n                max_cnt[int(s[i-1])] = max(max_cnt[int(s[i-1])], cnt)\n                cnt = 0\n            cnt += 1\n        return max_cnt[0] < max_cnt[1]\n"
    },
    {
        "problem_name": "longest-absolute-file-path",
        "solution": "# Time:  O(n)\n# Space: O(d), d is the max depth of the paths\n\nclass Solution(object):\n    def lengthLongestPath(self, input):\n        \"\"\"\n        :type input: str\n        :rtype: int\n        \"\"\"\n        def split_iter(s, tok):\n            start = 0\n            for i in xrange(len(s)):\n                if s[i] == tok:\n                    yield s[start:i]\n                    start = i + 1\n            yield s[start:]\n\n\n        max_len = 0\n        path_len = {0: 0}\n        for line in split_iter(input, '\\n'):\n            name = line.lstrip('\\t')\n            depth = len(line) - len(name)\n            if '.' in name:\n                max_len = max(max_len, path_len[depth] + len(name))\n            else:\n                path_len[depth + 1] = path_len[depth] + len(name) + 1\n        return max_len\n\n"
    },
    {
        "problem_name": "longest-alternating-subarray",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def alternatingSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = l = -1\n        for i in xrange(len(nums)-1):\n            if l != -1 and nums[i-1] == nums[i+1]:\n                l += 1\n            else:\n                l = 2 if nums[i+1]-nums[i] == 1 else -1\n            result = max(result, l)\n        return result\n"
    },
    {
        "problem_name": "longest-arithmetic-sequence",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nimport collections\n\nclass Solution(object):\n    def longestArithSeqLength(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        dp = collections.defaultdict(int)\n        for i in xrange(len(A)-1):\n            for j in xrange(i+1, len(A)):\n                v =  A[j]-A[i]\n                dp[v, j] = max(dp[v, j], dp[v, i]+1)\n        return max(dp.values())+1\n"
    },
    {
        "problem_name": "longest-arithmetic-subsequence-of-given-difference",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def longestSubsequence(self, arr, difference):\n        \"\"\"\n        :type arr: List[int]\n        :type difference: int\n        :rtype: int\n        \"\"\"\n        result = 1\n        lookup = collections.defaultdict(int)\n        for i in xrange(len(arr)):\n            lookup[arr[i]] = lookup[arr[i]-difference] + 1\n            result = max(result, lookup[arr[i]])\n        return result\n"
    },
    {
        "problem_name": "longest-binary-subsequence-less-than-or-equal-to-k",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def longestSubsequence(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result, base = 0, 1\n        for i in reversed(xrange(len(s))):\n            if s[i] == '0':\n                result += 1\n            elif base <= k:\n                k -= base\n                result += 1\n            if base <= k:\n                base <<= 1\n        return result\n"
    },
    {
        "problem_name": "longest-chunked-palindrome-decomposition",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Rabin-Karp Algorithm\nclass Solution(object):\n    def longestDecomposition(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: int\n        \"\"\"\n        def compare(text, l, s1, s2):\n            for i in xrange(l):\n                if text[s1+i] != text[s2+i]:\n                    return False\n            return True\n\n        MOD = 10**9+7\n        D = 26\n        result = 0\n        left, right, l, pow_D = 0, 0, 0, 1\n        for i in xrange(len(text)):\n            left = (D*left + (ord(text[i])-ord('a'))) % MOD\n            right = (pow_D*(ord(text[-1-i])-ord('a')) + right) % MOD\n            l += 1\n            pow_D = (pow_D*D) % MOD \n            if left == right and compare(text, l, i-l+1, len(text)-1-i):\n                result += 1\n                left, right, l, pow_D = 0, 0, 0, 1\n        return result\n"
    },
    {
        "problem_name": "longest-common-prefix",
        "solution": "# Time:  O(n * k), k is the length of the common prefix\n# Space: O(1)\n\nclass Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n\n        for i in xrange(len(strs[0])):\n            for string in strs[1:]:\n                if i >= len(string) or string[i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]\n\n\n# Time:  O(n * k), k is the length of the common prefix\n# Space: O(k)\nclass Solution2(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        prefix = \"\"\n        \n        for chars in zip(*strs):\n            if all(c == chars[0] for c in chars):\n                prefix += chars[0]\n            else:\n                return prefix\n            \n        return prefix\n"
    },
    {
        "problem_name": "longest-common-subpath",
        "solution": "# Time:  O(m * nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def longestCommonSubpath(self, n, paths):\n        \"\"\"\n        :type n: int\n        :type paths: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def RabinKarp(arr, x):  # double hashing\n            hashes = tuple([reduce(lambda h,x: (h*p+x)%MOD, (arr[i] for i in xrange(x)), 0) for p in P])\n            powers = [pow(p, x, MOD) for p in P]\n            lookup = {hashes}\n            for i in xrange(x, len(arr)):\n                hashes = tuple([(hashes[j]*P[j] - arr[i-x]*powers[j] + arr[i])%MOD for j in xrange(len(P))])  # in smaller datasets, tuple from list is much faster than tuple from generator, see https://stackoverflow.com/questions/16940293/why-is-there-no-tuple-comprehension-in-python\n                lookup.add(hashes)\n            return lookup\n        \n        def check(paths, x):\n            intersect = RabinKarp(paths[0], x)\n            for i in xrange(1, len(paths)):\n                intersect = set.intersection(intersect, RabinKarp(paths[i], x))\n                if not intersect:\n                    return False\n            return True\n\n        MOD, P = 10**9+7, (113, 109)  # MOD could be the min prime of 7-digit number (10**6+3), P could be (2, 3)\n        left, right = 1, min(len(p) for p in paths)\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(paths, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n\n\n# Time:  O(m * nlogn)\n# Space: O(n)\nclass Solution2(object):\n    def longestCommonSubpath(self, n, paths):\n        \"\"\"\n        :type n: int\n        :type paths: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def RabinKarp(arr, x):\n            h = reduce(lambda h,x: (h*P+x)%MOD, (arr[i] for i in xrange(x)), 0)\n            power = pow(P, x, MOD)\n            lookup = {h}\n            for i in xrange(x, len(arr)):\n                h = (h*P - arr[i-x]*power + arr[i])%MOD\n                lookup.add(h)\n            return lookup\n        \n        def check(paths, x):\n            intersect = RabinKarp(paths[0], x)\n            for i in xrange(1, len(paths)):\n                intersect = set.intersection(intersect, RabinKarp(paths[i], x))\n                if not intersect:\n                    return False\n            return True\n\n        MOD, P = 10**11+19, max(x for p in paths for x in p)+1  # MOD is the min prime of 12-digit number\n        left, right = 1, min(len(p) for p in paths)\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(paths, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "longest-common-subsequence-between-sorted-arrays",
        "solution": "# Time:  O(m * n)\n# Space: O(l), l is min(len(arr) for arr in arrays)\n\nclass Solution(object):\n    def longestCommomSubsequence(self, arrays):\n        \"\"\"\n        :type arrays: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = min(arrays, key=lambda x: len(x))\n        for arr in arrays:\n            new_result = []\n            i, j = 0, 0\n            while i != len(result) and j != len(arr):\n                if result[i] < arr[j]:\n                    i += 1\n                elif result[i] > arr[j]:\n                    j += 1\n                else:\n                    new_result.append(result[i])\n                    i += 1\n                    j += 1\n            result = new_result\n        return result\n\n\n# Time:  O(m * n)\n# Space: O(k), k is min(m * n, max(x for arr in arrays for x in arr))\nimport collections\n\n\nclass Solution2(object):\n    def longestCommomSubsequence(self, arrays):\n        \"\"\"\n        :type arrays: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        return [num for num, cnt in collections.Counter(x for arr in arrays for x in arr).iteritems() if cnt == len(arrays)]\n"
    },
    {
        "problem_name": "longest-common-subsequence",
        "solution": "# Time:  O(m * n)\n# Space: O(min(m, n))\n\nclass Solution(object):\n    def longestCommonSubsequence(self, text1, text2):\n        \"\"\"\n        :type text1: str\n        :type text2: str\n        :rtype: int\n        \"\"\"\n        if len(text1) < len(text2):\n            return self.longestCommonSubsequence(text2, text1)\n\n        dp = [[0 for _ in xrange(len(text2)+1)] for _ in xrange(2)]\n        for i in xrange(1, len(text1)+1):\n            for j in xrange(1, len(text2)+1):\n                dp[i%2][j] = dp[(i-1)%2][j-1]+1 if text1[i-1] == text2[j-1] \\\n                             else max(dp[(i-1)%2][j], dp[i%2][j-1])\n        return dp[len(text1)%2][len(text2)]\n"
    },
    {
        "problem_name": "longest-common-suffix-queries",
        "solution": "# Time:  O((n + q) * l)\n# Space: O(t)\n\n# trie\nclass Solution(object):\n    def stringIndices(self, wordsContainer, wordsQuery):\n        \"\"\"\n        :type wordsContainer: List[str]\n        :type wordsQuery: List[str]\n        :rtype: List[int]\n        \"\"\"\n        INF = float(\"INF\")\n        class Trie(object):\n            def __init__(self):\n                self.__nodes = []\n                self.__mns = []\n                self.__new_node()\n            \n            def __new_node(self):\n                self.__nodes.append([-1]*26)\n                self.__mns.append((INF, INF))\n                return len(self.__nodes)-1\n\n            def add(self, i, w):\n                curr = 0\n                self.__mns[curr] = min(self.__mns[curr], (len(w), i))\n                for c in reversed(w):\n                    x = ord(c)-ord('a')\n                    if self.__nodes[curr][x] == -1:\n                        self.__nodes[curr][x] = self.__new_node()\n                    curr = self.__nodes[curr][x]\n                    self.__mns[curr] = min(self.__mns[curr], (len(w), i))\n            \n            def query(self, w):\n                curr = 0\n                for c in reversed(w):\n                    x = ord(c)-ord('a')\n                    if self.__nodes[curr][x] == -1:\n                        break\n                    curr = self.__nodes[curr][x]\n                return self.__mns[curr][1]\n    \n        trie = Trie()\n        for i, w in enumerate(wordsContainer): \n            trie.add(i, w)\n        return [trie.query(w) for w in wordsQuery]\n"
    },
    {
        "problem_name": "longest-consecutive-sequence",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    # @param num, a list of integer\n    # @return an integer\n    def longestConsecutive(self, num):\n        result, lengths = 1, {key: 0 for key in num}\n        for i in num:\n            if lengths[i] == 0:\n                lengths[i] = 1\n                left, right = lengths.get(i - 1, 0), lengths.get(i + 1, 0)\n                length = 1 + left + right\n                result, lengths[i - left], lengths[i + right] = max(result, length), length, length\n        return result\n\n"
    },
    {
        "problem_name": "longest-continuous-increasing-subsequence",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findLengthOfLCIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, count = 0, 0\n        for i in xrange(len(nums)):\n            if i == 0 or nums[i-1] < nums[i]:\n                count += 1\n                result = max(result, count)\n            else:\n                count = 1\n        return result\n\n"
    },
    {
        "problem_name": "longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def longestSubarray(self, nums, limit):\n        \"\"\"\n        :type nums: List[int]\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        max_dq, min_dq = collections.deque(), collections.deque()\n        left = 0\n        for right, num in enumerate(nums):\n            while max_dq and nums[max_dq[-1]] <= num:\n                max_dq.pop()\n            max_dq.append(right)\n            while min_dq and nums[min_dq[-1]] >= num:\n                min_dq.pop()\n            min_dq.append(right)\n            if nums[max_dq[0]]-nums[min_dq[0]] > limit:\n                if max_dq[0] == left:\n                    max_dq.popleft()\n                if min_dq[0] == left:\n                    min_dq.popleft()\n                left += 1  # advance left by one to not count in result\n        return len(nums)-left\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\nclass Solution2(object):\n    def longestSubarray(self, nums, limit):\n        \"\"\"\n        :type nums: List[int]\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        max_dq, min_dq = collections.deque(), collections.deque()\n        result, left = 0, 0\n        for right, num in enumerate(nums):\n            while max_dq and nums[max_dq[-1]] <= num:\n                max_dq.pop()\n            max_dq.append(right)\n            while min_dq and nums[min_dq[-1]] >= num:\n                min_dq.pop()\n            min_dq.append(right)\n            while nums[max_dq[0]]-nums[min_dq[0]] > limit:  # both always exist \"right\" element\n                if max_dq[0] == left:\n                    max_dq.popleft()\n                if min_dq[0] == left:\n                    min_dq.popleft()\n                left += 1\n            result = max(result, right-left+1)\n        return result\n"
    },
    {
        "problem_name": "longest-cycle-in-a-graph",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# graph\nclass Solution(object):\n    def longestCycle(self, edges):\n        \"\"\"\n        :type edges: List[int]\n        :rtype: int\n        \"\"\"\n        result = -1\n        lookup = [-1]*len(edges)\n        idx = 0\n        for i in xrange(len(edges)):\n            if lookup[i] != -1:\n                continue\n            start = idx\n            while i != -1:\n                if lookup[i] != -1:\n                    break\n                lookup[i] = idx\n                idx += 1\n                i = edges[i]\n            if i != -1 and lookup[i] >= start:\n                result = max(result, idx-lookup[i])\n        return result\n"
    },
    {
        "problem_name": "longest-duplicate-substring",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# 1. other solution is to apply kasai's algorithm, refer to the link below:\n# - https://leetcode.com/problems/longest-duplicate-substring/discuss/290852/Suffix-array-clear-solution\n# 2. the best solution is to apply ukkonen's algorithm, refer to the link below:\n# - https://leetcode.com/problems/longest-duplicate-substring/discuss/312999/best-java-on-complexity-and-on-space-solution-suffix-tree-67ms\n\nimport collections\n\n\nclass Solution(object):\n    def longestDupSubstring(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        M = 10**9+7\n        D = 26\n\n        def check(S, L):\n            p = pow(D, L, M)\n            curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0)\n            lookup = collections.defaultdict(list)\n            lookup[curr].append(L-1)\n            for i in xrange(L, len(S)):\n                curr = ((D*curr) % M + ord(S[i])-ord('a') -\n                        ((ord(S[i-L])-ord('a'))*p) % M) % M\n                if curr in lookup:\n                    for j in lookup[curr]:  # check if string is the same when hash is the same\n                        if S[j-L+1:j+1] == S[i-L+1:i+1]:\n                            return i-L+1\n                lookup[curr].append(i)\n            return 0\n\n        left, right = 1, len(S)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(S, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        result = check(S, right)\n        return S[result:result + right]\n"
    },
    {
        "problem_name": "longest-even-odd-subarray-with-threshold",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def longestAlternatingSubarray(self, nums, threshold):\n        \"\"\"\n        :type nums: List[int]\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        result = l = 0\n        for x in nums:\n            if x > threshold:\n                l = 0\n                continue\n            if l%2 == x%2:\n                l += 1\n            else:\n                l = int(x%2 == 0)\n            result = max(result, l)\n        return result\n"
    },
    {
        "problem_name": "longest-happy-prefix",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# kmp solution\nclass Solution(object):\n    def longestPrefix(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j != -1 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n        \n        return s[:getPrefix(s)[-1]+1]\n\n\n# Time:  O(n) on average\n# Space: O(1)\n# rolling-hash solution\nclass Solution2(object):\n    def longestPrefix(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        M = 10**9+7\n        D = 26\n        def check(l, s):\n            for i in xrange(l):\n                if s[i] != s[len(s)-l+i]:\n                    return False\n            return True\n    \n        result, prefix, suffix, power = 0, 0, 0, 1\n        for i in xrange(len(s)-1):\n            prefix = (prefix*D + (ord(s[i])-ord('a'))) % M\n            suffix = (suffix + (ord(s[len(s)-(i+1)])-ord('a'))*power) % M\n            power = (power*D)%M\n            if prefix == suffix:\n                # we assume M is a very large prime without hash collision\n                # assert(check(i+1, s))\n                result = i+1\n        return s[:result]\n"
    },
    {
        "problem_name": "longest-happy-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport heapq\n\n\nclass Solution(object):\n    def longestDiverseString(self, a, b, c):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type c: int\n        :rtype: str\n        \"\"\"\n        max_heap = []\n        if a:\n            heapq.heappush(max_heap, (-a, 'a'))\n        if b:\n            heapq.heappush(max_heap, (-b, 'b'))\n        if c:\n            heapq.heappush(max_heap, (-c, 'c'))\n        result = []\n        while max_heap:\n            count1, c1 = heapq.heappop(max_heap)\n            if len(result) >= 2 and result[-1] == result[-2] == c1:\n                if not max_heap:\n                    return \"\".join(result)\n                count2, c2 = heapq.heappop(max_heap)\n                result.append(c2)\n                count2 += 1\n                if count2:\n                    heapq.heappush(max_heap, (count2, c2))\n                heapq.heappush(max_heap, (count1, c1))\n                continue\n            result.append(c1)\n            count1 += 1\n            if count1 != 0:\n                heapq.heappush(max_heap, (count1, c1))\n        return \"\".join(result)\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def longestDiverseString(self, a, b, c):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type c: int\n        :rtype: str\n        \"\"\"\n        choices = [[a, 'a'], [b, 'b'], [c, 'c']]\n        result = []\n        for _ in xrange(a+b+c):\n            choices.sort(reverse=True)\n            for i, (x, c) in enumerate(choices):\n                if x and result[-2:] != [c, c]:\n                    result.append(c)\n                    choices[i][0] -= 1\n                    break\n            else:\n                break\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "longest-harmonious-subsequence",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def findLHS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = collections.defaultdict(int)\n        result = 0\n        for num in nums:\n            lookup[num] += 1\n            for diff in [-1, 1]:\n                if (num + diff) in lookup:\n                    result = max(result, lookup[num] + lookup[num + diff])\n        return result\n\n"
    },
    {
        "problem_name": "longest-ideal-subsequence",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def longestIdealString(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        dp = [0]*26\n        for c in s:\n            x = ord(c)-ord('a')\n            dp[x] = max(dp[i] for i in xrange(max(x-k, 0), min(x+k+1, 26)))+1\n        return max(dp)\n"
    },
    {
        "problem_name": "longest-increasing-path-in-a-matrix",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\n# topological sort solution\nclass Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        if not matrix:\n            return 0\n        \n        in_degree = [[0]*len(matrix[0]) for _ in xrange(len(matrix))]\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                for di, dj in directions:\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < len(matrix) and\n                            0 <= nj < len(matrix[0]) and\n                            matrix[ni][nj] > matrix[i][j]):\n                        continue\n                    in_degree[i][j] += 1\n        q = []\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                if not in_degree[i][j]:\n                    q.append((i, j))\n        result = 0\n        while q:\n            new_q = []\n            for i, j in q:\n                for di, dj in directions:\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < len(matrix) and\n                            0 <= nj < len(matrix[0]) and\n                            matrix[i][j] > matrix[ni][nj]):\n                        continue\n                    in_degree[ni][nj] -= 1\n                    if not in_degree[ni][nj]:\n                        new_q.append((ni, nj))\n            q = new_q\n            result += 1         \n        return result\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\n# dfs + memoization solution\nclass Solution2(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def longestpath(matrix, i, j, max_lengths):\n            if max_lengths[i][j]:\n                return max_lengths[i][j]\n            max_depth = 0\n            for di, dj in directions:\n                x, y = i+di, j+dj\n                if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and \\\n                   matrix[x][y] < matrix[i][j]:\n                    max_depth = max(max_depth, longestpath(matrix, x, y, max_lengths))\n            max_lengths[i][j] = max_depth + 1\n            return max_lengths[i][j]\n\n        if not matrix:\n            return 0\n        result = 0\n        max_lengths = [[0 for _ in xrange(len(matrix[0]))] for _ in xrange(len(matrix))]\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                result = max(result, longestpath(matrix, i, j, max_lengths))\n        return result\n"
    },
    {
        "problem_name": "longest-increasing-subsequence-ii",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport bisect\n\n\n# Range Maximum Query\nclass SegmentTree(object):\n    def __init__(self, N,\n                 build_fn=lambda _: 0,\n                 query_fn=lambda x, y: y if x is None else x if y is None else max(x, y),\n                 update_fn=lambda x: x):\n        self.tree = [None]*(2*2**((N-1).bit_length()))\n        self.base = len(self.tree)//2\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        for i in xrange(self.base, self.base+N):\n            self.tree[i] = build_fn(i-self.base)\n        for i in reversed(xrange(1, self.base)):\n            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n\n    def update(self, i, h):\n        x = self.base+i\n        self.tree[x] = self.update_fn(h)\n        while x > 1:\n            x //= 2\n            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n\n    def query(self, L, R):\n        if L > R:\n            return 0\n        L += self.base\n        R += self.base\n        left = right = None\n        while L <= R:\n            if L & 1:\n                left = self.query_fn(left, self.tree[L])\n                L += 1\n            if R & 1 == 0:\n                right = self.query_fn(self.tree[R], right)\n                R -= 1\n            L //= 2\n            R //= 2\n        return self.query_fn(left, right)\n\n\n# segment tree with coordinate compression\nclass Solution(object):\n    def lengthOfLIS(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        sorted_nums = sorted({x-1 for x in nums})\n        num_to_idx = {x:i for i, x in enumerate(sorted_nums)}\n        st = SegmentTree(len(num_to_idx))\n        for x in nums:\n            x -= 1\n            st.update(num_to_idx[x], st.query(bisect.bisect_left(sorted_nums, x-k), num_to_idx[x]-1)+1)\n        return st.tree[1]  # st.query(0, len(num_to_idx)-1)\n"
    },
    {
        "problem_name": "longest-increasing-subsequence",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport bisect\n\n\nclass Solution(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        LIS = []\n        def insert(target):\n            left = bisect.bisect_left(LIS, target)\n            # If not found, append the target.\n            if left == len(LIS):\n                LIS.append(target)\n            else:\n                LIS[left] = target\n    \n        for num in nums:\n            insert(num)\n        return len(LIS)\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nclass Solution2(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        LIS = []\n        def insert(target):\n            left, right = 0, len(LIS) - 1\n            # Find the first index \"left\" which satisfies LIS[left] >= target\n            while left <= right:\n                mid = left + (right - left) // 2\n                if LIS[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # If not found, append the target.\n            if left == len(LIS):\n                LIS.append(target)\n            else:\n                LIS[left] = target\n\n        for num in nums:\n            insert(num)\n\n        return len(LIS)\n\n\n# Range Maximum Query\nclass SegmentTree(object):  # 0-based index\n    def __init__(self, N,\n                 build_fn=lambda x, y: [y]*(2*x),\n                 query_fn=lambda x, y: y if x is None else max(x, y),  # (lambda x, y: y if x is None else min(x, y))\n                 update_fn=lambda x, y: y,\n                 default_val=0):\n        self.N = N\n        self.H = (N-1).bit_length()\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        self.default_val = default_val\n        self.tree = build_fn(N, default_val)\n        self.lazy = [None]*N\n\n    def __apply(self, x, val):\n        self.tree[x] = self.update_fn(self.tree[x], val)\n        if x < self.N:\n            self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n    def update(self, L, R, h):  # Time: O(logN), Space: O(N)\n        def pull(x):\n            while x > 1:\n                x //= 2\n                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n                if self.lazy[x] is not None:\n                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\n\n        L += self.N\n        R += self.N\n        L0, R0 = L, R\n        while L <= R:\n            if L & 1:  # is right child\n                self.__apply(L, h) \n                L += 1\n            if R & 1 == 0:  # is left child\n                self.__apply(R, h)\n                R -= 1\n            L //= 2\n            R //= 2\n        pull(L0)\n        pull(R0)\n\n    def query(self, L, R):  # Time: O(logN), Space: O(N)\n        def push(x):\n            n = 2**self.H\n            while n != 1:\n                y = x // n\n                if self.lazy[y] is not None:\n                    self.__apply(y*2, self.lazy[y])\n                    self.__apply(y*2 + 1, self.lazy[y])\n                    self.lazy[y] = None\n                n //= 2\n\n        result = None\n        if L > R:\n            return result\n\n        L += self.N\n        R += self.N\n        push(L)\n        push(R)\n        while L <= R:\n            if L & 1:  # is right child\n                result = self.query_fn(result, self.tree[L])\n                L += 1\n            if R & 1 == 0:  # is left child\n                result = self.query_fn(result, self.tree[R])\n                R -= 1\n            L //= 2\n            R //= 2\n        return result\n    \n    def __str__(self):\n        showList = []\n        for i in xrange(self.N):\n            showList.append(self.query(i, i))\n        return \",\".join(map(str, showList))\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# optimized from Solution4\nclass Solution3(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        sorted_nums = sorted(set(nums))\n        lookup = {num:i for i, num in enumerate(sorted_nums)}\n        segment_tree = SegmentTree(len(lookup))\n        for num in nums:\n            segment_tree.update(lookup[num], lookup[num],\n                                segment_tree.query(0, lookup[num]-1)+1 if lookup[num] >= 1 else 1)\n        return segment_tree.query(0, len(lookup)-1) if len(lookup) >= 1 else 0\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# Traditional DP solution.\nclass Solution4(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = []  # dp[i]: the length of LIS ends with nums[i]\n        for i in xrange(len(nums)):\n            dp.append(1)\n            for j in xrange(i):\n                if nums[j] < nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp) if dp else 0\n\n"
    },
    {
        "problem_name": "longest-line-of-consecutive-one-in-matrix",
        "solution": "# Time:  O(m * n)\n# Space: O(n)\n\nclass Solution(object):\n    def longestLine(self, M):\n        \"\"\"\n        :type M: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not M: return 0\n        result = 0\n        dp = [[[0] * 4 for _ in xrange(len(M[0]))] for _ in xrange(2)]\n        for i in xrange(len(M)):\n            for j in xrange(len(M[0])):\n                dp[i % 2][j][:] = [0] * 4\n                if M[i][j] == 1:\n                    dp[i % 2][j][0] = dp[i % 2][j - 1][0]+1 if j > 0 else 1\n                    dp[i % 2][j][1] = dp[(i-1) % 2][j][1]+1 if i > 0 else 1\n                    dp[i % 2][j][2] = dp[(i-1) % 2][j-1][2]+1 if (i > 0 and j > 0) else 1\n                    dp[i % 2][j][3] = dp[(i-1) % 2][j+1][3]+1 if (i > 0 and j < len(M[0])-1) else 1\n                    result = max(result, max(dp[i % 2][j]))\n        return result\n\n"
    },
    {
        "problem_name": "longest-mountain-in-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n\nclass Solution(object):\n    def longestMountain(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        result, up_len, down_len = 0, 0, 0\n        for i in xrange(1, len(A)):\n            if (down_len and A[i-1] < A[i]) or A[i-1] == A[i]:\n                up_len, down_len = 0, 0\n            up_len += A[i-1] < A[i]\n            down_len += A[i-1] > A[i]\n            if up_len and down_len:\n                result = max(result, up_len+down_len+1)\n        return result\n\n"
    },
    {
        "problem_name": "longest-nice-subarray",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# sliding window, two pointers\nclass Solution(object):\n    def longestNiceSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = left = curr = 0\n        for right in xrange(len(nums)):\n            while curr&nums[right]:\n                curr ^= nums[left]\n                left += 1\n            curr |= nums[right]\n            result = max(result, right-left+1)\n        return result\n"
    },
    {
        "problem_name": "longest-nice-substring",
        "solution": "# Time:  O(26 * n) = O(n)\n# Space: O(26 * n) = O(n)\n\nclass Solution(object):\n    def longestNiceSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        lookup = set(list(s))\n        prev = -1\n        result = \"\"\n        for i in xrange(len(s)+1):\n            if not (i == len(s) or s[i] not in lookup or s[i].swapcase() not in lookup):\n                continue\n            if prev == -1 and i == len(s):\n                return s\n            tmp = self.longestNiceSubstring(s[prev+1:i])\n            if len(tmp) > len(result):\n                result = tmp\n            prev = i\n        return result\n"
    },
    {
        "problem_name": "longest-non-decreasing-subarray-from-two-arrays",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def maxNonDecreasingLength(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        result = 1\n        dp = [1]*2\n        for i in xrange(len(nums1)-1):\n            dp = [max((dp[0]+1 if nums1[i] <= nums1[i+1] else 1), (dp[1]+1 if nums2[i] <= nums1[i+1] else 1)),\n                  max((dp[0]+1 if nums1[i] <= nums2[i+1] else 1), (dp[1]+1 if nums2[i] <= nums2[i+1] else 1))]\n            result = max(result, max(dp))\n        return result\n"
    },
    {
        "problem_name": "longest-palindrome-by-concatenating-two-letter-words",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def longestPalindrome(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(words)\n        result = remain = 0\n        for x, c in cnt.iteritems():\n            if x == x[::-1]:\n                result += c//2\n                remain |= c%2\n            elif x < x[::-1] and x[::-1] in cnt:\n                result += min(c, cnt[x[::-1]])\n        return result*4+remain*2\n"
    },
    {
        "problem_name": "longest-palindrome",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        odds = 0\n        for k, v in collections.Counter(s).iteritems():\n            odds += v & 1\n        return len(s) - odds + int(odds > 0)\n\n    def longestPalindrome2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        odd = sum(map(lambda x: x & 1, collections.Counter(s).values()))\n        return len(s) - odd + int(odd > 0)\n\n"
    },
    {
        "problem_name": "longest-palindromic-subsequence-ii",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def longestPalindromeSubseq(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        dp = [[[0]*26 for _ in xrange(len(s))] for _ in xrange(2)]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i+1, len(s)):\n                if i == j-1:\n                    if s[j] == s[i]:\n                        dp[i%2][j][ord(s[i])-ord('a')] = 2\n                else:\n                    for k in xrange(26):\n                        if s[j] == s[i] and ord(s[j])-ord('a') != k:\n                            dp[i%2][j][ord(s[j])-ord('a')] = max(dp[i%2][j][ord(s[j])-ord('a')], dp[(i+1)%2][j-1][k]+2);\n                        dp[i%2][j][k] = max(dp[i%2][j][k], dp[i%2][j-1][k], dp[(i+1)%2][j][k], dp[(i+1)%2][j-1][k])\n        return max(dp[0][-1])\n"
    },
    {
        "problem_name": "longest-palindromic-subsequence",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def longestPalindromeSubseq(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if s == s[::-1]:  # optional, to optimize special case\n            return len(s)\n\n        dp = [[1] * len(s) for _ in xrange(2)]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i+1, len(s)):\n                if s[i] == s[j]:\n                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2\n                else:\n                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])\n        return dp[0][-1]\n\n"
    },
    {
        "problem_name": "longest-palindromic-substring",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            T = ['^']\n            for c in s:\n                T +=  ['#', c]\n            T += ['#', '$']\n            return T\n\n        T = preProcess(s)\n        P = [0] * len(T)\n        center, right = 0, 0\n        for i in xrange(1, len(T) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                P[i] = min(right - i, P[i_mirror])\n            else:\n                P[i] = 0\n\n            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                P[i] += 1\n\n            if i + P[i] > right:\n                center, right = i, i + P[i]\n\n        max_i = 0\n        for i in xrange(1, len(T) - 1):\n            if P[i] > P[max_i]:\n                max_i = i\n        start = (max_i - 1 - P[max_i]) // 2\n        return s[start : start + P[max_i]]\n\n\n# Time:  O(n^2)\n# Space: O(1)\nclass Solution2(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return (right-left+1)-2\n        \n        left, right = -1, -2\n        for i in xrange(len(s)):\n            l = max(expand(s, i, i), expand(s, i, i+1))\n            if l > right-left+1:\n                right = i+l//2\n                left = right-l+1\n        return s[left:right+1] if left >= 0 else \"\"\n"
    },
    {
        "problem_name": "longest-path-with-different-adjacent-characters",
        "solution": "# Time:  O(n)\n# Space: O(w)\n\nimport collections\n\n\n# tree, bfs, topological sort\nclass Solution(object):\n    def longestPath(self, parent, s):\n        \"\"\"\n        :type parent: List[int]\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def topological_sort(s, adj, in_degree):\n            result = 1\n            top2 = collections.defaultdict(lambda:[0]*2)\n            q =  [(i, 1) for i, d in enumerate(in_degree) if not d]\n            while q:\n                new_q = []\n                for (u, l) in q:\n                    for v in adj[u]:\n                        if s[v] != s[u]:\n                            if l > top2[v][0]:\n                                top2[v][0], top2[v][1] = l, top2[v][0]\n                            elif l > top2[v][1]:\n                                top2[v][1] = l\n                        in_degree[v] -= 1\n                        if in_degree[v]:\n                            continue\n                        new_q.append((v, top2[v][0]+1))\n                        result = max(result, top2[v][0]+top2[v][1]+1)\n                        del top2[v]\n                q = new_q\n            return result\n\n        adj = [[] for _ in xrange(len(s))]\n        in_degree = [0]*len(s)\n        for i in xrange(1, len(parent)):\n            adj[i].append(parent[i])\n            in_degree[parent[i]] += 1\n        return topological_sort(s, adj, in_degree)\n\n\n# Time:  O(n)\n# Space: O(h)\n# tree, dfs\nclass Solution2(object):\n    def longestPath(self, parent, s):\n        \"\"\"\n        :type parent: List[int]\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def iter_dfs(s, adj):\n            result = 0\n            stk = [(1, (0, [0]))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    u, ret = args\n                    top2 = [0]*2\n                    stk.append((4, (top2, ret)))\n                    stk.append((2, (u, 0, top2, ret)))\n                elif step == 2:\n                    u, i, top2, ret = args\n                    if i == len(adj[u]):\n                        continue\n                    ret2 = [0]\n                    stk.append((3, (u, i, top2, ret2)))\n                    stk.append((1, (adj[u][i], ret2))) \n                elif step == 3:\n                    u, i, top2, ret2 = args\n                    if s[adj[u][i]] != s[u]:\n                        if ret2[0] > top2[0]:\n                            top2[0], top2[1] = ret2[0], top2[0]\n                        elif ret2[0] > top2[1]:\n                            top2[1] = ret2[0]\n                    stk.append((2, (u, i+1, top2, ret)))\n                elif step == 4:\n                    top2, ret = args\n                    result = max(result, top2[0]+top2[1]+1)\n                    ret[0] = top2[0]+1\n            return result\n    \n        \n        adj = [[] for _ in xrange(len(s))]\n        for i in xrange(1, len(parent)):\n            adj[parent[i]].append(i)\n        return iter_dfs(s, adj)\n    \n\n# Time:  O(n)\n# Space: O(h)\n# tree, dfs\nclass Solution3(object):\n    def longestPath(self, parent, s):\n        \"\"\"\n        :type parent: List[int]\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def dfs(s, adj, u, result):\n            top2 = [0]*2\n            for v in adj[u]:\n                l = dfs(s, adj, v, result)\n                if s[v] == s[u]:\n                    continue\n                if l > top2[0]:\n                    top2[0], top2[1] = l, top2[0]\n                elif l > top2[1]:\n                    top2[1] = l\n            result[0] = max(result[0], top2[0]+top2[1]+1)\n            return top2[0]+1\n    \n        \n        adj = [[] for _ in xrange(len(s))]\n        for i in xrange(1, len(parent)):\n            adj[parent[i]].append(i)\n        result = [0]\n        dfs(s, adj, 0, result)\n        return result[0]\n    \n"
    },
    {
        "problem_name": "longest-repeating-character-replacement",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def characterReplacement(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result, max_count = 0, 0\n        count = collections.Counter()\n        for i in xrange(len(s)):\n            count[s[i]] += 1\n            max_count = max(max_count, count[s[i]])\n            if result - max_count >= k:\n                count[s[i-result]] -= 1\n            else:\n                result += 1\n        return result\n\n"
    },
    {
        "problem_name": "longest-repeating-substring",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def longestRepeatingSubstring(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        M = 10**9+7\n        D = 26\n\n        def check(S, L):\n            p = pow(D, L, M)\n            curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0)\n            lookup = collections.defaultdict(list)\n            lookup[curr].append(L-1)\n            result = 0\n            for i in xrange(L, len(S)):\n                curr = ((D*curr) % M + ord(S[i])-ord('a') -\n                        ((ord(S[i-L])-ord('a'))*p) % M) % M\n                if curr in lookup:\n                    for j in lookup[curr]:\n                        if S[j-L+1:j+1] == S[i-L+1:i+1]:\n                            if result == 0:\n                                result = i\n                            return result-L+1\n                lookup[curr].append(i)\n            return result\n\n        left, right = 0, len(S)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(S, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n        \n"
    },
    {
        "problem_name": "longest-square-streak-in-an-array",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# hash table\nclass Solution(object):\n    def longestSquareStreak(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        sorted_nums = sorted(set(nums))\n        squares = {x for x in sorted_nums if x%2 < 2}  # squared_num % 4 in [0, 1] \n        result = 0\n        for x in sorted_nums:\n            square, cnt = x**2, 1\n            while square in squares:\n                squares.remove(square)\n                cnt += 1\n                square *= square\n            result = max(result, cnt)\n        return result if result != 1 else -1\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# dp\nclass Solution2(object):\n    def longestSquareStreak(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = collections.defaultdict(int)\n        nums.sort()\n        result = -1\n        for x in nums:\n            sqrt_x = int(x**0.5)\n            if sqrt_x**2 == x:\n                dp[x] = dp[sqrt_x]+1\n            else:\n                dp[x] = 1\n            result = max(result, dp[x])\n        return result if result != 1 else -1\n"
    },
    {
        "problem_name": "longest-strictly-increasing-or-strictly-decreasing-subarray",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def longestMonotonicSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = cnt = 1\n        curr = prev = 0\n        for i in xrange(1, len(nums)):\n            curr = cmp(nums[i-1], nums[i])\n            if curr == 0:\n                cnt = 1\n                continue\n            else:\n                cnt = (cnt if curr == prev else 1)+1\n                result = max(result, cnt)\n            prev = curr\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\n# array\nclass Solution2(object):\n    def longestMonotonicSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = cnt1 = cnt2 = 1\n        for i in xrange(1, len(nums)):\n            if nums[i-1] < nums[i]:\n                cnt1 += 1\n                cnt2 = 1\n            elif nums[i-1] > nums[i]:\n                cnt2 += 1\n                cnt1 = 1\n            else:\n                cnt1 = cnt2 = 1\n            result = max(result, cnt1, cnt2)\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\n# array\nclass Solution3(object):\n    def longestMonotonicSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def f(compare):\n            result = l = 0\n            for i in xrange(len(nums)):\n                l += 1\n                if i+1 == len(nums) or not compare(nums[i], nums[i+1]):\n                    result = max(result, l)\n                    l = 0\n            return result\n\n        return max(f(lambda x, y: x < y), f(lambda x, y: x > y))\n"
    },
    {
        "problem_name": "longest-string-chain",
        "solution": "# Time:  O(n * l^2)\n# Space: O(n * l)\n\nimport collections\n\n\nclass Solution(object):\n    def longestStrChain(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        words.sort(key=len)\n        dp = collections.defaultdict(int)\n        for w in words:\n            for i in xrange(len(w)):\n                dp[w] = max(dp[w], dp[w[:i]+w[i+1:]]+1)\n        return max(dp.itervalues())\n"
    },
    {
        "problem_name": "longest-subarray-of-1s-after-deleting-one-element",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def longestSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count, left = 0, 0\n        for right in xrange(len(nums)):\n            count += (nums[right] == 0)\n            if count >= 2:\n                count -= (nums[left] == 0)\n                left += 1\n        return (right-left+1)-1\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def longestSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, count, left = 0, 0, 0\n        for right in xrange(len(nums)):\n            count += (nums[right] == 0)\n            while count >= 2:\n                count -= (nums[left] == 0)\n                left += 1\n            result = max(result, right-left+1)\n        return result-1\n"
    },
    {
        "problem_name": "longest-subarray-with-maximum-bitwise-and",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def longestSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        mx = max(nums)\n        result, l = 1, 0\n        for x in nums:\n            if x == mx:\n                l += 1\n                result = max(result, l)\n            else:\n                l = 0\n        return result\n"
    },
    {
        "problem_name": "longest-subsequence-repeated-k-times",
        "solution": "# Time:  O(n * (n/k)!)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def longestSubsequenceRepeatedK(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        def check(s, k, curr):\n            if not curr:\n                return True\n            i = 0\n            for c in s:\n                if c != curr[i]:\n                    continue\n                i += 1\n                if i != len(curr):\n                    continue\n                i = 0\n                k -= 1\n                if not k:\n                    return True\n            return False\n\n        def backtracking(s, k, curr, cnts, result):\n            if not check(s, k, curr):\n                return\n            if len(curr) > len(result):\n                result[:] = curr\n            for c in reversed(string.ascii_lowercase):\n                if cnts[c] < k:\n                    continue\n                cnts[c] -= k\n                curr.append(c)\n                backtracking(s, k, curr, cnts, result)\n                curr.pop()\n                cnts[c] += k\n                    \n        cnts = collections.Counter(s)\n        new_s = []\n        for c in s:\n            if cnts[c] < k:\n                continue\n            new_s.append(c)\n        result =[]\n        backtracking(new_s, k, [], cnts, result)\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "longest-subsequence-with-limited-sum",
        "solution": "# Time:  O(nlogn + qlogn)\n# Space: O(1)\n\nimport bisect\n\n\n# greedy, sort, binary search\nclass Solution(object):\n    def answerQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        for i in xrange(len(nums)-1):\n            nums[i+1] += nums[i]\n        return [bisect.bisect_right(nums, q) for q in queries]\n"
    },
    {
        "problem_name": "longest-substring-of-all-vowels-in-order",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def longestBeautifulSubstring(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        l = cnt = 1\n        for i in xrange(len(word)-1):\n            if word[i] > word[i+1]:\n                l = cnt = 1\n            else:\n                l += 1\n                cnt += int(word[i] < word[i+1])\n            if cnt == 5:\n                result = max(result, l)\n        return result\n"
    },
    {
        "problem_name": "longest-substring-of-one-repeating-character",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport itertools\n\n\n# Template:\n# https://github.com/kamyu104/FacebookHackerCup-2021/blob/main/Round%203/auth_ore_ization.py\nclass SegmentTree(object):\n    def __init__(self, N,\n                 build_fn=lambda _: float(\"inf\"),\n                 query_fn=lambda x, y: x if y is None else min(x, y),\n                 update_fn=lambda x: x):\n        self.tree = [None]*(2*2**((N-1).bit_length()))\n        self.base = len(self.tree)//2\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        for i in xrange(self.base, self.base+N):\n            self.tree[i] = build_fn(i-self.base)\n        for i in reversed(xrange(1, self.base)):\n            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n\n    def update(self, i, h):\n        x = self.base+i\n        self.tree[x] = self.update_fn(h)\n        while x > 1:\n            x //= 2\n            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n\n\n# segment tree\nclass Solution(object):\n    def longestRepeating(self, s, queryCharacters, queryIndices):\n        \"\"\"\n        :type s: str\n        :type queryCharacters: str\n        :type queryIndices: List[int]\n        :rtype: List[int]\n        \"\"\"\n        LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = xrange(7)\n        def build(i):\n            return update(s[i])\n\n        def update(y):\n            result = [0]*SIZE\n            result[LEFT] = result[RIGHT] = y\n            result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1\n            return result\n\n        def query(x, y):\n            return x if y is None else \\\n                   [x[LEFT],\n                    y[RIGHT],\n                    x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0),\n                    y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0),\n                    x[LEN]+y[LEN],\n                    max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)]\n        \n        result = []\n        st = SegmentTree(len(s), build_fn=build, query_fn=query, update_fn=update)\n        for c, i in itertools.izip(queryCharacters, queryIndices):\n            st.update(i, c)\n            result.append(st.tree[1][MAX_LEN])\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\n\n\n# Template:\n# https://github.com/kamyu104/FacebookHackerCup-2021/blob/main/Round%203/auth_ore_ization.py\nclass SegmentTree2(object):\n    def __init__(self, N,\n                 build_fn=lambda _: float(\"inf\"),\n                 query_fn=lambda x, y: y if x is None else x if y is None else min(x, y),\n                 update_fn=lambda x: x):\n        self.tree = [None]*(2*2**((N-1).bit_length()))\n        self.base = len(self.tree)//2\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        for i in xrange(self.base, self.base+N):\n            self.tree[i] = build_fn(i-self.base)\n        for i in reversed(xrange(1, self.base)):\n            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n\n    def update(self, i, h):\n        x = self.base+i\n        self.tree[x] = self.update_fn(h)\n        while x > 1:\n            x //= 2\n            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n\n    def query(self, L, R):\n        if L > R:\n            return None\n        L += self.base\n        R += self.base\n        left = right = None\n        while L <= R:\n            if L & 1:\n                left = self.query_fn(left, self.tree[L])\n                L += 1\n            if R & 1 == 0:\n                right = self.query_fn(self.tree[R], right)\n                R -= 1\n            L //= 2\n            R //= 2\n        return self.query_fn(left, right)\n\n\n# segment tree\nclass Solution2(object):\n    def longestRepeating(self, s, queryCharacters, queryIndices):\n        \"\"\"\n        :type s: str\n        :type queryCharacters: str\n        :type queryIndices: List[int]\n        :rtype: List[int]\n        \"\"\"\n        LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = xrange(7)\n        def build(i):\n            return update(s[i])\n\n        def update(y):\n            result = [0]*SIZE\n            result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1\n            result[LEFT] = result[RIGHT] = y\n            return result\n\n        def query(x, y):\n            return y if x is None else x if y is None else \\\n                   [x[LEFT],\n                    y[RIGHT],\n                    x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0),\n                    y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0),\n                    x[LEN]+y[LEN],\n                    max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)]\n        \n        result = []\n        st = SegmentTree2(len(s), build_fn=build, query_fn=query, update_fn=update)\n        for c, i in itertools.izip(queryCharacters, queryIndices):\n            st.update(i, c)\n            result.append(st.query(0, len(s)-1)[MAX_LEN])\n        return result\n"
    },
    {
        "problem_name": "longest-substring-with-at-least-k-repeating-characters",
        "solution": "# Time:  O(26 * n) = O(n)\n# Space: O(26) = O(1)\n\nclass Solution(object):\n    def longestSubstring(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def longestSubstringHelper(s, k, start, end):\n            count = [0] * 26\n            for i in xrange(start, end):\n                count[ord(s[i]) - ord('a')] += 1\n            max_len = 0\n            i = start\n            while i < end:\n                while i < end and count[ord(s[i]) - ord('a')] < k:\n                    i += 1\n                j = i\n                while j < end and count[ord(s[j]) - ord('a')] >= k:\n                    j += 1\n\n                if i == start and j == end:\n                    return end - start\n\n                max_len = max(max_len, longestSubstringHelper(s, k, i, j))\n                i = j\n            return max_len\n\n        return longestSubstringHelper(s, k, 0, len(s))\n\n"
    },
    {
        "problem_name": "longest-substring-with-at-most-k-distinct-characters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def lengthOfLongestSubstringKDistinct(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in xrange(256)]\n        for i, char in enumerate(s):\n            if visited[ord(char)] == 0:\n                distinct_count += 1\n            visited[ord(char)] += 1\n            while distinct_count > k:\n                visited[ord(s[start])] -= 1\n                if visited[ord(s[start])] == 0:\n                    distinct_count -= 1\n                start += 1\n            longest = max(longest, i - start + 1)\n        return longest\n\n\n# Time:  O(n)\n# Space: O(1)\nfrom collections import Counter\n\n\nclass Solution2(object):\n    def lengthOfLongestSubstringKDistinct(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        counter = Counter()\n        left, max_length = 0, 0\n        for right, char in enumerate(s):\n            counter[char] += 1\n            while len(counter) > k:\n                counter[s[left]] -= 1\n                if counter[s[left]] == 0:\n                    del counter[s[left]]\n                left += 1\n            max_length = max(max_length, right-left+1)\n        return max_length\n"
    },
    {
        "problem_name": "longest-substring-with-at-most-two-distinct-characters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param s, a string\n    # @return an integer\n    def lengthOfLongestSubstringTwoDistinct(self, s):\n        longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in xrange(256)]\n        for i, char in enumerate(s):\n            if visited[ord(char)] == 0:\n                distinct_count += 1\n            visited[ord(char)] += 1\n            while distinct_count > 2:\n                visited[ord(s[start])] -= 1\n                if visited[ord(s[start])] == 0:\n                    distinct_count -= 1\n                start += 1\n            longest = max(longest, i - start + 1)\n        return longest\n\n\n# Time:  O(n)\n# Space: O(1)\nfrom collections import Counter\n\n\nclass Solution2(object):\n    def lengthOfLongestSubstringTwoDistinct(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        counter = Counter()\n        left, max_length = 0, 0\n        for right, char in enumerate(s):\n            counter[char] += 1\n            while len(counter) > 2:\n                counter[s[left]] -= 1\n                if counter[s[left]] == 0:\n                    del counter[s[left]]\n                left += 1\n            max_length = max(max_length, right-left+1)\n        return max_length\n"
    },
    {
        "problem_name": "longest-substring-without-repeating-characters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 0, 0\n        lookup = {}\n        for right in xrange(len(s)):\n            if s[right] in lookup:\n                left = max(left, lookup[s[right]]+1)\n            lookup[s[right]] = right\n            result = max(result, right-left+1)\n        return result\n"
    },
    {
        "problem_name": "longest-turbulent-subarray",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxTurbulenceSize(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        result = 1\n        start = 0\n        for i in xrange(1, len(A)):\n            if i == len(A)-1 or \\\n               cmp(A[i-1], A[i]) * cmp(A[i], A[i+1]) != -1:\n                result = max(result, i-start+1)\n                start = i\n        return result\n"
    },
    {
        "problem_name": "longest-uncommon-subsequence-i",
        "solution": "# Time:  O(min(a, b))\n# Space: O(1)\n\nclass Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        if a == b:\n            return -1\n        return max(len(a), len(b))\n\n"
    },
    {
        "problem_name": "longest-uncommon-subsequence-ii",
        "solution": "# Time:  O(l * n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def findLUSlength(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: int\n        \"\"\"\n        def isSubsequence(a, b):\n            i = 0\n            for j in xrange(len(b)):\n                if i >= len(a):\n                    break\n                if a[i] == b[j]:\n                    i += 1\n            return i == len(a)\n\n        strs.sort(key=len, reverse=True)\n        for i in xrange(len(strs)):\n            all_of = True\n            for j in xrange(len(strs)):\n                if len(strs[j]) < len(strs[i]):\n                    break\n                if i != j and isSubsequence(strs[i], strs[j]):\n                    all_of = False\n                    break\n            if all_of:\n                return len(strs[i])\n        return -1\n\n"
    },
    {
        "problem_name": "longest-unequal-adjacent-groups-subsequence-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def getWordsInLongestSubsequence(self, n, words, groups):\n        \"\"\"\n        :type n: int\n        :type words: List[str]\n        :type groups: List[int]\n        :rtype: List[str]\n        \"\"\"\n        return [words[i] for i in xrange(n) if i == 0 or groups[i-1] != groups[i]]\n"
    },
    {
        "problem_name": "longest-unequal-adjacent-groups-subsequence-ii",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport itertools\n\n\n# dp, backtracing\nclass Solution(object):\n    def getWordsInLongestSubsequence(self, n, words, groups):\n        \"\"\"\n        :type n: int\n        :type words: List[str]\n        :type groups: List[int]\n        :rtype: List[str]\n        \"\"\"\n        def check(s1, s2):\n            return len(s1) == len(s2) and sum(a != b for a, b in itertools.izip(s1, s2)) == 1\n\n        dp = [[1, -1] for _ in xrange(n)]\n        for i in reversed(xrange(n)):\n            for j in xrange(i+1, n):\n                if groups[i] != groups[j] and check(words[j], words[i]):\n                    dp[i] = max(dp[i], [dp[j][0]+1, j])\n        result = []\n        i = max(xrange(n), key=lambda x: dp[x])\n        while i != -1:\n            result.append(words[i])\n            i = dp[i][1]\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\nimport itertools\n\n\n# dp, backtracing\nclass Solution2(object):\n    def getWordsInLongestSubsequence(self, n, words, groups):\n        \"\"\"\n        :type n: int\n        :type words: List[str]\n        :type groups: List[int]\n        :rtype: List[str]\n        \"\"\"\n        def check(s1, s2):\n            return len(s1) == len(s2) and sum(a != b for a, b in itertools.izip(s1, s2)) == 1\n\n        dp = [[1, -1] for _ in xrange(n)]\n        for i in xrange(n):\n            for j in xrange(i):\n                if groups[i] != groups[j] and check(words[j], words[i]):\n                    dp[i] = max(dp[i], [dp[j][0]+1, j])\n        result = []\n        i = max(xrange(n), key=lambda x: dp[x])\n        while i != -1:\n            result.append(words[i])\n            i = dp[i][1]\n        result.reverse()\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\nimport itertools\n\n\n# lis dp\nclass Solution3(object):\n    def getWordsInLongestSubsequence(self, n, words, groups):\n        \"\"\"\n        :type n: int\n        :type words: List[str]\n        :type groups: List[int]\n        :rtype: List[str]\n        \"\"\"\n        def check(s1, s2):\n            return len(s1) == len(s2) and sum(a != b for a, b in itertools.izip(s1, s2)) == 1\n\n        dp = [[] for _ in xrange(n)]\n        for i in xrange(n):\n            for j in xrange(i):\n                if groups[i] != groups[j] and check(words[j], words[i]) and len(dp[j]) > len(dp[i]):\n                    dp[i] = dp[j]\n            dp[i] = dp[i]+[i]\n        return map(lambda x: words[x], max(dp, key=lambda x: len(x)))\n"
    },
    {
        "problem_name": "longest-univalue-path",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def longestUnivaluePath(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        result = [0]\n        def dfs(node):\n            if not node:\n                return 0\n            left, right = dfs(node.left), dfs(node.right)\n            left = (left+1) if node.left and node.left.val == node.val else 0\n            right = (right+1) if node.right and node.right.val == node.val else 0\n            result[0] = max(result[0], left+right)\n            return max(left, right)\n\n        dfs(root)\n        return result[0]\n\n"
    },
    {
        "problem_name": "longest-uploaded-prefix",
        "solution": "# Time:  ctor:    O(1)\n#        upload:  O(1), amortized\n#        longest: O(1)\n# Space: O(n)\n\n# hash table\nclass LUPrefix(object):\n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.__lookup = set()\n        self.__curr = 0\n\n    def upload(self, video):\n        \"\"\"\n        :type video: int\n        :rtype: None\n        \"\"\"\n        self.__lookup.add(video-1)\n        while self.__curr in self.__lookup:\n            self.__lookup.remove(self.__curr)\n            self.__curr += 1\n\n    def longest(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.__curr\n"
    },
    {
        "problem_name": "longest-valid-parentheses",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def length(it, start, c):\n            depth, longest = 0, 0\n            for i in it:\n                if s[i] == c:\n                    depth += 1\n                else:\n                    depth -= 1\n                    if depth < 0:\n                        start, depth = i, 0\n                    elif depth == 0:\n                        longest = max(longest, abs(i - start))\n            return longest\n\n        return max(length(xrange(len(s)), -1, '('), \\\n                   length(reversed(xrange(len(s))), len(s), ')'))\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    # @param s, a string\n    # @return an integer\n    def longestValidParentheses(self, s):\n        longest, last, indices = 0, -1, []\n        for i in xrange(len(s)):\n            if s[i] == '(':\n                indices.append(i)\n            elif not indices:\n                last = i\n            else:\n                indices.pop()\n                if not indices:\n                    longest = max(longest, i - last)\n                else:\n                    longest = max(longest, i - indices[-1])\n        return longest\n\n"
    },
    {
        "problem_name": "longest-well-performing-interval",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def longestWPI(self, hours):\n        \"\"\"\n        :type hours: List[int]\n        :rtype: int\n        \"\"\"\n        result, accu = 0, 0\n        lookup = {}\n        for i, h in enumerate(hours):\n            accu = accu+1 if h > 8 else accu-1\n            if accu > 0:\n                result = i+1\n            elif accu-1 in lookup:\n                # lookup[accu-1] is the leftmost idx with smaller accu,\n                # because for i from 1 to some positive k,\n                # lookup[accu-i] is a strickly increasing sequence\n                result = max(result, i-lookup[accu-1])\n            lookup.setdefault(accu, i)\n        return result\n"
    },
    {
        "problem_name": "longest-word-in-dictionary-through-deleting",
        "solution": "# Time:  O((d * l) * logd), l is the average length of words\n# Space: O(1)\n\nclass Solution(object):\n    def findLongestWord(self, s, d):\n        \"\"\"\n        :type s: str\n        :type d: List[str]\n        :rtype: str\n        \"\"\"\n        d.sort(key = lambda x: (-len(x), x))\n        for word in d:\n            i = 0\n            for c in s:\n                if i < len(word) and word[i] == c:\n                    i += 1\n            if i == len(word):\n                return word\n        return \"\"\n\n"
    },
    {
        "problem_name": "longest-word-in-dictionary",
        "solution": "# Time:  O(n), n is the total sum of the lengths of words\n# Space: O(t), t is the number of nodes in trie\n\nfrom collections import defaultdict\nfrom operator import getitem\n\n\nclass Solution(object):\n    def longestWord(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        _trie = lambda: defaultdict(_trie)\n        trie = _trie()\n        for i, word in enumerate(words):\n            reduce(getitem, word, trie)[\"_end\"] = i\n\n        # DFS\n        stack = trie.values()\n        result = \"\"\n        while stack:\n            curr = stack.pop()\n            if \"_end\" in curr:\n                word = words[curr[\"_end\"]]\n                if len(word) > len(result) or (len(word) == len(result) and word < result):\n                    result = word\n                stack += [curr[letter] for letter in curr if letter != \"_end\"]\n        return result\n\n"
    },
    {
        "problem_name": "longest-word-with-all-prefixes",
        "solution": "# Time:  O(n)\n# Space: O(t), t is the number of nodes in trie\n\nimport collections\nimport string\n\n\nclass Solution(object):\n    def longestWord(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        def iter_dfs(words, node):\n            result = -1\n            stk = [node]\n            while stk:\n                node = stk.pop()\n                if result == -1 or len(words[node[\"_end\"]]) > len(words[result]):\n                    result = node[\"_end\"]\n                for c in reversed(string.ascii_lowercase):\n                    if c not in node or \"_end\" not in node[c]:\n                        continue\n                    stk.append(node[c])\n            return result       \n    \n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        trie[\"_end\"] = -1\n        for i, word in enumerate(words):\n            reduce(dict.__getitem__, word, trie)[\"_end\"] = i\n        result = iter_dfs(words, trie)\n        return words[result] if result != -1 else \"\" \n\n\n# Time:  O(n)\n# Space: O(t), t is the number of nodes in trie\nimport collections\nimport string\n\n\nclass Solution2(object):\n    def longestWord(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        def dfs(words, node, result):\n            if result[0] == -1 or len(words[node[\"_end\"]]) > len(words[result[0]]):\n                result[0] = node[\"_end\"]\n            for c in string.ascii_lowercase:\n                if c not in node or \"_end\" not in node[c]:\n                    continue\n                dfs(words, node[c], result)\n    \n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        trie[\"_end\"] = -1\n        for i, word in enumerate(words):\n            reduce(dict.__getitem__, word, trie)[\"_end\"] = i\n        result = [-1]\n        dfs(words, trie, result)\n        return words[result[0]] if result[0] != -1 else \"\"\n"
    },
    {
        "problem_name": "longest-zigzag-path-in-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def longestZigZag(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node, result):\n            if not node:\n                return [-1, -1]\n            left, right = dfs(node.left, result), dfs(node.right, result)\n            result[0] = max(result[0], left[1]+1, right[0]+1)\n            return [left[1]+1, right[0]+1]\n\n        result = [0]\n        dfs(root, result)\n        return result[0]\n"
    },
    {
        "problem_name": "loud-and-rich",
        "solution": "# Time:  O(q + r)\n# Space: O(q + r)\n\n\nclass Solution(object):\n    def loudAndRich(self, richer, quiet):\n        \"\"\"\n        :type richer: List[List[int]]\n        :type quiet: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def dfs(graph, quiet, node, result):\n            if result[node] is None:\n                result[node] = node\n                for nei in graph[node]:\n                    smallest_person = dfs(graph, quiet, nei, result)\n                    if quiet[smallest_person] < quiet[result[node]]:\n                        result[node] = smallest_person\n            return result[node]\n\n        graph = [[] for _ in xrange(len(quiet))]\n        for u, v in richer:\n            graph[v].append(u)\n        result = [None]*len(quiet)\n        return map(lambda x: dfs(graph, quiet, x, result), xrange(len(quiet)))\n\n"
    },
    {
        "problem_name": "lowest-common-ancestor-of-a-binary-search-tree",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def lowestCommonAncestor(self, root, p, q):\n        s, b = sorted([p.val, q.val])\n        while not s <= root.val <= b:\n            # Keep searching since root is outside of [s, b].\n            root = root.left if s <= root.val else root.right\n        # s <= root.val <= b.\n        return root\n\n"
    },
    {
        "problem_name": "lowest-common-ancestor-of-a-binary-tree-ii",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        pass\n\n\nclass Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        def iter_dfs(node, p, q):\n            result = None\n            stk = [(1, (node, [0]))]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    ret1, ret2 = [0], [0]\n                    stk.append((2, (node, ret1, ret2, ret)))\n                    stk.append((1, (node.right, ret2)))\n                    stk.append((1, (node.left, ret1)))\n                elif step == 2:\n                    node, ret1, ret2, ret = params\n                    curr = int(node == p or node == q)\n                    if curr+ret1[0]+ret2[0] == 2 and not result:\n                        result = node\n                    ret[0] = curr+ret1[0]+ret2[0]\n            return result\n\n        return iter_dfs(root, p, q)\n\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"        \n        def dfs(node, p, q, result):\n            if not node:\n                return 0\n            left = dfs(node.left, p, q, result)\n            right = dfs(node.right, p, q, result)\n            curr = int(node == p or node == q)\n            if curr+left+right == 2 and not result[0]:\n                result[0] = node\n            return curr+left+right\n\n        result = [0]\n        dfs(root, p, q, result)\n        return result[0]\n\n"
    },
    {
        "problem_name": "lowest-common-ancestor-of-a-binary-tree-iii",
        "solution": "# Time:  O(h)\n# Space: O(1)\n\n# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        pass\n\nclass Solution(object):\n    def lowestCommonAncestor(self, p, q):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n        a, b = p, q\n        while a != b:\n            a = a.parent if a else q\n            b = b.parent if b else p\n        return a\n\n\n# Time:  O(h)\n# Space: O(1)\nclass Solution2(object):\n    def lowestCommonAncestor(self, p, q):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n        def depth(node):\n            d = 0\n            while node:\n                node = node.parent\n                d += 1\n            return d\n        \n        p_d, q_d = depth(p), depth(q)\n        while p_d > q_d:\n            p = p.parent\n            p_d -= 1\n        while p_d < q_d:\n            q = q.parent\n            q_d -= 1\n        while p != q:\n            p = p.parent\n            q = q.parent\n        return p\n"
    },
    {
        "problem_name": "lowest-common-ancestor-of-a-binary-tree-iv",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        pass\n\n\nclass Solution(object):\n    def lowestCommonAncestor(self, root, nodes):\n        \"\"\"\n        :type root: TreeNode\n        :type nodes: List[TreeNode]\n        \"\"\"\n        def iter_dfs(root, lookup):\n            result = [0]\n            stk = [(1, (root, result))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    node, ret = args\n                    if not node or node in lookup:\n                        ret[0] = node\n                        continue\n                    ret1, ret2 = [None], [None]\n                    stk.append((2, (node, ret1, ret2, ret)))\n                    stk.append((1, (node.right, ret2)))\n                    stk.append((1, (node.left, ret1)))\n                elif step == 2:\n                    node, ret1, ret2, ret = args\n                    if ret1[0] and ret2[0]:\n                        ret[0] = node\n                    else:\n                        ret[0] = ret1[0] or ret2[0]\n            return result[0]\n        \n        return iter_dfs(root, set(nodes))\n\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def lowestCommonAncestor(self, root, nodes):\n        \"\"\"\n        :type root: TreeNode\n        :type nodes: List[TreeNode]\n        \"\"\"\n        def dfs(node, lookup):\n            if not node or node in lookup:\n                return node\n            left, right = dfs(node.left, lookup), dfs(node.right, lookup)\n            if left and right:\n                return node\n            return left or right\n        \n        return dfs(root, set(nodes))\n"
    },
    {
        "problem_name": "lowest-common-ancestor-of-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def lowestCommonAncestor(self, root, p, q):\n        if root in (None, p, q):\n            return root\n\n        left, right = [self.lowestCommonAncestor(child, p, q) \\\n                         for child in (root.left, root.right)]\n        # 1. If the current subtree contains both p and q,\n        #    return their LCA.\n        # 2. If only one of them is in that subtree,\n        #    return that one of them.\n        # 3. If neither of them is in that subtree,\n        #    return the node of that subtree.\n        return root if left and right else left or right\n\n"
    },
    {
        "problem_name": "lowest-common-ancestor-of-deepest-leaves",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def lcaDeepestLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        def lcaDeepestLeavesHelper(root):\n            if not root:\n                return 0, None\n            d1, lca1 = lcaDeepestLeavesHelper(root.left)\n            d2, lca2 = lcaDeepestLeavesHelper(root.right)\n            if d1 > d2:\n                return d1+1, lca1\n            if d1 < d2:\n                return d2+1, lca2\n            return d1+1, root\n\n        return lcaDeepestLeavesHelper(root)[1]\n"
    },
    {
        "problem_name": "lru-cache",
        "solution": "# Time:  O(1), per operation.\n# Space: O(k), k is the capacity of cache.\n\nimport collections\n\n\n# using OrderedDict\nclass LRUCache(object):\n    def __init__(self, capacity):\n        self.cache = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        val = self.cache[key]\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.cache and len(self.cache) == self.capacity:\n            self.cache.popitem(last=False)\n        self.__update(key, val)\n    \n    def __update(self, key, val):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = val\n\n\n# Time:  O(1), per operation.\n# Space: O(k), k is the capacity of cache.\n\n\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.val = val\n        self.key = key\n        self.next = None\n        self.prev = None\n\nclass LinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, node):\n        node.next, node.prev = None, None  # avoid dirty node\n        if self.head is None:\n            self.head = node\n        else:\n            self.tail.next = node\n            node.prev = self.tail\n        self.tail = node\n\n    def delete(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.next, node.prev = None, None  # make node clean\n\nclass LRUCache2(object):\n\n    def __init__(self, capacity):\n        self.list = LinkedList()\n        self.dict = {}\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        val = self.dict[key].val\n        self.__update(key, val)\n        return val\n\n    def put(self, key, val):\n        if key not in self.dict and len(self.dict) == self.capacity:\n            del self.dict[self.list.head.key]\n            self.list.delete(self.list.head)\n        self.__update(key, val)\n\n    def __update(self, key, val):\n        if key in self.dict:\n            self.list.delete(self.dict[key])\n        node = ListNode(key, val)\n        self.list.insert(node)\n        self.dict[key] = node\n"
    },
    {
        "problem_name": "lucky-numbers-in-a-matrix",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nimport itertools\n\n\nclass Solution(object):\n    def luckyNumbers (self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        rows = map(min, matrix)\n        cols = map(max, itertools.izip(*matrix))\n        return [cell for i, row in enumerate(matrix)\n                     for j, cell in enumerate(row) if rows[i] == cols[j]]\n\n    \n# Time:  O(m * n)\n# Space: O(m + n)\nimport itertools\n\n\nclass Solution2(object):\n    def luckyNumbers (self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        return list(set(map(min, matrix)) &\n                    set(map(max, itertools.izip(*matrix))))\n \n"
    },
    {
        "problem_name": "magic-squares-in-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n\nclass Solution(object):\n    def numMagicSquaresInside(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def magic(grid, r, c):\n            expect = k * (k**2+1) // 2\n            nums = set()\n            min_num = float(\"inf\")\n            sum_diag, sum_anti = 0, 0\n            for i in xrange(k):\n                sum_diag += grid[r+i][c+i]\n                sum_anti += grid[r+i][c+k-1-i]\n                sum_r, sum_c = 0, 0\n                for j in xrange(k):\n                    min_num = min(min_num, grid[r+i][c+j])\n                    nums.add(grid[r+i][c+j])\n                    sum_r += grid[r+i][c+j]\n                    sum_c += grid[r+j][c+i]\n                if not (sum_r == sum_c == expect):\n                    return False\n            return sum_diag == sum_anti == expect and \\\n                len(nums) == k**2 and \\\n                min_num == 1\n\n        k = 3\n        result = 0\n        for r in xrange(len(grid)-k+1):\n            for c in xrange(len(grid[r])-k+1):\n                if magic(grid, r, c):\n                    result += 1\n        return result\n\n"
    },
    {
        "problem_name": "magical-string",
        "solution": "# Time:  O(n)\n# Space: O(logn)\n\nimport itertools\n\n\nclass Solution(object):\n    def magicalString(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def gen():  # see figure 1 on page 3 of http://www.emis.ams.org/journals/JIS/VOL15/Nilsson/nilsson5.pdf\n            for c in 1, 2, 2:\n                yield c\n            for i, c in enumerate(gen()):\n                if i > 1:\n                    for _ in xrange(c):\n                        yield i % 2 + 1\n\n        return sum(c & 1 for c in itertools.islice(gen(), n))\n\n"
    },
    {
        "problem_name": "magnetic-force-between-two-balls",
        "solution": "# Time:  O(nlogn + nlogr), r is the range of positions\n# Space: O(1)\n\nclass Solution(object):\n    def maxDistance(self, position, m):\n        \"\"\"\n        :type position: List[int]\n        :type m: int\n        :rtype: int\n        \"\"\"\n        def check(position, m, x):\n            count, prev = 1, position[0]\n            for i in xrange(1, len(position)):\n                if position[i]-prev >= x:\n                    count += 1\n                    prev = position[i]\n            return count >= m\n        \n        position.sort()\n        left, right = 1, position[-1]-position[0]\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(position, m, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "majority-element-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        k, n, cnts = 3, len(nums), collections.defaultdict(int)\n\n        for i in nums:\n            cnts[i] += 1\n            # Detecting k items in cnts, at least one of them must have exactly\n            # one in it. We will discard those k items by one for each.\n            # This action keeps the same mojority numbers in the remaining numbers.\n            # Because if x / n  > 1 / k is true, then (x - 1) / (n - k) > 1 / k is also true.\n            if len(cnts) == k:\n                for j in cnts.keys():\n                    cnts[j] -= 1\n                    if cnts[j] == 0:\n                        del cnts[j]\n\n        # Resets cnts for the following counting.\n        for i in cnts.keys():\n            cnts[i] = 0\n\n        # Counts the occurrence of each candidate integer.\n        for i in nums:\n            if i in cnts:\n                cnts[i] += 1\n\n        # Selects the integer which occurs > [n / k] times.\n        result = []\n        for i in cnts.keys():\n            if cnts[i] > n / k:\n                result.append(i)\n\n        return result\n\n    def majorityElement2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [i[0] for i in collections.Counter(nums).items() if i[1] > len(nums) / 3]\n\n"
    },
    {
        "problem_name": "majority-element",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def boyer_moore_majority_vote():\n            result, cnt = None, 0\n            for x in nums:\n                if not cnt:\n                    result = x\n                if x == result:\n                    cnt += 1\n                else:\n                    cnt -= 1\n            return result\n\n        return boyer_moore_majority_vote()\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\nclass Solution2(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return collections.Counter(nums).most_common(1)[0][0]\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport collections\n\n\nclass Solution3(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sorted(collections.Counter(nums).items(), key=lambda a: a[1], reverse=True)[0][0]\n"
    },
    {
        "problem_name": "make-a-square-with-the-same-color",
        "solution": "# Time:  O((n - w + 1)^2 * w^2)\n# Space: O(1)\n\nimport collections\n\n\n# array\nclass Solution(object):\n    def canMakeSquare(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        N, W = 3, 2\n        return any(max(collections.Counter(grid[i+h][j+w] for h in xrange(W) for w in xrange(W)).itervalues()) >= W**2-1\n                   for i in xrange(N-W+1) for j in xrange(N-W+1))\n"
    },
    {
        "problem_name": "make-array-empty",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# sort\nclass Solution(object):\n    def countOperationsToEmptyArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        idxs = range(len(nums))\n        idxs.sort(key=lambda x: nums[x])\n        return len(idxs)+sum(len(idxs)-(i+1) for i in xrange(len(idxs)-1) if idxs[i] > idxs[i+1])\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# sort, bit, fenwick tree\nclass Solution2(object):\n    def countOperationsToEmptyArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n):\n                self.__bit = [0]*(n+1)  # Extra one for dummy node.\n\n            def add(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] += val\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = 0\n                while i > 0:\n                    ret += self.__bit[i]\n                    i -= (i & -i)\n                return ret\n        \n        bit = BIT(len(nums))\n        idxs = range(len(nums))\n        idxs.sort(key=lambda x: nums[x])\n        result = len(nums)\n        prev = -1\n        for i in idxs:\n            if prev == -1:\n                result += i\n            elif prev < i:\n                result += (i-prev)-(bit.query(i)-bit.query(prev-1))\n            else:\n                result += ((len(nums)-1)-bit.query(len(nums)-1))-((prev-i)-(bit.query(prev)-bit.query(i-1)))\n            bit.add(i, 1)\n            prev = i\n        return result\n"
    },
    {
        "problem_name": "make-array-non-decreasing-or-non-increasing",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\n# greedy, heap\nclass Solution(object):\n    def convertArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def f(nums):\n            result = 0\n            max_heap = []\n            for x in nums:\n                if max_heap and x < -max_heap[0]:\n                    result += -heapq.heappop(max_heap)-x\n                    heapq.heappush(max_heap, -x)\n                heapq.heappush(max_heap, -x)\n            return result\n        \n        return min(f(nums), f((x for x in reversed(nums))))\n\n\n# Time:  O(n^2)\n# Space: O(n)\nimport collections\n\n\n# dp\nclass Solution2(object):\n    def convertArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        vals = sorted(set(nums))\n        def f(nums):\n            dp = collections.defaultdict(int)  # dp[i]: min(cnt(j) for j in vals if j <= i)\n            for x in nums:\n                prev = -1\n                for i in vals:\n                    dp[i] = min(dp[i]+abs(i-x), dp[prev]) if prev != -1 else dp[i]+abs(i-x)\n                    prev = i\n            return dp[vals[-1]]\n\n        return min(f(nums), f((x for x in reversed(nums))))\n"
    },
    {
        "problem_name": "make-array-strictly-increasing",
        "solution": "# Time:  O(n^2 * logn)\n# Space: O(n)\n\nimport collections\nimport bisect\n\n\nclass Solution(object):\n    def makeArrayIncreasing(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: int\n        \"\"\"\n        arr2 = sorted(set(arr2))\n        dp = {0: -1}  # dp[min_cost] = end_with_val\n        for val1 in arr1:\n            next_dp = collections.defaultdict(lambda: float(\"inf\"))\n            for cost, val in dp.iteritems():\n                if val < val1:\n                    next_dp[cost] = min(next_dp[cost], val1)\n                k = bisect.bisect_right(arr2, val)\n                if k == len(arr2):\n                    continue\n                next_dp[cost+1] = min(next_dp[cost+1], arr2[k])\n            dp = next_dp\n            if not dp:\n                return -1\n        return min(dp.iterkeys())\n"
    },
    {
        "problem_name": "make-array-zero-by-subtracting-equal-amounts",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table\nclass Solution(object):\n    def minimumOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return len({x for x in nums if x})\n"
    },
    {
        "problem_name": "make-costs-of-paths-equal-in-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minIncrements(self, n, cost):\n        \"\"\"\n        :type n: int\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in reversed(xrange(n//2)):\n            result += abs(cost[2*i+1]-cost[2*i+2])\n            cost[i] += max(cost[2*i+1], cost[2*i+2])\n        return result\n"
    },
    {
        "problem_name": "make-k-subarray-sums-equal",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport random\n\n\n# math, greedy, quick select\nclass Solution(object):\n    def makeSubKSumEqual(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n            \n            right = len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        l = gcd(k, len(arr))\n        result = 0\n        for i in xrange(l):\n            vals = [arr[j] for j in xrange(i, len(arr), l)]\n            nth_element(vals, len(vals)//2)\n            result += sum(abs(v-vals[len(vals)//2]) for v in vals)\n        return result\n"
    },
    {
        "problem_name": "make-lexicographically-smallest-array-by-swapping-elements",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# sort\nclass Solution(object):\n    def lexicographicallySmallestArray(self, nums, limit):\n        \"\"\"\n        :type nums: List[int]\n        :type limit: int\n        :rtype: List[int]\n        \"\"\"\n        idxs = range(len(nums))\n        idxs.sort(key=lambda x: nums[x])\n        groups = []\n        for i in xrange(len(nums)):\n            if i-1 < 0 or nums[idxs[i]]-nums[idxs[i-1]] > limit:\n                groups.append([])\n            groups[-1].append(idxs[i])\n        result = [-1]*len(nums)\n        for g in groups:\n            for i, j in enumerate(sorted(g)):\n                result[j] = nums[g[i]]\n        return result\n"
    },
    {
        "problem_name": "make-number-of-distinct-characters-equal",
        "solution": "# Time:  O(m + n + 26^2)\n# Space: O(26)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def isItPossible(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: bool\n        \"\"\"\n        cnt1 = collections.Counter(word1)\n        cnt2 = collections.Counter(word2)\n        for i in cnt1.iterkeys():\n            for j in cnt2.iterkeys():\n                if i == j:\n                    if len(cnt1) == len(cnt2):\n                        return True\n                else:\n                    new_c1, new_c2 = len(cnt1), len(cnt2)\n                    if cnt1[i] == 1:\n                        new_c1 -= 1\n                    if j not in cnt1:\n                        new_c1 += 1\n                    if cnt2[j] == 1:\n                        new_c2 -= 1\n                    if i not in cnt2:\n                        new_c2 += 1\n                    if new_c1 == new_c2:\n                        return True\n        return False\n"
    },
    {
        "problem_name": "make-string-a-subsequence-using-cyclic-increments",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy, two pointers\nclass Solution(object):\n    def canMakeSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: bool\n        \"\"\"\n        i = 0\n        for c in str1:\n            if (ord(str2[i])-ord(c))%26 > 1:\n                continue\n            i += 1\n            if i == len(str2):\n                return True\n        return False\n"
    },
    {
        "problem_name": "make-string-anti-palindrome",
        "solution": "# Time:  O(n + 26)\n# Space: O(26)\n\n# counting sort, greedy\nclass Solution(object):\n    def makeAntiPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        cnt = [0]*26\n        for x in s:\n            cnt[ord(x)-ord('a')] += 1\n        if max(cnt) > len(s)//2:\n            return \"-1\"\n        result = [i for i, x in enumerate(cnt) for _ in xrange(x)]\n        l = next(l for l in xrange((len(s)//2)//2+1) if result[len(s)//2+l] != result[len(s)//2-1])\n        if l:\n            for i in xrange(cnt[result[len(s)//2-1]]-l):\n                result[len(s)//2+i], result[len(s)//2+i+l] = result[len(s)//2+i+l], result[len(s)//2+i]\n        return \"\".join(map(lambda x: chr(ord('a')+x), result))\n\n\n# Time:  O(n + 26)\n# Space: O(26)\n# counting sort, greedy, two pointers\nclass Solution2(object):\n    def makeAntiPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        cnt = [0]*26\n        for x in s:\n            cnt[ord(x)-ord('a')] += 1\n        if max(cnt) > len(s)//2:\n            return \"-1\"\n        result = [i for i, x in enumerate(cnt) for _ in xrange(x)]\n        left = len(s)//2\n        right = left+1\n        while right < len(s) and result[right] == result[left]:\n            right += 1 \n        while result[left] == result[len(s)-1-left]:\n            result[left] , result[right] = result[right], result[left]\n            left += 1\n            right += 1\n        return \"\".join(map(lambda x: chr(ord('a')+x), result))\n    \n\n# Time:  O(n * 26)\n# Space: O(26)\n# freq table, greedy\nclass Solution3(object):\n    def makeAntiPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        cnt = [0]*26\n        for x in s:\n            cnt[ord(x)-ord('a')] += 1\n        if max(cnt) > len(s)//2:\n            return \"-1\"\n        result = [-1]*len(s)\n        for i in xrange(len(s)//2):\n            j = next(j for j in xrange(len(cnt)) if cnt[j])\n            cnt[j] -= 1\n            result[i] = j\n        for i in xrange(len(s)//2, len(s)):\n            j = next(j for j in xrange(len(cnt)) if cnt[j] and result[(len(s)-1)-i] != j)\n            cnt[j] -= 1\n            result[i] = j\n        return \"\".join(map(lambda x: chr(ord('a')+x), result))\n"
    },
    {
        "problem_name": "make-sum-divisible-by-p",
        "solution": "# Time:  O(n)\n# Space: O(p)\n\nclass Solution(object):\n    def minSubarray(self, nums, p):\n        \"\"\"\n        :type nums: List[int]\n        :type p: int\n        :rtype: int\n        \"\"\"\n        residue = sum(nums) % p\n        if not residue:\n            return 0\n        result = len(nums)\n        curr, lookup = 0, {0: -1}\n        for i, num in enumerate(nums):\n            curr = (curr+num) % p\n            lookup[curr] = i\n            if (curr-residue) % p in lookup:\n                result = min(result, i-lookup[(curr-residue)%p])\n        return result if result < len(nums) else -1\n"
    },
    {
        "problem_name": "make-the-prefix-sum-non-negative",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\n# prefix sum, greedy, heap\nclass Solution(object):\n    def makePrefSumNonNegative(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = prefix = 0\n        min_heap = []\n        for x in nums:\n            heapq.heappush(min_heap, x)\n            prefix += x\n            if prefix < 0:\n                prefix -= heapq.heappop(min_heap)\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "make-the-string-great",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def makeGood(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stk = []\n        for ch in s:\n            counter_ch = ch.upper() if ch.islower() else ch.lower()\n            if stk and stk[-1] == counter_ch:\n                stk.pop()\n            else:\n                stk.append(ch)\n        return \"\".join(stk)\n"
    },
    {
        "problem_name": "make-the-xor-of-all-segments-equal-to-zero",
        "solution": "# Time:  O(n + k * m), m is the max number of nums\n# Space: O(min(k * m, n))\n\nimport collections\n\n\nclass Solution(object):\n    def minChanges(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def one_are_not_from_nums(nums, cnts):\n            mxs = [cnts[i].most_common(1)[0][1] for i in xrange(k)]\n            return len(nums) - (sum(mxs)-min(mxs))\n\n        def all_are_from_nums(nums, cnts):\n            dp = {0:0}\n            for cnt in cnts:\n                new_dp = collections.defaultdict(int)\n                for x in dp.iterkeys():\n                    for y in cnt.iterkeys():\n                        new_dp[x^y] = max(new_dp[x^y], dp[x]+cnt[y])\n                dp = new_dp\n            return len(nums)-dp[0]\n          \n        cnts = [collections.Counter(nums[j] for j in xrange(i, len(nums), k)) for i in xrange(k)]\n        return min(one_are_not_from_nums(nums, cnts), all_are_from_nums(nums, cnts))\n"
    },
    {
        "problem_name": "make-three-strings-equal",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\n# string\nclass Solution(object):\n    def findMinimumOperations(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: int\n        \"\"\"\n        for i, (a, b, c) in enumerate(itertools.izip(s1, s2, s3)):\n            if not a == b == c:\n                break\n        else:\n            i += 1\n        return len(s1)+len(s2)+len(s3)-3*i if i else -1\n"
    },
    {
        "problem_name": "make-two-arrays-equal-by-reversing-sub-arrays",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def canBeEqual(self, target, arr):\n        \"\"\"\n        :type target: List[int]\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        return collections.Counter(target) == collections.Counter(arr)\n\n\n# Time:  O(nlogn)\n# Space: O(1)\nclass Solution2(object):\n    def canBeEqual(self, target, arr):\n        \"\"\"\n        :type target: List[int]\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        target.sort(), arr.sort()\n        return target == arr\n"
    },
    {
        "problem_name": "making-a-large-island",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\n\nclass Solution(object):\n    def largestIsland(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def dfs(r, c, index, grid):\n            if not (0 <= r < len(grid) and\n                    0 <= c < len(grid[0]) and\n                    grid[r][c] == 1):\n                return 0\n            result = 1\n            grid[r][c] = index\n            for d in directions:\n                result += dfs(r+d[0], c+d[1], index, grid)\n            return result\n\n        area = {}\n        index = 2\n        for r in xrange(len(grid)):\n            for c in xrange(len(grid[r])):\n                if grid[r][c] == 1:\n                    area[index] = dfs(r, c, index, grid)\n                    index += 1\n\n        result = max(area.values() or [0])\n        for r in xrange(len(grid)):\n            for c in xrange(len(grid[r])):\n                if grid[r][c] == 0:\n                    seen = set()\n                    for d in directions:\n                        nr, nc = r+d[0], c+d[1]\n                        if not (0 <= nr < len(grid) and\n                                0 <= nc < len(grid[0]) and\n                                grid[nr][nc] > 1):\n                            continue\n                        seen.add(grid[nr][nc])\n                    result = max(result, 1 + sum(area[i] for i in seen))\n        return result\n\n"
    },
    {
        "problem_name": "making-file-names-unique",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def getFolderNames(self, names):\n        \"\"\"\n        :type names: List[str]\n        :rtype: List[str]\n        \"\"\"\n        count = collections.Counter()\n        result, lookup = [], set()\n        for name in names:\n            while True:\n                name_with_suffix = \"{}({})\".format(name, count[name]) if count[name] else name\n                count[name] += 1\n                if name_with_suffix not in lookup:\n                    break\n            result.append(name_with_suffix)\n            lookup.add(name_with_suffix)\n        return result\n"
    },
    {
        "problem_name": "map-of-highest-peak",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nclass Solution(object):\n    def highestPeak(self, isWater):\n        \"\"\"\n        :type isWater: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        q = []\n        for r, row in enumerate(isWater):\n            for c, cell in enumerate(row):\n                row[c] -= 1\n                if not cell:\n                    continue\n                q.append((r, c))\n        while q:\n            new_q = []\n            for r, c in q:\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc \n                    if not (0 <= nr < len(isWater) and\n                            0 <= nc < len(isWater[0]) and\n                            isWater[nr][nc] == -1):\n                        continue\n                    isWater[nr][nc] = isWater[r][c]+1\n                    q.append((nr, nc))\n            q = new_q\n        return isWater\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\nclass Solution2(object):\n    def highestPeak(self, isWater):\n        \"\"\"\n        :type isWater: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        q, heights = [], [[-1]*len(isWater[0]) for _ in xrange(len(isWater))]\n        for r, row in enumerate(isWater):\n            for c, cell in enumerate(row):\n                if not cell:\n                    continue\n                heights[r][c] = 0\n                q.append((r, c))\n        while q:\n            new_q = []\n            for r, c in q:\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc \n                    if not (0 <= nr < len(isWater) and\n                            0 <= nc < len(isWater[0]) and\n                            heights[nr][nc] == -1):\n                        continue\n                    heights[nr][nc] = heights[r][c]+1\n                    q.append((nr, nc))\n            q = new_q\n        return heights\n"
    },
    {
        "problem_name": "map-sum-pairs",
        "solution": "# Time:  O(n), n is the length of key\n# Space: O(t), t is the number of nodes in trie\n\nimport collections\n\n\nclass MapSum(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        self.__root = _trie()\n\n\n    def insert(self, key, val):\n        \"\"\"\n        :type key: str\n        :type val: int\n        :rtype: void\n        \"\"\"\n        # Time: O(n)\n        curr = self.__root\n        for c in key:\n            curr = curr[c]\n        delta = val\n        if \"_end\" in curr:\n            delta -= curr[\"_end\"]\n\n        curr = self.__root\n        for c in key:\n            curr = curr[c]\n            if \"_count\" in curr:\n                curr[\"_count\"] += delta\n            else:\n                curr[\"_count\"] = delta\n        curr[\"_end\"] = val\n\n\n    def sum(self, prefix):\n        \"\"\"\n        :type prefix: str\n        :rtype: int\n        \"\"\"\n        # Time: O(n)\n        curr = self.__root\n        for c in prefix:\n            if c not in curr:\n                return 0\n            curr = curr[c]\n        return curr[\"_count\"]\n\n\n\n"
    },
    {
        "problem_name": "mark-elements-on-array-by-performing-queries",
        "solution": "# Time:  O(q + nlogn)\n# Space: O(n)\n\n# hash table, heap\nclass Solution(object):\n    def unmarkedSumArray(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        total = sum(nums)\n        lookup = [False]*len(nums)\n        min_heap = [(x, i) for i, x in enumerate(nums)]\n        heapq.heapify(min_heap)\n        result = []\n        for i, k in queries:\n            if not lookup[i]:\n                lookup[i] = True\n                total -= nums[i]\n            for _ in xrange(k):\n                while min_heap:\n                    x, i = heapq.heappop(min_heap)\n                    if lookup[i]:\n                        continue\n                    lookup[i] = True\n                    total -= x\n                    break\n                if not min_heap:\n                    break\n            result.append(total)\n        return result\n"
    },
    {
        "problem_name": "masking-personal-information",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def maskPII(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        if '@' in S:\n            first, after = S.split('@')\n            return \"{}*****{}@{}\".format(first[0], first[-1], after).lower()\n\n        digits = filter(lambda x: x.isdigit(), S)\n        local = \"***-***-{}\".format(digits[-4:])\n        if len(digits) == 10:\n            return local\n        return \"+{}-{}\".format('*' * (len(digits) - 10), local)\n\n"
    },
    {
        "problem_name": "match-alphanumerical-pattern-in-matrix-i",
        "solution": "# Time:  O(n * m * r * c)\n# Space: O(1)\n\n# brute force, hash table\nclass Solution(object):\n    def findPattern(self, board, pattern):\n        \"\"\"\n        :type board: List[List[int]]\n        :type pattern: List[str]\n        :rtype: List[int]\n        \"\"\"\n        def check(i, j):\n            lookup = [-1]*26\n            lookup2 = [False]*10\n            for r in xrange(len(pattern)):\n                for c in xrange(len(pattern[0])):\n                    y = board[i+r][j+c]\n                    if pattern[r][c].isdigit():\n                        if int(pattern[r][c]) != y:\n                            return False\n                        continue\n                    x = ord(pattern[r][c])-ord('a')\n                    if lookup[x] == -1:\n                        if lookup2[y]:\n                            return False\n                        lookup2[y] = True\n                        lookup[x] = y\n                        continue\n                    if lookup[x] != y:\n                        return False\n            return True\n                    \n        return next(([i, j] for i in xrange(len(board)-len(pattern)+1) for j in xrange(len(board[0])-len(pattern[0])+1) if check(i, j)), [-1, -1])\n    \n"
    },
    {
        "problem_name": "match-substring-after-replacement",
        "solution": "# Time:  O(n * k), n = len(s), k = len(sub)\n# Space: O(m), m = len(mappings)\n\nimport collections\n\n\n# brute force\nclass Solution(object):\n    def matchReplacement(self, s, sub, mappings):\n        \"\"\"\n        :type s: str\n        :type sub: str\n        :type mappings: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        def transform(x):\n            return ord(x)-ord('0') if x.isdigit() else ord(x)-ord('a')+10 if x.islower() else ord(x)-ord('A')+36\n\n        def check(i):\n            return all(sub[j] == s[i+j] or lookup[sub[j]][s[i+j]] for j in xrange(len(sub)))\n            \n        lookup = [[0]*62 for _ in xrange(62)]\n        for a, b in mappings:\n            lookup[transform(a)][transform(b)] = 1\n        s = map(transform, s)\n        sub = map(transform, sub)\n        return any(check(i) for i in xrange(len(s)-len(sub)+1))\n\n\n# Time:  O(n * k), n = len(s), k = len(sub)\n# Space: O(m), m = len(mappings)\nimport collections\n\n\n# brute force\nclass Solution2(object):\n    def matchReplacement(self, s, sub, mappings):\n        \"\"\"\n        :type s: str\n        :type sub: str\n        :type mappings: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        def check(i):\n            return all(sub[j] == s[i+j] or (sub[j], s[i+j]) in lookup for j in xrange(len(sub)))\n            \n        lookup = set()\n        for a, b in mappings:\n            lookup.add((a, b))\n        return any(check(i) for i in xrange(len(s)-len(sub)+1))\n"
    },
    {
        "problem_name": "matchsticks-to-square",
        "solution": "# Time:  O(n * s * 2^n), s is the number of subset of which sum equals to side length.\n# Space: O(n * (2^n + s))\n\nclass Solution(object):\n    def makesquare(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        total_len = sum(nums)\n        if total_len % 4:\n            return False\n\n        side_len = total_len / 4\n        fullset = (1 << len(nums)) - 1\n\n        used_subsets = []\n        valid_half_subsets = [0] * (1 << len(nums))\n\n        for subset in xrange(fullset+1):\n            subset_total_len = 0\n            for i in xrange(len(nums)):\n                if subset & (1 << i):\n                    subset_total_len += nums[i]\n\n            if subset_total_len == side_len:\n                for used_subset in used_subsets:\n                    if (used_subset & subset) == 0:\n                        valid_half_subset = used_subset | subset\n                        valid_half_subsets[valid_half_subset] = True\n                        if valid_half_subsets[fullset ^ valid_half_subset]:\n                            return True\n                used_subsets.append(subset)\n\n        return False\n\n"
    },
    {
        "problem_name": "matrix-block-sum",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nclass Solution(object):\n    def matrixBlockSum(self, mat, K):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        m, n = len(mat), len(mat[0])\n        accu = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]\n        for i in xrange(m):\n            for j in xrange(n):\n                accu[i+1][j+1] = accu[i+1][j]+accu[i][j+1]-accu[i][j]+mat[i][j]\n        result = [[0 for _ in xrange(n)] for _ in xrange(m)]        \n        for i in xrange(m):\n            for j in xrange(n):\n                r1, c1, r2, c2 = max(i-K, 0), max(j-K, 0), min(i+K+1, m), min(j+K+1, n)\n                result[i][j] = accu[r2][c2]-accu[r1][c2]-accu[r2][c1]+accu[r1][c1]\n        return result\n"
    },
    {
        "problem_name": "matrix-cells-in-distance-order",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def allCellsDistOrder(self, R, C, r0, c0):\n        \"\"\"\n        :type R: int\n        :type C: int\n        :type r0: int\n        :type c0: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def append(R, C, r, c, result):\n            if 0 <= r < R and 0 <= c < C:\n                result.append([r, c])\n            \n        result = [[r0, c0]]\n        for d in xrange(1, R+C):\n            append(R, C, r0-d, c0, result)\n            for x in xrange(-d+1, d):\n                append(R, C, r0+x, c0+abs(x)-d, result)\n                append(R, C, r0+x, c0+d-abs(x), result)\n            append(R, C, r0+d, c0, result)\n        return result\n"
    },
    {
        "problem_name": "matrix-diagonal-sum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def diagonalSum(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        return sum(mat[i][i]+mat[~i][i] for i in xrange(len(mat))) - (mat[len(mat)//2][len(mat)//2] if len(mat)%2 == 1 else 0)\n"
    },
    {
        "problem_name": "matrix-similarity-after-cyclic-shifts",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def areSimilar(self, mat, k):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        return all(row[i] == row[(i+k)%len(row)]for row in mat for i in xrange(len(row)))\n"
    },
    {
        "problem_name": "max-area-of-island",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n), the max depth of dfs may be m * n\n\nclass Solution(object):\n    def maxAreaOfIsland(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [[-1,  0], [ 1,  0], [ 0,  1], [ 0, -1]]\n\n        def dfs(i, j, grid, area):\n            if not (0 <= i < len(grid) and \\\n                    0 <= j < len(grid[0]) and \\\n                    grid[i][j] > 0):\n                return False\n            grid[i][j] *= -1\n            area[0] += 1\n            for d in directions:\n                dfs(i+d[0], j+d[1], grid, area)\n            return True\n\n        result = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                area = [0]\n                if dfs(i, j, grid, area):\n                    result = max(result, area[0])\n        return result\n\n"
    },
    {
        "problem_name": "max-chunks-to-make-sorted-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# mono stack solution\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        result, increasing_stk = 0, []\n        for num in arr:\n            max_num = num if not increasing_stk else max(increasing_stk[-1], num)\n            while increasing_stk and increasing_stk[-1] > num:\n                increasing_stk.pop()\n            increasing_stk.append(max_num)\n        return len(increasing_stk)\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nclass Solution2(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        def compare(i1, i2):\n            return arr[i1]-arr[i2] if arr[i1] != arr[i2] else i1-i2\n\n        idxs = [i for i in xrange(len(arr))]\n        result, max_i = 0, 0\n        for i, v in enumerate(sorted(idxs, cmp=compare)):\n            max_i = max(max_i, v)\n            if max_i == i:\n                result += 1\n        return result\n\n"
    },
    {
        "problem_name": "max-chunks-to-make-sorted",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        result, max_i = 0, 0\n        for i, v in enumerate(arr):\n            max_i = max(max_i, v)\n            if max_i == i:\n                result += 1\n        return result\n\n    \n# Time:  O(n)\n# Space: O(n)\n# mono stack solution\nclass Solution2(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        result, increasing_stk = 0, []\n        for num in arr:\n            max_num = num if not increasing_stk else max(increasing_stk[-1], num)\n            while increasing_stk and increasing_stk[-1] > num:\n                increasing_stk.pop()\n            increasing_stk.append(max_num)\n        return len(increasing_stk)\n"
    },
    {
        "problem_name": "max-consecutive-ones-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, prev, curr = 0, 0, 0\n        for n in nums:\n            if n == 0:\n                result = max(result, prev+curr+1)\n                prev, curr = curr, 0\n            else:\n                curr += 1\n        return min(max(result, prev+curr+1), len(nums))\n\n"
    },
    {
        "problem_name": "max-consecutive-ones-iii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def longestOnes(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        result, i = 0, 0\n        for j in xrange(len(A)):\n            K -= int(A[j] == 0)\n            while K < 0:\n                K += int(A[i] == 0)\n                i += 1\n            result = max(result, j-i+1)\n        return result\n"
    },
    {
        "problem_name": "max-consecutive-ones",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, local_max = 0, 0\n        for n in nums:\n            local_max = (local_max + 1 if n else 0)\n            result = max(result, local_max)\n        return result\n\n"
    },
    {
        "problem_name": "max-difference-you-can-get-from-changing-an-integer",
        "solution": "# Time:  O(logn)\n# Space: O(logn)\n\nclass Solution(object):\n    def maxDiff(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        digits = str(num)\n        for b in digits:\n            if b < '9':\n                break\n        if digits[0] != '1':\n            a = digits[0]\n        else:\n            for a in digits:\n                if a > '1':\n                    break\n        return int(digits.replace(b, '9')) - \\\n               int(digits.replace(a, '1' if digits[0] != '1' else '0'))\n"
    },
    {
        "problem_name": "max-dot-product-of-two-subsequences",
        "solution": "# Time:  O(m * n)\n# Space: O(min(m, n))\n\nclass Solution(object):\n    def maxDotProduct(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums1) < len(nums2):\n            return self.maxDotProduct(nums2, nums1)\n        dp = [[0]*len(nums2) for i in xrange(2)]\n        for i in xrange(len(nums1)):\n            for j in xrange(len(nums2)):\n                dp[i%2][j] = nums1[i]*nums2[j]\n                if i and j:\n                    dp[i%2][j] += max(dp[(i-1)%2][j-1], 0)\n                if i:\n                    dp[i%2][j] = max(dp[i%2][j], dp[(i-1)%2][j])\n                if j:\n                    dp[i%2][j] = max(dp[i%2][j], dp[i%2][j-1])\n        return dp[(len(nums1)-1)%2][-1]\n"
    },
    {
        "problem_name": "max-increase-to-keep-city-skyline",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport itertools\n\n\nclass Solution(object):\n    def maxIncreaseKeepingSkyline(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        row_maxes = [max(row) for row in grid]\n        col_maxes = [max(col) for col in itertools.izip(*grid)]\n\n        return sum(min(row_maxes[r], col_maxes[c])-val \\\n                   for r, row in enumerate(grid) \\\n                   for c, val in enumerate(row))\n\n"
    },
    {
        "problem_name": "max-number-of-k-sum-pairs",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def maxOperations(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        count = collections.Counter()\n        result = 0\n        for x in nums:\n            if k-x in count and count[k-x]:\n                count[k-x] -= 1\n                result += 1\n            else:\n                count[x] += 1\n        return result\n"
    },
    {
        "problem_name": "max-pair-sum-in-an-array",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\n# hash table\nclass Solution(object):\n    def maxSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def max_digit(x):\n            result = 0\n            while x:\n                x, r = divmod(x, 10)\n                result = max(result, r)\n            return result\n    \n        result = -1\n        lookup = {}\n        for x in nums:\n            mx = max_digit(x)\n            if mx not in lookup:\n                lookup[mx] = x\n                continue\n            result = max(result, lookup[mx]+x)\n            lookup[mx] = max(lookup[mx], x)\n        return result\n"
    },
    {
        "problem_name": "max-points-on-a-line",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport collections\n\n\n# Definition for a point\nclass Point(object):\n    def __init__(self, a=0, b=0):\n        self.x = a\n        self.y = b\n\nclass Solution(object):\n    def maxPoints(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: int\n        \"\"\"\n        max_points = 0\n        for i, start in enumerate(points):\n            slope_count, same = collections.defaultdict(int), 1\n            for j in xrange(i + 1, len(points)):\n                end = points[j]\n                if start.x == end.x and start.y == end.y:\n                    same += 1\n                else:\n                    slope = float(\"inf\")\n                    if start.x - end.x != 0:\n                        slope = (start.y - end.y) * 1.0 / (start.x - end.x)\n                    slope_count[slope] += 1\n\n            current_max = same\n            for slope in slope_count:\n                current_max = max(current_max, slope_count[slope] + same)\n\n            max_points = max(max_points, current_max)\n\n        return max_points\n\n"
    },
    {
        "problem_name": "max-stack",
        "solution": "# Time:  push:    O(1)\n#        pop:     O(n), there is no built-in SortedDict in python. If applied, it could be reduced to O(logn)\n#        popMax:  O(n)\n#        top:     O(1)\n#        peekMax: O(1)\n# Space: O(n), n is the number of values in the current stack\n\nimport collections\n\n\nclass MaxStack(object):\n\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.__idx_to_val = collections.defaultdict(int)\n        self.__val_to_idxs = collections.defaultdict(list)\n        self.__top = None\n        self.__max = None\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: void\n        \"\"\"\n        idx = self.__val_to_idxs[self.__top][-1]+1 if self.__val_to_idxs else 0\n        self.__idx_to_val[idx] = x\n        self.__val_to_idxs[x].append(idx)\n        self.__top = x\n        self.__max = max(self.__max, x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        val = self.__top\n        self.__remove(val)\n        return val\n\n\n    def top(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.__top\n\n\n    def peekMax(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.__max\n\n\n    def popMax(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        val = self.__max\n        self.__remove(val)\n        return val\n\n\n    def __remove(self, val):\n        idx = self.__val_to_idxs[val][-1]\n        self.__val_to_idxs[val].pop()\n        if not self.__val_to_idxs[val]:\n            del self.__val_to_idxs[val]\n        del self.__idx_to_val[idx]\n        if val == self.__top:\n            self.__top = self.__idx_to_val[max(self.__idx_to_val.keys())] if self.__idx_to_val else None\n        if val == self.__max:\n            self.__max = max(self.__val_to_idxs.keys()) if self.__val_to_idxs else None\n\n\n\n"
    },
    {
        "problem_name": "max-sum-of-a-pair-with-equal-sum-of-digits",
        "solution": "# Time:  O(nlogr), r is max(nums)\n# Space: O(n)\n\n# greedy\nclass Solution(object):\n    def maximumSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def sum_digits(x):\n            result = 0\n            while x:\n                result += x%10\n                x //= 10\n            return result\n\n        lookup = {}\n        result = -1\n        for x in nums:\n            k = sum_digits(x)\n            if k not in lookup:\n                lookup[k] = x\n                continue\n            result = max(result, lookup[k]+x)\n            if x > lookup[k]:\n                lookup[k] = x\n        return result\n"
    },
    {
        "problem_name": "max-sum-of-sub-matrix-no-larger-than-k",
        "solution": "# Time:  O(min(m, n)^2 * max(m, n) * log(max(m, n)))\n# Space: O(max(m, n))\n\nfrom bisect import bisect_left, insort\n\nclass Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not matrix:\n            return 0\n\n        m = min(len(matrix), len(matrix[0]))\n        n = max(len(matrix), len(matrix[0]))\n        result = float(\"-inf\")\n\n        for i in xrange(m):\n            sums = [0] * n\n            for j in xrange(i, m):\n                for l in xrange(n):\n                    sums[l] += matrix[j][l] if m == len(matrix) else matrix[l][j]\n\n                # Find the max subarray no more than K.\n                accu_sum_set, accu_sum = [0], 0\n                for sum in sums:\n                    accu_sum += sum\n                    it = bisect_left(accu_sum_set, accu_sum - k)  # Time: O(logn)\n                    if it != len(accu_sum_set):\n                        result = max(result, accu_sum - accu_sum_set[it])\n                    insort(accu_sum_set, accu_sum)  # Time: O(n)\n\n        return result\n\n\n# Time:  O(min(m, n)^2 * max(m, n) * log(max(m, n))) ~ O(min(m, n)^2 * max(m, n)^2)\n# Space: O(max(m, n))\nclass Solution_TLE(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        class BST(object):  # not avl, rbtree\n            def __init__(self, val):\n                self.val = val\n                self.left = None\n                self.right = None\n\n            def insert(self, val):  # Time: O(h) = O(logn) ~ O(n)\n                curr = self\n                while curr:\n                    if curr.val >= val:\n                        if curr.left:\n                            curr = curr.left\n                        else:\n                            curr.left = BST(val)\n                            return\n                    else:\n                        if curr.right:\n                            curr = curr.right\n                        else:\n                            curr.right = BST(val)\n                            return\n\n            def lower_bound(self, val):  # Time: O(h) = O(logn) ~ O(n)\n                result, curr = None, self\n                while curr:\n                    if curr.val >= val:\n                        result, curr = curr, curr.left\n                    else:\n                        curr = curr.right\n                return result\n\n\n        if not matrix:\n            return 0\n\n        m = min(len(matrix), len(matrix[0]))\n        n = max(len(matrix), len(matrix[0]))\n        result = float(\"-inf\")\n\n        for i in xrange(m):\n            sums = [0] * n\n            for j in xrange(i, m):\n                for l in xrange(n):\n                    sums[l] += matrix[j][l] if m == len(matrix) else matrix[l][j]\n\n                # Find the max subarray no more than K.\n                accu_sum_set = BST(0)\n                accu_sum = 0\n                for sum in sums:\n                    accu_sum += sum\n                    node = accu_sum_set.lower_bound(accu_sum - k)\n                    if node:\n                        result = max(result, accu_sum - node.val)\n                    accu_sum_set.insert(accu_sum)\n\n        return result\n\n"
    },
    {
        "problem_name": "max-value-of-equation",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def findMaxValueOfEquation(self, points, k):\n        \"\"\"\n        :type points: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = float(\"-inf\")\n        dq = collections.deque()\n        for i, (x, y) in enumerate(points):\n            while dq and points[dq[0]][0] < x-k:\n                dq.popleft()\n            if dq:\n                result = max(result, (points[dq[0]][1]-points[dq[0]][0])+y+x)\n            while dq and points[dq[-1]][1]-points[dq[-1]][0] <= y-x:\n                dq.pop()\n            dq.append(i)\n        return result\n"
    },
    {
        "problem_name": "maximal-network-rank",
        "solution": "# Time:  O(m + n + k^2), k is the number of values greater or equal to top2\n# Space: O(m + n)\n\n# optimized from Solution2 with counting sort\nclass Solution(object):\n    def maximalNetworkRank(self, n, roads):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MAX_N = 100\n        MAX_NUM = MAX_N-1\n        def counting_sort(arr, key=lambda x:x, reverse=False):  # Time: O(n), Space: O(n)\n            count = [0]*(MAX_NUM+1)\n            for x in arr:\n                count[key(x)] += 1\n            for i in xrange(1, len(count)):\n                count[i] += count[i-1]\n            result = [0]*len(arr)\n            if not reverse:\n                for x in reversed(arr):  # stable sort\n                    count[key(x)] -= 1\n                    result[count[key(x)]] = x\n            else:\n                for x in arr:  # stable sort\n                    count[key(x)] -= 1\n                    result[count[key(x)]] = x\n                result.reverse()\n            return result\n\n        degree = [0]*n\n        adj = collections.defaultdict(set)\n        for a, b in roads:\n            degree[a] += 1\n            degree[b] += 1\n            adj[a].add(b)\n            adj[b].add(a)\n        sorted_idx = counting_sort(xrange(n), key=lambda x:degree[x], reverse=True)\n        m = 2\n        while m < n:\n            if degree[sorted_idx[m]] != degree[sorted_idx[1]]:\n                break\n            m += 1\n        result = degree[sorted_idx[0]] + degree[sorted_idx[1]] - 1  # at least sum(top2 values) - 1\n        for i in xrange(m-1):  # only need to check pairs of top2 values\n            for j in xrange(i+1, m):\n                if degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]]) > result:  # if equal to ideal sum of top2 values, break\n                    return degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]])                                                 \n        return result\n\n\n# Time:  O(m + nlogn + k^2), k is the number of values greater or equal to top2\n# Space: O(m + n)\nimport collections\n\n\n# optimized from Solution3\nclass Solution2(object):\n    def maximalNetworkRank(self, n, roads):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        degree = [0]*n\n        adj = collections.defaultdict(set)\n        for a, b in roads:\n            degree[a] += 1\n            degree[b] += 1\n            adj[a].add(b)\n            adj[b].add(a)\n        sorted_idx = range(n)\n        sorted_idx.sort(key=lambda x:-degree[x])\n        m = 2\n        while m < n:\n            if degree[sorted_idx[m]] != degree[sorted_idx[1]]:\n                break\n            m += 1\n        result = degree[sorted_idx[0]] + degree[sorted_idx[1]] - 1  # at least sum(top2 values) - 1\n        for i in xrange(m-1):  # only need to check pairs of top2 values\n            for j in xrange(i+1, m):\n                if degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]]) > result:  # if equal to ideal sum of top2 values, break\n                    return degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]])                                                 \n        return result\n\n\n# Time:  O(m + n^2)\n# Space: O(m + n)\nimport collections\n\n\nclass Solution3(object):\n    def maximalNetworkRank(self, n, roads):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        degree = [0]*n\n        adj = collections.defaultdict(set)\n        for a, b in roads:\n            degree[a] += 1\n            degree[b] += 1\n            adj[a].add(b)\n            adj[b].add(a)\n        result = 0\n        for i in xrange(n-1):\n            for j in xrange(i+1, n):\n                result = max(result, degree[i]+degree[j]-int(i in adj and j in adj[i]))\n        return result\n"
    },
    {
        "problem_name": "maximal-range-that-each-element-is-maximum-in-it",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# mono stack\nclass Solution(object):\n    def maximumLengthOfRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(nums)\n        stk = [-1]\n        nums.append(float(\"inf\"))\n        for i, x in enumerate(nums):\n            while stk[-1] != -1 and nums[stk[-1]] < x:\n                j = stk.pop()\n                result[j] = (i-1)-stk[-1]\n            stk.append(i)\n        return result\n"
    },
    {
        "problem_name": "maximal-rectangle",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def largestRectangleArea(heights):\n            stk, result, i = [-1], 0, 0\n            for i in xrange(len(heights)+1):\n                while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]):\n                    result = max(result, heights[stk.pop()]*((i-1)-stk[-1]))\n                stk.append(i) \n            return result\n\n        if not matrix:\n            return 0\n        result = 0\n        heights = [0]*len(matrix[0])\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n            result = max(result, largestRectangleArea(heights))\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# DP solution.\nclass Solution2(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        if not matrix:\n            return 0\n\n        result = 0\n        m = len(matrix)\n        n = len(matrix[0])\n        L = [0 for _ in xrange(n)]\n        H = [0 for _ in xrange(n)]\n        R = [n for _ in xrange(n)]\n\n        for i in xrange(m):\n            left = 0\n            for j in xrange(n):\n                if matrix[i][j] == '1':\n                    L[j] = max(L[j], left)\n                    H[j] += 1\n                else:\n                    L[j] = 0\n                    H[j] = 0\n                    R[j] = n\n                    left = j + 1\n\n            right = n\n            for j in reversed(xrange(n)):\n                if matrix[i][j] == '1':\n                    R[j] = min(R[j], right)\n                    result = max(result, H[j] * (R[j] - L[j]))\n                else:\n                    right = j\n\n        return result\n\n"
    },
    {
        "problem_name": "maximal-score-after-applying-k-operations",
        "solution": "# Time:  O(n + klogn)\n# Space: O(1)\n\nimport heapq\n\n\n# heap\nclass Solution(object):\n    def maxKelements(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n    \n        result = 0\n        for i, x in enumerate(nums):\n            nums[i] = -x\n        heapq.heapify(nums)\n        for _ in xrange(k):\n            if not nums:\n                break\n            x = -heapq.heappop(nums)\n            result += x\n            nx = ceil_divide(x, 3)\n            if not nx:\n                continue\n            heapq.heappush(nums, -nx)\n        return result\n  \n\n# Time:  O(n + klogn)\n# Space: O(1)\nimport heapq\n\n\n# heap\nclass Solution2(object):\n    def maxKelements(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n    \n        result = 0\n        for i, x in enumerate(nums):\n            nums[i] = -x\n        heapq.heapify(nums)\n        for _ in xrange(k):\n            x = -heapq.heappop(nums)\n            result += x\n            heapq.heappush(nums, -ceil_divide(x, 3))\n        return result\n  \n"
    },
    {
        "problem_name": "maximal-square",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    # @param {character[][]} matrix\n    # @return {integer}\n    def maximalSquare(self, matrix):\n        if not matrix:\n            return 0\n\n        m, n = len(matrix), len(matrix[0])\n        size = [[0 for j in xrange(n)] for i in xrange(2)]\n        max_size = 0\n\n        for j in xrange(n):\n            if matrix[0][j] == '1':\n                size[0][j] = 1\n            max_size = max(max_size, size[0][j])\n\n        for i in xrange(1, m):\n            if matrix[i][0] == '1':\n                size[i % 2][0] = 1\n            else:\n                size[i % 2][0] = 0\n            for j in xrange(1, n):\n                if matrix[i][j] == '1':\n                    size[i % 2][j] = min(size[i % 2][j - 1], \\\n                                         size[(i - 1) % 2][j], \\\n                                         size[(i - 1) % 2][j - 1]) + 1\n                    max_size = max(max_size, size[i % 2][j])\n                else:\n                    size[i % 2][j] = 0\n\n        return max_size * max_size\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\n# DP.\nclass Solution2(object):\n    # @param {character[][]} matrix\n    # @return {integer}\n    def maximalSquare(self, matrix):\n        if not matrix:\n            return 0\n\n        m, n = len(matrix), len(matrix[0])\n        size = [[0 for j in xrange(n)] for i in xrange(m)]\n        max_size = 0\n\n        for j in xrange(n):\n            if matrix[0][j] == '1':\n                size[0][j] = 1\n            max_size = max(max_size, size[0][j])\n\n        for i in xrange(1, m):\n            if matrix[i][0] == '1':\n                size[i][0] = 1\n            else:\n                size[i][0] = 0\n            for j in xrange(1, n):\n                if matrix[i][j] == '1':\n                    size[i][j] = min(size[i][j - 1],  \\\n                                     size[i - 1][j],  \\\n                                     size[i - 1][j - 1]) + 1\n                    max_size = max(max_size, size[i][j])\n                else:\n                    size[i][j] = 0\n\n        return max_size * max_size\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\n# DP.\nclass Solution3(object):\n    # @param {character[][]} matrix\n    # @return {integer}\n    def maximalSquare(self, matrix):\n        if not matrix:\n            return 0\n\n        H, W = 0, 1\n        # DP table stores (h, w) for each (i, j).\n        table = [[[0, 0] for j in xrange(len(matrix[0]))] \\\n                         for i in xrange(len(matrix))]\n        for i in reversed(xrange(len(matrix))):\n            for j in reversed(xrange(len(matrix[i]))):\n                # Find the largest h such that (i, j) to (i + h - 1, j) are feasible.\n                # Find the largest w such that (i, j) to (i, j + w - 1) are feasible.\n                if matrix[i][j] == '1':\n                    h, w = 1, 1\n                    if i + 1 < len(matrix):\n                        h = table[i + 1][j][H] + 1\n                    if j + 1 < len(matrix[i]):\n                        w = table[i][j + 1][W] + 1\n                    table[i][j] = [h, w]\n\n        # A table stores the length of largest square for each (i, j).\n        s = [[0 for j in xrange(len(matrix[0]))] \\\n                for i in xrange(len(matrix))]\n        max_square_area = 0\n        for i in reversed(xrange(len(matrix))):\n            for j in reversed(xrange(len(matrix[i]))):\n                side = min(table[i][j][H], table[i][j][W])\n                if matrix[i][j] == '1':\n                    # Get the length of largest square with bottom-left corner (i, j).\n                    if i + 1 < len(matrix) and j + 1 < len(matrix[i + 1]):\n                        side = min(s[i + 1][j + 1] + 1, side)\n                    s[i][j] = side\n                    max_square_area = max(max_square_area, side * side)\n\n        return max_square_area\n\n\n"
    },
    {
        "problem_name": "maximize-area-of-square-hole-in-grid",
        "solution": "# Time:  O(h + v), h = len(hBars), v = len(vBars)\n# Space: O(h + v)\n\n# array, hash table\nclass Solution(object):\n    def maximizeSquareHoleArea(self, n, m, hBars, vBars):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :type hBars: List[int]\n        :type vBars: List[int]\n        :rtype: int\n        \"\"\"\n        def max_gap(arr):\n            result = l = 1\n            lookup = set(arr)\n            while lookup:\n                x = next(iter(lookup))\n                left = x\n                while left-1 in lookup:\n                    left -= 1\n                right = x\n                while right+1 in lookup:\n                    right += 1\n                for i in xrange(left, right+1):\n                    lookup.remove(i)\n                result = max(result, (right-left+1)+1)\n            return result\n\n        return min(max_gap(hBars), max_gap(vBars))**2\n\n\n# Time:  O(hlogh + vlogv), h = len(hBars), v = len(vBars)\n# Space: O(1)\n# array, sort\nclass Solution2(object):\n    def maximizeSquareHoleArea(self, n, m, hBars, vBars):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :type hBars: List[int]\n        :type vBars: List[int]\n        :rtype: int\n        \"\"\"\n        def max_gap(arr):\n            arr.sort()\n            result = l = 1\n            for i in xrange(len(arr)):\n                l += 1\n                result = max(result, l)\n                if i+1 != len(arr) and arr[i+1] != arr[i]+1:\n                    l = 1\n            return result\n\n        return min(max_gap(hBars), max_gap(vBars))**2\n"
    },
    {
        "problem_name": "maximize-consecutive-elements-in-an-array-after-modification",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, dp\nclass Solution(object):\n    def maxSelectedElements(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        result = 1\n        dp = [1]*2  # dp[i]: the maximum length of a consecutive sequence ending with x+i, where x is the last visited value\n        for i in xrange(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                dp[1] = dp[0]+1\n            elif nums[i] == nums[i-1]+1:\n                dp[0] += 1\n                dp[1] += 1\n            elif nums[i] == nums[i-1]+2:\n                dp[0] = dp[1]+1\n                dp[1] = 1\n            else:\n                dp[0] = dp[1] = 1\n            result = max(result, dp[0], dp[1])\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport collections\n\n\n# sort, dp\nclass Solution2(object):\n    def maxSelectedElements(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        dp = collections.defaultdict(int)\n        dp[nums[0]] = dp[nums[0]+1] = 1\n        for i in xrange(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                dp[nums[i]+1] = dp[nums[i]]+1\n            elif nums[i] == nums[i-1]+1:\n                dp[nums[i]+1] = dp[nums[i]]+1\n                dp[nums[i]] = dp[nums[i]-1]+1\n            elif nums[i] == nums[i-1]+2:\n                dp[nums[i]] = dp[nums[i]-1]+1\n                dp[nums[i]+1] = 1\n            else:\n                dp[nums[i]] = dp[nums[i]+1] = 1\n        return max(dp.itervalues())\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport collections\n\n\n# sort, dp\nclass Solution3(object):\n    def maxSelectedElements(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        dp = collections.defaultdict(int)\n        for x in nums:\n            dp[x+1] = dp[x]+1\n            dp[x] = dp[x-1]+1\n        return max(dp.itervalues())\n"
    },
    {
        "problem_name": "maximize-distance-to-closest-person",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n\nclass Solution(object):\n    def maxDistToClosest(self, seats):\n        \"\"\"\n        :type seats: List[int]\n        :rtype: int\n        \"\"\"\n        prev, result = -1, 1\n        for i in xrange(len(seats)):\n            if seats[i]:\n                if prev < 0:\n                    result = i\n                else:\n                    result = max(result, (i-prev)//2)\n                prev = i\n        return max(result, len(seats)-1-prev)\n\n"
    },
    {
        "problem_name": "maximize-greatness-of-an-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# freq table, contructive algorithms\nclass Solution(object):\n    def maximizeGreatness(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return len(nums)-max(collections.Counter(nums).itervalues())\n  \n\n# Time:  O(nlogn)\n# Space: O(1)\n# sort, greedy, two pointers\nclass Solution2(object):\n    def maximizeGreatness(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        left = 0\n        for right in xrange(len(nums)):\n            if nums[right] > nums[left]:\n                left += 1\n        return left\n"
    },
    {
        "problem_name": "maximize-grid-happiness",
        "solution": "# Time:  O(C(m * n, i) * C(m * n - i, e))\n# Space: O(min(m * n, i + e))\n\nclass Solution(object):\n    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type introvertsCount: int\n        :type extrovertsCount: int\n        :rtype: int\n        \"\"\"\n        def left(curr):\n            return curr[-1] if len(curr)%n else 0\n\n        def up(curr):\n            return curr[-n] if len(curr) >= n else 0 \n\n        def count_total(curr, t, total):\n            return (total\n                    - 30*((left(curr) == 1)+(up(curr) == 1))\n                    + 20*((left(curr) == 2)+(up(curr) == 2))\n                    + (120 - 30*((left(curr) != 0)+(up(curr) != 0)))*(t == 1)\n                    + ( 40 + 20*((left(curr) != 0)+(up(curr) != 0)))*(t == 2))\n        \n        def iter_backtracking(i, e):\n            result = 0\n            curr = []\n            stk = [(2, (i, e, 0))]\n            while stk:\n                step, params = stk.pop()\n                if step == 2:\n                    i, e, total = params             \n                    if len(curr) == m*n or (i == 0 and e == 0):\n                        result = max(result, total)                \n                        continue\n                    if total + (i+e)*120 < result:  # pruning\n                        continue\n                    if e > 0:\n                        stk.append((3, tuple()))\n                        stk.append((2, (i, e-1, count_total(curr, 2, total))))\n                        stk.append((1, (2,)))\n                    if i > 0:\n                        stk.append((3, tuple()))\n                        stk.append((2, (i-1, e, count_total(curr, 1, total))))\n                        stk.append((1, (1,)))\n                    if left(curr) or up(curr):  # leave unoccupied iff left or up is occupied\n                        stk.append((3, tuple()))\n                        stk.append((2, (i, e, total)))\n                        stk.append((1, (0,)))\n                elif step == 1:\n                    x = params[0]\n                    curr.append(x)\n                elif step == 3:\n                    curr.pop()\n            return result\n          \n        return iter_backtracking(introvertsCount, extrovertsCount)\n\n\n# Time:  O(C(m * n, i) * C(m * n - i, e))\n# Space: O(min(m * n, i + e))\nclass Solution2(object):\n    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type introvertsCount: int\n        :type extrovertsCount: int\n        :rtype: int\n        \"\"\"\n        def left(curr):\n            return curr[-1] if len(curr)%n else 0\n\n        def up(curr):\n            return curr[-n] if len(curr) >= n else 0 \n\n        def count_total(curr, t, total):\n            return (total\n                    - 30*((left(curr) == 1)+(up(curr) == 1))\n                    + 20*((left(curr) == 2)+(up(curr) == 2))\n                    + (120 - 30*((left(curr) != 0)+(up(curr) != 0)))*(t == 1)\n                    + ( 40 + 20*((left(curr) != 0)+(up(curr) != 0)))*(t == 2))\n        \n        def backtracking(i, e, total, curr, result):              \n            if len(curr) == m*n or (i == 0 and e == 0):\n                result[0] = max(result[0], total)                \n                return\n            if total + (i+e)*120 < result[0]:  # pruning\n                return\n            if left(curr) or up(curr):  # leave unoccupied iff left or up is occupied\n                curr.append(0)\n                backtracking(i, e, total, curr, result)\n                curr.pop()\n            if i > 0:\n                new_total = count_total(curr, 1, total)\n                curr.append(1)\n                backtracking(i-1, e, new_total, curr, result)\n                curr.pop()\n            if e > 0:\n                new_total = count_total(curr, 2, total)\n                curr.append(2)\n                backtracking(i, e-1, new_total, curr, result)\n                curr.pop()\n\n        result = [0]\n        backtracking(introvertsCount, extrovertsCount, 0, [], result)\n        return result[0]\n"
    },
    {
        "problem_name": "maximize-happiness-of-selected-children",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, greedy\nclass Solution(object):\n    def maximumHappinessSum(self, happiness, k):\n        \"\"\"\n        :type happiness: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        happiness.sort(reverse=True)\n        return sum(max(happiness[i]-i, 0) for i in xrange(k))\n"
    },
    {
        "problem_name": "maximize-number-of-nice-divisors",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# variant of \"343. integer break\"\nclass Solution(object):\n    def maxNiceDivisors(self, primeFactors):\n        \"\"\"\n        :type primeFactors: int\n        :rtype: int\n        \"\"\"\n        # given a1 + a2 + ... + ak <= n, find max of a1 * a2 * ... * ak \n        # => given a1 + a2 + ... + ak = n, find max of a1 * a2 * ... * ak \n        # => ai is either 3 or 2, see proof in \"343. integer break\"\n        MOD = 10**9 + 7\n        if primeFactors <= 3:\n            return primeFactors\n        if primeFactors % 3 == 0:  # 6 => 3*3\n            return pow(3, primeFactors//3, MOD)\n        if primeFactors % 3 == 1:  # 4 => 2*2 \n            return (2*2*pow(3, (primeFactors-4)//3, MOD)) % MOD\n        return (2*pow(3, (primeFactors-2)//3, MOD)) % MOD  # 5 => 2*3\n"
    },
    {
        "problem_name": "maximize-number-of-subsequences-in-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# counting, greedy\nclass Solution(object):\n    def maximumSubsequenceCount(self, text, pattern):\n        \"\"\"\n        :type text: str\n        :type pattern: str\n        :rtype: int\n        \"\"\"\n        result = cnt1 = cnt2 = 0\n        for c in text:\n            if c == pattern[1]:\n                result += cnt1\n                cnt2 += 1\n            if c == pattern[0]:\n                cnt1 += 1\n        return result + max(cnt1, cnt2)  # add pattern[1] at back or pattern[0] at front\n"
    },
    {
        "problem_name": "maximize-palindrome-length-from-subsequences",
        "solution": "# Time:  O((m + n)^2)\n# Space: O((m + n)^2)\n\nclass Solution(object):\n    def longestPalindrome(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        s = word1+word2\n        dp = [[0]*len(s) for _ in xrange(len(s))]\n        result = 0\n        for j in xrange(len(s)):\n            dp[j][j] = 1\n            for i in reversed(xrange(j)):\n                if s[i] == s[j]:\n                    dp[i][j] = 2 if i+1 == j else dp[i+1][j-1] + 2\n                    if i < len(word1) <= j:\n                        result = max(result, dp[i][j])\n                else:\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n        return result\n\n\n# Time:  O((m + n)^2)\n# Space: O((m + n)^2)\nclass Solution2(object):\n    def longestPalindrome(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        s = word1+word2\n        dp = [[0]*len(s) for _ in xrange(len(s))]\n        for j in xrange(len(s)):\n            dp[j][j] = 1\n            for i in reversed(xrange(j)):\n                if s[i] == s[j]:\n                    dp[i][j] = 2 if i+1 == j else dp[i+1][j-1] + 2\n                else:\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n        return max([dp[i][j] for i in xrange(len(word1)) for j in xrange(len(word1), len(s)) if s[i] == s[j]] or [0])\n"
    },
    {
        "problem_name": "maximize-score-after-n-operations",
        "solution": "# Time:  O(n^2 * 2^n)\n# Space: O(2^n)\n\nimport itertools\nfrom fractions import gcd\n\n\nclass Solution(object):\n    def maxScore(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def popcount(n):\n            count = 0\n            while n:\n                n &= n-1\n                count += 1\n            return count\n\n        def bits(mask):\n            result = []\n            i = 0\n            while mask:\n                if mask&1:\n                    result.append(i)\n                i += 1\n                mask >>= 1\n            return result\n            \n        dp = [0]*(2**len(nums))\n        for mask in xrange(3, len(dp)):\n            cnt = popcount(mask)\n            if cnt%2:\n                continue\n            for i, j in itertools.combinations(bits(mask), 2):  # Time: O(n^2)\n                dp[mask] = max(dp[mask], cnt//2*gcd(nums[i], nums[j]) + dp[mask^(1<<i)^(1<<j)])\n        return dp[-1]\n"
    },
    {
        "problem_name": "maximize-sum-of-array-after-k-negations",
        "solution": "# Time:  O(n) ~ O(n^2), O(n) on average.\n# Space: O(1)\n\nimport random\n\n\n# quick select solution\nclass Solution(object):\n    def largestSumAfterKNegations(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        def kthElement(nums, k, compare):\n            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == k:\n                    return\n                elif new_pivot_idx > k:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < k.\n                    left = new_pivot_idx + 1\n                    \n        kthElement(A, K, lambda a, b: a < b)\n        remain = K\n        for i in xrange(K):\n            if A[i] < 0:\n                A[i] = -A[i]\n                remain -= 1\n        return sum(A) - ((remain)%2)*min(A)*2\n\n\n# Time:  O(nlogn)\n# Space: O(1)\nclass Solution2(object):\n    def largestSumAfterKNegations(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        A.sort()\n        remain = K\n        for i in xrange(K):\n            if A[i] >= 0:\n                break\n            A[i] = -A[i]\n            remain -= 1\n        return sum(A) - (remain%2)*min(A)*2\n"
    },
    {
        "problem_name": "maximize-the-beauty-of-the-garden",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maximumBeauty(self, flowers):\n        \"\"\"\n        :type flowers: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = {}\n        prefix = [0]\n        result = float(\"-inf\")\n        for i, f in enumerate(flowers):\n            prefix.append(prefix[-1]+f if f > 0 else prefix[-1])\n            if not f in lookup:\n                lookup[f] = i\n                continue\n            result = max(result, 2*f+prefix[i+1]-prefix[lookup[f]] if f < 0 else prefix[i+1]-prefix[lookup[f]])\n        return result\n"
    },
    {
        "problem_name": "maximize-the-confusion-of-an-exam",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def maxConsecutiveAnswers(self, answerKey, k):\n        \"\"\"\n        :type answerKey: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = max_count = 0\n        count = collections.Counter()\n        for i in xrange(len(answerKey)):\n            count[answerKey[i]] += 1\n            max_count = max(max_count, count[answerKey[i]])\n            if result-max_count >= k:\n                count[answerKey[i-result]] -= 1\n            else:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "maximize-the-minimum-powered-city",
        "solution": "# Time:  O(nlogk)\n# Space: O(n)\n\n# binary search, sliding window, greedy\nclass Solution(object):\n    def maxPower(self, stations, r, k):\n        \"\"\"\n        :type stations: List[int]\n        :type r: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def min_power():\n            mn = float(\"inf\")\n            curr = sum(stations[i] for i in xrange(r))\n            for i in xrange(len(stations)):\n                if i+r < len(stations):\n                    curr += stations[i+r]\n                if i >= r+1:\n                    curr -= stations[i-(r+1)]\n                mn = min(mn, curr)\n            return mn\n    \n        def check(target):\n            arr = stations[:]\n            curr = sum(arr[i] for i in xrange(r))\n            cnt = k\n            for i in xrange(len(arr)):\n                if i+r < len(arr):\n                    curr += arr[i+r]\n                if i >= r+1:\n                    curr -= arr[i-(r+1)]\n                if curr >= target:\n                    continue\n                diff = target-curr\n                if diff > cnt:\n                    return False\n                cnt -= diff\n                curr += diff\n                if i+r < len(arr):\n                    arr[i+r] += diff\n            return True\n\n        mn = min_power() \n        left, right = mn, mn+k\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n    \n"
    },
    {
        "problem_name": "maximize-the-number-of-partitions-after-operations",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# prefix sum, greedy\nclass Solution(object):\n    def maxPartitionsAfterOperations(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def popcount(n):\n            n = (n & 0x55555555) + ((n >> 1) & 0x55555555)\n            n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n            n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)\n            n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)\n            n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)\n            return n\n\n        left = [0]*(len(s)+1)\n        left_mask = [0]*(len(s)+1)\n        cnt = mask = 0\n        for i in xrange(len(s)):\n            mask |= 1<<(ord(s[i])-ord('a'))\n            if popcount(mask) > k:\n                cnt += 1\n                mask = 1<<(ord(s[i])-ord('a'))\n            left[i+1] = cnt\n            left_mask[i+1] = mask\n        right = [0]*(len(s)+1)\n        right_mask = [0]*(len(s)+1)\n        cnt = mask = 0\n        for i in reversed(xrange(len(s))):\n            mask |= 1<<(ord(s[i])-ord('a'))\n            if popcount(mask) > k:\n                cnt += 1\n                mask = 1<<(ord(s[i])-ord('a'))\n            right[i] = cnt\n            right_mask[i] = mask\n\n        result = 0\n        for i in xrange(len(s)):\n            curr = left[i]+right[i+1]\n            mask = left_mask[i]|right_mask[i+1]\n            if popcount(left_mask[i]) == popcount(right_mask[i+1]) == k and popcount(mask) != 26:\n                curr += 3\n            elif popcount(mask)+int(popcount(mask) != 26) > k:  # test case: s = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\", k = 26\n                curr += 2\n            else:\n                curr += 1\n            result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "maximize-the-profit-as-the-salesman",
        "solution": "# Time:  O(n + m), m = len(offers)\n# Space: O(n + m)\n\n# dp\nclass Solution(object):\n    def maximizeTheProfit(self, n, offers):\n        \"\"\"\n        :type n: int\n        :type offers: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = [[] for _ in xrange(n)]\n        for s, e, g in offers:\n            lookup[e].append([s, g])\n        dp = [0]*(n+1)\n        for e in xrange(n):\n            dp[e+1] = dp[(e-1)+1]\n            for s, g in lookup[e]:\n                dp[e+1] = max(dp[e+1], dp[(s-1)+1]+g)\n        return dp[-1]\n"
    },
    {
        "problem_name": "maximize-the-topmost-element-after-k-moves",
        "solution": "# Time:  O(min(n, k))\n# Space: O(1)\n\n# constructive algorithms\nclass Solution(object):\n    def maximumTop(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(nums) == 1 == k%2:\n            return -1\n        if k <= 1:\n            return nums[k]\n        return max(nums[i] for i in xrange(min(k+1, len(nums))) if i != k-1)\n"
    },
    {
        "problem_name": "maximize-total-tastiness-of-purchased-fruits",
        "solution": "# Time:  O(n * a * c), n = len(price), a = maxAmount, c = maxCoupons\n# Space: O(a * c)\n\nimport itertools\n\n\n# dp\nclass Solution(object):\n    def maxTastiness(self, price, tastiness, maxAmount, maxCoupons):\n        \"\"\"\n        :type price: List[int]\n        :type tastiness: List[int]\n        :type maxAmount: int\n        :type maxCoupons: int\n        :rtype: int\n        \"\"\"\n        dp = [[0]*(maxCoupons+1) for _ in xrange(maxAmount+1)]\n        for p, t in itertools.izip(price, tastiness):\n            for i in reversed(xrange(p//2, maxAmount+1)):\n                for j in reversed(xrange(maxCoupons+1)):\n                    if i-p >= 0:\n                        dp[i][j] = max(dp[i][j], t+dp[i-p][j])\n                    if j-1 >= 0:\n                        dp[i][j] = max(dp[i][j], t+dp[i-p//2][j-1])\n        return dp[maxAmount][maxCoupons]\n"
    },
    {
        "problem_name": "maximize-value-of-function-in-a-ball-passing-game",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# graph, prefix sum, two pointers, sliding window\nclass Solution(object):\n    def getMaxFunctionValue(self, receiver, k):\n        \"\"\"\n        :type receiver: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def find_cycles(adj):\n            result = []\n            lookup = [0]*len(adj)\n            idx = 0\n            for u in xrange(len(adj)):\n                prev = idx\n                while not lookup[u]:\n                    idx += 1\n                    lookup[u] = idx\n                    u = adj[u]\n                if lookup[u] > prev:\n                    result.append((u, idx-lookup[u]+1))\n            return result\n\n        def find_prefixes():\n            lookup = [(-1, -1)]*len(receiver)\n            prefixes = [[0] for _ in xrange(len(cycles))]\n            for idx, (u, l) in enumerate(cycles):\n                for i in xrange(l):\n                    lookup[u] = (idx, i)\n                    prefixes[idx].append(prefixes[idx][i]+u)\n                    u = receiver[u]\n            return lookup, prefixes\n        \n        def get_sum(prefix, i, cnt):\n            l = len(prefix)-1\n            q, r = divmod(cnt, l)\n            return (q*prefix[-1]+\n                    (prefix[min(i+r, l)]-prefix[i])+\n                    (prefix[max(((i+r)-l, 0))]-prefix[0]))\n        \n        def start_inside_cycle():\n            result = 0\n            for u, l in cycles:\n                for _ in xrange(l):\n                    idx, i = lookup[u]\n                    result = max(result, get_sum(prefixes[idx], i, k+1))\n                    u = receiver[u]\n            return result\n    \n        def start_outside_cycle():\n            result = 0\n            degree = [0]*len(receiver)\n            for x in receiver:\n                degree[x] += 1\n            for u in xrange(len(receiver)):\n                if degree[u]:\n                    continue\n                curr = 0\n                dq = collections.deque()\n                while lookup[u][0] == -1:\n                    curr += u\n                    dq.append(u)\n                    if len(dq) == k+1:\n                        result = max(result, curr)\n                        curr -= dq.popleft()\n                    u = receiver[u]\n                idx, i = lookup[u]\n                while dq:\n                    result = max(result, curr+get_sum(prefixes[idx], i, (k+1)-len(dq)))\n                    curr -= dq.popleft()\n            return result\n            \n        cycles = find_cycles(receiver)\n        lookup, prefixes = find_prefixes()\n        return max(start_inside_cycle(), start_outside_cycle())\n\n\n# Time:  O(nlogk)\n# Space: O(nlogk)\n# binary lifting\nclass Solution2(object):\n    def getMaxFunctionValue(self, receiver, k):\n        \"\"\"\n        :type receiver: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        l = (k+1).bit_length()\n        P = [receiver[:] for _ in xrange(l)]\n        S = [range(len(receiver)) for _ in xrange(l)]\n        for i in xrange(1, len(P)):\n            for u in xrange(len(receiver)):\n                P[i][u] = P[i-1][P[i-1][u]]\n                S[i][u] = S[i-1][u]+S[i-1][P[i-1][u]]\n        result = 0\n        for u in xrange(len(receiver)):\n            curr = 0\n            for i in xrange(l):\n                if (k+1)&(1<<i):\n                    curr += S[i][u]\n                    u = P[i][u]\n            result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "maximize-win-from-two-segments",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# two pointers, sliding window, dp\nclass Solution(object):\n    def maximizeWin(self, prizePositions, k):\n        \"\"\"\n        :type prizePositions: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        dp = [0]*(len(prizePositions)+1)\n        result = left = 0\n        for right in xrange(len(prizePositions)):\n            while prizePositions[right]-prizePositions[left] > k:\n                left += 1\n            dp[right+1] = max(dp[right], right-left+1)\n            result = max(result, dp[left]+(right-left+1))\n        return result\n"
    },
    {
        "problem_name": "maximum-69-number",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def maximum69Number (self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        curr, base, change = num, 3, 0\n        while curr:\n            if curr%10 == 6:\n                change = base\n            base *= 10\n            curr //= 10\n        return num+change\n\n\n# Time:  O(logn)\n# Space: O(logn)\nclass Solution2(object):\n    def maximum69Number (self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        return int(str(num).replace('6', '9', 1))\n"
    },
    {
        "problem_name": "maximum-absolute-sum-of-any-subarray",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxAbsoluteSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        curr = mx = mn = 0\n        for num in nums:\n            curr += num\n            mx = max(mx, curr)\n            mn = min(mn, curr)\n        return mx-mn\n"
    },
    {
        "problem_name": "maximum-alternating-subarray-sum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maximumAlternatingSubarraySum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def kadane(nums, start):\n            result = float(\"-inf\")\n            curr = odd = 0\n            for i in xrange(start, len(nums)):\n                curr = (curr+nums[i]) if not odd else max(curr-nums[i], 0)\n                result = max(result, curr)\n                odd ^= 1\n            return result\n\n        return max(kadane(nums, 0), kadane(nums, 1))\n"
    },
    {
        "problem_name": "maximum-alternating-subsequence-sum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxAlternatingSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = nums[0]\n        for i in xrange(len(nums)-1):\n            result += max(nums[i+1]-nums[i], 0)\n        return result\n"
    },
    {
        "problem_name": "maximum-and-sum-of-array",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\n# weighted bipartite matching solution\nclass Solution(object):\n    def maximumANDSum(self, nums, numSlots):\n        \"\"\"\n        :type nums: List[int]\n        :type numSlots: int\n        :rtype: int\n        \"\"\"\n        # Template translated from:\n        # https://github.com/kth-competitive-programming/kactl/blob/main/content/graph/WeightedMatching.h\n        def hungarian(a):  # Time: O(n^2 * m), Space: O(n + m)\n            if not a:\n                return 0, []\n            n, m = len(a)+1, len(a[0])+1\n            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)\n            for i in xrange(1, n):\n                p[0] = i\n                j0 = 0  # add \"dummy\" worker 0\n                dist, pre = [float(\"inf\")]*m, [-1]*m\n                done = [False]*(m+1)\n                while True:  # dijkstra\n                    done[j0] = True\n                    i0, j1, delta = p[j0], None, float(\"inf\")\n                    for j in xrange(1, m):\n                        if done[j]:\n                            continue\n                        cur = a[i0-1][j-1]-u[i0]-v[j]\n                        if cur < dist[j]:\n                            dist[j], pre[j] = cur, j0\n                        if dist[j] < delta:\n                            delta, j1 = dist[j], j\n                    for j in xrange(m):\n                        if done[j]:\n                            u[p[j]] += delta\n                            v[j] -= delta\n                        else:\n                            dist[j] -= delta\n                    j0 = j1\n                    if not p[j0]:\n                        break\n                while j0:  # update alternating path\n                    j1 = pre[j0]\n                    p[j0], j0 = p[j1], j1\n            for j in xrange(1, m):\n                if p[j]:\n                    ans[p[j]-1] = j-1\n            return -v[0], ans  # min cost\n    \n        return -hungarian([[-((nums[i] if i < len(nums) else 0) & (1+x//2)) for x in xrange(2*numSlots)] for i in xrange(2*numSlots)])[0]\n\n\n# Time:  O(n^3)\n# Space: O(n^2)\nfrom scipy.optimize import linear_sum_assignment as hungarian\nimport itertools\n\n\n# 3rd-party weighted bipartite matching solution\nclass Solution2(object):\n    def maximumANDSum(self, nums, numSlots):\n        \"\"\"\n        :type nums: List[int]\n        :type numSlots: int\n        :rtype: int\n        \"\"\"\n        adj = [[-((nums[i] if i < len(nums) else 0) & (1+x//2)) for x in xrange(2*numSlots)] for i in xrange(2*numSlots)]\n        return -sum(adj[i][j] for i, j in itertools.izip(*hungarian(adj)))    \n\n\n# Time:  O(n * 3^n)\n# Space: O(3^n)\n# bottom-up dp (hard to implement but faster)\nclass Solution3(object):\n    def maximumANDSum(self, nums, numSlots):\n        \"\"\"\n        :type nums: List[int]\n        :type numSlots: int\n        :rtype: int\n        \"\"\"\n        def count(x):\n            result = 0\n            while x:\n                result += x%3\n                x //= 3\n            return result\n\n        dp = [0]*(3**numSlots)\n        for mask in xrange(1, len(dp)):\n            i = count(mask)-1\n            x = nums[i] if i < len(nums) else 0\n            base = 1\n            for slot in xrange(1, numSlots+1):\n                if mask//base%3:\n                    dp[mask] = max(dp[mask], (x&slot)+dp[mask-base])\n                base *= 3\n        return dp[-1]\n\n\n# Time:  O(n * 3^n)\n# Space: O(3^n)\n# memoization, top-down dp (easy to implement but slower)\nclass Solution4(object):\n    def maximumANDSum(self, nums, numSlots):\n        \"\"\"\n        :type nums: List[int]\n        :type numSlots: int\n        :rtype: int\n        \"\"\"\n        def memoiztion(i, mask):  # i is metadata, which could be derived from mask, just for shorter implementation\n            if lookup[mask] != -1:\n                return lookup[mask]\n            x = nums[i] if i < len(nums) else 0\n            base = 1\n            for slot in xrange(1, numSlots+1):\n                if mask//base%3:\n                     lookup[mask] = max(lookup[mask], (x&slot)+memoiztion(i-1, mask-base))\n                base *= 3\n            return lookup[mask]\n        \n        lookup = [-1]*(3**numSlots)\n        lookup[0] = 0\n        return memoiztion(2*numSlots-1, 3**numSlots-1)\n"
    },
    {
        "problem_name": "maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts",
        "solution": "# Time:  O(hlogh + wlogw)\n# Space: O(1)\n\nclass Solution(object):\n    def maxArea(self, h, w, horizontalCuts, verticalCuts):\n        \"\"\"\n        :type h: int\n        :type w: int\n        :type horizontalCuts: List[int]\n        :type verticalCuts: List[int]\n        :rtype: int\n        \"\"\"\n        def max_len(l, cuts):\n            cuts.sort()\n            l = max(cuts[0]-0, l-cuts[-1])\n            for i in xrange(1, len(cuts)):\n                l = max(l, cuts[i]-cuts[i-1])\n            return l\n\n        MOD = 10**9+7\n        return max_len(h, horizontalCuts) * max_len(w, verticalCuts) % MOD\n"
    },
    {
        "problem_name": "maximum-area-of-longest-diagonal-rectangle",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def areaOfMaxDiagonal(self, dimensions):\n        \"\"\"\n        :type dimensions: List[List[int]]\n        :rtype: int\n        \"\"\"\n        return max((l**2+w**2, l*w) for l, w in dimensions)[1]\n"
    },
    {
        "problem_name": "maximum-ascending-subarray-sum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxAscendingSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = curr = 0\n        for i in xrange(len(nums)): \n            if not (i and nums[i-1] < nums[i]):\n                curr = 0\n            curr += nums[i]\n            result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "maximum-average-pass-ratio",
        "solution": "# Time:  O(n + mlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def maxAverageRatio(self, classes, extraStudents):\n        \"\"\"\n        :type classes: List[List[int]]\n        :type extraStudents: int\n        :rtype: float\n        \"\"\"\n        def profit(a, b):\n            return float(a+1)/(b+1)-float(a)/b\n\n        max_heap = [(-profit(a, b), a, b) for a, b in classes]\n        heapq.heapify(max_heap)\n        while extraStudents:\n            v, a, b = heapq.heappop(max_heap)\n            a, b = a+1, b+1\n            heapq.heappush(max_heap, (-profit(a, b), a, b))\n            extraStudents -= 1\n        return sum(float(a)/b for v, a, b in max_heap)/len(classes)\n"
    },
    {
        "problem_name": "maximum-average-subarray-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findMaxAverage(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: float\n        \"\"\"\n        result = total = sum(nums[:k])\n        for i in xrange(k, len(nums)):\n            total += nums[i] - nums[i-k]\n            result = max(result, total)\n        return float(result) / k\n\n"
    },
    {
        "problem_name": "maximum-average-subarray-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def findMaxAverage(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: float\n        \"\"\"\n        def getDelta(avg, nums, k):\n            accu = [0.0] * (len(nums) + 1)\n            minval_pos = None\n            delta = 0.0\n            for i in xrange(len(nums)):\n                accu[i+1] = nums[i] + accu[i] - avg\n                if i >= (k-1):\n                    if minval_pos == None or accu[i-k+1] < accu[minval_pos]:\n                        minval_pos = i-k+1\n                    if accu[i+1] - accu[minval_pos] >= 0:\n                        delta = max(delta, (accu[i+1] - accu[minval_pos]) / (i+1 - minval_pos))\n            return delta\n\n        left, delta = min(nums), float(\"inf\")\n        while delta > 1e-5:\n            delta = getDelta(left, nums, k)\n            left += delta\n        return left\n\n"
    },
    {
        "problem_name": "maximum-average-subtree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def maximumAverageSubtree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: float\n        \"\"\"\n        def maximumAverageSubtreeHelper(root, result):\n            if not root:\n                return [0.0, 0]\n            s1, n1 = maximumAverageSubtreeHelper(root.left, result)\n            s2, n2 = maximumAverageSubtreeHelper(root.right, result)\n            s = s1+s2+root.val\n            n = n1+n2+1\n            result[0] = max(result[0], s / n)\n            return [s, n]\n\n        result = [0]\n        maximumAverageSubtreeHelper(root, result)\n        return result[0]\n"
    },
    {
        "problem_name": "maximum-bags-with-full-capacity-of-rocks",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, greedy\nclass Solution(object):\n    def maximumBags(self, capacity, rocks, additionalRocks):\n        \"\"\"\n        :type capacity: List[int]\n        :type rocks: List[int]\n        :type additionalRocks: int\n        :rtype: int\n        \"\"\"\n        for i in xrange(len(capacity)):\n            capacity[i] -= rocks[i]\n        capacity.sort()\n        for i, c in enumerate(capacity):\n            if c > additionalRocks:\n                return i\n            additionalRocks -= c\n        return len(capacity)\n"
    },
    {
        "problem_name": "maximum-balanced-subsequence-sum",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nfrom sortedcontainers import SortedList\n\n\n# sorted list, binary search, mono stack\nclass Solution(object):\n    def maxBalancedSubsequenceSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        def query(sl, k):\n            j = sl.bisect_left((k,))\n            return sl[j-1][1] if j-1 >= 0 else NEG_INF\n    \n        def update(sl, k, v):\n            j = sl.bisect_left((k,))\n            if j < len(sl) and sl[j][0] == k:\n                if not (sl[j][1] < v):\n                    return\n                del sl[j]\n            elif not (j-1 < 0 or sl[j-1][1] < v):\n                return\n            sl.add((k, v))\n            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:\n                del sl[j+1]\n\n        sl = SortedList()\n        for i, x in enumerate(nums):\n            v = max(query(sl, (x-i)+1), 0)+x\n            update(sl, x-i, v)\n        return sl[-1][1]\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# bit, fenwick tree\nclass Solution2(object):\n    def maxBalancedSubsequenceSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n, default=0, fn=lambda x, y: x+y):\n                self.__bit = [NEG_INF]*(n+1)  # Extra one for dummy node.\n                self.__default = default\n                self.__fn = fn\n\n            def update(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] = self.__fn(self.__bit[i], val)\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = self.__default\n                while i > 0:\n                    ret = self.__fn(ret, self.__bit[i])\n                    i -= (i & -i)\n                return ret\n\n        val_to_idx = {x:i for i, x in enumerate(sorted({x-i for i, x in enumerate(nums)}))}\n        bit = BIT(len(val_to_idx), default=NEG_INF, fn=max)\n        for i, x in enumerate(nums):\n            v = max(bit.query(val_to_idx[x-i]), 0)+x\n            bit.update(val_to_idx[x-i], v)\n        return bit.query(len(val_to_idx)-1)\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# segment tree\nclass Solution3(object):\n    def maxBalancedSubsequenceSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        # Range Maximum Query\n        class SegmentTree(object):\n            def __init__(self, N,\n                         build_fn=lambda _: None,\n                         query_fn=lambda x, y: max(x, y),\n                         update_fn=lambda x, y: max(x, y)):\n                self.tree = [None]*(2*2**((N-1).bit_length()))\n                self.base = len(self.tree)//2\n                self.query_fn = query_fn\n                self.update_fn = update_fn\n                for i in xrange(self.base, self.base+N):\n                    self.tree[i] = build_fn(i-self.base)\n                for i in reversed(xrange(1, self.base)):\n                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n\n            def update(self, i, h):\n                x = self.base+i\n                self.tree[x] = self.update_fn(self.tree[x], h)\n                while x > 1:\n                    x //= 2\n                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n\n            def query(self, L, R):\n                if L > R:\n                    return None\n                L += self.base\n                R += self.base\n                left = right = None\n                while L <= R:\n                    if L & 1:\n                        left = self.query_fn(left, self.tree[L])\n                        L += 1\n                    if R & 1 == 0:\n                        right = self.query_fn(self.tree[R], right)\n                        R -= 1\n                    L //= 2\n                    R //= 2\n                return self.query_fn(left, right)\n\n        val_to_idx = {x:i for i, x in enumerate(sorted({x-i for i, x in enumerate(nums)}))}\n        st = SegmentTree(len(val_to_idx))\n        for i, x in enumerate(nums):\n            v = max(st.query(0, val_to_idx[x-i]), 0)+x\n            st.update(val_to_idx[x-i], v)\n        return st.query(0, len(val_to_idx)-1)\n"
    },
    {
        "problem_name": "maximum-beauty-of-an-array-after-applying-operation",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, two pointers, sliding window\nclass Solution(object):\n    def maximumBeauty(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        left = 0\n        for right in xrange(len(nums)):\n            if nums[right]-nums[left] > k*2:\n                left += 1\n        return right-left+1\n"
    },
    {
        "problem_name": "maximum-binary-string-after-change",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maximumBinaryString(self, binary):\n        \"\"\"\n        :type binary: str\n        :rtype: str\n        \"\"\"\n        result = list(binary)\n        zeros = ones = 0\n        for i, c in enumerate(result):\n            if c == '0':\n                zeros += 1\n            elif zeros == 0:\n                ones += 1\n            result[i] = '1'\n        if ones != len(result):\n            result[zeros+ones-1] = '0'\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "maximum-binary-tree-ii",
        "solution": "# Time:  O(h)\n# Space: O(1)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def insertIntoMaxTree(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return TreeNode(val)\n\n        if val > root.val:\n            node = TreeNode(val)\n            node.left = root\n            return node\n        \n        curr = root\n        while curr.right and curr.right.val > val:\n            curr = curr.right\n        node = TreeNode(val)\n        curr.right, node.left = node, curr.right\n        return root\n"
    },
    {
        "problem_name": "maximum-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def constructMaximumBinaryTree(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        # https://github.com/kamyu104/LintCode/blob/master/C++/max-tree.cpp\n        nodeStack = []\n        for num in nums:\n            node = TreeNode(num)\n            while nodeStack and num > nodeStack[-1].val:\n                node.left = nodeStack.pop()\n            if nodeStack:\n                nodeStack[-1].right = node\n            nodeStack.append(node)\n        return nodeStack[0]\n\n"
    },
    {
        "problem_name": "maximum-building-height",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def maxBuilding(self, n, restrictions):\n        \"\"\"\n        :type n: int\n        :type restrictions: List[List[int]]\n        :rtype: int\n        \"\"\"\n        restrictions.extend([[1, 0], [n, n-1]])\n        restrictions.sort()\n        for i in reversed(xrange(len(restrictions)-1)):\n            restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1]+(restrictions[i+1][0]-restrictions[i][0]))\n        result = 0\n        for i in xrange(1, len(restrictions)):\n            restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1]+(restrictions[i][0]-restrictions[i-1][0]))\n            left, h1 = restrictions[i-1]\n            right, h2 = restrictions[i]\n            result = max(result, max(h1, h2)+((right-left)-abs(h1-h2))//2)\n        return result\n"
    },
    {
        "problem_name": "maximum-candies-allocated-to-k-children",
        "solution": "# Time:  O(nlogr), r is max(candies)\n# Space: O(1)\n\n# binary search\nclass Solution(object):\n    def maximumCandies(self, candies, k):\n        \"\"\"\n        :type candies: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(x):\n            return sum(c//x for c in candies) >= k\n\n        left, right = 1, max(candies)\n        while left <= right:\n            mid = left+(right-left)//2\n            if not check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "maximum-candies-you-can-get-from-boxes",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        \"\"\"\n        :type status: List[int]\n        :type candies: List[int]\n        :type keys: List[List[int]]\n        :type containedBoxes: List[List[int]]\n        :type initialBoxes: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        q = collections.deque(initialBoxes)\n        while q:\n            changed = False\n            for _ in xrange(len(q)):\n                box = q.popleft()\n                if not status[box]:\n                    q.append(box)\n                    continue\n                changed = True\n                result += candies[box]\n                for contained_key in keys[box]:\n                    status[contained_key] = 1\n                for contained_box in containedBoxes[box]:\n                    q.append(contained_box)\n            if not changed:\n                break\n        return result\n"
    },
    {
        "problem_name": "maximum-coins-heroes-can-collect",
        "solution": "# Time:  O(nlogn + mlogm)\n# Space: O(n + m)\n\n# sort, two pointers\nclass Solution(object):\n    def maximumCoins(self, heroes, monsters, coins):\n        \"\"\"\n        :type heroes: List[int]\n        :type monsters: List[int]\n        :type coins: List[int]\n        :rtype: List[int]\n        \"\"\"\n        idxs1 = range(len(heroes))\n        idxs1.sort(key=lambda x: heroes[x])\n        idxs2 = range(len(monsters))\n        idxs2.sort(key=lambda x: monsters[x])\n        result = [0]*len(idxs1)\n        i = curr = 0\n        for idx in idxs1:\n            for i in xrange(i, len(idxs2)):\n                if monsters[idxs2[i]] > heroes[idx]:\n                    break\n                curr += coins[idxs2[i]]\n            else:\n                i = len(idxs2)\n            result[idx] = curr\n        return result\n"
    },
    {
        "problem_name": "maximum-compatibility-score-sum",
        "solution": "# Time:  O(m^2 * (n + m))\n# Space: O(m^2)\n\nimport itertools\n\n\n# weighted bipartite matching solution\nclass Solution(object):\n    def maxCompatibilitySum(self, students, mentors):\n        \"\"\"\n        :type students: List[List[int]]\n        :type mentors: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # Template translated from:\n        # https://github.com/kth-competitive-programming/kactl/blob/main/content/graph/WeightedMatching.h\n        def hungarian(a):  # Time: O(n^2 * m), Space: O(n + m)\n            if not a:\n                return 0, []\n            n, m = len(a)+1, len(a[0])+1\n            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)\n            for i in xrange(1, n):\n                p[0] = i\n                j0 = 0  # add \"dummy\" worker 0\n                dist, pre = [float(\"inf\")]*m, [-1]*m\n                done = [False]*(m+1)\n                while True:  # dijkstra\n                    done[j0] = True\n                    i0, j1, delta = p[j0], None, float(\"inf\")\n                    for j in xrange(1, m):\n                        if done[j]:\n                            continue\n                        cur = a[i0-1][j-1]-u[i0]-v[j]\n                        if cur < dist[j]:\n                            dist[j], pre[j] = cur, j0\n                        if dist[j] < delta:\n                            delta, j1 = dist[j], j\n                    for j in xrange(m):\n                        if done[j]:\n                            u[p[j]] += delta\n                            v[j] -= delta\n                        else:\n                            dist[j] -= delta\n                    j0 = j1\n                    if not p[j0]:\n                        break\n                while j0:  # update alternating path\n                    j1 = pre[j0]\n                    p[j0], j0 = p[j1], j1\n            for j in xrange(1, m):\n                if p[j]:\n                    ans[p[j]-1] = j-1\n            return -v[0], ans  # min cost\n\n        def score(s, m):\n            return sum(int(a == b) for a, b in itertools.izip(s, m))\n\n        return -hungarian([[-score(s, m) for m in mentors] for s in students])[0]\n\n\n# Time:  O(m * (n + 2^m))\n# Space: O(2^m)\n# dp solution\nclass Solution2(object):\n    def maxCompatibilitySum(self, students, mentors):\n        \"\"\"\n        :type students: List[List[int]]\n        :type mentors: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def popcount(n):  # Time: O(logn) ~= O(1) if n is a 32-bit number\n            result = 0\n            while n:\n                n &= n-1\n                result += 1\n            return result\n\n        def masks(vvi):\n            result = []\n            for vi in vvi:\n                mask, bit = 0, 1\n                for i in xrange(len(vi)):\n                    if vi[i]:\n                        mask |= bit\n                    bit <<= 1\n                result.append(mask)\n            return result\n\n        nums1, nums2 = masks(students), masks(mentors)\n        dp = [(0, 0)]*(2**len(nums2))\n        for mask in xrange(len(dp)):\n            bit = 1\n            for i in xrange(len(nums2)):\n                if (mask&bit) == 0:\n                    dp[mask|bit] = max(dp[mask|bit], (dp[mask][0]+(len(students[0])-popcount(nums1[dp[mask][1]]^nums2[i])), dp[mask][1]+1))\n                bit <<= 1\n        return dp[-1][0]\n"
    },
    {
        "problem_name": "maximum-consecutive-floors-without-special-floors",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort\nclass Solution(object):\n    def maxConsecutive(self, bottom, top, special):\n        \"\"\"\n        :type bottom: int\n        :type top: int\n        :type special: List[int]\n        :rtype: int\n        \"\"\"\n        special.sort()\n        result = max(special[0]-bottom, top-special[-1])\n        for i in xrange(1, len(special)):\n            result = max(result, special[i]-special[i-1]-1)\n        return result\n"
    },
    {
        "problem_name": "maximum-cost-of-trip-with-k-highways",
        "solution": "# Time:  O(n^2 * 2^n)\n# Space: O(n * 2^n)\n\nimport itertools\n\n\n# combination based dp\nclass Solution(object):\n    def maximumCost(self, n, highways, k):\n        \"\"\"\n        :type n: int\n        :type highways: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k+1 > n:  # optionally optimize\n            return -1\n        adj = [[] for _ in xrange(n)]\n        for c1, c2, t in highways:\n            adj[c1].append((c2, t))\n            adj[c2].append((c1, t))\n        result = -1 if k != 1 else 0\n        dp = [[0, []] for _ in xrange((1<<n))]\n        for i in xrange(n):\n            dp[1<<i][1].append(i)\n        for cnt in xrange(1, n+1):\n            for choice in itertools.combinations(xrange(n), cnt):\n                mask = reduce(lambda x, y:x|(1<<y), choice, 0)\n                total, lasts = dp[mask]\n                for u in lasts:\n                    for v, t in adj[u]:\n                        if mask&(1<<v):\n                            continue\n                        new_mask = mask|(1<<v)\n                        if total+t < dp[new_mask][0]:\n                            continue\n                        if total+t == dp[new_mask][0]:\n                            dp[new_mask][1].append(v)\n                            continue\n                        dp[new_mask][0] = total+t\n                        dp[new_mask][1] = [v]\n                        if bin(mask).count('1') == k:\n                            result = max(result, dp[new_mask][0])\n        return result\n\n\n# Time:  O(n^2 * 2^n)\n# Space: O(n * 2^n)\n# bfs based dp\nclass Solution2(object):\n    def maximumCost(self, n, highways, k):\n        \"\"\"\n        :type n: int\n        :type highways: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k+1 > n:  # required to optimize, otherwise, TLE or MLE\n            return -1\n        adj = [[] for _ in xrange(n)]\n        for c1, c2, t in highways:\n            adj[c1].append((c2, t))\n            adj[c2].append((c1, t))\n        result = -1\n        dp = [(u, 1<<u, 0) for u in xrange(n)]\n        while dp:\n            new_dp = []\n            for u, mask, total in dp:\n                if bin(mask).count('1') == k+1:\n                    result = max(result, total)\n                for v, t in adj[u]:\n                    if mask&(1<<v) == 0:\n                        new_dp.append((v, mask|(1<<v), total+t))\n            dp = new_dp\n        return result\n"
    },
    {
        "problem_name": "maximum-count-of-positive-integer-and-negative-integer",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport bisect\n\n\n# binary search\nclass Solution(object):\n    def maximumCount(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return max(bisect.bisect_left(nums, 0)-0, len(nums)-bisect.bisect_left(nums, 1))\n"
    },
    {
        "problem_name": "maximum-deletions-on-a-string",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\n# dp\nclass Solution(object):\n    def deleteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if all(x == s[0] for x in s):\n            return len(s)\n        dp2 = [[0]*(len(s)+1) for i in xrange(2)]  # dp2[i%2][j]: max prefix length of s[i:] and s[j:]\n        dp = [1]*len(s)  # dp[i]: max operation count of s[i:]\n        for i in reversed(xrange(len(s)-1)):\n            for j in xrange(i+1, len(s)):\n                dp2[i%2][j] = dp2[(i+1)%2][j+1]+1 if s[j] == s[i] else 0\n                if dp2[i%2][j] >= j-i:\n                    dp[i] = max(dp[i], dp[j]+1)\n        return dp[0]\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# dp, kmp algorithm\nclass Solution2(object):\n    def deleteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def getPrefix(pattern, start):\n            prefix = [-1]*(len(pattern)-start)\n            j = -1\n            for i in xrange(1, len(pattern)-start):\n                while j != -1 and pattern[start+j+1] != pattern[start+i]:\n                    j = prefix[j]\n                if pattern[start+j+1] == pattern[start+i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        if all(x == s[0] for x in s):\n            return len(s)\n        dp = [1]*len(s)  # dp[i]: max operation count of s[i:]\n        for i in reversed(xrange(len(s)-1)):\n            prefix = getPrefix(s, i)  # prefix[j]+1: longest prefix suffix length of s[i:j+1]\n            for j in xrange(1, len(prefix), 2):\n                if 2*(prefix[j]+1) == j+1:\n                    dp[i] = max(dp[i], dp[i+(prefix[j]+1)]+1)\n        return dp[0]\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# dp, rolling hash\nclass Solution3(object):\n    def deleteString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        MOD, P = 10**9+7, (113, 109)\n        def hash(i, j):\n            return [(prefix[idx][j+1]-prefix[idx][i]*power[idx][j-i+1])%MOD for idx in xrange(len(P))]\n\n        if all(x == s[0] for x in s):\n            return len(s)\n\n        power = [[1] for _ in xrange(len(P))]\n        prefix = [[0] for _ in xrange(len(P))]\n        for x in s:\n            for idx, p in enumerate(P):\n                power[idx].append((power[idx][-1]*p)%MOD)\n                prefix[idx].append((prefix[idx][-1]*p+(ord(x)-ord('a')))%MOD)\n        dp = [1]*len(s)  # dp[i]: max operation count of s[i:]\n        for i in reversed(xrange(len(s)-1)):\n            for j in xrange(1, (len(s)-i)//2+1):\n                if hash(i, i+j-1) == hash(i+j, i+2*j-1):\n                    dp[i] = max(dp[i], dp[i+j]+1)\n        return dp[0]\n"
    },
    {
        "problem_name": "maximum-depth-of-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h), h is height of binary tree\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return an integer\n    def maxDepth(self, root):\n        if root is None:\n            return 0\n        else:\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n\n"
    },
    {
        "problem_name": "maximum-depth-of-n-ary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\n\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        depth = 0\n        for child in root.children:\n            depth = max(depth, self.maxDepth(child))\n        return 1+depth\n\n"
    },
    {
        "problem_name": "maximum-difference-between-increasing-elements",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maximumDifference(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, prefix = 0, float(\"inf\")\n        for x in nums: \n            result = max(result, x-prefix)\n            prefix = min(prefix, x)\n        return result if result else -1\n"
    },
    {
        "problem_name": "maximum-difference-between-node-and-ancestor",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n# iterative stack solution\nclass Solution(object):\n    def maxAncestorDiff(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        result = 0\n        stack = [(root, 0, float(\"inf\"))]\n        while stack:\n            node, mx, mn = stack.pop()\n            if not node:\n                continue\n            result = max(result, mx-node.val, node.val-mn)\n            mx = max(mx, node.val)\n            mn = min(mn, node.val)\n            stack.append((node.left, mx, mn))\n            stack.append((node.right, mx, mn))\n        return result\n\n\n# Time:  O(n)\n# Space: O(h)\n# recursive solution\nclass Solution2(object):\n    def maxAncestorDiff(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def maxAncestorDiffHelper(node, mx, mn): \n            if not node:\n                return 0\n            result = max(mx-node.val, node.val-mn)\n            mx = max(mx, node.val)\n            mn = min(mn, node.val)\n            result = max(result, maxAncestorDiffHelper(node.left, mx, mn))\n            result = max(result, maxAncestorDiffHelper(node.right, mx, mn))\n            return result\n\n        return maxAncestorDiffHelper(root, 0, float(\"inf\"))\n"
    },
    {
        "problem_name": "maximum-difference-by-remapping-a-digit",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minMaxDifference(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        def f(dst):\n            result = 0\n            base = 1\n            while base <= num:\n                base *= 10\n            base //= 10\n            src = -1\n            while base:\n                d = num//base%10\n                if src == -1 and d != dst:\n                    src = d\n                result += base*(dst if d == src else d)\n                base //= 10\n            return result\n    \n        return f(9)-f(0)\n"
    },
    {
        "problem_name": "maximum-difference-score-in-a-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def maxScore(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        POS_INF = float(\"inf\")\n        NEG_INF = float(\"-inf\")\n        result = NEG_INF\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                mn = POS_INF\n                if i-1 >= 0:\n                    mn = min(mn, grid[i-1][j])\n                if j-1 >= 0:\n                    mn = min(mn, grid[i][j-1])\n                result = max(result, grid[i][j]-mn)\n                grid[i][j] = min(grid[i][j], mn)\n        return result\n"
    },
    {
        "problem_name": "maximum-distance-between-a-pair-of-values",
        "solution": "# Time:  O(n + m)\n# Space: O(1)\n\nclass Solution(object):\n    def maxDistance(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        result = i = j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] > nums2[j]:\n                i += 1\n            else:\n                result = max(result, j-i)\n                j += 1\n        return result\n"
    },
    {
        "problem_name": "maximum-distance-in-arrays",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxDistance(self, arrays):\n        \"\"\"\n        :type arrays: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result, min_val, max_val = 0,  arrays[0][0], arrays[0][-1]\n        for i in xrange(1, len(arrays)):\n            result = max(result, \\\n                         max(max_val - arrays[i][0], \\\n                             arrays[i][-1] - min_val))\n            min_val = min(min_val, arrays[i][0])\n            max_val = max(max_val, arrays[i][-1])\n        return result\n\n"
    },
    {
        "problem_name": "maximum-earnings-from-taxi",
        "solution": "# Time:  O(n + mlogm), m is the number of rides\n# Space: O(n)\n\nclass Solution(object):\n    def maxTaxiEarnings(self, n, rides):\n        \"\"\"\n        :type n: int\n        :type rides: List[List[int]]\n        :rtype: int\n        \"\"\"\n        rides.sort()\n        dp = [0]*(n+1)\n        j = 0\n        for i in xrange(1, n+1):\n            dp[i] = max(dp[i], dp[i-1])\n            while j < len(rides) and rides[j][0] == i:\n                dp[rides[j][1]] = max(dp[rides[j][1]], dp[i]+rides[j][1]-rides[j][0]+rides[j][2])\n                j += 1\n        return dp[-1]\n"
    },
    {
        "problem_name": "maximum-elegance-of-a-k-length-subsequence",
        "solution": "# Time:  O(nlogk)\n# Space: O(k)\n\nimport heapq\nfrom sortedcontainers import SortedList\n\n\n# heap, sorted list, greedy\nclass Solution(object):\n    def findMaximumElegance(self, items, k):\n        \"\"\"\n        :type items: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        curr = 0\n        lookup = set()\n        stk = []\n        for p, c in heapq.nlargest(k, items):\n            if c in lookup:\n                stk.append(p)\n            curr += p\n            lookup.add(c)\n        sl = SortedList()\n        lookup2 = {}\n        for p, c in items:\n            if c in lookup:\n                continue\n            if c in lookup2:\n                if lookup2[c] >= p:\n                    continue\n                sl.remove((lookup2[c], c))\n            sl.add((p, c))\n            lookup2[c] = p\n            if len(sl) > len(stk):\n                del lookup2[sl[0][1]]\n                del sl[0]\n        result = curr+len(lookup)**2\n        for p, c in reversed(sl):\n            curr += p-stk.pop()\n            lookup.add(c)\n            result = max(result, curr+len(lookup)**2) \n        return result\n\n\n# Time:  O(n + klogk)\n# Space: O(n)\nimport random\nimport collections\n\n# quick select, sort, greedy\nclass Solution2(object):\n    def findMaximumElegance(self, items, k):\n        \"\"\"\n        :type items: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n            \n            right = len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n    \n        def nlargest(k, nums):\n            nth_element(nums, k-1, compare=lambda a, b: a > b)\n            return sorted(nums[:k], reverse=True)\n    \n        curr = 0\n        lookup = set()\n        stk = []\n        for p, c in nlargest(k, items):\n            if c in lookup:\n                stk.append(p)\n            curr += p\n            lookup.add(c)\n        lookup2 = collections.defaultdict(int)\n        for p, c in items:\n            if c in lookup:\n                continue\n            lookup2[c] = max(lookup2[c], p)\n        l = len(lookup)\n        result = curr+l**2\n        for p in nlargest(min(len(stk), len(lookup2)), lookup2.values()):\n            curr += p-stk.pop()\n            l += 1\n            result = max(result, curr+l**2) \n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(k)\n# sort, greedy\nclass Solution3(object):\n    def findMaximumElegance(self, items, k):\n        \"\"\"\n        :type items: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        items.sort(reverse=True)\n        result = curr = 0\n        lookup = set()\n        stk = []\n        for i in xrange(k):\n            if items[i][1] in lookup:\n                stk.append(items[i][0])\n            curr += items[i][0]\n            lookup.add(items[i][1])\n        result = curr+len(lookup)**2\n        for i in xrange(k, len(items)):\n            if items[i][1] in lookup:\n                continue\n            if not stk:\n                break\n            curr += items[i][0]-stk.pop()\n            lookup.add(items[i][1])\n            result = max(result, curr+len(lookup)**2)\n        return result\n"
    },
    {
        "problem_name": "maximum-element-after-decreasing-and-rearranging",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def maximumElementAfterDecrementingAndRearranging(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        arr.sort()\n        result = 1\n        for i in xrange(1, len(arr)):\n            result = min(result+1, arr[i])\n        return result\n"
    },
    {
        "problem_name": "maximum-element-sum-of-a-complete-subset-of-indices",
        "solution": "# Time:  O(n * (1 + 1/4 + 1/9 + ... + 1/x^2)) = O(pi^2 * 6 * n) = O(n), see https://en.wikipedia.org/wiki/Basel_problem\n# Space: O(1)\n\n# number theory, basel problem\nclass Solution(object):\n    def maximumSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return max(sum(nums[i*x**2-1] for x in xrange(1, int((len(nums)//i)**0.5)+1)) for i in xrange(1, len(nums)+1))\n"
    },
    {
        "problem_name": "maximum-employees-to-be-invited-to-a-meeting",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maximumInvitations(self, favorite):\n        \"\"\"\n        :type favorite: List[int]\n        :rtype: int\n        \"\"\"\n        def find_cycles(adj):\n            result = []\n            lookup = [False]*len(adj)\n            for u in xrange(len(adj)):\n                cnt = {}\n                while not lookup[u]:\n                    lookup[u] = True\n                    cnt[u] = len(cnt)\n                    u = adj[u]\n                if u in cnt:\n                    result.append((u, len(cnt)-cnt[u]))\n            return result\n\n        def bfs(adj, u, exclude):\n            result = 0\n            q = [u]\n            while q:\n                result += 1\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if v == exclude:\n                            continue\n                        new_q.append(v)\n                q = new_q\n            return result\n            \n        inv_adj = [[] for _ in xrange(len(favorite))]  \n        for u, v in enumerate(favorite):\n            inv_adj[v].append(u)\n        cycles = find_cycles(favorite)\n        return max(max([l for _, l in cycles if l > 2] or [0]),\n                   sum(bfs(inv_adj, u, favorite[u]) + bfs(inv_adj, favorite[u], u) for u, l in cycles if l == 2))\n"
    },
    {
        "problem_name": "maximum-enemy-forts-that-can-be-captured",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array, two pointers\nclass Solution(object):\n    def captureForts(self, forts):\n        \"\"\"\n        :type forts: List[int]\n        :rtype: int\n        \"\"\"\n        result = left = 0\n        for right in xrange(len(forts)):\n            if not forts[right]:\n                continue\n            if forts[right] == -forts[left]:\n                result = max(result, right-left-1)\n            left = right\n        return result\n"
    },
    {
        "problem_name": "maximum-equal-frequency",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def maxEqualFreq(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        count = collections.Counter()\n        freq = [0 for _ in xrange(len(nums)+1)]\n        for i, n in enumerate(nums, 1):\n            freq[count[n]] -= 1\n            freq[count[n]+1] += 1\n            count[n] += 1\n            c = count[n]\n            if freq[c]*c == i and i < len(nums):\n                result = i+1\n            remain = i-freq[c]*c\n            if freq[remain] == 1 and remain in [1, c+1]:\n                result = i\n        return result\n"
    },
    {
        "problem_name": "maximum-erasure-value",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maximumUniqueSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = {}\n        prefix = [0]*(len(nums)+1)\n        result, left = 0, 0\n        for right, num in enumerate(nums):\n            prefix[right+1] = prefix[right]+num\n            if num in lookup:\n                left = max(left, lookup[num]+1)\n            lookup[num] = right\n            result = max(result, prefix[right+1]-prefix[left])\n        return result\n"
    },
    {
        "problem_name": "maximum-font-to-fit-a-sentence-in-a-screen",
        "solution": "# Time:  O(n + logm), n is the length of text, m is the number of fonts\n# Space: O(1)\n\nimport collections\n\n\nclass FontInfo(object):\n    def getWidth(self, fontSize, ch):\n        \"\"\"\n        :type fontSize: int\n        :type ch: char\n        :rtype int\n        \"\"\"\n        pass\n    \n    def getHeight(self, fontSize):\n        \"\"\"\n        :type fontSize: int\n        :rtype int\n        \"\"\"\n        pass\n\n\nclass Solution(object):\n    def maxFont(self, text, w, h, fonts, fontInfo):\n        \"\"\"\n        :type text: str\n        :type w: int\n        :type h: int\n        :type fonts: List[int]\n        :type fontInfo: FontInfo\n        :rtype: int\n        \"\"\"\n        def check(count, w, h, fonts, fontInfo, x):  # Time: O(1)\n            return (fontInfo.getHeight(fonts[x]) <= h and\n                    sum(cnt * fontInfo.getWidth(fonts[x], c) for c, cnt in count.iteritems()) <= w)\n\n        count = collections.Counter(text)\n        left, right = 0, len(fonts)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(count, w, h, fonts, fontInfo, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return fonts[right] if right >= 0 else -1\n"
    },
    {
        "problem_name": "maximum-frequency-score-of-a-subarray",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# two pointers, sliding window freq table, hash table\nclass Solution(object):\n    def maxFrequencyScore(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        lookup = {}\n        def powmod(n, p):\n            if (n, p) not in lookup:\n                lookup[n, p] = (lookup[n, p-1]*n)%MOD if p >= 2 else n%MOD  # assumed powmod(n, p-1) was accessed before powmod(n, p)\n            return lookup[n, p]\n\n        result = curr = 0\n        cnt = collections.Counter()\n        for i in xrange(len(nums)):\n            if i >= k:\n                curr = (curr-powmod(nums[i-k], cnt[nums[i-k]]))%MOD\n                cnt[nums[i-k]] -= 1\n                if cnt[nums[i-k]]:\n                    curr = (curr+powmod(nums[i-k], cnt[nums[i-k]]))%MOD\n            if cnt[nums[i]]:\n               curr = (curr-powmod(nums[i], cnt[nums[i]]))%MOD\n            cnt[nums[i]] += 1\n            curr = (curr+powmod(nums[i], cnt[nums[i]]))%MOD\n            if i >= k-1:\n                result = max(result, curr)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport collections\n\n\n# two pointers, sliding window, freq table\nclass Solution2(object):\n    def maxFrequencyScore(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result = curr = 0\n        cnt = collections.Counter()\n        for i in xrange(len(nums)):\n            if i >= k:\n                curr = (curr-pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD\n                cnt[nums[i-k]] -= 1\n                if cnt[nums[i-k]]:\n                    curr = (curr+pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD\n            if cnt[nums[i]]:\n               curr = (curr-pow(nums[i], cnt[nums[i]], MOD))%MOD\n            cnt[nums[i]] += 1\n            curr = (curr+pow(nums[i], cnt[nums[i]], MOD))%MOD\n            if i >= k-1:\n                result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "maximum-frequency-stack",
        "solution": "# Time:  O(1)\n# Space: O(n)\n\nimport collections\n\n\nclass FreqStack(object):\n\n    def __init__(self):\n        self.__freq = collections.Counter()\n        self.__group = collections.defaultdict(list)\n        self.__maxfreq = 0\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: void\n        \"\"\"\n        self.__freq[x] += 1\n        if self.__freq[x] > self.__maxfreq:\n            self.__maxfreq = self.__freq[x]\n        self.__group[self.__freq[x]].append(x)   \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        x = self.__group[self.__maxfreq].pop()\n        if not self.__group[self.__maxfreq]:\n            self.__group.pop(self.__maxfreq)\n            self.__maxfreq -= 1\n        self.__freq[x] -= 1\n        if not self.__freq[x]:\n            self.__freq.pop(x)\n        return x\n\n\n\n"
    },
    {
        "problem_name": "maximum-fruits-harvested-after-at-most-k-steps",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maxTotalFruits(self, fruits, startPos, k):\n        \"\"\"\n        :type fruits: List[List[int]]\n        :type startPos: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        max_pos = max(startPos, fruits[-1][0])\n        cnt = [0]*(1+max_pos)\n        for p, a in fruits:\n            cnt[p] = a\n        prefix = [0]\n        for x in cnt:\n            prefix.append(prefix[-1]+x)\n        result = 0\n        for left_dist in xrange(min(startPos, k)+1):\n            right_dist = max(k-2*left_dist, 0)            \n            left, right = startPos-left_dist, min(startPos+right_dist, max_pos)\n            result = max(result, prefix[right+1]-prefix[left])\n        for right_dist in xrange(min(max_pos-startPos, k)+1):\n            left_dist = max(k-2*right_dist, 0) \n            left, right = max(startPos-left_dist, 0), startPos+right_dist\n            result = max(result, prefix[right+1]-prefix[left])\n        return result\n"
    },
    {
        "problem_name": "maximum-gap",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) < 2:\n            return 0\n\n        # Init bucket.\n        max_val, min_val = max(nums), min(nums)\n        gap = max(1, (max_val - min_val) / (len(nums) - 1))\n        bucket_size = (max_val - min_val) / gap + 1\n        bucket = [{'min':float(\"inf\"), 'max':float(\"-inf\")} \\\n                    for _ in xrange(bucket_size)]\n\n        # Find the bucket where the n should be put.\n        for n in nums:\n            # min_val / max_val is in the first / last bucket.\n            if n in (max_val, min_val):\n                continue\n            i = (n - min_val) / gap\n            bucket[i]['min'] = min(bucket[i]['min'], n)\n            bucket[i]['max'] = max(bucket[i]['max'], n)\n\n        # Count each bucket gap between the first and the last bucket.\n        max_gap, pre_bucket_max = 0, min_val\n        for i in xrange(bucket_size):\n            # Skip the bucket it empty.\n            if bucket[i]['min'] == float(\"inf\") and \\\n                bucket[i]['max'] == float(\"-inf\"):\n                continue\n            max_gap = max(max_gap, bucket[i]['min'] - pre_bucket_max)\n            pre_bucket_max = bucket[i]['max']\n        # Count the last bucket.\n        max_gap = max(max_gap, max_val - pre_bucket_max)\n\n        return max_gap\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nclass Solution2(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n\n        if len(nums) < 2:\n            return 0\n\n        nums.sort()\n        pre = nums[0]\n        max_gap = float(\"-inf\")\n\n        for i in nums:\n            max_gap = max(max_gap, i - pre)\n            pre = i\n        return max_gap\n\n\n"
    },
    {
        "problem_name": "maximum-gcd-sum-of-a-subarray",
        "solution": "# Time:  O(nlogr), r = max(nums)\n# Space: O(logr)\n\n# number theory, dp, prefix sum\nclass Solution(object):\n    def maxGcdSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        result = prefix = 0\n        dp = []\n        for right, x in enumerate(nums):\n            dp.append((right, x, prefix))\n            prefix += x\n            new_dp = []\n            for left, g, p in dp:  # Time: O(logr)\n                ng = gcd(g, x)  # Total Time: O(nlogr)\n                if not new_dp or new_dp[-1][1] != ng:\n                    new_dp.append((left, ng, p))  # left and ng are both strictly increasing\n            dp = new_dp\n            for left, g, p in dp:\n                if right-left+1 < k:\n                    break\n                result = max(result, (prefix-p)*g)\n        return result\n\n\n# Time:  O(nlogr), r = max(nums)\n# Space: O(n)\n# number theory, dp, prefix sum\nclass Solution2(object):\n    def maxGcdSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        prefix = [0]*(len(nums)+1)\n        for i, x in enumerate(nums):\n            prefix[i+1] = prefix[i]+x\n        result = 0\n        dp = []\n        for right, x in enumerate(nums):\n            dp.append((right, x))\n            new_dp = []\n            for left, g in dp:  # Time: O(logr)\n                ng = gcd(g, x)  # Total Time: O(nlogr)\n                if not new_dp or new_dp[-1][1] != ng:\n                    new_dp.append((left, ng))  # left and ng are both strictly increasing\n            dp = new_dp\n            for left, g in dp:\n                if right-left+1 < k:\n                    break\n                result = max(result, (prefix[right+1]-prefix[left])*g)\n        return result\n\n\n# Time:  O(n * logr * (logn * logr)) = O(n * (logr)^2 * logn), r = max(nums)\n# Space: O(nlogn)\n# number theory, binary search, rmq, sparse table, prefix sum\nclass Solution3_TLE(object):\n    def maxGcdSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        def binary_search_right(left, right, check):\n            while left <= right:\n                mid = left + (right-left)//2\n                if not check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return right\n\n        # RMQ - Sparse Table\n        # Template: https://github.com/kamyu104/GoogleCodeJam-Farewell-Rounds/blob/main/Round%20D/genetic_sequences2.py3\n        # Time:  ctor:  O(NlogN) * O(fn)\n        #        query: O(fn)\n        # Space: O(NlogN)\n        class SparseTable(object):\n            def __init__(self, arr, fn):\n                self.fn = fn\n                self.bit_length = [0]\n                n = len(arr)\n                k = n.bit_length()-1  # log2_floor(n)\n                for i in xrange(k+1):\n                    self.bit_length.extend(i+1 for _ in xrange(min(1<<i, (n+1)-len(self.bit_length))))\n                self.st = [[0]*n for _ in xrange(k+1)]\n                self.st[0] = arr[:]\n                for i in xrange(1, k+1):  # Time: O(NlogN) * O(fn)\n                    for j in xrange((n-(1<<i))+1):\n                        self.st[i][j] = fn(self.st[i-1][j], self.st[i-1][j+(1<<(i-1))])\n        \n            def query(self, L, R):  # Time: O(fn)\n                i = self.bit_length[R-L+1]-1  # log2_floor(R-L+1)\n                return self.fn(self.st[i][L], self.st[i][R-(1<<i)+1])\n        \n        prefix = [0]*(len(nums)+1)\n        for i, x in enumerate(nums):\n            prefix[i+1] = prefix[i]+x\n        result = 0\n        rmq = SparseTable(nums, gcd)\n        for left, x in enumerate(nums):\n            right = left\n            while right < len(nums):  # O(logr) times\n                g = rmq.query(left, right)\n                right = binary_search_right(right, len(nums)-1, lambda x: rmq.query(left, x) >= g)  # Time: O(logn) * O(logr)\n                if right-left+1 >= k:\n                    result = max(result, (prefix[right+1]-prefix[left])*g)\n                right += 1\n        return result\n"
    },
    {
        "problem_name": "maximum-genetic-difference-query",
        "solution": "# Time:  O(nlogk + mlogk), k is max(max(vals), n-1)\n# Space: O(n + logk)\n\nimport collections\n\n\nclass Trie(object):\n    def __init__(self, bit_count):\n        self.__root = {}\n        self.__bit_count = bit_count\n        \n    def insert(self, num, v):\n        node = self.__root\n        for i in reversed(xrange(self.__bit_count)):\n            curr = (num>>i) & 1\n            new_node = node.setdefault(curr, collections.defaultdict(int))\n            new_node[\"_cnt\"] += v\n            if not new_node[\"_cnt\"]:\n                del node[curr]\n                break\n            node = new_node\n                \n    def query(self, num):\n        node, result = self.__root, 0\n        for i in reversed(xrange(self.__bit_count)):\n            curr = (num>>i) & 1\n            if 1^curr in node:\n                node = node[1^curr]\n                result |= 1<<i\n            else:\n                node = node[curr]\n        return result\n\n\nclass Solution(object):\n    def maxGeneticDifference(self, parents, queries):\n        \"\"\"\n        :type parents: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def iter_dfs(adj, qs, trie, result):\n            stk = [(1, adj[-1][0])]\n            while stk:\n                step, node = stk.pop()\n                if step == 1:\n                    trie.insert(node, 1)\n                    for i, val in qs[node]:\n                        result[i] = trie.query(val)\n                    stk.append((2, node))\n                    for child in reversed(adj[node]):\n                        stk.append((1, child))\n                elif step == 2:\n                    trie.insert(node, -1)\n    \n        adj = collections.defaultdict(list)\n        for node, parent in enumerate(parents):\n            adj[parent].append(node)\n        qs = collections.defaultdict(list)\n        max_val = len(parents)-1\n        for i, (node, val) in enumerate(queries):\n            qs[node].append((i, val))\n            max_val = max(max_val, val)\n        result = [0]*len(queries)\n        iter_dfs(adj, qs, Trie(max_val.bit_length()), result)\n        return result\n\n\n# Time:  O(nlogk + mlogk), k is max(max(vals), n-1)\n# Space: O(n + logk)\nimport collections\n\n\nclass Trie(object):\n    def __init__(self, bit_count):\n        self.__root = {}\n        self.__bit_count = bit_count\n        \n    def insert(self, num, v):\n        node = self.__root\n        for i in reversed(xrange(self.__bit_count)):\n            curr = (num>>i) & 1\n            new_node = node.setdefault(curr, collections.defaultdict(int))\n            new_node[\"_cnt\"] += v\n            if not new_node[\"_cnt\"]:\n                del node[curr]\n                break\n            node = new_node\n                \n    def query(self, num):\n        node, result = self.__root, 0\n        for i in reversed(xrange(self.__bit_count)):\n            curr = (num>>i) & 1\n            if 1^curr in node:\n                node = node[1^curr]\n                result |= 1<<i\n            else:\n                node = node[curr]\n        return result\n\n\nclass Solution2(object):\n    def maxGeneticDifference(self, parents, queries):\n        \"\"\"\n        :type parents: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def dfs(adj, qs, node, trie, result):\n            trie.insert(node, 1)\n            for i, val in qs[node]:\n                result[i] = trie.query(val)\n            for child in adj[node]:\n                dfs(adj, qs, child, trie, result)\n            trie.insert(node, -1)\n\n        adj = collections.defaultdict(list)\n        for node, parent in enumerate(parents):\n            adj[parent].append(node)\n        qs = collections.defaultdict(list)\n        max_val = len(parents)-1\n        for i, (node, val) in enumerate(queries):\n            qs[node].append((i, val))\n            max_val = max(max_val, val)\n        result = [0]*len(queries)\n        dfs(adj, qs, adj[-1][0], Trie(max_val.bit_length()), result)\n        return result\n"
    },
    {
        "problem_name": "maximum-good-people-based-on-statements",
        "solution": "# Time:  O(n^2 * 2^n)\n# Space: O(1)\n\n# brute force, bitmask\nclass Solution(object):\n    def maximumGood(self, statements):\n        \"\"\"\n        :type statements: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def check(mask):\n            return all(((mask>>j)&1) == statements[i][j]\n                       for i in xrange(len(statements)) if (mask>>i)&1 \n                       for j in xrange(len(statements[i])) if statements[i][j] != 2)\n\n        def popcount(x):\n            result = 0\n            while x:\n                x &= x-1\n                result += 1\n            return result\n\n        result = 0\n        for mask in xrange(1<<len(statements)):\n            if check(mask):\n                result = max(result, popcount(mask))\n        return result\n"
    },
    {
        "problem_name": "maximum-good-subarray-sum",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# prefix sum\nclass Solution(object):\n    def maximumSubarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        prefix = collections.defaultdict(lambda: float(\"inf\"))\n        curr = 0\n        result = float(\"-inf\")\n        for x in nums:\n            prefix[x] = min(prefix[x], curr)\n            curr += x\n            result = max(result, curr-prefix[x-k], curr-prefix[x+k])\n        return result if result != float(\"-inf\") else 0\n"
    },
    {
        "problem_name": "maximum-hamming-distances",
        "solution": "# Time:  O(m * 2^m)\n# Space: O(2^m)\n\n# bitmasks, knapsack dp\nclass Solution(object):\n    def maxHammingDistances(self, nums, m):\n        \"\"\"\n        :type nums: List[int]\n        :type m: int\n        :rtype: List[int]\n        \"\"\"\n        dp = [float(\"-inf\")]*(1<<m)\n        for x in nums:\n            dp[x] = 0\n        for i in xrange(m):\n            new_dp = dp[:]\n            for mask in xrange(1<<m):\n                new_dp[mask] = max(new_dp[mask], dp[mask^(1<<i)]+1)\n            dp = new_dp\n        return [dp[x] for x in nums]\n\n\n# Time:  O(m * 2^m)\n# Space: O(2^m)\n# bitmasks, bfs\nclass Solution2(object):\n    def maxHammingDistances(self, nums, m):\n        \"\"\"\n        :type nums: List[int]\n        :type m: int\n        :rtype: List[int]\n        \"\"\"\n        q = []\n        dist = [-1]*(1<<m)\n        for x in nums:\n            if dist[x] != -1:\n                continue\n            dist[x] = 0\n            q.append(x)\n        d = 0\n        while q:\n            d += 1\n            new_q = []\n            for u in q:\n                for i in xrange(m):\n                    if dist[u^(1<<i)] != -1:\n                        continue\n                    dist[u^(1<<i)] = d\n                    new_q.append(u^(1<<i))\n            q = new_q\n        return [m-dist[((1<<m)-1)^x] for x in nums]\n"
    },
    {
        "problem_name": "maximum-height-by-stacking-cuboids",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n    \nclass Solution(object):\n    def maxHeight(self, cuboids):\n        \"\"\"\n        :type cuboids: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for cuboid in cuboids:\n            cuboid.sort()\n        cuboids.append([0, 0, 0])\n        cuboids.sort()\n        dp = [0]*len(cuboids)\n        for i in xrange(1, len(cuboids)):\n            for j in xrange(i):\n                if all(cuboids[j][k] <= cuboids[i][k] for k in xrange(3)):\n                    dp[i] = max(dp[i], dp[j]+cuboids[i][2])\n        return max(dp)\n"
    },
    {
        "problem_name": "maximum-ice-cream-bars",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def maxIceCream(self, costs, coins):\n        \"\"\"\n        :type costs: List[int]\n        :type coins: int\n        :rtype: int\n        \"\"\"\n        costs.sort()\n        for i, c in enumerate(costs):\n            coins -= c\n            if coins < 0:\n                return i\n        return len(costs)\n"
    },
    {
        "problem_name": "maximum-increasing-triplet-value",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nfrom sortedcontainers import SortedList\n\n\n# sorted list, prefix sum\nclass Solution(object):\n    def maximumTripletValue(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left = SortedList()\n        right = [0]*len(nums)\n        for i in reversed(xrange(1, len(nums)-1)):\n            right[i] = max(right[i+1], nums[i+1])\n        result = 0\n        for i in xrange(1, len(nums)-1):\n            left.add(nums[i-1])\n            j = left.bisect_left(nums[i])\n            if j-1 >= 0 and right[i] > nums[i]:\n                result = max(result, left[j-1]-nums[i]+right[i])\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nfrom sortedcontainers import SortedList\n\n\n# sorted list\nclass Solution2(object):\n    def maximumTripletValue(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left = SortedList()\n        right = SortedList(nums[i] for i in xrange(1, len(nums)))\n        result = 0\n        for i in xrange(1, len(nums)-1):\n            left.add(nums[i-1])\n            right.remove(nums[i])\n            j = left.bisect_left(nums[i])\n            if j-1 >= 0 and right[-1] > nums[i]:\n                result = max(result, left[j-1]-nums[i]+right[-1])\n        return result\n"
    },
    {
        "problem_name": "maximum-length-of-a-concatenated-string-with-unique-characters",
        "solution": "# Time:  O(n) ~ O(2^n)\n# Space: O(1) ~ O(2^n)\n\npower = [1]\nlog2 = {1:0}\nfor i in xrange(1, 26):\n    power.append(power[-1]<<1)\n    log2[power[i]] = i\n\n\nclass Solution(object):\n    def maxLength(self, arr):\n        \"\"\"\n        :type arr: List[str]\n        :rtype: int\n        \"\"\"\n        def bitset(s):\n            result = 0\n            for c in s:\n                if result & power[ord(c)-ord('a')]:\n                    return 0\n                result |= power[ord(c)-ord('a')]\n            return result\n        \n        def number_of_one(n):\n            result = 0\n            while n:\n                n &= n-1\n                result += 1\n            return result\n\n        dp = [0]\n        for x in arr:\n            x_set = bitset(x)\n            if not x_set:\n                continue\n            curr_len = len(dp)\n            for i in xrange(curr_len):\n                if dp[i] & x_set:\n                    continue\n                dp.append(dp[i] | x_set)\n        return max(number_of_one(s_set) for s_set in dp)\n\n\n# Time:  O(2^n)\n# Space: O(1)\nclass Solution2(object):\n    def maxLength(self, arr):\n        \"\"\"\n        :type arr: List[str]\n        :rtype: int\n        \"\"\" \n        def bitset(s):\n            result = 0\n            for c in s:\n                if result & power[ord(c)-ord('a')]:\n                    return 0\n                result |= power[ord(c)-ord('a')]\n            return result\n    \n        bitsets = [bitset(x) for x in arr]\n        result = 0\n        for i in xrange(power[len(arr)]):\n            curr_bitset, curr_len = 0, 0\n            while i:\n                j = i & -i  # rightmost bit\n                i ^= j\n                j = log2[j]  # log2(j)\n                if not bitsets[j] or (curr_bitset & bitsets[j]):\n                    break\n                curr_bitset |= bitsets[j]\n                curr_len += len(arr[j])\n            else:\n                result = max(result, curr_len)\n        return result\n"
    },
    {
        "problem_name": "maximum-length-of-pair-chain",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def findLongestChain(self, pairs):\n        \"\"\"\n        :type pairs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        pairs.sort(key=lambda x: x[1])\n        cnt, i = 0, 0\n        for j in xrange(len(pairs)):\n            if j == 0 or pairs[i][1] < pairs[j][0]:\n                cnt += 1\n                i = j\n        return cnt\n\n"
    },
    {
        "problem_name": "maximum-length-of-repeated-subarray",
        "solution": "# Time:  O(m * n)\n# Space: O(min(m, n))\n\nimport collections\n\n\nclass Solution(object):\n    def findLength(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        if len(A) < len(B): return self.findLength(B, A)\n        result = 0\n        dp = [[0] * (len(B)+1) for _ in xrange(2)]\n        for i in xrange(len(A)):\n            for j in xrange(len(B)):\n                if A[i] == B[j]:\n                    dp[(i+1)%2][j+1] = dp[i%2][j]+1\n                else:\n                    dp[(i+1)%2][j+1] = 0\n            result = max(result, max(dp[(i+1)%2]))\n        return result\n\n\n# Time:  O(m * n * log(min(m, n)))\n# Space: O(min(m, n))\n# Binary search + rolling hash solution (226 ms)\nclass Solution2(object):\n    def findLength(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        if len(A) > len(B): return self.findLength(B, A)\n        M, p = 10**9+7, 113\n        p_inv = pow(p, M-2, M)\n        def check(guess):\n            def rolling_hashes(source, length):\n                if length == 0:\n                    yield 0, 0\n                    return\n\n                val, power = 0, 1\n                for i, x in enumerate(source):\n                    val = (val + x*power) % M\n                    if i < length - 1:\n                        power = (power*p) % M\n                    else:\n                        yield val, i-(length-1)\n                        val = (val-source[i-(length-1)])*p_inv % M\n\n            hashes = collections.defaultdict(list)\n            for hash_val, i in rolling_hashes(A, guess):\n                hashes[hash_val].append(i)\n            for hash_val, j in rolling_hashes(B, guess):\n                if any(A[i:i+guess] == B[j:j+guess] for i in hashes[hash_val]):\n                    return True\n            return False\n\n        left, right = 0, min(len(A), len(B)) + 1\n        while left < right:\n            mid = left + (right-left)/2\n            if not check(mid):  # find the min idx such that check(idx) == false\n                right = mid\n            else:\n                left = mid+1\n        return left-1\n\n\n# Time:  O(m * n * min(m, n) * log(min(m, n)))\n# Space: O(min(m^2, n^2))\n# Binary search (122 ms)\nclass Solution3(object):\n    def findLength(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        if len(A) > len(B): return self.findLength(B, A)\n\n        def check(length):\n            lookup = set(A[i:i+length] \\\n                       for i in xrange(len(A)-length+1))\n            return any(B[j:j+length] in lookup \\\n                       for j in xrange(len(B)-length+1))\n\n        A = ''.join(map(chr, A))\n        B = ''.join(map(chr, B))\n        left, right = 0, min(len(A), len(B)) + 1\n        while left < right:\n            mid = left + (right-left)/2\n            if not check(mid):  # find the min idx such that check(idx) == false\n                right = mid\n            else:\n                left = mid+1\n        return left-1\n\n"
    },
    {
        "problem_name": "maximum-length-of-semi-decreasing-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# mono stack\nclass Solution(object):\n    def maxSubarrayLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        stk = []\n        for i in reversed(xrange(len(nums))):\n            if not stk or nums[stk[-1]] > nums[i]:\n                stk.append(i)\n        result = 0\n        for left in xrange(len(nums)):\n            while stk and nums[stk[-1]] < nums[left]:\n                result = max(result, stk.pop()-left+1)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# sort\nclass Solution2(object):\n    def maxSubarrayLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        idxs = range(len(nums))\n        idxs.sort(key=lambda x: nums[x], reverse=True)\n        result = 0\n        for left in xrange(len(nums)):\n            while idxs and nums[idxs[-1]] < nums[left]:\n                result = max(result, idxs.pop()-left+1)\n        return result\n"
    },
    {
        "problem_name": "maximum-length-of-subarray-with-positive-product",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def getMaxLen(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, neg_cnt, last_zero_pos, first_valid_neg_pos = 0, 0, -1, -1\n        for i in xrange(len(nums)):\n            if nums[i] == 0:\n                neg_cnt = 0\n                last_zero_pos = i\n                first_valid_neg_pos = -1\n                continue\n            if nums[i] < 0:\n                if first_valid_neg_pos == -1:\n                    first_valid_neg_pos = i\n                neg_cnt += 1\n            result = max(result, i-(last_zero_pos if neg_cnt%2 == 0 else first_valid_neg_pos))\n        return result\n"
    },
    {
        "problem_name": "maximum-length-substring-with-two-occurrences",
        "solution": "# Time:  O(n + 26)\n# Space: O(26)\n\n# freq table, sliding window, two pointers\nclass Solution(object):\n    def maximumLengthSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        COUNT = 2\n        result = 0\n        cnt = [0]*26\n        left = invalid_cnt = 0\n        for right, x in enumerate(s):\n            if cnt[ord(x)-ord('a')] == COUNT:\n                invalid_cnt += 1\n            cnt[ord(x)-ord('a')] += 1\n            if invalid_cnt:\n                cnt[ord(s[left])-ord('a')] -= 1\n                if cnt[ord(s[left])-ord('a')] == COUNT:\n                    invalid_cnt -= 1\n                left += 1\n        return right-left+1\n\n\n# Time:  O(n + 26)\n# Space: O(26)\n# freq table, sliding window, two pointers\nclass Solution2(object):\n    def maximumLengthSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        COUNT = 2\n        result = 0\n        cnt = [0]*26\n        left = 0\n        for right, x in enumerate(s):\n            cnt[ord(x)-ord('a')] += 1\n            while cnt[ord(x)-ord('a')] > COUNT:\n                cnt[ord(s[left])-ord('a')] -= 1\n                left += 1\n            result = max(result, right-left+1)\n        return result\n"
    },
    {
        "problem_name": "maximum-level-sum-of-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nimport collections\n\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n# dfs solution\nclass Solution(object):\n    def maxLevelSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node, i, level_sums):\n            if not node:\n                return\n            if i == len(level_sums):\n                level_sums.append(0)\n            level_sums[i] += node.val\n            dfs(node.left, i+1, level_sums)\n            dfs(node.right, i+1, level_sums)\n\n        level_sums = []\n        dfs(root, 0, level_sums)\n        return level_sums.index(max(level_sums))+1\n\n    \n# Time:  O(n)\n# Space: O(w)\n# bfs solution\nclass Solution2(object):\n    def maxLevelSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        result, level, max_total = 0, 1, float(\"-inf\")\n        q = collections.deque([root])\n        while q:\n            total = 0\n            for _ in xrange(len(q)):\n                node = q.popleft()\n                total += node.val\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            if total > max_total:\n                result, max_total = level, total\n            level += 1\n        return result\n"
    },
    {
        "problem_name": "maximum-linear-stock-score",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# math, freq table\nclass Solution(object):\n    def maxScore(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter()\n        for i, x in enumerate(prices):\n            cnt[x-i] += x\n        return max(cnt.itervalues())\n"
    },
    {
        "problem_name": "maximum-matching-of-players-with-trainers",
        "solution": "# Time:  O(nlogn + mlogm)\n# Space: O(1)\n\n# greedy, sort\nclass Solution(object):\n    def matchPlayersAndTrainers(self, players, trainers):\n        \"\"\"\n        :type players: List[int]\n        :type trainers: List[int]\n        :rtype: int\n        \"\"\"\n        players.sort()\n        trainers.sort()\n        result = 0\n        for x in trainers:\n            if players[result] > x:\n                continue\n            result += 1\n            if result == len(players):\n                break\n        return result\n"
    },
    {
        "problem_name": "maximum-matrix-sum",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def maxMatrixSum(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        abs_total = sum(abs(x) for row in matrix for x in row)\n        min_abs_val = min(abs(x) for row in matrix for x in row)\n        neg_cnt = sum(x < 0 for row in matrix for x in row)\n        return abs_total if neg_cnt%2 == 0 else abs_total - 2*min_abs_val\n"
    },
    {
        "problem_name": "maximum-nesting-depth-of-the-parentheses",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxDepth(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = curr = 0\n        for c in s:\n            if c == '(':\n                curr += 1\n                result = max(result, curr)\n            elif c == ')':\n                curr -= 1\n        return result\n"
    },
    {
        "problem_name": "maximum-nesting-depth-of-two-valid-parentheses-strings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxDepthAfterSplit(self, seq):\n        \"\"\"\n        :type seq: str\n        :rtype: List[int]\n        \"\"\"\n        return [(i & 1) ^ (seq[i] == '(') for i, c in enumerate(seq)]\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def maxDepthAfterSplit(self, seq):\n        \"\"\"\n        :type seq: str\n        :rtype: List[int]\n        \"\"\"\n        A, B = 0, 0\n        result = [0]*len(seq)\n        for i, c in enumerate(seq):\n            point = 1 if c == '(' else -1\n            if (point == 1 and A <= B) or \\\n               (point == -1 and A >= B):\n                A += point\n            else:\n                B += point\n                result[i] = 1\n        return result\n"
    },
    {
        "problem_name": "maximum-non-negative-product-in-a-matrix",
        "solution": "# Time:  O(m * n)\n# Space: O(n)\n\n# dp with rolling window\nclass Solution(object):\n    def maxProductPath(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        max_dp = [[0]*len(grid[0]) for _ in xrange(2)]\n        min_dp = [[0]*len(grid[0]) for _ in xrange(2)]\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[i])):\n                if i == 0 and j == 0:\n                    max_dp[i%2][j] = min_dp[i%2][j] = grid[i][j]\n                    continue\n                curr_max = max(max_dp[(i-1)%2][j] if i > 0 else max_dp[i%2][j-1],\n                               max_dp[i%2][j-1] if j > 0 else max_dp[(i-1)%2][j])\n                curr_min = min(min_dp[(i-1)%2][j] if i > 0 else min_dp[i%2][j-1],\n                               min_dp[i%2][j-1] if j > 0 else min_dp[(i-1)%2][j])\n                if grid[i][j] < 0:\n                    curr_max, curr_min = curr_min, curr_max\n                max_dp[i%2][j] = curr_max*grid[i][j]\n                min_dp[i%2][j] = curr_min*grid[i][j]\n        return max_dp[(len(grid)-1)%2][-1]%MOD if max_dp[(len(grid)-1)%2][-1] >= 0 else -1\n"
    },
    {
        "problem_name": "maximum-number-of-accepted-invitations",
        "solution": "# Time:  O(m * n * sqrt(m + n))\n# Space: O(m * n)\n\nfrom functools import partial\n\n# Time:  O(E * sqrt(V))\n# Space: O(V)\n# Source code from http://code.activestate.com/recipes/123641-hopcroft-karp-bipartite-matching/\n# Hopcroft-Karp bipartite max-cardinality matching and max independent set\n# David Eppstein, UC Irvine, 27 Apr 2002\ndef bipartiteMatch(graph):\n    '''Find maximum cardinality matching of a bipartite graph (U,V,E).\n    The input format is a dictionary mapping members of U to a list\n    of their neighbors in V.  The output is a triple (M,A,B) where M is a\n    dictionary mapping members of V to their matches in U, A is the part\n    of the maximum independent set in U, and B is the part of the MIS in V.\n    The same object may occur in both U and V, and is treated as two\n    distinct vertices if this happens.'''\n    \n    # initialize greedy matching (redundant, but faster than full search)\n    matching = {}\n    for u in graph:\n        for v in graph[u]:\n            if v not in matching:\n                matching[v] = u\n                break\n    \n    while 1:\n        # structure residual graph into layers\n        # pred[u] gives the neighbor in the previous layer for u in U\n        # preds[v] gives a list of neighbors in the previous layer for v in V\n        # unmatched gives a list of unmatched vertices in final layer of V,\n        # and is also used as a flag value for pred[u] when u is in the first layer\n        preds = {}\n        unmatched = []\n        pred = dict([(u,unmatched) for u in graph])\n        for v in matching:\n            del pred[matching[v]]\n        layer = list(pred)\n        \n        # repeatedly extend layering structure by another pair of layers\n        while layer and not unmatched:\n            newLayer = {}\n            for u in layer:\n                for v in graph[u]:\n                    if v not in preds:\n                        newLayer.setdefault(v,[]).append(u)\n            layer = []\n            for v in newLayer:\n                preds[v] = newLayer[v]\n                if v in matching:\n                    layer.append(matching[v])\n                    pred[matching[v]] = v\n                else:\n                    unmatched.append(v)\n        \n        # did we finish layering without finding any alternating paths?\n        if not unmatched:\n            unlayered = {}\n            for u in graph:\n                for v in graph[u]:\n                    if v not in preds:\n                        unlayered[v] = None\n            return (matching,list(pred),list(unlayered))\n\n        # recursively search backward through layers to find alternating paths\n        # recursion returns true if found path, false otherwise\n        def recurse(v):\n            if v in preds:\n                L = preds[v]\n                del preds[v]\n                for u in L:\n                    if u in pred:\n                        pu = pred[u]\n                        del pred[u]\n                        if pu is unmatched or recurse(pu):\n                            matching[v] = u\n                            return 1\n            return 0\n        \n        def recurse_iter(v):\n            def divide(v):\n                if v not in preds:\n                    return\n                L = preds[v]\n                del preds[v]\n                for u in L :\n                    if u in pred and pred[u] is unmatched:  # early return\n                        del pred[u]\n                        matching[v] = u\n                        ret[0] = True\n                        return\n                stk.append(partial(conquer, v, iter(L)))\n\n            def conquer(v, it):\n                for u in it:\n                    if u not in pred:\n                        continue\n                    pu = pred[u]\n                    del pred[u]\n                    stk.append(partial(postprocess, v, u, it))\n                    stk.append(partial(divide, pu))\n                    return\n\n            def postprocess(v, u, it):\n                if not ret[0]:\n                    stk.append(partial(conquer, v, it))\n                    return\n                matching[v] = u\n\n            ret, stk = [False], []\n            stk.append(partial(divide, v))\n            while stk:\n                stk.pop()()\n            return ret[0]\n\n        for v in unmatched: recurse_iter(v)\n\n\nimport collections\n\n\n# Hopcroft-Karp bipartite matching\nclass Solution(object):\n    def maximumInvitations(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        adj = collections.defaultdict(list)\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if not grid[i][j]:\n                    continue\n                adj[j].append(i)\n        return len(bipartiteMatch(adj)[0])\n\n\n# Time:  O(|V| * |E|) = O(min(m, n) * (m * n))\n# Space: O(|V|) = O(min(m, n))\n# Hungarian bipartite matching with less space\nclass Solution2(object):\n    def maximumInvitations(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def augment(grid, u, lookup, match):\n            for v in xrange(V):\n                if not get_grid(u, v) or v in lookup:\n                    continue\n                lookup.add(v)\n                if v not in match or augment(grid, match[v], lookup, match):\n                    match[v] = u  # greedily match\n                    return True\n            return False\n    \n        def hungarian(grid):\n            match = {}\n            for i in xrange(U):\n                augment(grid, i, set(), match)\n            return len(match)\n\n        U, V = min(len(grid), len(grid[0])), max(len(grid), len(grid[0]))\n        get_grid = (lambda x, y: grid[x][y]) if len(grid) < len(grid[0]) else (lambda x, y: grid[y][x])\n        return hungarian(grid)\n\n\n# Time:  O(|V| * |E|) = O(min(m, n) * (m * n))\n# Space: O(|E|) = O(m * n)\nimport collections\n\n\n# Hungarian bipartite matching\nclass Solution3(object):\n    def maximumInvitations(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def augment(adj, u, lookup, match):\n            for v in adj[u]:\n                if v in lookup:\n                    continue\n                lookup.add(v)\n                if v not in match or augment(adj, match[v], lookup, match):\n                    match[v] = u  # greedily match\n                    return True\n            return False\n    \n        def hungarian(adj):\n            match = {}\n            for i in adj.iterkeys():\n                augment(adj, i, set(), match)\n            return len(match)\n        \n        adj = collections.defaultdict(list)\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if not grid[i][j]:\n                    continue\n                if len(grid) < len(grid[0]):\n                    adj[i].append(j)\n                else:\n                    adj[j].append(i)\n        return hungarian(adj)\n"
    },
    {
        "problem_name": "maximum-number-of-achievable-transfer-requests",
        "solution": "# Time:  O((n + r) * 2^r)\n# Space: O(n + r)\n\nimport itertools\n\n\n# early return solution\nclass Solution(object):\n    def maximumRequests(self, n, requests):\n        \"\"\"\n        :type n: int\n        :type requests: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for k in reversed(xrange(1, len(requests)+1)):\n            for c in itertools.combinations(xrange(len(requests)), k):\n                change = [0]*n\n                for i in c:\n                    change[requests[i][0]] -= 1\n                    change[requests[i][1]] += 1\n                if all(c == 0 for c in change):\n                    return k  # early return\n        return 0\n    \n\n# Time:  O((n + r) * 2^r)\n# Space: O(n + r)\n# full search solution (much slower)\nclass Solution2(object):\n    def maximumRequests(self, n, requests):\n        \"\"\"\n        :type n: int\n        :type requests: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def evaluate(n, requests, mask):\n            change = [0]*n\n            base, count = 1, 0\n            for i in xrange(len(requests)):\n                if base & mask:\n                    change[requests[i][0]] -= 1\n                    change[requests[i][1]] += 1\n                    count += 1\n                base <<= 1\n            return count if all(c == 0 for c in change) else 0\n\n        return max(evaluate(n, requests, i) for i in xrange(1 << len(requests)))\n"
    },
    {
        "problem_name": "maximum-number-of-alloys",
        "solution": "# Time:  O(k * nlogn)\n# Space: O(n)\n\n# sort, math\nclass Solution(object):\n    def maxNumberOfAlloys(self, n, k, budget, composition, stock, cost):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type budget: int\n        :type composition: List[List[int]]\n        :type stock: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        def count(machine, budget):\n            def cnt(x):\n                return stock[x]//machine[x]\n    \n            idxs = range(n)\n            idxs.sort(key=cnt)\n            result = cnt(idxs[0])\n            prefix = curr = discount = 0\n            for i in xrange(n):\n                curr += cost[idxs[i]]*machine[idxs[i]]\n                discount += cost[idxs[i]]*(stock[idxs[i]]%machine[idxs[i]])\n                if i+1 != n and cnt(idxs[i+1])-cnt(idxs[i]) == 0:\n                    continue\n                prefix += curr\n                budget += discount\n                curr = discount = 0\n                mn = min((cnt(idxs[i+1])-cnt(idxs[i]) if i+1 < n else float(\"inf\")), budget//prefix)\n                if mn == 0:\n                    break\n                budget -= prefix*mn\n                result += mn\n            return result\n\n        return max(count(machine, budget) for machine in composition)\n\n\n# Time:  O(k * n * logr), r = min(stock)+budget\n# Space: O(1)\n# binary search\nclass Solution2(object):\n    def maxNumberOfAlloys(self, n, k, budget, composition, stock, cost):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type budget: int\n        :type composition: List[List[int]]\n        :type stock: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        def check(x):\n            for machine in composition:\n                curr = 0\n                for i in xrange(n):\n                    curr += max(x*machine[i]-stock[i], 0)*cost[i]\n                    if curr > budget:\n                        break\n                if curr <= budget:\n                    return True\n            return False\n\n        left, right = 1, min(stock)+budget\n        while left <= right:\n            mid = left+(right-left)//2\n            if not check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "maximum-number-of-balloons",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def maxNumberOfBalloons(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: int\n        \"\"\"\n        TARGET = \"balloon\"\n        source_count = collections.Counter(text)\n        target_count = collections.Counter(TARGET)\n        return min(source_count[c]//target_count[c] for c in target_count.iterkeys())\n"
    },
    {
        "problem_name": "maximum-number-of-balls-in-a-box",
        "solution": "# Time:  O(nlogm)\n# Space: O(logm)\n\nimport collections\nimport itertools\n\n\nclass Solution(object):\n    def countBalls(self, lowLimit, highLimit):\n        \"\"\"\n        :type lowLimit: int\n        :type highLimit: int\n        :rtype: int\n        \"\"\"\n        count = collections.Counter()\n        for i in xrange(lowLimit, highLimit+1):\n            count[sum(itertools.imap(int, str(i)))] += 1\n        return max(count.itervalues())\n"
    },
    {
        "problem_name": "maximum-number-of-books-you-can-take",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# mono stack\nclass Solution(object):\n    def maximumBooks(self, books):\n        \"\"\"\n        :type books: List[int]\n        :rtype: int\n        \"\"\"\n        def count(right, l):\n            left = max(right-l+1, 0)\n            return (left+right)*(right-left+1)//2\n        \n        result = curr = 0\n        stk = [-1]\n        for i in xrange(len(books)):\n            while stk[-1] != -1 and books[stk[-1]] >= books[i]-(i-stk[-1]):\n                j = stk.pop()\n                curr -= count(books[j], j-stk[-1])\n            curr += count(books[i], i-stk[-1])\n            stk.append(i)\n            result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-coins-you-can-get",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def maxCoins(self, piles):\n        \"\"\"\n        :type piles: List[int]\n        :rtype: int\n        \"\"\"\n        piles.sort()\n        return sum(itertools.islice(piles, len(piles)//3, len(piles), 2))\n"
    },
    {
        "problem_name": "maximum-number-of-consecutive-values-you-can-make",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def getMaximumConsecutive(self, coins):\n        \"\"\"\n        :type coins: List[int]\n        :rtype: int\n        \"\"\"\n        coins.sort()\n        result = 1\n        for c in coins:\n            if c > result:\n                break\n            result += c\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-darts-inside-of-a-circular-dartboard",
        "solution": "# Time:  O(n^2 * logn)\n# Space: O(n)\n\nimport math\n\n\n# angle sweep solution\n# great explanation:\n# https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/discuss/636345/Python-O(n3)-and-O(n2logn)-solution-explained-in-detail-with-pictures\nclass Solution(object):\n    def numPoints(self, points, r):\n        \"\"\"\n        :type points: List[List[int]]\n        :type r: int\n        :rtype: int\n        \"\"\"\n        def count_points(points, r, i):\n            angles = []\n            for j in xrange(len(points)):\n                if i == j:\n                    continue\n                dx, dy = points[i][0]-points[j][0], points[i][1]-points[j][1]\n                d = math.sqrt(dx**2 + dy**2)\n                if d > 2*r:\n                    continue\n                delta, angle = math.acos(d/(2*r)), math.atan2(dy, dx)\n                angles.append((angle-delta, 0)), angles.append((angle+delta, 1))\n            angles.sort()\n            result, count = 1, 1\n            for _, is_closed in angles:  # angle sweep\n                if not is_closed:\n                    count += 1\n                else:\n                    count -= 1\n                result = max(result, count)\n            return result\n\n        return max(count_points(points, r, i) for i in xrange(len(points)))\n"
    },
    {
        "problem_name": "maximum-number-of-eaten-apples",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def eatenApples(self, apples, days):\n        \"\"\"\n        :type apples: List[int]\n        :type days: List[int]\n        :rtype: int\n        \"\"\"\n        min_heap = []\n        result = i = 0\n        while i < len(apples) or min_heap:\n            if i < len(apples) and apples[i] > 0:\n                heapq.heappush(min_heap, [i+days[i], i])\n            while min_heap and (min_heap[0][0] <= i or apples[min_heap[0][1]] == 0):\n                heapq.heappop(min_heap)\n            if min_heap:\n                apples[min_heap[0][1]] -= 1\n                result += 1\n            i += 1\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-events-that-can-be-attended-ii",
        "solution": "# Time:  O(nlogn + n * k)\n# Space: O(n * k)\n\nimport bisect\n\n\nclass Solution(object):\n    def maxValue(self, events, k):\n        \"\"\"\n        :type events: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        events.sort(key=lambda x: x[1])\n        sorted_ends = [x[1] for x in events]\n        dp = [[0]*(k+1) for _ in xrange(len(events)+1)]\n        for i in xrange(1, len(events)+1):\n            prev_i_m_1 = bisect.bisect_left(sorted_ends, events[i-1][0])-1\n            for j in xrange(1, k+1):\n                dp[i][j] = max(dp[i-1][j], dp[prev_i_m_1+1][j-1]+events[i-1][2])\n        return dp[-1][-1]\n\n\n# Time:  O(nlogn + n * k)\n# Space: O(n * k)\nimport bisect\n\n\nclass Solution2(object):\n    def maxValue(self, events, k):\n        \"\"\"\n        :type events: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        events.sort()\n        sorted_starts = [x[0] for x in events]\n        dp = [[0]*(k+1) for _ in xrange(len(events)+1)]\n        for i in reversed(xrange(len(events))):\n            next_i = bisect.bisect_right(sorted_starts, events[i][1])-1\n            for j in xrange(1, k+1):\n                dp[i][j] = max(dp[i+1][j], dp[next_i+1][j-1]+events[i][2])\n        return dp[0][-1]\n"
    },
    {
        "problem_name": "maximum-number-of-events-that-can-be-attended",
        "solution": "# Time:  O(r + nlogn), r is the max end day of events\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def maxEvents(self, events):\n        \"\"\"\n        :type events: List[List[int]]\n        :rtype: int\n        \"\"\"\n        events.sort(reverse=True)\n        min_heap = []\n        result = 0\n        for d in xrange(1, max(events, key=lambda x:x[1])[1]+1):\n            while events and events[-1][0] == d:\n                heapq.heappush(min_heap, events.pop()[1])\n            while min_heap and min_heap[0] == d-1:\n                heapq.heappop(min_heap)\n            if not min_heap:\n                continue\n            heapq.heappop(min_heap)\n            result += 1       \n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-fish-in-a-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\n# bfs\nclass Solution(object):\n    def findMaxFish(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n        def bfs(i, j):\n            result = grid[i][j]\n            grid[i][j] = 0\n            q = [(i, j)]\n            while q:\n                new_q = []\n                for i, j in q:\n                    for di, dj in DIRECTIONS:\n                        ni, nj = i+di, j+dj\n                        if not (0 <= ni < len(grid) and\n                                0 <= nj < len(grid[0]) and\n                                grid[ni][nj]):\n                            continue\n                        result += grid[ni][nj]\n                        grid[ni][nj] = 0\n                        new_q.append((ni, nj))\n                q = new_q\n            return result\n\n        result = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j]:\n                    result = max(result, bfs(i, j))\n        return result\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\n# dfs\nclass Solution2(object):\n    def findMaxFish(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n        def dfs(i, j):\n            result = grid[i][j]\n            grid[i][j] = 0\n            stk = [(i, j)]\n            while stk:\n                i, j = stk.pop()\n                for di, dj in reversed(DIRECTIONS):\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < len(grid) and\n                            0 <= nj < len(grid[0]) and\n                            grid[ni][nj]):\n                        continue\n                    result += grid[ni][nj]\n                    grid[ni][nj] = 0\n                    stk.append((ni, nj))\n            return result\n\n        result = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j]:\n                    result = max(result, dfs(i, j))\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-groups-entering-a-competition",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def maximumGroups(self, grades):\n        \"\"\"\n        :type grades: List[int]\n        :rtype: int\n        \"\"\"\n        # (1+x)*x/2 <= len(grades)\n        # => x <= ((1+8*len(grades))**0.5-1)/2.0\n        return int(((1+8*len(grades))**0.5-1)/2.0)\n"
    },
    {
        "problem_name": "maximum-number-of-groups-getting-fresh-donuts",
        "solution": "# Time:  O((b/2) * (n/(b/2)+1)^(b/2))\n# Space: O((n/(b/2)+1)^(b/2))\n\n# greedy + memoization solution\nclass Solution(object):\n    def maxHappyGroups(self, batchSize, groups):\n        \"\"\"\n        :type batchSize: int\n        :type groups: List[int]\n        :rtype: int\n        \"\"\"\n        def memoization(batchSize, count, mask, remain, lookup):\n            if lookup[mask] == 0:\n                a_remain = 0\n                if remain in count:\n                    curr, basis = mask, 1\n                    for i, c in count.iteritems():\n                        if i == remain:\n                            break\n                        basis *= c+1\n                        curr //= c+1\n                    a_remain = curr%(count[remain]+1)\n                result = 0\n                if a_remain:\n                    result = max(result, int(remain == 0) + memoization(batchSize, count, mask-basis, 0, lookup))\n                else:\n                    curr, basis = mask, 1\n                    for i, c in count.iteritems():\n                        if curr%(c+1):\n                            result = max(result, int(remain == 0) + memoization(batchSize, count, mask-basis, (remain-i)%batchSize, lookup))\n                        basis *= c+1\n                        curr //= c+1\n                lookup[mask] = result\n            return lookup[mask]\n    \n        count = [0]*batchSize\n        for i in groups:\n            count[i%len(count)] += 1\n        result = count[0]\n        count[0] = 0\n        for i in xrange(1, len(count)//2+1):  # optimization\n            pair_count = min(count[i], count[len(count)-i]) if 2*i != len(count) else count[i]//2\n            result += pair_count\n            count[i] -= pair_count\n            count[len(count)-i] -= pair_count\n        new_count = {i:c for i, c in enumerate(count) if c}\n        max_mask = reduce(lambda total, c: total*(c+1), new_count.itervalues(), 1)\n        lookup = [0]*max_mask\n        return result+memoization(batchSize, new_count, max_mask-1, 0, lookup)\n\n\n# Time:  O((b/2) * (n/(b/2)+1)^(b/2))\n# Space: O((n/(b/2)+1)^(b/2))\n# dp solution\nclass Solution2(object):\n    def maxHappyGroups(self, batchSize, groups):\n        \"\"\"\n        :type batchSize: int\n        :type groups: List[int]\n        :rtype: int\n        \"\"\"\n        count = [0]*batchSize\n        for i in groups:\n            count[i%len(count)] += 1\n        result = count[0]\n        count[0] = 0\n        for i in xrange(1, len(count)//2+1):  # optimization\n            pair_count = min(count[i], count[len(count)-i]) if 2*i != len(count) else count[i]//2\n            result += pair_count\n            count[i] -= pair_count\n            count[len(count)-i] -= pair_count\n        new_count = {i:c for i, c in enumerate(count) if c}\n        max_mask = reduce(lambda total, c: total*(c+1), new_count.itervalues(), 1)\n        dp = [0]*max_mask\n        for mask in xrange(len(dp)):\n            remain = 0\n            curr, basis = mask, 1\n            for i, c in new_count.iteritems():\n                ai = curr%(c+1)\n                if ai:\n                    dp[mask] = max(dp[mask], dp[mask-basis])\n                remain = (remain+ai*i)%batchSize\n                basis *= c+1\n                curr //= c+1\n            if mask != len(dp)-1 and remain == 0:\n                dp[mask] += 1\n        return result+dp[-1]\n"
    },
    {
        "problem_name": "maximum-number-of-groups-with-increasing-length",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# constructive algorithms, counting sort, greedy\nclass Solution(object):\n    def maxIncreasingGroups(self, usageLimits):\n        \"\"\"\n        :type usageLimits: List[int]\n        :rtype: int\n        \"\"\"\n        def inplace_counting_sort(nums, reverse=False):  # Time: O(n)\n            if not nums:\n                return\n            count = [0]*(max(nums)+1)\n            for num in nums:\n                count[num] += 1\n            for i in xrange(1, len(count)):\n                count[i] += count[i-1]\n            for i in reversed(xrange(len(nums))):  # inplace but unstable sort\n                while nums[i] >= 0:\n                    count[nums[i]] -= 1\n                    j = count[nums[i]]\n                    nums[i], nums[j] = nums[j], ~nums[i]\n            for i in xrange(len(nums)):\n                nums[i] = ~nums[i]  # restore values\n            if reverse:  # unstable sort\n                nums.reverse()\n\n        usageLimits = [min(x, len(usageLimits)) for x in usageLimits]\n        inplace_counting_sort(usageLimits)\n        result = curr = 0\n        for x in usageLimits:\n            curr += x\n            if curr >= result+1:\n                curr -= result+1\n                result += 1\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# constructive algorithms, sort, greedy\nclass Solution2(object):\n    def maxIncreasingGroups(self, usageLimits):\n        \"\"\"\n        :type usageLimits: List[int]\n        :rtype: int\n        \"\"\"\n        usageLimits.sort()\n        result = curr = 0\n        for x in usageLimits:\n            curr += x\n            if curr >= result+1:\n                curr -= result+1\n                result += 1\n        return result\n\n    \n# Time:  O(nlogn)\n# Space: O(1)\n# constructive algorithms, sort, binary search, greedy\nclass Solution3(object):\n    def maxIncreasingGroups(self, usageLimits):\n        \"\"\"\n        :type usageLimits: List[int]\n        :rtype: int\n        \"\"\"\n        def check(l):\n            curr = 0\n            for i in xrange(l):\n                curr += usageLimits[~i]-(l-i)\n                curr = min(curr, 0)\n            for i in xrange(len(usageLimits)-l):\n                curr += usageLimits[i]\n            return curr >= 0\n\n        usageLimits.sort()\n        left, right = 1, len(usageLimits)\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# constructive algorithms, sort, binary search, greedy, prefix sum\nclass Solution4(object):\n    def maxIncreasingGroups(self, usageLimits):\n        \"\"\"\n        :type usageLimits: List[int]\n        :rtype: int\n        \"\"\"\n        def check(l):\n            return all((i+1)*i//2 <= prefix[len(usageLimits)-(l-i)] for i in xrange(1, l+1))\n\n        usageLimits.sort()\n        prefix = [0]*(len(usageLimits)+1)\n        for i in xrange(len(usageLimits)):\n            prefix[i+1] = prefix[i]+usageLimits[i]\n        left, right = 1, len(usageLimits)\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "maximum-number-of-integers-to-choose-from-a-range-i",
        "solution": "# Time:  O(b)\n# Space: O(b)\n\n# math\nclass Solution(object):\n    def maxCount(self, banned, n, maxSum):\n        \"\"\"\n        :type banned: List[int]\n        :type n: int\n        :type maxSum: int\n        :rtype: int\n        \"\"\"\n        k = min(int((-1+(1+8*maxSum))**0.5/2), n)  # k = argmax((k+1)*k//2 <= maxSum)\n        total = (k+1)*k//2\n        result = k\n        lookup = set(banned)\n        for x in lookup:\n            if x <= k:\n                total -= x\n                result -= 1\n        for i in xrange(k+1, n+1):\n            if i in lookup:\n                continue\n            if total+i > maxSum:\n                break\n            total += i\n            result += 1\n        return result\n\n\n# Time:  O(blogb + logn * logb)\n# Space: O(b)\nimport bisect\n\n\n# binary search, prefix sum\nclass Solution2(object):\n    def maxCount(self, banned, n, maxSum):\n        \"\"\"\n        :type banned: List[int]\n        :type n: int\n        :type maxSum: int\n        :rtype: int\n        \"\"\"\n        def check(x):\n            return (x+1)*x//2-prefix[bisect.bisect_right(sorted_banned, x)] <= maxSum\n    \n        sorted_banned = sorted(set(banned))\n        prefix = [0]*(len(sorted_banned)+1)\n        for i in xrange(len(sorted_banned)):\n            prefix[i+1] = prefix[i]+sorted_banned[i]\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right-bisect.bisect_right(sorted_banned, right)\n\n \n# Time:  O(n)\n# Space: O(b)\n# greedy\nclass Solution3(object):\n    def maxCount(self, banned, n, maxSum):\n        \"\"\"\n        :type banned: List[int]\n        :type n: int\n        :type maxSum: int\n        :rtype: int\n        \"\"\"\n        lookup = set(banned)\n        result = total = 0\n        for i in xrange(1, n+1):\n            if i in lookup:\n                continue\n            if total+i > maxSum:\n                break\n            total += i\n            result += 1\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-integers-to-choose-from-a-range-ii",
        "solution": "# Time:  O(b)\n# Space: O(b)\n\n# math\nclass Solution(object):\n    def maxCount(self, banned, n, maxSum):\n        \"\"\"\n        :type banned: List[int]\n        :type n: int\n        :type maxSum: int\n        :rtype: int\n        \"\"\"\n        k = min(int((-1+(1+8*maxSum))**0.5/2), n)  # k = argmax((k+1)*k//2 <= maxSum)\n        total = (k+1)*k//2\n        result = k\n        lookup = set(banned)\n        for x in lookup:\n            if x <= k:\n                total -= x\n                result -= 1\n        for i in xrange(k+1, n+1):\n            if i in lookup:\n                continue\n            if total+i > maxSum:\n                break\n            total += i\n            result += 1\n        return result\n\n\n# Time:  O(blogb + logn * logb)\n# Space: O(b)\nimport bisect\n\n\n# binary search, prefix sum\nclass Solution2(object):\n    def maxCount(self, banned, n, maxSum):\n        \"\"\"\n        :type banned: List[int]\n        :type n: int\n        :type maxSum: int\n        :rtype: int\n        \"\"\"\n        def check(x):\n            return (x+1)*x//2-prefix[bisect.bisect_right(sorted_banned, x)] <= maxSum\n    \n        sorted_banned = sorted(set(banned))\n        prefix = [0]*(len(sorted_banned)+1)\n        for i in xrange(len(sorted_banned)):\n            prefix[i+1] = prefix[i]+sorted_banned[i]\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right-bisect.bisect_right(sorted_banned, right)\n"
    },
    {
        "problem_name": "maximum-number-of-intersections-on-the-chart",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# sort, line sweep, coordinate compression\nclass Solution(object):\n    def maxIntersectionCount(self, y):\n        \"\"\"\n        :type y: List[int]\n        :rtype: int\n        \"\"\"\n        val_to_idx = {x:i for i, x in enumerate(sorted(set(y)))}\n        cnts = [0]*(2*len(val_to_idx)+1)\n        for i in xrange(len(y)-1):\n            # [y[i], y[i+1]) <=> [y[i], y[i+1]-0.5] <=> [2*y[i], 2*y[i+1]-1]\n            left, right = 2*val_to_idx[y[i]], 2*val_to_idx[y[i+1]]+(-1 if y[i] < y[i+1] else +1)\n            cnts[min(left, right)] += 1\n            cnts[max(left, right)+1] -= 1\n        # [y[i], y[i]] <=> [2*y[i], 2*y[i]]\n        cnts[2*val_to_idx[y[-1]]] += 1\n        cnts[2*val_to_idx[y[-1]]+1] -= 1\n        result = cnt = 0\n        for c in cnts:\n            cnt += c\n            result = max(result, cnt)\n        return result\n    \n\n# Time:  O(nlogn)\n# Space: O(n)\n# sort, line sweep\nclass Solution2(object):\n    def maxIntersectionCount(self, y):\n        \"\"\"\n        :type y: List[int]\n        :rtype: int\n        \"\"\"\n        events = []\n        for i in xrange(len(y)-1):\n            # [y[i], y[i+1]) <=> [y[i], y[i+1]-0.5] <=> [2*y[i], 2*y[i+1]-1]\n            left, right = 2*y[i], 2*y[i+1]+(-1 if y[i] < y[i+1] else +1)\n            events.append((min(left, right), +1))\n            events.append((max(left, right)+1, -1))\n        # [y[i], y[i]] <=> [2*y[i], 2*y[i]]\n        events.append((2*y[-1], +1))\n        events.append((2*y[-1]+1, -1))\n        events.sort()\n        result = cnt = 0\n        for _, c in events:\n            cnt += c\n            result = max(result, cnt)\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-jumps-to-reach-the-last-index",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\n# dp\nclass Solution(object):\n    def maximumJumps(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        dp = [-1]*len(nums)\n        dp[0] = 0\n        for i in xrange(1, len(nums)):\n            for j in xrange(i):\n                if abs(nums[i]-nums[j]) <= target:\n                    if dp[j] != -1:\n                        dp[i] = max(dp[i], dp[j]+1)\n        return dp[-1]\n"
    },
    {
        "problem_name": "maximum-number-of-k-divisible-components",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# bfs, greedy\nclass Solution(object):\n    def maxKDivisibleComponents(self, n, edges, values, k):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type values: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def bfs():\n            result = 0\n            dp = [x%k for x in values]\n            cnt = [len(adj[u]) for u in xrange(len(adj))]\n            q = [u for u in xrange(n) if cnt[u] == 1]\n            while q:\n                new_q = []\n                for u in q:\n                    if not dp[u]:\n                        result += 1\n                    for v in adj[u]:\n                        dp[v] = (dp[v]+dp[u])%k\n                        cnt[v] -= 1\n                        if cnt[v] == 1:\n                            new_q.append(v)\n                q = new_q\n            return max(result, 1)\n\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return bfs()\n"
    },
    {
        "problem_name": "maximum-number-of-moves-in-a-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(m)\n\n# dp\nclass Solution(object):\n    def maxMoves(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = [True]*len(grid)\n        result = 0\n        for c in xrange(len(grid[0])-1):\n            new_dp = [False]*len(grid)\n            for r in xrange(len(grid)):\n                if not dp[r]:\n                    continue\n                if grid[r][c] < grid[r][c+1]:\n                    new_dp[r] = True\n                if r-1 >= 0 and grid[r][c] < grid[r-1][c+1]:\n                    new_dp[r-1] = True\n                if r+1 < len(grid) and grid[r][c] < grid[r+1][c+1]:\n                    new_dp[r+1] = True\n            dp = new_dp\n            if not sum(dp):\n                break\n        else:\n            c = len(grid[0])-1\n        return c\n\n\n# Time:  O(m * n)\n# Space: O(m)\n# dp\nclass Solution2(object):\n    def maxMoves(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = [0]*len(grid)\n        for c in reversed(xrange(len(grid[0])-1)):\n            new_dp = [0]*len(grid)\n            for r in xrange(len(grid)):\n                if grid[r][c] < grid[r][c+1]:\n                    new_dp[r] = max(new_dp[r], dp[r]+1)\n                if r-1 >= 0 and grid[r][c] < grid[r-1][c+1]:\n                    new_dp[r] = max(new_dp[r], dp[r-1]+1)\n                if r+1 < len(grid) and grid[r][c] < grid[r+1][c+1]:\n                    new_dp[r] = max(new_dp[r], dp[r+1]+1)\n            dp = new_dp\n        return max(dp)\n\n\n# Time:  O(m * n)\n# Space: O(m)\n# bfs\nclass Solution3(object):\n    def maxMoves(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        q = set(xrange(len(grid)))\n        for c in xrange(len(grid[0])-1):\n            new_q = set()\n            for r in q:\n                if grid[r][c] < grid[r][c+1]:\n                    new_q.add(r)\n                if r-1 >= 0 and grid[r][c] < grid[r-1][c+1]:\n                    new_q.add(r-1)\n                if r+1 < len(grid) and grid[r][c] < grid[r+1][c+1]:\n                    new_q.add(r+1)\n            q = new_q\n            if not q:\n                break\n        else:\n            c = len(grid[0])-1\n        return c\n"
    },
    {
        "problem_name": "maximum-number-of-non-overlapping-palindrome-substrings",
        "solution": "# Time:  O(n * k)\n# Space: O(1)\n\n# two pointers, greedy\nclass Solution(object):\n    def maxPalindromes(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = prev = 0\n        for mid in xrange(2*len(s)-1):\n            left, right = mid//2, mid//2+mid%2\n            while left >= prev and right < len(s) and s[left] == s[right]:\n                if right-left+1 >= k:\n                    prev = right+1\n                    result += 1\n                    break\n                left, right = left-1, right+1\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-non-overlapping-subarrays-with-sum-equals-target",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maxNonOverlapping(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        lookup = {0:-1}\n        result, accu, right = 0, 0, -1\n        for i, num in enumerate(nums):\n            accu += num\n            if accu-target in lookup and lookup[accu-target] >= right:\n                right = i\n                result += 1  # greedy\n            lookup[accu] = i\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-non-overlapping-substrings",
        "solution": "# Time:  O(n)\n# space: O(1)\n\nclass Solution(object):\n    def maxNumOfSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        def find_right_from_left(s, first, last, left):\n            right, i = last[ord(s[left])-ord('a')], left\n            while i <= right:\n                if first[ord(s[i])-ord('a')] < left:\n                    return -1\n                right = max(right, last[ord(s[i])-ord('a')])\n                i += 1\n            return right\n            \n        first, last = [float(\"inf\")]*26, [float(\"-inf\")]*26\n        for i, c in enumerate(s):\n            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)\n            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)\n        result = [\"\"]\n        right = float(\"inf\")\n        for left, c in enumerate(s):\n            if left != first[ord(c)-ord('a')]:\n                continue\n            new_right = find_right_from_left(s, first, last, left)\n            if new_right == -1:\n                continue\n            if left > right:\n                result.append(\"\")\n            right = new_right\n            result[-1] = s[left:right+1]\n        return result\n\n\n# Time:  O(n)\n# space: O(1)\nclass Solution2(object):\n    def maxNumOfSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        def find_right_from_left(s, first, last, left):\n            right, i = last[ord(s[left])-ord('a')], left\n            while i <= right:\n                if first[ord(s[i])-ord('a')] < left:\n                    return -1\n                right = max(right, last[ord(s[i])-ord('a')])\n                i += 1\n            return right\n\n        first, last = [float(\"inf\")]*26, [float(\"-inf\")]*26\n        for i, c in enumerate(s):\n            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)\n            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)\n        intervals = []\n        for c in xrange(len(first)):\n            if first[c] == float(\"inf\"):\n                continue\n            left, right = first[c], find_right_from_left(s, first, last, first[c])\n            if right != -1:\n                intervals.append((right, left))\n        intervals.sort()  # Time: O(26log26)\n        result, prev = [], -1\n        for right, left in intervals:\n            if left <= prev:\n                continue\n            result.append(s[left:right+1])\n            prev = right\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-occurrences-of-a-substring",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# rolling hash (Rabin-Karp Algorithm)\nclass Solution(object):\n    def maxFreq(self, s, maxLetters, minSize, maxSize):\n        \"\"\"\n        :type s: str\n        :type maxLetters: int\n        :type minSize: int\n        :type maxSize: int\n        :rtype: int\n        \"\"\"\n        M, p = 10**9+7, 113\n        power, rolling_hash = pow(p, minSize-1, M), 0\n\n        left = 0\n        lookup, count = collections.defaultdict(int), collections.defaultdict(int)\n        for right in xrange(len(s)):\n            count[s[right]] += 1\n            if right-left+1 > minSize:\n                count[s[left]] -= 1\n                rolling_hash = (rolling_hash - ord(s[left])*power) % M\n                if count[s[left]] == 0:\n                    count.pop(s[left])\n                left += 1\n            rolling_hash = (rolling_hash*p + ord(s[right])) % M\n            if right-left+1 == minSize and len(count) <= maxLetters:\n                lookup[rolling_hash] += 1\n        return max(lookup.values() or [0])\n\n\n# Time:  O(m * n), m = 26\n# Space: O(m * n)\nclass Solution2(object):\n    def maxFreq(self, s, maxLetters, minSize, maxSize):\n        \"\"\"\n        :type s: str\n        :type maxLetters: int\n        :type minSize: int\n        :type maxSize: int\n        :rtype: int\n        \"\"\"\n        lookup = {}\n        for right in xrange(minSize-1, len(s)):\n            word = s[right-minSize+1:right+1]\n            if word in lookup:\n                lookup[word] += 1\n            elif len(collections.Counter(word)) <= maxLetters:\n                lookup[word] = 1\n        return max(lookup.values() or [0])\n"
    },
    {
        "problem_name": "maximum-number-of-ones",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def maximumNumberOfOnes(self, width, height, sideLength, maxOnes):\n        \"\"\"\n        :type width: int\n        :type height: int\n        :type sideLength: int\n        :type maxOnes: int\n        :rtype: int\n        \"\"\"\n        if width < height:\n            width, height = height, width\n\n        # 1. split matrix by SxS tiles\n        # 2. split each SxS tile into four parts\n        #    (r, c), (r, S-c), (S-r, c), (S-r, S-c)\n        # 3. for each count of tile part in matrix is\n        #    (R+1)*(C+1), (R+1)*C, R*(C+1), R*C (already in descending order)\n        # 4. fill one into matrix by tile part of which count is in descending order\n        #    until number of ones in a tile comes to maxOnes\n        # \n        # ps. area of a tile and its count in matrix are as follows:\n        #\n        #  |<---- c ---->|<-- S-c -->|\n        #  ^             |           |\n        #  |             |           |\n        #  r (R+1)*(C+1) |  (R+1)*C  |\n        #  |             |           |\n        #  v             |           |\n        #  ---------------------------\n        #  ^             |           |\n        #  |             |           |\n        #  S-r  R*(C+1)  |   R*C     |\n        #  |             |           |\n        #  v             |           |\n        #  ---------------------------\n        #\n\n        R, r = divmod(height, sideLength)\n        C, c = divmod(width, sideLength)\n        assert(R <= C)\n        area_counts = [(r*c, (R+1)*(C+1)), \\\n                       (r*(sideLength-c), (R+1)*C), \\\n                       ((sideLength-r)*c, R*(C+1)), \\\n                       ((sideLength-r)*(sideLength-c), R*C)]\n        result = 0\n        for area, count in area_counts:\n            area = min(maxOnes, area)\n            result += count*area\n            maxOnes -= area\n            if not maxOnes:\n                break\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-operations-with-the-same-score-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def maxOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 1\n        target = nums[0]+nums[1]\n        for i in xrange(2, len(nums)-1, 2):\n            if nums[i]+nums[i+1] != target:\n                break\n            result += 1\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-operations-with-the-same-score-ii",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\n# memoization\nclass Solution(object):\n    def maxOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def memoization(left, right, target, lookup):\n            if not right-left+1 >= 2:\n                return 0\n            if lookup[left][right] == -1:\n                lookup[left][right] = max(1+memoization(left+2, right-0, target, lookup) if nums[left]+nums[left+1]   == target else 0,\n                                          1+memoization(left+1, right-1, target, lookup) if nums[left]+nums[right]    == target else 0,\n                                          1+memoization(left+0, right-2, target, lookup) if nums[right-1]+nums[right] == target else 0)\n            return lookup[left][right] \n\n        return max(memoization(0, len(nums)-1, target, [[-1]*(len(nums)) for _ in xrange(len(nums))]) for target in {nums[0]+nums[1], nums[0]+nums[-1], nums[-2]+nums[-1]})\n"
    },
    {
        "problem_name": "maximum-number-of-pairs-in-array",
        "solution": "# Time:  O(n)\n# Space: O(r), r = max(nums)\n\n# freq table\nclass Solution(object):\n    def numberOfPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        cnt = [0]*(max(nums)+1)\n        pair_cnt = 0\n        for x in nums:\n            cnt[x] ^= 1\n            if not cnt[x]:\n                pair_cnt += 1\n        return [pair_cnt, len(nums)-2*pair_cnt]\n\n\n# Time:  O(n)\n# Space: O(r), r = max(nums)\nimport collections\n\n\n# freq table\nclass Solution2(object):\n    def numberOfPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        cnt = collections.Counter(nums);\n        pair_cnt = sum(x//2 for x in cnt.itervalues())\n        return [pair_cnt, len(nums)-2*pair_cnt]\n"
    },
    {
        "problem_name": "maximum-number-of-people-that-can-be-caught-in-tag",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy with two pointers solution\nclass Solution(object):\n    def catchMaximumAmountofPeople(self, team, dist):\n        \"\"\"\n        :type team: List[int]\n        :type dist: int\n        :rtype: int\n        \"\"\"\n        result = i = j = 0\n        while i < len(team) and j < len(team):\n            if i+dist < j or team[i] != 1:\n                i += 1\n            elif j+dist < i or team[j] != 0:\n                j += 1\n            else:\n                result += 1\n                i += 1\n                j += 1\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\n# greedy with sliding window solution\nclass Solution2(object):\n    def catchMaximumAmountofPeople(self, team, dist):\n        \"\"\"\n        :type team: List[int]\n        :type dist: int\n        :rtype: int\n        \"\"\"\n        result = j = 0\n        for i in xrange(len(team)):\n            if not team[i]:\n                continue\n            while j < i-dist:\n                j += 1\n            while j <= min(i+dist, len(team)-1):\n                if team[j] == 0:\n                    break\n                j += 1\n            if j <= min(i+dist, len(team)-1):\n                result += 1\n                j += 1\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-points-from-grid-queries",
        "solution": "# Time:  O((m * n + q) * log(m * n))\n# Space: O(m * n)\n\nimport heapq\n\n\n# bfs, heap, prefix sum, binary search\nclass Solution(object):\n    def maxPoints(self, grid, queries):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        min_heap = [(grid[0][0], 0, 0)]\n        lookup = [[False]*len(grid[0]) for _ in xrange(len(grid))]\n        lookup[0][0] = True\n        mx = 0\n        cnt = collections.Counter()\n        while min_heap:\n            curr, i, j = heapq.heappop(min_heap)\n            mx = max(mx, curr)\n            cnt[mx] += 1\n            for di, dj in directions:\n                ni, nj = i+di, j+dj\n                if not (0 <= ni < len(grid) and\n                        0 <= nj < len(grid[0]) and\n                        not lookup[ni][nj]):\n                    continue\n                lookup[ni][nj] = True\n                heapq.heappush(min_heap, (grid[ni][nj], ni, nj))\n        vals = sorted(cnt.iterkeys())\n        prefix = [0]*(len(vals)+1)\n        for i in xrange(len(vals)):\n            prefix[i+1] += prefix[i]+cnt[vals[i]]\n        return map(lambda x: prefix[bisect.bisect_left(vals, x)], queries)\n"
    },
    {
        "problem_name": "maximum-number-of-points-with-cost",
        "solution": "# Time:  O(m * n)\n# Space: O(n)\n\nclass Solution(object):\n    def maxPoints(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = points[0]\n        for i in xrange(1, len(points)):\n            prefix = [0]*len(points[i])\n            prefix[0] = dp[0]\n            for j in xrange(1, len(points[i])):\n                prefix[j] = max(prefix[j-1], dp[j]+j)\n            suffix = [0]*len(points[i])\n            suffix[-1] = dp[-1]-(len(points[i])-1)\n            for j in reversed(xrange(len(points[i])-1)):\n                suffix[j] = max(suffix[j+1], dp[j]-j)\n            new_dp = [0]*len(points[i])\n            for j in xrange(len(points[i])):\n                new_dp[j] = max(prefix[j]-j, suffix[j]+j)+points[i][j]\n            dp = new_dp\n        return max(dp)\n"
    },
    {
        "problem_name": "maximum-number-of-potholes-that-can-be-fixed",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# counting sort, greedy\nclass Solution(object):\n    def maxPotholes(self, road, budget):\n        \"\"\"\n        :type road: str\n        :type budget: int\n        :rtype: int\n        \"\"\"\n        def inplace_counting_sort(nums, reverse=False):  # Time: O(n)\n            if not nums:\n                return\n            count = [0]*(max(nums)+1)\n            for num in nums:\n                count[num] += 1\n            for i in xrange(1, len(count)):\n                count[i] += count[i-1]\n            for i in reversed(xrange(len(nums))):  # inplace but unstable sort\n                while nums[i] >= 0:\n                    count[nums[i]] -= 1\n                    j = count[nums[i]]\n                    nums[i], nums[j] = nums[j], ~nums[i]\n            for i in xrange(len(nums)):\n                nums[i] = ~nums[i]  # restore values\n            if reverse:  # unstable sort\n                nums.reverse()\n    \n        ls = []\n        l = 0\n        for i in xrange(len(road)):\n            l += 1\n            if i+1 == len(road) or road[i+1] != road[i]:\n                if road[i] == 'x':\n                    ls.append(l)\n                l = 0\n        inplace_counting_sort(ls)\n        result = 0\n        for l in reversed(ls):\n            c = min(l+1, budget)\n            if c-1 <= 0:\n                break\n            result += c-1\n            budget -= c\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# sort, greedy\nclass Solution2(object):\n    def maxPotholes(self, road, budget):\n        \"\"\"\n        :type road: str\n        :type budget: int\n        :rtype: int\n        \"\"\"\n        ls = []\n        l = 0\n        for i in xrange(len(road)):\n            l += 1\n            if i+1 == len(road) or road[i+1] != road[i]:\n                if road[i] == 'x':\n                    ls.append(l)\n                l = 0\n        ls.sort()\n        result = 0\n        for l in reversed(ls):\n            c = min(l+1, budget)\n            if c-1 <= 0:\n                break\n            result += c-1\n            budget -= c\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-removable-characters",
        "solution": "# Time:  O(rlogn)\n# Space: O(r)\n\n# if r = O(1), this is better\nclass Solution(object):\n    def maximumRemovals(self, s, p, removable):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :type removable: List[int]\n        :rtype: int\n        \"\"\"\n        def check(s, p, removable, x):\n            lookup = set(removable[i] for i in xrange(x))\n            j = 0\n            for i in xrange(len(s)):\n                if i in lookup or s[i] != p[j]:\n                    continue\n                j += 1\n                if j == len(p):\n                    return True\n            return False\n\n        left, right = 0, len(removable)\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(s, p, removable, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n\n\n# Time:  O(rlogn)\n# Space: O(n)\n# if r = O(n), this is better\nclass Solution2(object):\n    def maximumRemovals(self, s, p, removable):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :type removable: List[int]\n        :rtype: int\n        \"\"\"\n        def check(s, p, lookup, x):\n            j = 0\n            for i in xrange(len(s)):\n                if lookup[i] <= x or s[i] != p[j]:\n                    continue\n                j += 1\n                if j == len(p):\n                    return True\n            return False\n\n        lookup = [float(\"inf\")]*len(s)\n        for i, r in enumerate(removable):\n            lookup[r] = i+1\n        left, right = 0, len(removable)\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(s, p, lookup, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "maximum-number-of-removal-queries-that-can-be-processed-i",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\n# dp\nclass Solution(object):\n    def maximumProcessableQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [[float(\"-inf\")]*len(nums) for _ in xrange(len(nums))]\n        dp[0][-1] = 0\n        for l in reversed(xrange(1, len(nums))):\n            for i in xrange(len(nums)-(l-1)):\n                j = i+(l-1)\n                if i-1 >= 0:\n                    dp[i][j] = max(dp[i][j], dp[i-1][j]+(1 if nums[i-1] >= queries[dp[i-1][j]] else 0))\n                if j+1 < len(nums):\n                    dp[i][j] = max(dp[i][j], dp[i][j+1]+(1 if nums[j+1] >= queries[dp[i][j+1]] else 0))\n                if dp[i][j] == len(queries):\n                    return len(queries)\n        return max(dp[i][i]+(1 if nums[i] >= queries[dp[i][i]] else 0) for i in xrange(len(nums)))\n"
    },
    {
        "problem_name": "maximum-number-of-robots-within-budget",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# sliding window, two pointers, mono deque\nclass Solution(object):\n    def maximumRobots(self, chargeTimes, runningCosts, budget):\n        \"\"\"\n        :type chargeTimes: List[int]\n        :type runningCosts: List[int]\n        :type budget: int\n        :rtype: int\n        \"\"\"\n        result = left = curr = 0\n        dq = collections.deque()\n        for right in xrange(len(chargeTimes)):\n            while dq and chargeTimes[dq[-1]] <= chargeTimes[right]:\n                dq.pop()\n            dq.append(right)\n            curr += runningCosts[right]\n            if chargeTimes[dq[0]]+(right-left+1)*curr > budget:\n                if dq[0] == left:\n                    dq.popleft()\n                curr -= runningCosts[left]\n                left += 1\n        return right-left+1\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\n# sliding window, two pointers, mono deque\nclass Solution2(object):\n    def maximumRobots(self, chargeTimes, runningCosts, budget):\n        \"\"\"\n        :type chargeTimes: List[int]\n        :type runningCosts: List[int]\n        :type budget: int\n        :rtype: int\n        \"\"\"\n        result = left = curr = 0\n        dq = collections.deque()\n        for right in xrange(len(chargeTimes)):\n            while dq and chargeTimes[dq[-1]] <= chargeTimes[right]:\n                dq.pop()\n            dq.append(right)\n            curr += runningCosts[right]\n            while dq and chargeTimes[dq[0]]+(right-left+1)*curr > budget:\n                if dq[0] == left:\n                    dq.popleft()\n                curr -= runningCosts[left]\n                left += 1\n            result = max(result, right-left+1)            \n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-tasks-you-can-assign",
        "solution": "# Time:  O(n * (logn)^2)\n# Space: O(n)\n\nfrom sortedcontainers import SortedList\n\n\nclass Solution(object):\n    def maxTaskAssign(self, tasks, workers, pills, strength):\n        \"\"\"\n        :type tasks: List[int]\n        :type workers: List[int]\n        :type pills: int\n        :type strength: int\n        :rtype: int\n        \"\"\"\n        def check(tasks, workers, pills, strength, x):\n            t = SortedList(tasks[:x])\n            for worker in workers[-x:]:  # enumerate from the weakest worker to the strongest worker, greedily assign him to the hardest task which he can do\n                i = t.bisect_right(worker)-1\n                if i != -1:\n                    t.pop(i)\n                    continue\n                if pills:\n                    i = t.bisect_right(worker+strength)-1\n                    if i != -1:\n                        t.pop(i)\n                        pills -= 1\n                        continue\n                return False\n            return True\n\n        tasks.sort()\n        workers.sort()\n        left, right = 1, min(len(workers), len(tasks))\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(tasks, workers, pills, strength, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n\n\n# Time:  O(n * (logn)^2)\n# Space: O(n)\nfrom sortedcontainers import SortedList\n\n\nclass Solution2(object):\n    def maxTaskAssign(self, tasks, workers, pills, strength):\n        \"\"\"\n        :type tasks: List[int]\n        :type workers: List[int]\n        :type pills: int\n        :type strength: int\n        :rtype: int\n        \"\"\"\n        def check(tasks, workers, pills, strength, x):\n            w = SortedList(workers[-x:])\n            for task in tasks[-x:]:  # enumerate from the hardest task to the easiest task, greedily assign it to the weakest worker whom it can be done by\n                i = w.bisect_left(task)\n                if i != len(w):\n                    w.pop(i)\n                    continue\n                if pills:\n                    i = w.bisect_left(task-strength)\n                    if i != len(w):\n                        w.pop(i)\n                        pills -= 1\n                        continue\n                return False\n            return True\n\n        tasks.sort(reverse=True)\n        workers.sort()\n        left, right = 1, min(len(workers), len(tasks))\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(tasks, workers, pills, strength, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n\n\n# Time:  O(n^2 * logn)\n# Space: O(n)\nimport bisect\n\n\nclass Solution3(object):\n    def maxTaskAssign(self, tasks, workers, pills, strength):\n        \"\"\"\n        :type tasks: List[int]\n        :type workers: List[int]\n        :type pills: int\n        :type strength: int\n        :rtype: int\n        \"\"\"\n        def check(tasks, workers, pills, strength, x):\n            t = tasks[:x]\n            for worker in workers[-x:]:  # enumerate from the weakest worker to the strongest worker, greedily assign him to the hardest task which he can do\n                i = bisect.bisect_right(t, worker)-1\n                if i != -1:\n                    t.pop(i)\n                    continue\n                if pills:\n                    i = bisect.bisect_right(t, worker+strength)-1\n                    if i != -1:\n                        t.pop(i)\n                        pills -= 1\n                        continue\n                return False\n            return True\n\n        tasks.sort()\n        workers.sort()\n        left, right = 1, min(len(workers), len(tasks))\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(tasks, workers, pills, strength, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n\n\n# Time:  O(n^2 * logn)\n# Space: O(n)\nimport bisect\n\n\nclass Solution4(object):\n    def maxTaskAssign(self, tasks, workers, pills, strength):\n        \"\"\"\n        :type tasks: List[int]\n        :type workers: List[int]\n        :type pills: int\n        :type strength: int\n        :rtype: int\n        \"\"\"\n        def check(tasks, workers, pills, strength, x):\n            w = workers[-x:]\n            for task in tasks[-x:]:  # enumerate from the hardest task to the easiest task, greedily assign it to the weakest worker whom it can be done by\n                i = bisect.bisect_left(w, task)\n                if i != len(w):\n                    w.pop(i)\n                    continue\n                if pills:\n                    i = bisect.bisect_left(w, task-strength)\n                    if i != len(w):\n                        w.pop(i)\n                        pills -= 1\n                        continue\n                return False\n            return True\n\n        tasks.sort(reverse=True)\n        workers.sort()\n        left, right = 1, min(len(workers), len(tasks))\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(tasks, workers, pills, strength, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "maximum-number-of-upgradable-servers",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\n# math\nclass Solution(object):\n    def maxUpgrades(self, count, upgrade, sell, money):\n        \"\"\"\n        :type count: List[int]\n        :type upgrade: List[int]\n        :type sell: List[int]\n        :type money: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # let x be the number of sold servers\n        # (c-x)*u <= m+(x*s)\n        # -x <= (m-c*u)//(u+s) <= 0\n        # c-x <= c+(m-c*u)//(u+s) <= c\n        return [min(c+(m-c*u)//(u+s), c) for c, u, s, m in itertools.izip(count, upgrade, sell, money)]\n"
    },
    {
        "problem_name": "maximum-number-of-visible-points",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport math\n\n\nclass Solution(object):\n    def visiblePoints(self, points, angle, location):\n        \"\"\"\n        :type points: List[List[int]]\n        :type angle: int\n        :type location: List[int]\n        :rtype: int\n        \"\"\"\n        arr, extra = [], 0\n        for p in points:\n            if p == location:\n                extra += 1\n                continue\n            arr.append(math.atan2(p[1]-location[1], p[0]-location[0]))\n        arr.sort()\n        arr.extend([x + 2.0*math.pi for x in arr])  # make it circular\n        d = 2.0*math.pi * (angle/360.0)\n        left = result = 0\n        for right in xrange(len(arr)):\n            while arr[right]-arr[left] > d:\n                left += 1\n            result = max(result, right-left+1)\n        return result + extra\n"
    },
    {
        "problem_name": "maximum-number-of-vowels-in-a-substring-of-given-length",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxVowels(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        VOWELS = set(\"aeiou\")\n        result = curr = 0\n        for i, c in enumerate(s):\n            curr += c in VOWELS\n            if i >= k:\n                curr -= s[i-k] in VOWELS\n            result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-ways-to-partition-an-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def waysToPartition(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        total = sum(nums)\n        right = collections.Counter()\n        prefix = 0\n        for i in xrange(len(nums)-1):\n            prefix += nums[i]\n            right[prefix-(total-prefix)] += 1\n        result = right[0]\n        left = collections.Counter()\n        prefix = 0\n        for x in nums:\n            result = max(result, left[k-x]+right[-(k-x)])\n            prefix += x\n            left[prefix-(total-prefix)] += 1\n            right[prefix-(total-prefix)] -= 1\n        return result\n"
    },
    {
        "problem_name": "maximum-number-of-weeks-for-which-you-can-work",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfWeeks(self, milestones):\n        \"\"\"\n        :type milestones: List[int]\n        :rtype: int\n        \"\"\"\n        total, max_num = sum(milestones), max(milestones)\n        other_total = (total-max_num)\n        return other_total+min(other_total+1, max_num)\n"
    },
    {
        "problem_name": "maximum-number-of-words-found-in-sentences",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def mostWordsFound(self, sentences):\n        \"\"\"\n        :type sentences: List[str]\n        :rtype: int\n        \"\"\"\n        return 1+max(s.count(' ') for s in sentences)\n"
    },
    {
        "problem_name": "maximum-number-of-words-you-can-type",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def canBeTypedWords(self, text, brokenLetters):\n        \"\"\"\n        :type text: str\n        :type brokenLetters: str\n        :rtype: int\n        \"\"\"\n        lookup = set(brokenLetters)\n        result, broken = 0, False\n        for c in text:\n            if c == ' ':\n                result += int(broken == False)\n                broken = False\n            elif c in lookup:\n                broken = True\n        return result + int(broken == False)\n"
    },
    {
        "problem_name": "maximum-number-that-makes-result-of-bitwise-and-zero",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def maxNumber(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return (1<<(n.bit_length()-1))-1\n"
    },
    {
        "problem_name": "maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k",
        "solution": "# Time:  O(max(logk, x) * log((logk) / x))\n# Space: O((logk) / x)\n\n# bit manipulation, binary search, combinatorics\nclass Solution(object):\n    def findMaximumNumber(self, k, x):\n        \"\"\"\n        :type k: int\n        :type x: int\n        :rtype: int\n        \"\"\"\n        def floor_log2(x):\n            return x.bit_length()-1\n\n        def binary_search_right(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if not check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return right\n    \n        def count(l):\n            return (prefix_cnt<<(x*l))+lookup[l]\n\n        result = prefix_cnt = 0\n        lookup = [0]\n        i = 0\n        while (lookup[-1]<<x)+(1<<(i+x-1)) <= k:\n            lookup.append((lookup[-1]<<x)+(1<<(i+x-1)))\n            i += x\n        while k >= prefix_cnt:\n            # l = result.bit_length()\n            # assert(prefix_cnt == sum(c == '1' and (l-i)%x == 0 for i, c in enumerate(bin(result)[2:])))\n            l = binary_search_right(1, len(lookup)-1, lambda l: count(l) <= k)\n            cnt, i = count(l), x*l\n            c = min(floor_log2(k//cnt) if cnt else float(\"inf\"), x-1)\n            cnt <<= c\n            i += c\n            k -= cnt\n            result += 1<<i\n            prefix_cnt += int((i+1)%x == 0)\n        return result-1\n\n\n# Time:  O(max(logk, x) * (max(logk, x) / x))\n# Space: O(1)\n# bit manipulation, combinatorics\nclass Solution2(object):\n    def findMaximumNumber(self, k, x):\n        \"\"\"\n        :type k: int\n        :type x: int\n        :rtype: int\n        \"\"\"\n        def floor_log2(x):\n            return x.bit_length()-1\n\n        result = prefix_cnt = 0\n        while k >= prefix_cnt:\n            # l = result.bit_length()\n            # assert(prefix_cnt == sum(c == '1' and (l-i)%x == 0 for i, c in enumerate(bin(result)[2:])))\n            cnt, i = prefix_cnt, 0\n            while (cnt<<x)+(1<<(i+x-1)) <= k:\n                cnt = (cnt<<x)+(1<<(i+x-1))\n                i += x\n            c = min(floor_log2(k//cnt) if cnt else float(\"inf\"), x-1)\n            cnt <<= c\n            i += c\n            k -= cnt\n            result += 1<<i\n            prefix_cnt += int((i+1)%x == 0)\n        return result-1\n\n\n# Time:  O(max(logk, x)^2)\n# Space: O(1)\n# bit manipulation, combinatorics\nclass Solution3(object):\n    def findMaximumNumber(self, k, x):\n        \"\"\"\n        :type k: int\n        :type x: int\n        :rtype: int\n        \"\"\"\n        def floor_log2(x):\n            return x.bit_length()-1\n\n        result = prefix_cnt = 0\n        while k >= prefix_cnt:\n            # l = result.bit_length()\n            # assert(prefix_cnt == sum(c == '1' and (l-i)%x == 0 for i, c in enumerate(bin(result)[2:])))\n            cnt, i = prefix_cnt, 0\n            while (cnt<<1)+(1<<i if (i+1)%x == 0 else 0) <= k:\n                cnt = (cnt<<1)+(1<<i if (i+1)%x == 0 else 0)\n                i += 1\n            k -= cnt\n            result += 1<<i\n            prefix_cnt += int((i+1)%x == 0)\n        return result-1\n\n\n# Time:  O(max(logk, x) * (max(logk, x) / x))\n# Space: O(1)\n# bit manipulation, binary search, combinatorics\nclass Solution4(object):\n    def findMaximumNumber(self, k, x):\n        \"\"\"\n        :type k: int\n        :type x: int\n        :rtype: int\n        \"\"\"\n        def binary_search_right(left, right, check):\n            while left <= right:\n                mid = left+(right-left)//2\n                if not check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return right\n\n        def count(v):\n            cnt = i = 0\n            while 1<<(i+x-1) <= v:\n                q, r = divmod(v+1, 1<<((i+x-1)+1))\n                cnt += q*1*(1<<(i+x-1))+max(r-1*(1<<(i+x-1)), 0)\n                i += x\n            return cnt\n\n        return binary_search_right(1, max(k<<2, 1<<x), lambda v: count(v) <= k)  # right bound is verified by checking all possible (k, v) values, or just set right = solution.findMaximumNumber(10**15, 8) <= 10**15\n"
    },
    {
        "problem_name": "maximum-odd-binary-number",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy, partition\nclass Solution(object):\n    def maximumOddBinaryNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        a = list(s)\n        left = 0\n        for i in xrange(len(a)):\n            if a[i] != '1':\n                continue\n            a[i], a[left] = a[left], a[i]\n            left += 1\n        if a[-1] != '1':\n            a[-1], a[left-1] = a[left-1], a[-1]\n        return \"\".join(a)\n\n\n# Time:  O(n)\n# Space: O(1)\n# greedy\nclass Solution2(object):\n    def maximumOddBinaryNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        n = s.count('1')\n        return \"\".join(['1']*(n-1)+['0']*(len(s)-n)+['1'])\n"
    },
    {
        "problem_name": "maximum-of-absolute-value-expression",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxAbsValExpr(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: int\n        \"\"\"\n        # 1. max(|arr1[i]-arr1[j]| + |arr2[i]-arr2[j]| + |i-j| for i > j)\n        #    = max(|arr1[i]-arr1[j]| + |arr2[i]-arr2[j]| + |i-j| for j > i)\n        # 2. for i > j:\n        #        (|arr1[i]-arr1[j]| + |arr2[i]-arr2[j]| + |i-j|)\n        #        >= c1*(arr1[i]-arr1[j]) + c2*(arr2[i]-arr2[j]) + i-j for c1 in (1, -1), c2 in (1, -1)\n        #        = (c1*arr1[i]+c2*arr2[i]+i) - (c1*arr1[j]+c2*arr2[j]+j) for c1 in (1, -1), c2 in (1, -1)\n        # 1 + 2 => max(|arr1[i]-arr1[j]| + |arr2[i]-arr2[j]| + |i-j| for i != j)\n        #          = max((c1*arr1[i]+c2*arr2[i]+i) - (c1*arr1[j]+c2*arr2[j]+j)\n        #                for c1 in (1, -1), c2 in (1, -1) for i > j)\n        result = 0\n        for c1 in [1, -1]:\n            for c2 in [1, -1]:\n                min_prev = float(\"inf\")\n                for i in xrange(len(arr1)):\n                    curr = c1*arr1[i] + c2*arr2[i] + i\n                    result = max(result, curr-min_prev)\n                    min_prev = min(min_prev, curr)\n        return result\n\n    \n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def maxAbsValExpr(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: int\n        \"\"\"\n        return max(max(c1*arr1[i] + c2*arr2[i] + i for i in xrange(len(arr1))) -\n                   min(c1*arr1[i] + c2*arr2[i] + i for i in xrange(len(arr1)))\n                   for c1 in [1, -1] for c2 in [1, -1])\n"
    },
    {
        "problem_name": "maximum-of-minimum-values-in-all-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def findMaximums(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def find_bound(nums, direction, init):\n            result = [0]*len(nums)\n            stk = [init]\n            for i in direction(xrange(len(nums))):\n                while stk[-1] != init and nums[stk[-1]] >= nums[i]:\n                    stk.pop()\n                result[i] = stk[-1]\n                stk.append(i)\n            return result\n\n        left = find_bound(nums, lambda x: x, -1)\n        right = find_bound(nums, reversed, len(nums))\n        result = [-1]*len(nums)\n        for i, v in enumerate(nums):\n            result[((right[i]-1)-left[i])-1] = max(result[((right[i]-1)-left[i])-1], v)\n        for i in reversed(xrange(len(nums)-1)):\n            result[i] = max(result[i], result[i+1])\n        return result\n"
    },
    {
        "problem_name": "maximum-or",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# prefix sum, greedy\nclass Solution(object):\n    def maximumOr(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        right = [0]*(len(nums)+1)\n        for i in reversed(xrange(len(nums))):\n            right[i] = right[i+1]|nums[i]\n        result = left = 0\n        for i in xrange(len(nums)):\n            result = max(result, left|(nums[i]<<k)|right[i+1])\n            left |= nums[i]\n        return result\n"
    },
    {
        "problem_name": "maximum-palindromes-after-operations",
        "solution": "# Time:  O(n * l + nlogn)\n# Space: O(n)\n\n# freq table, greedy, sort\nclass Solution(object):\n    def maxPalindromesAfterOperations(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        cnt = [0]*26\n        for w in words:\n            for c in w:\n                cnt[ord(c)-ord('a')] += 1\n        curr = sum(x//2 for x in cnt)\n        for i, l in enumerate(sorted(map(len, words))):\n            curr -= l//2\n            if curr < 0:\n                return i\n        return len(words)\n"
    },
    {
        "problem_name": "maximum-path-quality-of-a-graph",
        "solution": "# Time: O(|V| + |E| + 4^(maxTime/min(times))) = O(|V| + |E| + 4^10)\n# Time: O(|V| + |E|)\n\nclass Solution(object):\n    def maximalPathQuality(self, values, edges, maxTime):\n        \"\"\"\n        :type values: List[int]\n        :type edges: List[List[int]]\n        :type maxTime: int\n        :rtype: int\n        \"\"\"\n        def iter_dfs(values, adj, maxTime):\n            lookup, lookup2 = [0]*len(adj), set()\n            result = 0\n            stk = [(1, (0, maxTime, 0))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    u, time, total = args\n                    lookup[u] += 1\n                    if lookup[u] == 1:\n                        total += values[u]\n                    if not u:\n                        result = max(result, total)\n                    stk.append((4, (u,)))\n                    for v, t in reversed(adj[u]):\n                        if (u, v) in lookup2 or time < t:  # same directed edge won't be visited twice\n                            continue\n                        stk.append((3, (u, v)))\n                        stk.append((1, (v, time-t, total)))\n                        stk.append((2, (u, v)))\n                elif step == 2:\n                    u, v = args\n                    lookup2.add((u, v))\n                elif step == 3:\n                    u, v = args\n                    lookup2.remove((u, v))\n                elif step == 4:\n                    u = args[0]\n                    lookup[u] -= 1\n            return result\n\n        adj = [[] for _ in xrange(len(values))]\n        for u, v, t in edges:\n            adj[u].append((v, t))\n            adj[v].append((u, t))\n        return iter_dfs(values, adj, maxTime)\n\n\n# Time: O(|V| + |E| + 4^(maxTime/min(times))) = O(|V| + |E| + 4^10)\n# Time: O(|V| + |E|)\nclass Solution2(object):\n    def maximalPathQuality(self, values, edges, maxTime):\n        \"\"\"\n        :type values: List[int]\n        :type edges: List[List[int]]\n        :type maxTime: int\n        :rtype: int\n        \"\"\"\n        def dfs(values, adj, u, time, total, lookup, lookup2, result):\n            lookup[u] += 1\n            if lookup[u] == 1:\n                total += values[u]\n            if not u:\n                result[0] = max(result[0], total)\n            for v, t in adj[u]:\n                if (u, v) in lookup2 or time < t:  # same directed edge won't be visited twice\n                    continue\n                lookup2.add((u, v))\n                dfs(values, adj, v, time-t, total, lookup, lookup2, result)\n                lookup2.remove((u, v))\n            lookup[u] -= 1\n\n        adj = [[] for _ in xrange(len(values))]\n        for u, v, t in edges:\n            adj[u].append((v, t))\n            adj[v].append((u, t))\n        result = [0]\n        dfs(values, adj, 0, maxTime, 0, [0]*len(adj), set(), result)\n        return result[0]\n\n\n# Time: O(|V| + |E| + 4^(maxTime/min(times))) = O(|V| + |E| + 4^10)\n# Time: O(|V| + |E|)\nclass Solution3(object):\n    def maximalPathQuality(self, values, edges, maxTime):\n        \"\"\"\n        :type values: List[int]\n        :type edges: List[List[int]]\n        :type maxTime: int\n        :rtype: int\n        \"\"\"\n        def dfs(values, adj, u, time, total, lookup, lookup2):\n            lookup[u] += 1\n            if lookup[u] == 1:\n                total += values[u]\n            result = total if not u else 0\n            for v, t in adj[u]:\n                if (u, v) in lookup2 or time < t:  # same directed edge won't be visited twice\n                    continue\n                lookup2.add((u, v))\n                result = max(result, dfs(values, adj, v, time-t, total, lookup, lookup2))\n                lookup2.remove((u, v))\n            lookup[u] -= 1\n            return result\n\n        adj = [[] for _ in xrange(len(values))]\n        for u, v, t in edges:\n            adj[u].append((v, t))\n            adj[v].append((u, t))\n        return dfs(values, adj, 0, maxTime, 0, [0]*len(adj), set())\n"
    },
    {
        "problem_name": "maximum-performance-of-a-team",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport itertools\nimport heapq\n\n\nclass Solution(object):\n    def maxPerformance(self, n, speed, efficiency, k):\n        \"\"\"\n        :type n: int\n        :type speed: List[int]\n        :type efficiency: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        result, s_sum = 0, 0\n        min_heap = []\n        for e, s in sorted(itertools.izip(efficiency, speed), reverse=True):\n            s_sum += s\n            heapq.heappush(min_heap, s)\n            if len(min_heap) > k:\n                s_sum -= heapq.heappop(min_heap)\n            result = max(result, s_sum*e)\n        return result % MOD\n"
    },
    {
        "problem_name": "maximum-points-after-collecting-coins-from-all-nodes",
        "solution": "# Time:  O(nlogr), r = max(coins)\n# Space: O(n)\n\n# dfs, bitmasks, pruning\nclass Solution(object):\n    def maximumPoints(self, edges, coins, k):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type coins: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        def dfs(u, p, base):\n            if base >= max_base:\n                return 0\n            if lookup[u]&base:  # we prefer the first way to the second way, so the visited state cannot improve the current chosen ways\n                return NEG_INF\n            lookup[u] |= base\n            return max(((coins[u]//base)-k)+sum(dfs(v, u, base) for v in adj[u] if v != p),\n                        (coins[u]//(base<<1))+sum(dfs(v, u, base<<1) for v in adj[u] if v != p) if (coins[u]//base)-k < coins[u]//(base*2) else NEG_INF)  #  if (coins[u]//base)-k >= coins[u]//(base*2), the first way is always better\n\n        adj = [[] for _ in xrange(len(coins))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        max_base = 1<<max(coins).bit_length()\n        lookup = [0]*len(coins)\n        return dfs(0, -1, 1)\n\n\n# Time:  O(nlogr), r = max(coins)\n# Space: O(nlogr)\n# tree dp, memoization\nclass Solution2(object):\n    def maximumPoints(self, edges, coins, k):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type coins: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def memoization(u, p, d):\n            if d >= max_d:\n                return 0\n            if lookup[u][d] is None:\n                lookup[u][d] = max(((coins[u]>>d)-k)+sum(memoization(v, u, d) for v in adj[u] if v != p),\n                                    (coins[u]>>(d+1))+sum(memoization(v, u, d+1) for v in adj[u] if v != p))\n            return lookup[u][d]\n\n        adj = [[] for _ in xrange(len(coins))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        max_d = max(coins).bit_length()\n        lookup = [[None]*max_d for _ in xrange(len(coins))]\n        return memoization(0, -1, 0)\n"
    },
    {
        "problem_name": "maximum-points-in-an-archery-competition",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(n)\n\n# bitmasks\nclass Solution(object):\n    def maximumBobPoints(self, numArrows, aliceArrows):\n        \"\"\"\n        :type numArrows: int\n        :type aliceArrows: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def check(mask, numArrows):\n            score = 0\n            cnt = [0]*len(aliceArrows)\n            i, base = 0, 1\n            for k, a in enumerate(aliceArrows):\n                if mask&1:\n                    need = a+1\n                    if need > numArrows:\n                        return 0, [0]*len(aliceArrows)\n                    numArrows -= need\n                    cnt[k] = need\n                    score += k\n                mask >>= 1\n            cnt[-1] += numArrows\n            return score, cnt\n        \n        result = [0]*len(aliceArrows)\n        best = 0\n        for mask in xrange(1, 2**len(aliceArrows)):\n            score, cnt = check(mask, numArrows)\n            if score > best:\n                best = score\n                result = cnt\n        return result\n"
    },
    {
        "problem_name": "maximum-points-inside-the-square",
        "solution": "# Time:  O(n + 26)\n# Space: O(26)\n\nimport itertools\n\n\n# hash table\nclass Solution(object):\n    def maxPointsInsideSquare(self, points, s):\n        \"\"\"\n        :type points: List[List[int]]\n        :type s: str\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        lookup = [INF for _ in xrange(26)]\n        d = INF\n        for c, (x, y) in itertools.izip(s, points):\n            k = ord(c)-ord('a')\n            mn2 = max(abs(x), abs(y))\n            if mn2 < lookup[k]:\n                mn2, lookup[k] = lookup[k], mn2\n            d = min(d, mn2)\n        return sum(mn1 < d for mn1 in lookup)\n"
    },
    {
        "problem_name": "maximum-points-you-can-obtain-from-cards",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxScore(self, cardPoints, k):\n        \"\"\"\n        :type cardPoints: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result, total, curr, left = float(\"inf\"), 0, 0, 0\n        for right, point in enumerate(cardPoints):\n            total += point\n            curr += point\n            if right-left+1 > len(cardPoints)-k:\n                curr -= cardPoints[left]\n                left += 1\n            if right-left+1 == len(cardPoints)-k:\n                result = min(result, curr)\n        return total-result\n"
    },
    {
        "problem_name": "maximum-population-year",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maximumPopulation(self, logs):\n        \"\"\"\n        :type logs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MIN_YEAR, MAX_YEAR = 1950, 2050\n        years = [0]*(MAX_YEAR-MIN_YEAR+1)\n        for s, e in logs:\n            years[s-MIN_YEAR] += 1\n            years[e-MIN_YEAR] -= 1\n        result = 0\n        for i in xrange(len(years)):\n            if i:\n                years[i] += years[i-1]\n            if years[i] > years[result]:\n                result = i\n        return result+MIN_YEAR\n"
    },
    {
        "problem_name": "maximum-price-to-fill-a-bag",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# greedy, sort\nclass Solution(object):\n    def maxPrice(self, items, capacity):\n        \"\"\"\n        :type items: List[List[int]]\n        :type capacity: int\n        :rtype: float\n        \"\"\"\n        result = 0\n        items.sort(key=lambda x: float(x[0])/x[1], reverse=True)\n        for p, c in items:\n            cnt = min(c, capacity)\n            capacity -= cnt\n            result += (float(p)/c)*cnt\n        return result if capacity == 0 else -1\n"
    },
    {
        "problem_name": "maximum-prime-difference",
        "solution": "# Time:  O(r + n), r = max(nums)\n# Space: O(r)\n\n# linear sieve of eratosthenes, number theory\ndef linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)\n    primes = []\n    spf = [-1]*(n+1)  # the smallest prime factor\n    for i in xrange(2, n+1):\n        if spf[i] == -1:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if i*p > n or p > spf[i]:\n                break\n            spf[i*p] = p\n    return spf\n\n\nMAX_N = 100\nSPF = linear_sieve_of_eratosthenes(MAX_N)\nclass Solution(object):\n    def maximumPrimeDifference(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left = next(i for i in xrange(len(nums)) if SPF[nums[i]] == nums[i])\n        right = next(i for i in reversed(xrange(len(nums))) if SPF[nums[i]] == nums[i])\n        return right-left\n"
    },
    {
        "problem_name": "maximum-product-after-k-increments",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# math, sort\nclass Solution(object):\n    def maximumProduct(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        nums.sort()\n        total = sum(nums)\n        for i in reversed(xrange(len(nums))):\n            if nums[i]*(i+1)-total <= k:\n                break\n            total -= nums[i]\n        q, r = divmod(k+total, i+1)\n        return (pow(q, (i+1)-r, MOD)*pow(q+1, r, MOD)*\n                reduce(lambda x, y: x*y%MOD, (nums[j] for j in xrange(i+1, len(nums))), 1)) % MOD\n\n\n# Time:  O(n + k)\n# Space: O(n)\nimport collections\n\n\n# freq table\nclass Solution2(object):\n    def maximumProduct(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        cnt = collections.Counter(nums)\n        min_num = min(cnt.iterkeys())\n        while k:\n            c = min(cnt[min_num], k)\n            cnt[min_num] -= c\n            cnt[min_num+1] += c \n            if not cnt[min_num]:\n                del cnt[min_num]\n                min_num += 1\n            k -= c\n        return reduce(lambda total, x: total*pow(x[0], x[1], MOD)%MOD, cnt.iteritems(), 1)\n\n\n# Time:  O(n + klogn)\n# Space: O(1)\nimport heapq\n\n\n# heap\nclass Solution3(object):\n    def maximumProduct(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        min_heap = nums\n        heapq.heapify(min_heap)\n        while k:\n            heapq.heappush(min_heap, heapq.heappop(min_heap)+1)\n            k -= 1\n        return reduce(lambda x, y: x*y%MOD, min_heap)\n"
    },
    {
        "problem_name": "maximum-product-difference-between-two-pairs",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxProductDifference(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        largest, smallest = [0]*2, [float(\"inf\")]*2\n        for x in nums:\n            if x >= largest[0]:\n                largest[:] = [x, largest[0]]\n            elif x > largest[1]:\n                largest[1] =x\n            if x <= smallest[0]:\n                smallest[:] = [x, smallest[0]]\n            elif x < smallest[1]:\n                smallest[1] = x\n        return largest[0]*largest[1] - smallest[0]*smallest[1]\n"
    },
    {
        "problem_name": "maximum-product-of-splitted-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def maxProduct(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        def dfs(root, total, result):\n            if not root:\n                return 0\n            subtotal = dfs(root.left, total, result)+dfs(root.right, total, result)+root.val\n            result[0] = max(result[0], subtotal*(total-subtotal) )\n            return subtotal\n\n        result = [0]\n        dfs(root, dfs(root, 0, result), result)\n        return result[0] % MOD\n"
    },
    {
        "problem_name": "maximum-product-of-the-length-of-two-palindromic-subsequences",
        "solution": "# Time:  O(3^n)\n# Space: O(2^n)\n\nclass Solution(object):\n    def maxProduct(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def palindromic_subsequence_length(s, mask):\n            result = 0\n            left, right = 0, len(s)-1\n            left_bit, right_bit = 1<<left, 1<<right\n            while left <= right:\n                if mask&left_bit == 0:\n                    left, left_bit = left+1, left_bit<<1\n                elif mask&right_bit == 0:\n                    right, right_bit = right-1, right_bit>>1\n                elif s[left] == s[right]:\n                    result += 1 if left == right else 2\n                    left, left_bit = left+1, left_bit<<1\n                    right, right_bit = right-1, right_bit>>1\n                else:\n                    return 0\n            return result\n        \n        dp = [palindromic_subsequence_length(s, mask) for mask in xrange(1<<len(s))]\n        result = 0\n        for mask in xrange(len(dp)):\n            if dp[mask]*(len(s)-dp[mask]) <= result:  # optimize\n                continue\n            # submask enumeration:\n            # => sum(nCr(n, k) * 2^k for k in xrange(n+1)) = (1 + 2)^n = 3^n\n            # => Time: O(3^n), see https://cp-algorithms.com/algebra/all-submasks.html\n            submask = inverse_mask = (len(dp)-1)^mask\n            while submask:\n                result = max(result, dp[mask]*dp[submask])\n                submask = (submask-1)&inverse_mask\n        return result\n"
    },
    {
        "problem_name": "maximum-product-of-the-length-of-two-palindromic-substrings",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def maxProduct(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def manacher(s):\n            s = '^#' + '#'.join(s) + '#$'\n            P = [0]*len(s)\n            C, R = 0, 0\n            for i in xrange(1, len(s)-1):\n                i_mirror = 2*C-i\n                if R > i:\n                    P[i] = min(R-i, P[i_mirror])\n                while s[i+1+P[i]] == s[i-1-P[i]]:\n                    P[i] += 1\n                if i+P[i] > R:\n                    C, R = i, i+P[i]\n            return P\n\n        P = manacher(s)\n        q = collections.deque()\n        left = [0]\n        for i in xrange(len(s)):\n            while q and q[0][1] < i:\n                q.popleft()\n            left.append(max(left[-1], 1+2*(i-q[0][0]) if q else 1))\n            q.append((i, i+P[2*i+2]//2))\n        q = collections.deque()\n        result = right = 0\n        for i in reversed(xrange(len(s))):\n            while q and q[0][1] > i:\n                q.popleft()\n            right = max(right, 1+2*(q[0][0]-i) if q else 1)\n            q.append((i, i-P[2*i+2]//2))\n            result = max(result, left[i]*right)\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def maxProduct(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def manacher(s):\n            s = '^#' + '#'.join(s) + '#$'\n            P = [0]*len(s)\n            C, R = 0, 0\n            for i in xrange(1, len(s)-1):\n                i_mirror = 2*C-i\n                if R > i:\n                    P[i] = min(R-i, P[i_mirror])\n                while s[i+1+P[i]] == s[i-1-P[i]]:\n                    P[i] += 1\n                if i+P[i] > R:\n                    C, R = i, i+P[i]\n            return P\n\n        import operator\n        def accumulate(iterable, func=operator.add, initial=None):\n            it = iter(iterable)\n            total = initial\n            if initial is None:\n                try:\n                    total = next(it)\n                except StopIteration:\n                    return\n            yield total\n            for element in it:\n                total = func(total, element)\n                yield total\n\n        def fin_max_len(s):\n            P = manacher(s)\n            intervals = [[(i-2)//2-P[i]//2, (i-2)//2+P[i]//2] for i in xrange(2,len(P)-2, 2)]\n            dp = [0]*len(s)\n            for l, r in reversed(intervals): \n                dp[r] = r-l+1\n            for i in reversed(xrange(len(s)-1)):\n                dp[i] = max(dp[i], dp[i+1]-2)\n            return list(accumulate(dp, max, 0))\n        \n        l1, l2 = fin_max_len(s), fin_max_len(s[::-1])[::-1]\n        return max(x*y for x, y in itertools.izip(l1, l2))\n"
    },
    {
        "problem_name": "maximum-product-of-three-numbers",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maximumProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        min1, min2 = float(\"inf\"), float(\"inf\")\n        max1, max2, max3 = float(\"-inf\"), float(\"-inf\"), float(\"-inf\")\n\n        for n in nums:\n            if n <= min1:\n                min2 = min1\n                min1 = n\n            elif n <= min2:\n                min2 = n\n\n            if n >= max1:\n                max3 = max2\n                max2 = max1\n                max1 = n\n            elif n >= max2:\n                max3 = max2\n                max2 = n\n            elif n >= max3:\n                max3 = n\n\n        return max(min1 * min2 * max1, max1 * max2 * max3)\n\n"
    },
    {
        "problem_name": "maximum-product-of-two-elements-in-an-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        m1 = m2 = 0\n        for num in nums:\n            if num > m1:\n                m1, m2 = num, m1\n            elif num > m2:\n                m2 = num\n        return (m1-1)*(m2-1)\n"
    },
    {
        "problem_name": "maximum-product-of-word-lengths",
        "solution": "# Time:  O(n) ~ O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def maxProduct(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        def counting_sort(words):\n            k = 1000  # k is max length of words in the dictionary\n            buckets = [[] for _ in xrange(k)]\n            for word in words:\n                buckets[len(word)].append(word)\n            res = []\n            for i in reversed(xrange(k)):\n                if buckets[i]:\n                    res += buckets[i]\n            return res\n\n        words = counting_sort(words)\n        bits = [0] * len(words)\n        for i, word in enumerate(words):\n            for c in word:\n                bits[i] |= (1 << (ord(c) - ord('a')))\n\n        max_product = 0\n        for i in xrange(len(words) - 1):\n            if len(words[i]) ** 2 <= max_product:\n                break\n            for j in xrange(i + 1, len(words)):\n                if len(words[i]) * len(words[j]) <= max_product:\n                    break\n                if not (bits[i] & bits[j]):\n                    max_product = len(words[i]) * len(words[j])\n        return max_product\n\n# Time:  O(nlogn) ~ O(n^2)\n# Space: O(n)\n# Sorting + Pruning + Bit Manipulation\nclass Solution2(object):\n    def maxProduct(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        words.sort(key=lambda x: len(x), reverse=True)\n        bits = [0] * len(words)\n        for i, word in enumerate(words):\n            for c in word:\n                bits[i] |= (1 << (ord(c) - ord('a')))\n\n        max_product = 0\n        for i in xrange(len(words) - 1):\n            if len(words[i]) ** 2 <= max_product:\n                break\n            for j in xrange(i + 1, len(words)):\n                if len(words[i]) * len(words[j]) <= max_product:\n                    break\n                if not (bits[i] & bits[j]):\n                    max_product = len(words[i]) * len(words[j])\n        return max_product\n\n"
    },
    {
        "problem_name": "maximum-product-subarray",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param A, a list of integers\n    # @return an integer\n    def maxProduct(self, A):\n        global_max, local_max, local_min = float(\"-inf\"), 1, 1\n        for x in A:\n            local_max, local_min = max(x, local_max * x, local_min * x), min(x, local_max * x, local_min * x)\n            global_max = max(global_max, local_max)\n        return global_max\n\nclass Solution2(object):\n    # @param A, a list of integers\n    # @return an integer\n    def maxProduct(self, A):\n        global_max, local_max, local_min = float(\"-inf\"), 1, 1\n        for x in A:\n            local_max = max(1, local_max)\n            if x > 0:\n                local_max, local_min = local_max * x, local_min * x\n            else:\n                local_max, local_min = local_min * x, local_max * x\n            global_max = max(global_max, local_max)\n        return global_max\n\n"
    },
    {
        "problem_name": "maximum-profit-from-trading-stocks",
        "solution": "# Time:  O(n * b)\n# Space: O(b)\n\nimport itertools\n\n\n# dp, optimized from solution2\nclass Solution(object):\n    def maximumProfit(self, present, future, budget):\n        \"\"\"\n        :type present: List[int]\n        :type future: List[int]\n        :type budget: int\n        :rtype: int\n        \"\"\"\n        dp = [0]*(budget+1)\n        for i, (p, f) in enumerate(itertools.izip(present, future)):\n            if f-p < 0:\n                continue\n            for b in reversed(xrange(p, budget+1)):\n                dp[b] = max(dp[b], dp[b-p]+(f-p))\n        return dp[-1]\n\n\n# Time:  O(n * b)\n# Space: O(b)\nimport itertools\n\n\n# dp\nclass Solution2(object):\n    def maximumProfit(self, present, future, budget):\n        \"\"\"\n        :type present: List[int]\n        :type future: List[int]\n        :type budget: int\n        :rtype: int\n        \"\"\"\n        dp = [[0]*(budget+1) for _ in xrange(2)]\n        for i, (p, f) in enumerate(itertools.izip(present, future)):\n            for b in xrange(budget+1):\n                dp[(i+1)%2][b] = max(dp[i%2][b], (dp[i%2][b-p]+(f-p) if b-p >= 0 else 0))\n        return dp[len(present)%2][-1]\n"
    },
    {
        "problem_name": "maximum-profit-in-job-scheduling",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport itertools\nimport bisect\n\n\nclass Solution(object):\n    def jobScheduling(self, startTime, endTime, profit):\n        \"\"\"\n        :type startTime: List[int]\n        :type endTime: List[int]\n        :type profit: List[int]\n        :rtype: int\n        \"\"\"\n        jobs = sorted(itertools.izip(endTime, startTime, profit))\n        dp = [(0, 0)]\n        for e, s, p in jobs:\n            i = bisect.bisect_right(dp, (s+1, 0))-1\n            if dp[i][1]+p > dp[-1][1]:\n                dp.append((e, dp[i][1]+p))\n        return dp[-1][1]\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport heapq\nclass Solution(object):\n    def jobScheduling(self, startTime, endTime, profit):\n        \"\"\"\n        :type startTime: List[int]\n        :type endTime: List[int]\n        :type profit: List[int]\n        :rtype: int\n        \"\"\"\n        min_heap = zip(startTime, endTime, profit)\n        heapq.heapify(min_heap)\n        result = 0\n        while min_heap:\n            s, e, p = heapq.heappop(min_heap)\n            if s < e:\n                heapq.heappush(min_heap, (e, s, result+p))\n            else:\n                result = max(result, p)\n        return result\n"
    },
    {
        "problem_name": "maximum-profit-of-operating-a-centennial-wheel",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\n        \"\"\"\n        :type customers: List[int]\n        :type boardingCost: int\n        :type runningCost: int\n        :rtype: int\n        \"\"\"\n        max_run = -1\n        i = max_prof = prof = waiting = 0\n        run = 1\n        while i < len(customers) or waiting > 0:\n            if i < len(customers):\n                waiting += customers[i]  # each run i increases people by customers[i]\n                i += 1\n            boarding = min(waiting, 4)  # greedy\n            waiting -= boarding\n            prof += boarding * boardingCost - runningCost \n            if prof > max_prof:\n                max_prof = prof\n                max_run = run\n            run += 1\n        return max_run\n"
    },
    {
        "problem_name": "maximum-profitable-triplets-with-increasing-prices-i",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport itertools\nfrom sortedcontainers import SortedList\n\n\n# prefix sum, sorted list, binary search, mono stack\nclass Solution(object):\n    def maxProfit(self, prices, profits):\n        \"\"\"\n        :type prices: List[int]\n        :type profits: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        def query(sl, k):\n            j = sl.bisect_left((k,))\n            return sl[j-1][1] if j-1 >= 0 else NEG_INF\n    \n        def update(sl, k, v):\n            j = sl.bisect_left((k,))\n            if j < len(sl) and sl[j][0] == k:\n                if not (sl[j][1] < v):\n                    return\n                del sl[j]\n            elif not (j-1 < 0 or sl[j-1][1] < v):\n                return\n            sl.add((k, v))\n            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:\n                del sl[j+1]\n\n        result = NEG_INF\n        sl1, sl2 = SortedList(), SortedList()\n        for price, profit in itertools.izip(prices, profits):\n            result = max(result, query(sl2, price)+profit)\n            update(sl1, price, profit)\n            update(sl2, price, query(sl1, price)+profit)\n        return result if result != NEG_INF else -1\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nfrom sortedcontainers import SortedList\n\n\n# prefix sum, sorted list, binary search, mono stack\nclass Solution2(object):\n    def maxProfit(self, prices, profits):\n        \"\"\"\n        :type prices: List[int]\n        :type profits: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n\n        right = [NEG_INF]*len(prices)\n        sl = SortedList()\n        for i in reversed(xrange(len(prices))):\n            j = sl.bisect_left((-prices[i],))\n            if j-1 >= 0:\n                right[i] = sl[j-1][1]\n            if not (j-1 < 0 or sl[j-1][1] < profits[i]):\n                continue\n            sl.add((-prices[i], profits[i]))\n            j = sl.bisect_left((-prices[i], profits[i]))\n            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:\n                del sl[j+1]\n        result = NEG_INF\n        sl = SortedList()\n        for i in xrange(len(prices)):\n            j = sl.bisect_left((prices[i],))\n            if j-1 >= 0:\n                result = max(result, sl[j-1][1]+profits[i]+right[i])\n            if not (j-1 < 0 or sl[j-1][1] < profits[i]):\n                continue\n            sl.add((prices[i], profits[i]))\n            j = sl.bisect_left((prices[i], profits[i]))\n            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:\n                del sl[j+1]\n        return result if result != NEG_INF else -1\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\n\n\n# prefix sum, bit, fenwick tree\nclass Solution3(object):\n    def maxProfit(self, prices, profits):\n        \"\"\"\n        :type prices: List[int]\n        :type profits: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n, default=0, fn=lambda x, y: x+y):\n                self.__bit = [NEG_INF]*(n+1)  # Extra one for dummy node.\n                self.__default = default\n                self.__fn = fn\n\n            def update(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] = self.__fn(self.__bit[i], val)\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = self.__default\n                while i > 0:\n                    ret = self.__fn(ret, self.__bit[i])\n                    i -= (i & -i)\n                return ret\n\n        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}\n        result = NEG_INF\n        bit1, bit2 = BIT(len(price_to_idx), default=NEG_INF, fn=max), BIT(len(price_to_idx), default=NEG_INF, fn=max)\n        for price, profit in itertools.izip(prices, profits):\n            result = max(result, bit2.query(price_to_idx[price]-1)+profit)\n            bit1.update(price_to_idx[price], profit)\n            bit2.update(price_to_idx[price], bit1.query(price_to_idx[price]-1)+profit)\n        return result if result != NEG_INF else -1\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\n\n\n# prefix sum, segment tree\nclass Solution4(object):\n    def maxProfit(self, prices, profits):\n        \"\"\"\n        :type prices: List[int]\n        :type profits: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        # Range Maximum Query\n        class SegmentTree(object):\n            def __init__(self, N,\n                         build_fn=lambda _: None,\n                         query_fn=lambda x, y: max(x, y),\n                         update_fn=lambda x, y: max(x, y)):\n                self.tree = [None]*(2*2**((N-1).bit_length()))\n                self.base = len(self.tree)//2\n                self.query_fn = query_fn\n                self.update_fn = update_fn\n                for i in xrange(self.base, self.base+N):\n                    self.tree[i] = build_fn(i-self.base)\n                for i in reversed(xrange(1, self.base)):\n                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n\n            def update(self, i, h):\n                x = self.base+i\n                self.tree[x] = self.update_fn(self.tree[x], h)\n                while x > 1:\n                    x //= 2\n                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n\n            def query(self, L, R):\n                if L > R:\n                    return None\n                L += self.base\n                R += self.base\n                left = right = None\n                while L <= R:\n                    if L & 1:\n                        left = self.query_fn(left, self.tree[L])\n                        L += 1\n                    if R & 1 == 0:\n                        right = self.query_fn(self.tree[R], right)\n                        R -= 1\n                    L //= 2\n                    R //= 2\n                return self.query_fn(left, right)\n\n        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}\n        result = NEG_INF\n        st1, st2 = SegmentTree(len(price_to_idx)), SegmentTree(len(price_to_idx))\n        for price, profit in itertools.izip(prices, profits):\n            mx2 = st2.query(0, price_to_idx[price]-1)\n            if mx2 is not None:\n                result = max(result, mx2+profit)\n            st1.update(price_to_idx[price], profit)\n            mx1 = st1.query(0, price_to_idx[price]-1)\n            if mx1 is not None:\n                st2.update(price_to_idx[price], mx1+profit)\n        return result if result != NEG_INF else -1\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# prefix sum, segment tree\nclass Solution5(object):\n    def maxProfit(self, prices, profits):\n        \"\"\"\n        :type prices: List[int]\n        :type profits: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        # Range Maximum Query\n        class SegmentTree(object):\n            def __init__(self, N,\n                         build_fn=lambda _: None,\n                         query_fn=lambda x, y: max(x, y),\n                         update_fn=lambda x, y: max(x, y)):\n                self.tree = [None]*(2*2**((N-1).bit_length()))\n                self.base = len(self.tree)//2\n                self.query_fn = query_fn\n                self.update_fn = update_fn\n                for i in xrange(self.base, self.base+N):\n                    self.tree[i] = build_fn(i-self.base)\n                for i in reversed(xrange(1, self.base)):\n                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n\n            def update(self, i, h):\n                x = self.base+i\n                self.tree[x] = self.update_fn(self.tree[x], h)\n                while x > 1:\n                    x //= 2\n                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n\n            def query(self, L, R):\n                if L > R:\n                    return None\n                L += self.base\n                R += self.base\n                left = right = None\n                while L <= R:\n                    if L & 1:\n                        left = self.query_fn(left, self.tree[L])\n                        L += 1\n                    if R & 1 == 0:\n                        right = self.query_fn(self.tree[R], right)\n                        R -= 1\n                    L //= 2\n                    R //= 2\n                return self.query_fn(left, right)\n\n        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}\n        right = [NEG_INF]*len(prices)\n        st = SegmentTree(len(price_to_idx))\n        for i in reversed(xrange(len(prices))):\n            right[i] = st.query(price_to_idx[prices[i]]+1, len(price_to_idx)-1)\n            st.update(price_to_idx[prices[i]], profits[i])\n        result = NEG_INF\n        st = SegmentTree(len(price_to_idx))\n        for i in xrange(len(prices)):\n            left = st.query(0, price_to_idx[prices[i]]-1)\n            if left is not None and right[i] is not None:\n                result = max(result, left+profits[i]+right[i])\n            st.update(price_to_idx[prices[i]], profits[i])\n        return result if result != NEG_INF else -1\n"
    },
    {
        "problem_name": "maximum-profitable-triplets-with-increasing-prices-ii",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport itertools\nfrom sortedcontainers import SortedList\n\n\n# prefix sum, sorted list, binary search, mono stack\nclass Solution(object):\n    def maxProfit(self, prices, profits):\n        \"\"\"\n        :type prices: List[int]\n        :type profits: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        def query(sl, k):\n            j = sl.bisect_left((k,))\n            return sl[j-1][1] if j-1 >= 0 else NEG_INF\n    \n        def update(sl, k, v):\n            j = sl.bisect_left((k,))\n            if j < len(sl) and sl[j][0] == k:\n                if not (sl[j][1] < v):\n                    return\n                del sl[j]\n            elif not (j-1 < 0 or sl[j-1][1] < v):\n                return\n            sl.add((k, v))\n            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:\n                del sl[j+1]\n\n        result = NEG_INF\n        sl1, sl2 = SortedList(), SortedList()\n        for price, profit in itertools.izip(prices, profits):\n            result = max(result, query(sl2, price)+profit)\n            update(sl1, price, profit)\n            update(sl2, price, query(sl1, price)+profit)\n        return result if result != NEG_INF else -1\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nfrom sortedcontainers import SortedList\n\n\n# prefix sum, sorted list, binary search, mono stack\nclass Solution2(object):\n    def maxProfit(self, prices, profits):\n        \"\"\"\n        :type prices: List[int]\n        :type profits: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n\n        right = [NEG_INF]*len(prices)\n        sl = SortedList()\n        for i in reversed(xrange(len(prices))):\n            j = sl.bisect_left((-prices[i],))\n            if j-1 >= 0:\n                right[i] = sl[j-1][1]\n            if not (j-1 < 0 or sl[j-1][1] < profits[i]):\n                continue\n            sl.add((-prices[i], profits[i]))\n            j = sl.bisect_left((-prices[i], profits[i]))\n            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:\n                del sl[j+1]\n        result = NEG_INF\n        sl = SortedList()\n        for i in xrange(len(prices)):\n            j = sl.bisect_left((prices[i],))\n            if j-1 >= 0:\n                result = max(result, sl[j-1][1]+profits[i]+right[i])\n            if not (j-1 < 0 or sl[j-1][1] < profits[i]):\n                continue\n            sl.add((prices[i], profits[i]))\n            j = sl.bisect_left((prices[i], profits[i]))\n            while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]:\n                del sl[j+1]\n        return result if result != NEG_INF else -1\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\n\n\n# prefix sum, bit, fenwick tree\nclass Solution3(object):\n    def maxProfit(self, prices, profits):\n        \"\"\"\n        :type prices: List[int]\n        :type profits: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n, default=0, fn=lambda x, y: x+y):\n                self.__bit = [NEG_INF]*(n+1)  # Extra one for dummy node.\n                self.__default = default\n                self.__fn = fn\n\n            def update(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] = self.__fn(self.__bit[i], val)\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = self.__default\n                while i > 0:\n                    ret = self.__fn(ret, self.__bit[i])\n                    i -= (i & -i)\n                return ret\n\n        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}\n        result = NEG_INF\n        bit1, bit2 = BIT(len(price_to_idx), default=NEG_INF, fn=max), BIT(len(price_to_idx), default=NEG_INF, fn=max)\n        for price, profit in itertools.izip(prices, profits):\n            result = max(result, bit2.query(price_to_idx[price]-1)+profit)\n            bit1.update(price_to_idx[price], profit)\n            bit2.update(price_to_idx[price], bit1.query(price_to_idx[price]-1)+profit)\n        return result if result != NEG_INF else -1\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\n\n\n# prefix sum, segment tree\nclass Solution4(object):\n    def maxProfit(self, prices, profits):\n        \"\"\"\n        :type prices: List[int]\n        :type profits: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        # Range Maximum Query\n        class SegmentTree(object):\n            def __init__(self, N,\n                         build_fn=lambda _: None,\n                         query_fn=lambda x, y: max(x, y),\n                         update_fn=lambda x, y: max(x, y)):\n                self.tree = [None]*(2*2**((N-1).bit_length()))\n                self.base = len(self.tree)//2\n                self.query_fn = query_fn\n                self.update_fn = update_fn\n                for i in xrange(self.base, self.base+N):\n                    self.tree[i] = build_fn(i-self.base)\n                for i in reversed(xrange(1, self.base)):\n                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n\n            def update(self, i, h):\n                x = self.base+i\n                self.tree[x] = self.update_fn(self.tree[x], h)\n                while x > 1:\n                    x //= 2\n                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n\n            def query(self, L, R):\n                if L > R:\n                    return None\n                L += self.base\n                R += self.base\n                left = right = None\n                while L <= R:\n                    if L & 1:\n                        left = self.query_fn(left, self.tree[L])\n                        L += 1\n                    if R & 1 == 0:\n                        right = self.query_fn(self.tree[R], right)\n                        R -= 1\n                    L //= 2\n                    R //= 2\n                return self.query_fn(left, right)\n\n        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}\n        result = NEG_INF\n        st1, st2 = SegmentTree(len(price_to_idx)), SegmentTree(len(price_to_idx))\n        for price, profit in itertools.izip(prices, profits):\n            mx2 = st2.query(0, price_to_idx[price]-1)\n            if mx2 is not None:\n                result = max(result, mx2+profit)\n            st1.update(price_to_idx[price], profit)\n            mx1 = st1.query(0, price_to_idx[price]-1)\n            if mx1 is not None:\n                st2.update(price_to_idx[price], mx1+profit)\n        return result if result != NEG_INF else -1\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# prefix sum, segment tree\nclass Solution5(object):\n    def maxProfit(self, prices, profits):\n        \"\"\"\n        :type prices: List[int]\n        :type profits: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        # Range Maximum Query\n        class SegmentTree(object):\n            def __init__(self, N,\n                         build_fn=lambda _: None,\n                         query_fn=lambda x, y: max(x, y),\n                         update_fn=lambda x, y: max(x, y)):\n                self.tree = [None]*(2*2**((N-1).bit_length()))\n                self.base = len(self.tree)//2\n                self.query_fn = query_fn\n                self.update_fn = update_fn\n                for i in xrange(self.base, self.base+N):\n                    self.tree[i] = build_fn(i-self.base)\n                for i in reversed(xrange(1, self.base)):\n                    self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])\n\n            def update(self, i, h):\n                x = self.base+i\n                self.tree[x] = self.update_fn(self.tree[x], h)\n                while x > 1:\n                    x //= 2\n                    self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n\n            def query(self, L, R):\n                if L > R:\n                    return None\n                L += self.base\n                R += self.base\n                left = right = None\n                while L <= R:\n                    if L & 1:\n                        left = self.query_fn(left, self.tree[L])\n                        L += 1\n                    if R & 1 == 0:\n                        right = self.query_fn(self.tree[R], right)\n                        R -= 1\n                    L //= 2\n                    R //= 2\n                return self.query_fn(left, right)\n\n        price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))}\n        right = [NEG_INF]*len(prices)\n        st = SegmentTree(len(price_to_idx))\n        for i in reversed(xrange(len(prices))):\n            right[i] = st.query(price_to_idx[prices[i]]+1, len(price_to_idx)-1)\n            st.update(price_to_idx[prices[i]], profits[i])\n        result = NEG_INF\n        st = SegmentTree(len(price_to_idx))\n        for i in xrange(len(prices)):\n            left = st.query(0, price_to_idx[prices[i]]-1)\n            if left is not None and right[i] is not None:\n                result = max(result, left+profits[i]+right[i])\n            st.update(price_to_idx[prices[i]], profits[i])\n        return result if result != NEG_INF else -1\n"
    },
    {
        "problem_name": "maximum-repeating-substring",
        "solution": "# Time:  O(n), n is the length of sequence\n# Space: O(m), m is the length of word\n\n# optimized kmp solution\nclass Solution(object):\n    def maxRepeating(self, sequence, word):\n        \"\"\"\n        :type sequence: str\n        :type word: str\n        :rtype: int\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1] * len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j > -1 and pattern[j + 1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        if len(sequence) < len(word):\n            return 0\n\n        prefix = getPrefix(word)\n        result, count, j, prev = 0, 0, -1, -1\n        for i in xrange(len(sequence)):\n            while j > -1 and word[j+1] != sequence[i]:\n                j = prefix[j]\n            if word[j+1] == sequence[i]:\n                j += 1\n            if j+1 == len(word):     \n                count = count+1 if i-prev == len(word) else 1\n                result = max(result, count)\n                j, prev = -1, i\n        return result\n\n\n# Time:  O(n), n is the length of sequence\n# Space: O(n)\n# kmp solution\nclass Solution2(object):\n    def maxRepeating(self, sequence, word):\n        \"\"\"\n        :type sequence: str\n        :type word: str\n        :rtype: int\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1] * len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j > -1 and pattern[j + 1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        if len(sequence) < len(word):\n            return 0\n\n        new_word = word*(len(sequence)//len(word))\n        prefix = getPrefix(new_word)\n        result, j = 0, -1\n        for i in xrange(len(sequence)):\n            while j > -1 and new_word[j+1] != sequence[i]:\n                j = prefix[j]\n            if new_word[j+1] == sequence[i]:\n                j += 1\n            result = max(result, j+1)\n            if j+1 == len(new_word):     \n                break\n        return result//len(word)\n"
    },
    {
        "problem_name": "maximum-rows-covered-by-columns",
        "solution": "# Time:  O(m * n + m * C(n, k))\n# Space: O(m)\n\n# bitmasks, hakmem-175\nclass Solution(object):\n    def maximumRows(self, matrix, numSelect):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type numSelect: int\n        :rtype: int\n        \"\"\"\n        def next_popcount(n):  # reference: https://massivealgorithms.blogspot.com/2014/06/hakmem-item-175.html\n            lowest_bit = n&-n\n            left_bits = n+lowest_bit\n            changed_bits = n^left_bits\n            right_bits = (changed_bits//lowest_bit)>>2\n            return left_bits|right_bits\n\n        masks = [reduce(lambda m, c: m|(matrix[r][-1-c]<<c), xrange(len(matrix[0])), 0) for r in xrange(len(matrix))]\n        result = 0\n        mask = (1<<numSelect)-1\n        while mask < 1<<len(matrix[0]):\n            result = max(result, sum((m&mask) == m for m in masks))\n            mask = next_popcount(mask)\n        return result\n"
    },
    {
        "problem_name": "maximum-running-time-of-n-computers",
        "solution": "# Time:  O(nlogm)\n# Space: O(1)\n\nimport heapq\n\n\n# greedy\nclass Solution(object):\n    def maxRunTime(self, n, batteries):\n        \"\"\"\n        :type n: int\n        :type batteries: List[int]\n        :rtype: int\n        \"\"\"\n        total = sum(batteries)\n        for i in xrange(len(batteries)):\n            batteries[i] = -batteries[i]  # max_heap\n        heapq.heapify(batteries)\n        while -batteries[0] > total//n:\n            n -= 1\n            total -= -heapq.heappop(batteries)\n        return total//n\n\n\n# Time:  O(nlogr), r is the range of possible minutes\n# Space: O(1)\n# binary search\nclass Solution2(object):\n    def maxRunTime(self, n, batteries):\n        \"\"\"\n        :type n: int\n        :type batteries: List[int]\n        :rtype: int\n        \"\"\"\n        def check(n, batteries, x):\n            return sum(min(b, x) for b in batteries) >= n*x\n\n        left, right = min(batteries), sum(batteries)//n\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(n, batteries, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "maximum-score-after-applying-operations-on-a-tree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# iterative dfs, tree dp\nclass Solution(object):\n    def maximumScoreAfterOperations(self, edges, values):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type values: List[int]\n        :rtype: int\n        \"\"\"\n        def iter_dfs():\n            dp = [0]*len(values)\n            stk = [(1, 0, -1)]\n            while stk:\n                step, u, p = stk.pop() \n                if step == 1:\n                    if len(adj[u]) == (1 if u else 0):\n                        dp[u] = values[u]\n                        continue\n                    stk.append((2, u, p))\n                    for v in reversed(adj[u]):\n                        if v != p:\n                            stk.append((1, v, u))\n                elif step == 2:\n                    dp[u] = min(sum(dp[v] for v in adj[u] if v != p), values[u])  # min(pick u, not pick u)\n            return dp[0]\n\n        adj = [[] for _ in xrange(len(values))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return sum(values)-iter_dfs()\n\n\n# Time:  O(n)\n# Space: O(n)\n# dfs, tree dp\nclass Solution2(object):\n    def maximumScoreAfterOperations(self, edges, values):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type values: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(u, p):\n            if len(adj[u]) == (1 if u else 0):\n                return values[u]\n            return min(sum(dfs(v, u) for v in adj[u] if v != p), values[u])  # min(pick u, not pick u)\n\n        adj = [[] for _ in xrange(len(values))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return sum(values)-dfs(0, -1)\n"
    },
    {
        "problem_name": "maximum-score-after-splitting-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxScore(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, zeros, ones = 0, 0, 0\n        for i in xrange(1, len(s)-1):\n            if s[i] == '0':\n                zeros += 1\n            else:\n                ones += 1\n            result = max(result, zeros-ones)\n        return result + ones + (s[0] == '0') + (s[-1] == '1')\n"
    },
    {
        "problem_name": "maximum-score-from-performing-multiplication-operations",
        "solution": "# Time:  O(m^2)\n# Space: O(m)\n\nclass Solution(object):\n    def maximumScore(self, nums, multipliers):\n        \"\"\"\n        :type nums: List[int]\n        :type multipliers: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [0]*(len(multipliers)+1)\n        for l, m in enumerate(reversed(multipliers), start=len(nums)-len(multipliers)):\n            dp = [max(m*nums[i]+dp[i+1], m*nums[i+l]+dp[i]) for i in xrange(len(dp)-1)]\n        return dp[0]\n"
    },
    {
        "problem_name": "maximum-score-from-removing-stones",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def maximumScore(self, a, b, c):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type c: int\n        :rtype: int\n        \"\"\"\n        # assumed c is the max size\n        # case1: a+b > c\n        # => (a+b-c)//2 + c = (a+b+c)//2 < a+b\n        # case2: a+b <= c\n        # => a+b <= (a+b+c)//2\n        return min((a+b+c)//2, a+b+c - max(a, b, c))\n"
    },
    {
        "problem_name": "maximum-score-from-removing-substrings",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maximumGain(self, s, x, y):\n        \"\"\"\n        :type s: str\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        def score(s, a, x):\n            i = result = 0\n            for j in xrange(len(s)):\n                s[i] = s[j]\n                i += 1\n                if i >= 2 and s[i-2:i] == a:\n                    i -= 2\n                    result += x\n            s[:] = s[:i]\n            return result\n                \n        s, a, b = list(s), list(\"ab\"), list(\"ba\")\n        if x < y:\n            x, y = y, x\n            a, b = b, a\n        return score(s, a, x) + score(s, b, y)\n"
    },
    {
        "problem_name": "maximum-score-of-a-good-subarray",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maximumScore(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = curr = nums[k]\n        left = right = k\n        while left-1 >= 0 or right+1 < len(nums):\n            # choosing larger one to expand is always better than or equal to choosing smaller one\n            if (nums[left-1] if left-1 >= 0 else 0) <= (nums[right+1] if right+1 < len(nums) else 0):\n                right += 1\n            else:\n                left -= 1\n            curr = min(curr, nums[left], nums[right])\n            result = max(result, curr*(right-left+1))\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport bisect\n\n\nclass Solution2(object):\n    def maximumScore(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def score(nums, k):\n            prefix = [nums[k]]*(k+1)\n            for i in reversed(xrange(k)):\n                prefix[i] = min(prefix[i+1], nums[i])\n            result = right = nums[k]\n            for j in xrange(k+1, len(nums)):\n                right = min(right, nums[j])\n                i = bisect.bisect_left(prefix, right)\n                if i >= 0:\n                    result = max(result, right*(j-i+1))\n            return result\n\n        return max(score(nums, k), score(nums[::-1], len(nums)-1-k))\n \n"
    },
    {
        "problem_name": "maximum-score-of-a-node-sequence",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|V|)\n\nimport heapq\n\n\n# graph\nclass Solution(object):\n    def maximumScore(self, scores, edges):\n        \"\"\"\n        :type scores: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def find_top3(scores, x, top3):\n            heapq.heappush(top3, (scores[x], x))\n            if len(top3) > 3:\n                heapq.heappop(top3)\n\n        top3 = [[] for _ in xrange(len(scores))]\n        for a, b in edges:\n            find_top3(scores, b, top3[a])\n            find_top3(scores, a, top3[b])\n        result = -1\n        for a, b in edges:\n            for _, c in top3[a]:\n                if c == b:\n                    continue\n                for _, d in top3[b]:\n                    if d == a or d == c:\n                        continue\n                    result = max(result, sum(scores[x] for x in (a, b, c, d)))\n        return result\n\n"
    },
    {
        "problem_name": "maximum-score-of-spliced-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy, kadane's algorithm\nclass Solution(object):\n    def maximumsSplicedArray(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        def kadane(a):\n            result = curr = 0\n            for x in a:\n                curr = max(curr+x, 0)\n                result = max(result, curr)\n            return result\n    \n        return max(sum(nums1)+kadane((nums2[i]-nums1[i] for i in xrange(len(nums1)))),\n                   sum(nums2)+kadane((nums1[i]-nums2[i] for i in xrange(len(nums2)))))\n"
    },
    {
        "problem_name": "maximum-score-words-formed-by-letters",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def maxScoreWords(self, words, letters, score):\n        \"\"\"\n        :type words: List[str]\n        :type letters: List[str]\n        :type score: List[int]\n        :rtype: int\n        \"\"\"\n        def backtracking(words, word_scores, word_counts, curr, curr_score, letter_count, result):\n            result[0] = max(result[0], curr_score) \n            for i in xrange(curr, len(words)):\n                if any(letter_count[c] < word_counts[i][c] for c in word_counts[i]):\n                    continue\n                backtracking(words, word_scores, word_counts, i+1,\n                             curr_score+word_scores[i], letter_count-word_counts[i],\n                             result)\n\n        letter_count = collections.Counter(letters)    \n        word_counts = map(collections.Counter, words)\n        word_scores = [sum(score[ord(c)-ord('a')] for c in words[i])\n                       for i in xrange(len(words))]\n        result = [0]\n        backtracking(words, word_scores, word_counts, 0, 0, letter_count, result)\n        return result[0]\n"
    },
    {
        "problem_name": "maximum-segment-sum-after-removals",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n    def __init__(self, nums):\n        self.set = range(len(nums))\n        self.rank = [0]*len(nums)\n        self.size = nums[:]\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x, y = self.find_set(x), self.find_set(y)\n        if x == y:\n            return False\n        if self.rank[x] > self.rank[y]:  # union by rank\n            x, y = y, x\n        self.set[x] = self.set[y]\n        if self.rank[x] == self.rank[y]:\n            self.rank[y] += 1\n        self.size[y] += self.size[x]\n        return True\n\n    def total(self, x):\n        return self.size[self.find_set(x)]\n\n\n# union find\nclass Solution(object):\n    def maximumSegmentSum(self, nums, removeQueries):\n        \"\"\"\n        :type nums: List[int]\n        :type removeQueries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(removeQueries)\n        lookup = [0]*len(nums)\n        uf = UnionFind(nums)\n        for i in reversed(xrange(1, len(removeQueries))): \n            q = removeQueries[i]\n            lookup[q] = 1\n            if q-1 >= 0 and lookup[q-1]:\n                uf.union_set(q-1, q)\n            if q+1 < len(nums) and lookup[q+1]:\n                uf.union_set(q, q+1)\n            result[i-1] = max(result[i], uf.total(q))   \n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nfrom sortedcontainers import SortedList\n\n\n# prefix sum, sorted list\nclass Solution2(object):\n    def maximumSegmentSum(self, nums, removeQueries):\n        \"\"\"\n        :type nums: List[int]\n        :type removeQueries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        removed_idxs = SortedList([-1, len(nums)])\n        prefix = [0]*(len(nums)+1)\n        for i in xrange(len(nums)):\n            prefix[i+1] = prefix[i]+nums[i]\n        segments = SortedList([prefix[-1]])\n        result = []\n        for q in removeQueries: \n            removed_idxs.add(q)\n            i = removed_idxs.bisect_left(q)\n            left, right = removed_idxs[i-1], removed_idxs[i+1]\n            segments.remove(prefix[right]-prefix[left+1])\n            segments.add(prefix[q]-prefix[left+1])\n            segments.add(prefix[right]-prefix[q+1])\n            result.append(segments[-1])\n        return result\n"
    },
    {
        "problem_name": "maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold",
        "solution": "# Time:  O(m * n * log(min(m, n)))\n# Space: O(m * n)\n\nclass Solution(object):\n    def maxSideLength(self, mat, threshold):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        def check(dp, mid, threshold):\n            for i in xrange(mid, len(dp)):\n                for j in xrange(mid, len(dp[0])):\n                    if dp[i][j] - dp[i-mid][j] - dp[i][j-mid] + dp[i-mid][j-mid] <= threshold:\n                        return True\n            return False\n        \n        dp = [[0 for _ in xrange(len(mat[0])+1)] for _ in xrange(len(mat)+1)]\n        for i in xrange(1, len(mat)+1):\n            for j in xrange(1, len(mat[0])+1):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1]\n\n        left, right = 0, min(len(mat), len(mat[0])+1)\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(dp, mid, threshold):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "maximum-size-of-a-set-after-removals",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# math, hash table, greedy\nclass Solution(object):\n    def maximumSetSize(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        lookup1, lookup2 = set(nums1), set(nums2)\n        n, c = len(nums1), len(lookup1&lookup2)\n        d1, d2 = min(len(lookup1)-c, n//2), min(len(lookup2)-c, n//2)\n        return min(n, d1+d2+c)\n\n\n# Time:  O(n)\n# Space: O(n)\n# math, hash table, greedy\nclass Solution2(object):\n    def maximumSetSize(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        lookup1, lookup2 = set(nums1), set(nums2)\n        n, c = len(nums1), len(lookup1&lookup2)\n        d1, d2 = min(len(lookup1)-c, n//2), min(len(lookup2)-c, n//2)\n        r1, r2 = n//2-d1, n//2-d2\n        return d1+d2+min(r1+r2, c)  # = min(d1+d2+r1+r2, d1+d2+c) = min(d1+d2+(n//2-d1)+(n//2-d2), d1+d2+c) = min(n, d1+d2+c)\n"
    },
    {
        "problem_name": "maximum-size-subarray-sum-equals-k",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maxSubArrayLen(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        sums = {}\n        cur_sum, max_len = 0, 0\n        for i in xrange(len(nums)):\n            cur_sum += nums[i]\n            if cur_sum == k:\n                max_len = i + 1\n            elif cur_sum - k in sums:\n                max_len = max(max_len, i - sums[cur_sum - k])\n            if cur_sum not in sums:\n                sums[cur_sum] = i  # Only keep the smallest index.\n        return max_len\n\n"
    },
    {
        "problem_name": "maximum-spending-after-buying-items",
        "solution": "# Time:  O(m * n * logm)\n# Space: O(m)\n\nimport heapq\n\n\n# greedy, heap\nclass Solution(object):\n    def maxSpending(self, values):\n        \"\"\"\n        :type values: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(values), len(values[0])\n        min_heap = [(values[i].pop(), i) for i in xrange(m)]\n        heapq.heapify(min_heap)\n        result = 0\n        for d in xrange(1, m*n+1):\n            x, i = heapq.heappop(min_heap)\n            result += x*d\n            if values[i]:\n                heapq.heappush(min_heap, (values[i].pop(), i))\n        return result\n"
    },
    {
        "problem_name": "maximum-split-of-positive-even-integers",
        "solution": "# Time:  O(sqrt(n))\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def maximumEvenSplit(self, finalSum):\n        \"\"\"\n        :type finalSum: int\n        :rtype: List[int]\n        \"\"\"\n        if finalSum%2:\n            return []\n        result = []\n        i = 2\n        while i <= finalSum:\n            result.append(i)\n            finalSum -= i\n            i += 2\n        result[-1] += finalSum\n        return result\n"
    },
    {
        "problem_name": "maximum-square-area-by-removing-fences-from-a-field",
        "solution": "# Time:  O(h^2 + v^2)\n# Space: O(h^2 + v^2)\n\n# hash table\nclass Solution(object):\n    def maximizeSquareArea(self, m, n, hFences, vFences):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type hFences: List[int]\n        :type vFences: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def diff(arr, x):\n            arr.append(1)\n            arr.append(x)\n            return {abs(arr[i]-arr[j]) for i in xrange(len(arr)) for j in xrange(i+1, len(arr))}\n\n        lookup = diff(hFences, m)\n        result = -1\n        for x in diff(vFences, n):\n            if x in lookup:\n                result = max(result, x**2)\n        return result%MOD if result != -1 else -1\n\n\n# Time:  O(h^2 + v^2)\n# Space: O(min(h, v)^2)\n# hash table\nclass Solution2(object):\n    def maximizeSquareArea(self, m, n, hFences, vFences):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type hFences: List[int]\n        :type vFences: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def diff(arr, x, check):\n            arr.append(1)\n            arr.append(x)\n            for i in xrange(len(arr)):\n                for j in xrange(i+1, len(arr)):\n                    if not check:\n                        lookup.add(abs(arr[i]-arr[j]))\n                        continue\n                    if abs(arr[i]-arr[j]) in lookup:\n                        result[0] = max(result[0], (arr[i]-arr[j])**2)\n\n        if len(hFences) > len(vFences):\n            hFences, vFences = vFences, hFences\n            m, n = n, m\n        result = [-1]\n        lookup = set()\n        diff(hFences, m, False)\n        diff(vFences, n, True)\n        return result[0]%MOD if result[0] != -1 else -1\n"
    },
    {
        "problem_name": "maximum-star-sum-of-a-graph",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport random\n\n\n# quick select\nclass Solution(object):\n    def maxStarSum(self, vals, edges, k):\n        \"\"\"\n        :type vals: List[int]\n        :type edges: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        adj = [[] for _ in xrange(len(vals))]\n        for u, v in edges:\n            if vals[v] > 0:\n                adj[u].append(v)\n            if vals[u] > 0:\n                adj[v].append(u)\n        result = float(\"-inf\")\n        for u in xrange(len(vals)):\n            if 1 <= k <= len(adj[u]):\n                nth_element(adj[u], k-1, lambda a, b: vals[a] > vals[b])\n            result = max(result, vals[u]+sum(vals[adj[u][i]] for i in range(min(k, len(adj[u])))))\n        return result\n"
    },
    {
        "problem_name": "maximum-strength-of-a-group",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def maxStrength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if all(x <= 0 for x in nums) and sum(x < 0 for x in nums) <= 1:\n            return max(nums)\n        result = reduce(lambda x, y: x*y, (x for x in nums if x))\n        return result if result > 0 else result//max(x for x in nums if x < 0)\n"
    },
    {
        "problem_name": "maximum-strength-of-k-disjoint-subarrays",
        "solution": "# Time:  O(k * n)\n# Space: O(n)\n\n# dp, greedy, kadane's algorithm\nclass Solution(object):\n    def maximumStrength(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        dp = [0]*(len(nums)+1)\n        for i in xrange(k):\n            new_dp = [float(\"-inf\")]*(len(nums)+1)\n            for j in xrange(len(nums)):\n                new_dp[j+1] = max(new_dp[j], dp[j])+nums[j]*(k-i)*(1 if i%2 == 0 else -1)\n            dp = new_dp\n        return max(dp)\n\n\n# Time:  O(k * n)\n# Space: O(k * n)\n# dp, greedy, kadane's algorithm\nclass Solution2(object):\n    def maximumStrength(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        dp = [[float(\"-inf\")]*(len(nums)+1) for _ in xrange(k+1)]\n        dp[0] = [0]*(len(nums)+1)\n        for i in xrange(k):\n            for j in xrange(len(nums)):\n                dp[i+1][j+1] = max(dp[i+1][j], dp[i][j])+nums[j]*(k-i)*(1 if i%2 == 0 else -1)\n        return max(dp[-1])\n"
    },
    {
        "problem_name": "maximum-strictly-increasing-cells-in-a-matrix",
        "solution": "# Time:  O(m * n * log(m * n))\n# Space: O(m * n)\n\nimport collections\n\n\n# sort, dp\nclass Solution(object):\n    def maxIncreasingCells(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = collections.defaultdict(list)\n        for i in xrange(len(mat)):\n            for j in xrange(len(mat[0])):\n                lookup[mat[i][j]].append((i, j))\n        dp = [[0]*len(mat[0]) for _ in xrange(len(mat))]\n        row, col = [0]*len(mat), [0]*len(mat[0])\n        for x in sorted(lookup.iterkeys()):\n            for i, j in lookup[x]:\n                dp[i][j] = max(row[i], col[j])+1\n            for i, j in lookup[x]:\n                row[i] = max(row[i], dp[i][j])\n                col[j] = max(col[j], dp[i][j])\n        return max(row)\n"
    },
    {
        "problem_name": "maximum-strong-pair-xor-i",
        "solution": "# Time:  O(nlogn + nlogr) = O(nlogr), r = max(nums)\n# Space: O(t)\n\n# bit manipulation, greedy, trie, sort, two pointers\nclass Solution(object):\n    def maximumStrongPairXor(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        class Trie(object):\n            def __init__(self, bit_length):\n                self.__nodes = []\n                self.__cnts = []\n                self.__new_node()\n                self.__bit_length = bit_length\n            \n            def __new_node(self):\n                self.__nodes.append([-1]*2)\n                self.__cnts.append(0)\n                return len(self.__nodes)-1\n\n            def update(self, num, d):\n                curr = 0\n                for i in reversed(xrange(self.__bit_length)):\n                    x = num>>i\n                    if self.__nodes[curr][x&1] == -1:\n                        self.__nodes[curr][x&1] = self.__new_node()\n                    curr = self.__nodes[curr][x&1]\n                    self.__cnts[curr] += d\n                        \n            def query(self, num):\n                result = curr = 0\n                for i in reversed(xrange(self.__bit_length)):\n                    result <<= 1\n                    x = num>>i\n                    if self.__nodes[curr][1^(x&1)] != -1 and self.__cnts[self.__nodes[curr][1^(x&1)]]:\n                        curr = self.__nodes[curr][1^(x&1)]\n                        result |= 1\n                    else:\n                        curr = self.__nodes[curr][x&1]\n                return result\n    \n        nums.sort()\n        trie = Trie(nums[-1].bit_length())\n        result = j = 0\n        for i, num in enumerate(nums):\n            trie.update(num, +1)\n            while not (nums[i] <= 2*nums[j]) :\n                trie.update(nums[j], -1)\n                j += 1\n            result = max(result, trie.query(num))\n        return result\n\n\n# Time:  O(nlogr), r = max(nums)\n# Space: O(t)\n# bit manipulation, greedy, trie, dp\nclass Solution2(object):\n    def maximumStrongPairXor(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        class Trie(object):\n            def __init__(self, bit_length):\n                self.__nodes = []\n                self.__mins = []\n                self.__maxs = []\n                self.__new_node()\n                self.__bit_length = bit_length\n            \n            def __new_node(self):\n                self.__nodes.append([-1]*2)\n                self.__mins.append(float(\"inf\"))\n                self.__maxs.append(float(\"-inf\"))\n                return len(self.__nodes)-1\n\n            def insert(self, num):\n                curr = 0\n                for i in reversed(xrange(self.__bit_length)):\n                    x = num>>i\n                    if self.__nodes[curr][x&1] == -1:\n                        self.__nodes[curr][x&1] = self.__new_node()\n                    curr = self.__nodes[curr][x&1]\n                    self.__mins[curr] = min(self.__mins[curr], num)\n                    self.__maxs[curr] = max(self.__maxs[curr], num)\n                        \n            def query(self, num):\n                result = curr = 0\n                for i in reversed(xrange(self.__bit_length)):\n                    result <<= 1\n                    x = num>>i\n                    y = (result|1)^x\n                    assert(x != y) \n                    if (self.__nodes[curr][y&1] != -1 and\n                        ((x > y and num <= 2*self.__maxs[self.__nodes[curr][y&1]]) or\n                         (x < y and self.__mins[self.__nodes[curr][y&1]] <= 2*num))):\n                        result |= 1\n                        curr = self.__nodes[curr][y&1]\n                    else:\n                        curr = self.__nodes[curr][1^(y&1)]\n                return result\n    \n        trie = Trie(max(nums).bit_length())\n        result = 0\n        for num in nums:\n            trie.insert(num)\n            result = max(result, trie.query(num))\n        return result\n\n\n# Time:  O(nlogr), r = max(nums)\n# Space: O(n)\n# bit manipulation, greedy, dp\nclass Solution3(object):\n    def maximumStrongPairXor(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in reversed(xrange(max(nums).bit_length())):\n            prefix_min, prefix_max = {}, {}\n            for x in nums:\n                y = x>>i\n                if y not in prefix_min:\n                    prefix_min[y] = prefix_max[y] = x\n                prefix_min[y] = min(prefix_min[y], x)\n                prefix_max[y] = max(prefix_max[y], x)\n            result <<= 1\n            for x in prefix_min.iterkeys():\n                y = (result|1)^x\n                assert(x != y)\n                if y in prefix_max and prefix_min[max(x, y)] <= 2*prefix_max[min(x, y)]:\n                    result |= 1\n                    break\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(1)\n# bit manipulation, brute force\nclass Solution4(object):\n    def maximumStrongPairXor(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return max(nums[i]^nums[j] for i in xrange(len(nums)) for j in xrange(i, len(nums)) if abs(nums[i]-nums[j]) <= min(nums[i], nums[j]))\n"
    },
    {
        "problem_name": "maximum-strong-pair-xor-ii",
        "solution": "# Time:  O(nlogn + nlogr) = O(nlogr), r = max(nums)\n# Space: O(t)\n\n# bit manipulation, greedy, trie, sort, two pointers\nclass Solution(object):\n    def maximumStrongPairXor(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        class Trie(object):\n            def __init__(self, bit_length):\n                self.__nodes = []\n                self.__cnts = []\n                self.__new_node()\n                self.__bit_length = bit_length\n            \n            def __new_node(self):\n                self.__nodes.append([-1]*2)\n                self.__cnts.append(0)\n                return len(self.__nodes)-1\n\n            def update(self, num, d):\n                curr = 0\n                for i in reversed(xrange(self.__bit_length)):\n                    x = num>>i\n                    if self.__nodes[curr][x&1] == -1:\n                        self.__nodes[curr][x&1] = self.__new_node()\n                    curr = self.__nodes[curr][x&1]\n                    self.__cnts[curr] += d\n                        \n            def query(self, num):\n                result = curr = 0\n                for i in reversed(xrange(self.__bit_length)):\n                    result <<= 1\n                    x = num>>i\n                    if self.__nodes[curr][1^(x&1)] != -1 and self.__cnts[self.__nodes[curr][1^(x&1)]]:\n                        curr = self.__nodes[curr][1^(x&1)]\n                        result |= 1\n                    else:\n                        curr = self.__nodes[curr][x&1]\n                return result\n    \n        nums.sort()\n        trie = Trie(nums[-1].bit_length())\n        result = j = 0\n        for i, num in enumerate(nums):\n            trie.update(num, +1)\n            while not (nums[i] <= 2*nums[j]) :\n                trie.update(nums[j], -1)\n                j += 1\n            result = max(result, trie.query(num))\n        return result\n\n\n# Time:  O(nlogr), r = max(nums)\n# Space: O(t)\n# bit manipulation, greedy, trie, dp\nclass Solution2(object):\n    def maximumStrongPairXor(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        class Trie(object):\n            def __init__(self, bit_length):\n                self.__nodes = []\n                self.__mins = []\n                self.__maxs = []\n                self.__new_node()\n                self.__bit_length = bit_length\n            \n            def __new_node(self):\n                self.__nodes.append([-1]*2)\n                self.__mins.append(float(\"inf\"))\n                self.__maxs.append(float(\"-inf\"))\n                return len(self.__nodes)-1\n\n            def insert(self, num):\n                curr = 0\n                for i in reversed(xrange(self.__bit_length)):\n                    x = num>>i\n                    if self.__nodes[curr][x&1] == -1:\n                        self.__nodes[curr][x&1] = self.__new_node()\n                    curr = self.__nodes[curr][x&1]\n                    self.__mins[curr] = min(self.__mins[curr], num)\n                    self.__maxs[curr] = max(self.__maxs[curr], num)\n                        \n            def query(self, num):\n                result = curr = 0\n                for i in reversed(xrange(self.__bit_length)):\n                    result <<= 1\n                    x = num>>i\n                    y = (result|1)^x\n                    assert(x != y) \n                    if (self.__nodes[curr][y&1] != -1 and\n                        ((x > y and num <= 2*self.__maxs[self.__nodes[curr][y&1]]) or\n                         (x < y and self.__mins[self.__nodes[curr][y&1]] <= 2*num))):\n                        result |= 1\n                        curr = self.__nodes[curr][y&1]\n                    else:\n                        curr = self.__nodes[curr][1^(y&1)]\n                return result\n    \n        trie = Trie(max(nums).bit_length())\n        result = 0\n        for num in nums:\n            trie.insert(num)\n            result = max(result, trie.query(num))\n        return result\n\n\n# Time:  O(nlogr), r = max(nums)\n# Space: O(n)\n# bit manipulation, greedy, dp\nclass Solution3(object):\n    def maximumStrongPairXor(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in reversed(xrange(max(nums).bit_length())):\n            prefix_min, prefix_max = {}, {}\n            for x in nums:\n                y = x>>i\n                if y not in prefix_min:\n                    prefix_min[y] = prefix_max[y] = x\n                prefix_min[y] = min(prefix_min[y], x)\n                prefix_max[y] = max(prefix_max[y], x)\n            result <<= 1\n            for x in prefix_min.iterkeys():\n                y = (result|1)^x\n                assert(x != y)\n                if y in prefix_max and prefix_min[max(x, y)] <= 2*prefix_max[min(x, y)]:\n                    result |= 1\n                    break\n        return result\n"
    },
    {
        "problem_name": "maximum-students-taking-exam",
        "solution": "# Time:  O(m * n * sqrt(m * n))\n# Space: O(m * n)\n\n# the problem is the same as google codejam 2008 round 3 problem C\n# https://github.com/kamyu104/GoogleCodeJam-2008/blob/master/Round%203/no_cheating.py\n\nimport collections\n\n\nfrom functools import partial\n\n# Time:  O(E * sqrt(V))\n# Space: O(V)\n# Source code from http://code.activestate.com/recipes/123641-hopcroft-karp-bipartite-matching/\n# Hopcroft-Karp bipartite max-cardinality matching and max independent set\n# David Eppstein, UC Irvine, 27 Apr 2002\ndef bipartiteMatch(graph):\n    '''Find maximum cardinality matching of a bipartite graph (U,V,E).\n    The input format is a dictionary mapping members of U to a list\n    of their neighbors in V.  The output is a triple (M,A,B) where M is a\n    dictionary mapping members of V to their matches in U, A is the part\n    of the maximum independent set in U, and B is the part of the MIS in V.\n    The same object may occur in both U and V, and is treated as two\n    distinct vertices if this happens.'''\n    \n    # initialize greedy matching (redundant, but faster than full search)\n    matching = {}\n    for u in graph:\n        for v in graph[u]:\n            if v not in matching:\n                matching[v] = u\n                break\n    \n    while 1:\n        # structure residual graph into layers\n        # pred[u] gives the neighbor in the previous layer for u in U\n        # preds[v] gives a list of neighbors in the previous layer for v in V\n        # unmatched gives a list of unmatched vertices in final layer of V,\n        # and is also used as a flag value for pred[u] when u is in the first layer\n        preds = {}\n        unmatched = []\n        pred = dict([(u,unmatched) for u in graph])\n        for v in matching:\n            del pred[matching[v]]\n        layer = list(pred)\n        \n        # repeatedly extend layering structure by another pair of layers\n        while layer and not unmatched:\n            newLayer = {}\n            for u in layer:\n                for v in graph[u]:\n                    if v not in preds:\n                        newLayer.setdefault(v,[]).append(u)\n            layer = []\n            for v in newLayer:\n                preds[v] = newLayer[v]\n                if v in matching:\n                    layer.append(matching[v])\n                    pred[matching[v]] = v\n                else:\n                    unmatched.append(v)\n        \n        # did we finish layering without finding any alternating paths?\n        if not unmatched:\n            unlayered = {}\n            for u in graph:\n                for v in graph[u]:\n                    if v not in preds:\n                        unlayered[v] = None\n            return (matching,list(pred),list(unlayered))\n\n        # recursively search backward through layers to find alternating paths\n        # recursion returns true if found path, false otherwise\n        def recurse(v):\n            if v in preds:\n                L = preds[v]\n                del preds[v]\n                for u in L:\n                    if u in pred:\n                        pu = pred[u]\n                        del pred[u]\n                        if pu is unmatched or recurse(pu):\n                            matching[v] = u\n                            return 1\n            return 0\n        \n        def recurse_iter(v):\n            def divide(v):\n                if v not in preds:\n                    return\n                L = preds[v]\n                del preds[v]\n                for u in L :\n                    if u in pred and pred[u] is unmatched:  # early return\n                        del pred[u]\n                        matching[v] = u\n                        ret[0] = True\n                        return\n                stk.append(partial(conquer, v, iter(L)))\n\n            def conquer(v, it):\n                for u in it:\n                    if u not in pred:\n                        continue\n                    pu = pred[u]\n                    del pred[u]\n                    stk.append(partial(postprocess, v, u, it))\n                    stk.append(partial(divide, pu))\n                    return\n\n            def postprocess(v, u, it):\n                if not ret[0]:\n                    stk.append(partial(conquer, v, it))\n                    return\n                matching[v] = u\n\n            ret, stk = [False], []\n            stk.append(partial(divide, v))\n            while stk:\n                stk.pop()()\n            return ret[0]\n\n        for v in unmatched: recurse_iter(v)\n\n\n# Hopcroft-Karp bipartite matching\nclass Solution(object):\n    def maxStudents(self, seats):\n        \"\"\"\n        :type seats: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1)]\n        E, count = collections.defaultdict(list), 0\n        for i in xrange(len(seats)):\n            for j in xrange(len(seats[0])):\n                if seats[i][j] != '.':\n                    continue\n                count += 1\n                if j%2:\n                    continue\n                for dx, dy in directions:\n                    ni, nj = i+dx, j+dy\n                    if 0 <= ni < len(seats) and \\\n                       0 <= nj < len(seats[0]) and \\\n                       seats[ni][nj] == '.':\n                        E[i*len(seats[0])+j].append(ni*len(seats[0])+nj)\n        return count-len(bipartiteMatch(E)[0])\n\n\n# Time:  O(|V| * |E|) = O(m^2 * n^2)\n# Space: O(|V| + |E|) = O(m * n)\n# Hungarian bipartite matching\nclass Solution2(object):\n    def maxStudents(self, seats):\n        \"\"\"\n        :type seats: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1)]\n        def dfs(seats, e, lookup, matching):\n            i, j = e\n            for dx, dy in directions:\n                ni, nj = i+dx, j+dy\n                if 0 <= ni < len(seats) and 0 <= nj < len(seats[0]) and \\\n                    seats[ni][nj] == '.' and not lookup[ni][nj]:\n                    lookup[ni][nj] = True\n                    if matching[ni][nj] == -1 or dfs(seats, matching[ni][nj], lookup, matching):\n                        matching[ni][nj] = e\n                        return True\n            return False\n        \n        def Hungarian(seats):\n            result = 0\n            matching = [[-1]*len(seats[0]) for _ in xrange(len(seats))]\n            for i in xrange(len(seats)):\n                for j in xrange(0, len(seats[0]), 2):\n                    if seats[i][j] != '.':\n                        continue\n                    lookup = [[False]*len(seats[0]) for _ in xrange(len(seats))]\n                    if dfs(seats, (i, j), lookup, matching):\n                        result += 1\n            return result\n          \n        count = 0\n        for i in xrange(len(seats)):\n            for j in xrange(len(seats[0])):\n                if seats[i][j] == '.':\n                    count += 1\n        return count-Hungarian(seats)\n\n\n# Time:  O(m * 2^n * 2^n) = O(m * 4^n)\n# Space: O(2^n)\n# dp solution\nclass Solution3(object):\n    def maxStudents(self, seats):\n        \"\"\"\n        :type seats: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def popcount(n):\n            result = 0\n            while n:\n                n &= n - 1\n                result += 1\n            return result\n        \n        dp = {0: 0}\n        for row in seats:\n            invalid_mask = sum(1 << c for c, v in enumerate(row) if v == '#')\n            new_dp = {}\n            for mask1, v1 in dp.iteritems():\n                for mask2 in xrange(1 << len(seats[0])):\n                    if (mask2 & invalid_mask) or \\\n                       (mask2 & (mask1 << 1)) or (mask2 & (mask1 >> 1)) or \\\n                       (mask2 & (mask2 << 1)) or (mask2 & (mask2 >> 1)):\n                        continue\n                    new_dp[mask2] = max(new_dp.get(mask2, 0), v1+popcount(mask2))\n            dp = new_dp\n        return max(dp.itervalues()) if dp else 0\n"
    },
    {
        "problem_name": "maximum-subarray-min-product",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maxSumMinProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        prefix = [0]*(len(nums)+1)\n        for i in xrange(len(nums)):\n            prefix[i+1] = prefix[i]+nums[i]\n        stk, result = [-1], 0\n        for i in xrange(len(nums)+1):\n            while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]):\n                result = max(result, nums[stk.pop()]*(prefix[(i-1)+1]-prefix[stk[-1]+1]))\n            stk.append(i) \n        return result%MOD\n"
    },
    {
        "problem_name": "maximum-subarray-sum-after-one-operation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxSumAfterOperation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        prev_with_square = prev_without_square = 0\n        result = 0\n        for num in nums:\n            without_square = max(num, num+prev_without_square)\n            with_square = max(num*num, num*num+prev_without_square, num+prev_with_square)\n            result = max(result, with_square)\n            prev_with_square, prev_without_square = with_square, without_square\n        return result\n"
    },
    {
        "problem_name": "maximum-subarray-sum-with-one-deletion",
        "solution": "class Solution(object):\n    def maximumSum(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        result, prev, curr = float(\"-inf\"), float(\"-inf\"), float(\"-inf\")\n        for x in arr:\n            curr = max(prev, curr+x, x)\n            result = max(result, curr)\n            prev = max(prev+x, x)\n        return result\n"
    },
    {
        "problem_name": "maximum-subarray",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, curr = float(\"-inf\"), float(\"-inf\")\n        for x in nums:\n            curr = max(curr+x, x)\n            result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "maximum-subsequence-score",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport itertools\nimport heapq\n\n\n# greedy, heap\nclass Solution(object):\n    def maxScore(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = curr = 0\n        min_heap = []\n        for a, b in sorted(itertools.izip(nums1, nums2), key=lambda x: x[1],  reverse=True):\n            curr += a\n            heapq.heappush(min_heap, a)\n            if len(min_heap) > k:\n                curr -= heapq.heappop(min_heap)\n            if len(min_heap) == k:\n                result = max(result, curr*b)\n        return result\n"
    },
    {
        "problem_name": "maximum-subtree-of-the-same-color",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# iterative dfs\nclass Solution(object):\n    def maximumSubtreeSize(self, edges, colors):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type colors: List[int]\n        :rtype: int\n        \"\"\"\n        def iter_dfs():\n            result = 0\n            stk = [(1, (0, -1, [1]))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    u, p, ret = args\n                    stk.append((4, (ret,)))\n                    stk.append((2, (u, p, ret, 0)))\n                elif step == 2:\n                    u, p, ret, i = args\n                    if i == len(adj[u]):\n                        continue\n                    v = adj[u][i]\n                    stk.append((2, (u, p, ret, i+1)))\n                    if v == p:\n                        continue\n                    new_ret = [1]\n                    stk.append((3, (v, u, new_ret, ret)))\n                    stk.append((1, (v, u, new_ret)))\n                elif step == 3:\n                    v, u, new_ret, ret = args\n                    if ret[0] == -1:\n                        continue \n                    if new_ret[0] == 0 or colors[v] != colors[u]:\n                        ret[0] = -1\n                        continue\n                    ret[0] += new_ret[0]\n                elif step == 4:\n                    ret = args[0]\n                    result = max(result, ret[0])\n            return result\n\n        adj = [[] for _ in xrange(len(colors))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return iter_dfs()\n\n\n# Time:  O(n)\n# Space: O(h)\n# dfs\nclass Solution2(object):\n    def maximumSubtreeSize(self, edges, colors):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type colors: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(u, p):\n            cnt = 1\n            for v in adj[u]:\n                if v == p:\n                    continue\n                c = dfs(v, u)\n                if cnt == -1:\n                    continue\n                if c == -1 or colors[v] != colors[u]:\n                    cnt = -1\n                    continue\n                cnt += c\n            result[0] = max(result[0], cnt)\n            return cnt\n\n        adj = [[] for _ in xrange(len(colors))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        result = [0]\n        dfs(0, -1)\n        return result[0]\n"
    },
    {
        "problem_name": "maximum-sum-bst-in-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n# dfs solution with stack\nclass Solution(object):\n    def maxSumBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = [[root, None, []]]\n        while stk:\n            node, tmp, ret = stk.pop()\n            if tmp:\n                lvalid, lsum, lmin, lmax = tmp[0]\n                rvalid, rsum, rmin, rmax = tmp[1]\n                if lvalid and rvalid and lmax < node.val < rmin:\n                    total = lsum + node.val + rsum\n                    result = max(result, total)\n                    ret[:] = [True, total, min(lmin, node.val), max(node.val, rmax)]\n                    continue\n                ret[:] = [False, 0, 0, 0]\n                continue\n            if not node:\n                ret[:] = [True, 0, float(\"inf\"), float(\"-inf\")]\n                continue\n            new_tmp = [[], []]\n            stk.append([node, new_tmp, ret])\n            stk.append([node.right, None, new_tmp[1]])\n            stk.append([node.left, None, new_tmp[0]])\n        return result\n\n\n# Time:  O(n)\n# Space: O(h)\n# dfs solution with recursion\nclass Solution2(object):\n    def maxSumBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node, result):\n            if not node:\n                return True, 0, float(\"inf\"), float(\"-inf\")\n            lvalid, lsum, lmin, lmax = dfs(node.left, result)\n            rvalid, rsum, rmin, rmax = dfs(node.right, result)\n            if lvalid and rvalid and lmax < node.val < rmin:\n                total = lsum + node.val + rsum\n                result[0] = max(result[0], total)\n                return True, total, min(lmin, node.val), max(node.val, rmax)\n            return False, 0, 0, 0\n\n        result = [0]\n        dfs(root, result)\n        return result[0]\n"
    },
    {
        "problem_name": "maximum-sum-circular-subarray",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxSubarraySumCircular(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        total, max_sum, cur_max, min_sum, cur_min = 0, -float(\"inf\"), 0, float(\"inf\"), 0\n        for a in A:\n            cur_max = max(cur_max+a, a)\n            max_sum = max(max_sum, cur_max)\n            cur_min = min(cur_min+a, a)\n            min_sum = min(min_sum, cur_min)\n            total += a\n        return max(max_sum, total-min_sum) if max_sum >= 0 else max_sum\n\n"
    },
    {
        "problem_name": "maximum-sum-obtained-of-any-permutation",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport itertools\n\n\nclass Solution(object):\n    def maxSumRangeQuery(self, nums, requests):\n        \"\"\"\n        :type nums: List[int]\n        :type requests: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def addmod(a, b, mod):  # avoid overflow in other languages\n            a %= mod\n            b %= mod\n            if mod-a <= b:\n                b -= mod\n            return a+b\n        \n        def mulmod(a, b, mod):  # avoid overflow in other languages\n            a %= mod\n            b %= mod\n            if a < b:\n                a, b = b, a\n            result = 0\n            while b > 0:\n                if b%2 == 1:\n                    result = addmod(result, a, mod)\n                a = addmod(a, a, mod)\n                b //= 2\n            return result\n\n        MOD = 10**9+7\n\n        count = [0]*len(nums)\n        for start, end in requests:\n            count[start] += 1\n            if end+1 < len(count):\n                count[end+1] -= 1\n        for i in xrange(1, len(count)):\n            count[i] += count[i-1]\n        nums.sort()\n        count.sort()\n        result = 0\n        for i, (num, c) in enumerate(itertools.izip(nums, count)):\n            # result = addmod(result, mulmod(num, c, MOD), MOD)\n            result = (result+num*c)%MOD\n        return result\n"
    },
    {
        "problem_name": "maximum-sum-of-3-non-overlapping-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maxSumOfThreeSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        accu = [0]\n        for num in nums:\n            accu.append(accu[-1]+num)\n\n        left_pos = [0] * n\n        total = accu[k]-accu[0]\n        for i in xrange(k, n):\n            if accu[i+1]-accu[i+1-k] > total:\n                left_pos[i] = i+1-k\n                total = accu[i+1]-accu[i+1-k]\n            else:\n                left_pos[i] = left_pos[i-1]\n\n        right_pos = [n-k] * n\n        total = accu[n]-accu[n-k]\n        for i in reversed(xrange(n-k)):\n            if accu[i+k]-accu[i] > total:\n                right_pos[i] = i\n                total = accu[i+k]-accu[i]\n            else:\n                right_pos[i] = right_pos[i+1]\n\n        result, max_sum = [], 0\n        for i in xrange(k, n-2*k+1):\n            left, right = left_pos[i-1], right_pos[i+k]\n            total = (accu[i+k]-accu[i]) + \\\n                    (accu[left+k]-accu[left]) + \\\n                    (accu[right+k]-accu[right])\n            if total > max_sum:\n                max_sum = total\n                result = [left, i, right]\n        return result\n\n"
    },
    {
        "problem_name": "maximum-sum-of-almost-unique-subarray",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table, two pointers, sliding window\nclass Solution(object):\n    def maxSum(self, nums, m, k):\n        \"\"\"\n        :type nums: List[int]\n        :type m: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        lookup = collections.Counter()\n        result = curr = left = 0\n        for right in xrange(len(nums)):\n            curr += nums[right]\n            lookup[nums[right]] += 1\n            if right-left+1 == k+1:\n                lookup[nums[left]] -= 1\n                if lookup[nums[left]] == 0:\n                    del lookup[nums[left]]\n                curr -= nums[left]\n                left += 1\n            if right-left+1 == k and len(lookup) >= m:\n                result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "maximum-sum-of-an-hourglass",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n# brute force\nclass Solution(object):\n    def maxSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def total(i, j):\n            return (grid[i][j]+grid[i][j+1]+grid[i][j+2]+\n                               grid[i+1][j+1]+\n                    grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2])\n\n        return max(total(i, j) for i in xrange(len(grid)-2) for j in xrange(len(grid[0])-2))\n"
    },
    {
        "problem_name": "maximum-sum-of-distinct-subarrays-with-length-k",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\n# two pointers\nclass Solution(object):\n    def maximumSubarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = left = total = 0\n        lookup = set()\n        for right in xrange(len(nums)):\n            while nums[right] in lookup or len(lookup) == k:\n                lookup.remove(nums[left])\n                total -= nums[left]\n                left += 1\n            lookup.add(nums[right])\n            total += nums[right]\n            if len(lookup) == k:\n                result = max(result, total)\n        return result\n"
    },
    {
        "problem_name": "maximum-sum-of-two-non-overlapping-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxSumTwoNoOverlap(self, A, L, M):\n        \"\"\"\n        :type A: List[int]\n        :type L: int\n        :type M: int\n        :rtype: int\n        \"\"\"\n        for i in xrange(1, len(A)):\n            A[i] += A[i-1]\n        result, L_max, M_max = A[L+M-1], A[L-1], A[M-1]\n        for i in xrange(L+M, len(A)):\n            L_max = max(L_max, A[i-M] - A[i-L-M])\n            M_max = max(M_max, A[i-L] - A[i-L-M])\n            result = max(result,\n                         L_max + A[i] - A[i-M],\n                         M_max + A[i] - A[i-L])\n        return result\n"
    },
    {
        "problem_name": "maximum-sum-queries",
        "solution": "# Time:  O(nlogn + mlogm + mlogn)\n# Space: O(n + m)\n\nimport itertools\nimport bisect\n\n\n# sort, mono stack, binary search\nclass Solution(object):\n    def maximumSumQueries(self, nums1, nums2, queries):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        pairs = sorted(((i, j) for i, j in itertools.izip(nums1, nums2)))\n        result = [0]*len(queries)\n        stk = []\n        for x, y, i in sorted(((x, y, i) for i, (x, y) in enumerate(queries)), reverse=True):\n            while pairs and pairs[-1][0] >= x:\n                a, b = pairs.pop()\n                while stk and stk[-1][1] <= a+b:\n                    stk.pop()\n                if not stk or stk[-1][0] < b:\n                    stk.append((b, a+b))\n            j = bisect.bisect_left(stk, (y,))\n            result[i] = stk[j][1] if j != len(stk) else -1\n        return result\n"
    },
    {
        "problem_name": "maximum-sum-score-of-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# prefix sum, math\nclass Solution(object):\n    def maximumSumScore(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        prefix = suffix = 0\n        result = float(\"-inf\")\n        right = len(nums)-1\n        for left in xrange(len(nums)):\n            prefix += nums[left]\n            suffix += nums[right]\n            right -= 1\n            result = max(result, prefix, suffix)\n        return result\n\n    \n# Time:  O(n)\n# Space: O(1)\n# prefix sum\nclass Solution2(object):\n    def maximumSumScore(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        total = sum(nums)\n        prefix = 0\n        result = float(\"-inf\")\n        for x in nums:\n            prefix += x\n            result = max(result, prefix, total-prefix+x)\n        return result\n"
    },
    {
        "problem_name": "maximum-sum-with-exactly-k-elements",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def maximizeSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return max(nums)*k+k*(k-1)//2\n"
    },
    {
        "problem_name": "maximum-swap",
        "solution": "# Time:  O(logn), logn is the length of the number string\n# Space: O(logn)\n\nclass Solution(object):\n    def maximumSwap(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        digits = list(str(num))\n        left, right = 0, 0\n        max_idx = len(digits)-1\n        for i in reversed(xrange(len(digits))):\n            if digits[i] > digits[max_idx]:\n                max_idx = i\n            elif digits[max_idx] > digits[i]:\n                left, right = i, max_idx\n        digits[left], digits[right] = digits[right], digits[left]\n        return int(\"\".join(digits))\n\n"
    },
    {
        "problem_name": "maximum-tastiness-of-candy-basket",
        "solution": "# Time:  O(nlogr), r = max(price)-min(price)\n# Space: O(1)\n\n# binary search, greedy\nclass Solution(object):\n    def maximumTastiness(self, price, k):\n        \"\"\"\n        :type price: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(x):  # max cnt if smallest absolute difference >= x\n            cnt = prev = 0\n            for i in xrange(len(price)):\n                if prev and price[i]-prev < x:\n                    continue\n                cnt += 1\n                if cnt == k:\n                    break\n                prev = price[i]\n            return cnt >= k\n\n        price.sort()\n        left, right = 1, price[-1]-price[0]\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return right\n"
    },
    {
        "problem_name": "maximum-total-beauty-of-the-gardens",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nimport bisect\n\n\n# sort, prefix sum, greedy, two pointers, improved from solution3\nclass Solution(object):\n    def maximumBeauty(self, flowers, newFlowers, target, full, partial):\n        \"\"\"\n        :type flowers: List[int]\n        :type newFlowers: int\n        :type target: int\n        :type full: int\n        :type partial: int\n        :rtype: int\n        \"\"\"\n        flowers.sort()\n        n = bisect.bisect_left(flowers, target)\n        prefix, suffix = 0, sum(flowers[i] for i in xrange(n))\n        result = left = 0\n        for right in xrange(n+1):\n            if right:\n                suffix -= flowers[right-1]\n            total = newFlowers-((n-right)*target-suffix)\n            if total < 0:\n                continue\n            while not (left == right or (left and (total+prefix)//left <= flowers[left])):\n                prefix += flowers[left]\n                left += 1\n            mn = min((total+prefix)//left if left else 0, target-1)\n            result = max(result, mn*partial+(len(flowers)-right)*full)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(1)\nimport bisect\n\n\n# sort, prefix sum, greedy, two pointers, improved from solution4\nclass Solution2(object):\n    def maximumBeauty(self, flowers, newFlowers, target, full, partial):\n        \"\"\"\n        :type flowers: List[int]\n        :type newFlowers: int\n        :type target: int\n        :type full: int\n        :type partial: int\n        :rtype: int\n        \"\"\"\n        flowers.sort()\n        n = bisect.bisect_left(flowers, target)\n        prefix = [0]*(n+1)\n        for i in xrange(n):\n            prefix[i+1] = prefix[i]+flowers[i]\n        result = suffix = 0\n        left = n\n        for right in reversed(xrange(n+1)):\n            if right != n:\n                suffix += flowers[right]\n            total = newFlowers-((n-right)*target-suffix)\n            if total < 0:\n                continue\n            left = min(left, right)\n            while not (left == 0 or (prefix[left]-prefix[left-1])*left-prefix[left] <= total):\n                left -= 1\n            mn = min((total+prefix[left])//left if left else 0, target-1)\n            result = max(result, mn*partial+(len(flowers)-right)*full)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport bisect\n\n\n# sort, prefix sum, greedy, binary search\nclass Solution3(object):\n    def maximumBeauty(self, flowers, newFlowers, target, full, partial):\n        \"\"\"\n        :type flowers: List[int]\n        :type newFlowers: int\n        :type target: int\n        :type full: int\n        :type partial: int\n        :rtype: int\n        \"\"\"\n        def check(prefix, total, x):\n            return x and (total+prefix[x])//x <= prefix[x+1]-prefix[x]\n\n        def binary_search(prefix, total, left, right):\n            while left <= right:\n                mid = left+(right-left)//2\n                if check(prefix, total, mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n    \n        flowers.sort()\n        n = bisect.bisect_left(flowers, target)\n        prefix = [0]*(n+1)\n        for i in xrange(n):\n            prefix[i+1] = prefix[i]+flowers[i]\n        suffix = sum(flowers[i] for i in xrange(n))\n        result = left = 0\n        for right in xrange(n+1):\n            if right:\n                suffix -= flowers[right-1]\n            total = newFlowers-((n-right)*target-suffix)\n            if total < 0:\n                continue\n            left = binary_search(prefix, total, 0, right-1)\n            mn = min((total+prefix[left])//left if left else 0, target-1)\n            result = max(result, mn*partial+(len(flowers)-right)*full)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport bisect\n\n\n# sort, prefix sum, greedy, binary search\nclass Solution4(object):\n    def maximumBeauty(self, flowers, newFlowers, target, full, partial):\n        \"\"\"\n        :type flowers: List[int]\n        :type newFlowers: int\n        :type target: int\n        :type full: int\n        :type partial: int\n        :rtype: int\n        \"\"\"\n        def check(prefix, total, x):\n            return (prefix[x]-prefix[x-1])*x-prefix[x] <= total\n\n        def binary_search_right(prefix, total, left, right):\n            while left <= right:\n                mid = left+(right-left)//2\n                if not check(prefix, total, mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return right\n    \n        flowers.sort()\n        n = bisect.bisect_left(flowers, target)\n        prefix = [0]*(n+1)\n        for i in xrange(n):\n            prefix[i+1] = prefix[i]+flowers[i]\n        result = suffix = 0\n        left = n\n        for right in reversed(xrange(n+1)):\n            if right != n:\n                suffix += flowers[right]\n            total = newFlowers-((n-right)*target-suffix)\n            if total < 0:\n                break\n            left = binary_search_right(prefix, total, 1, right)\n            mn = min((total+prefix[left])//left if left else 0, target-1)\n            result = max(result, mn*partial+(len(flowers)-right)*full)\n        return result\n"
    },
    {
        "problem_name": "maximum-total-importance-of-roads",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# greedy, counting sort\nclass Solution(object):\n    def maximumImportance(self, n, roads):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def inplace_counting_sort(nums, reverse=False):  # Time: O(n)\n            count = [0]*(max(nums)+1)\n            for num in nums:\n                count[num] += 1\n            for i in xrange(1, len(count)):\n                count[i] += count[i-1]\n            for i in reversed(xrange(len(nums))):  # inplace but unstable sort\n                while nums[i] >= 0:\n                    count[nums[i]] -= 1\n                    j = count[nums[i]]\n                    nums[i], nums[j] = nums[j], ~nums[i]\n            for i in xrange(len(nums)):\n                nums[i] = ~nums[i]  # restore values\n            if reverse:  # unstable sort\n                nums.reverse()\n\n        degree = [0]*n\n        for a, b in roads:\n            degree[a] += 1\n            degree[b] += 1\n        inplace_counting_sort(degree)\n        return sum(i*x for i, x in enumerate(degree, 1))\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# greedy, sort\nclass Solution2(object):\n    def maximumImportance(self, n, roads):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        degree = [0]*n\n        for a, b in roads:\n            degree[a] += 1\n            degree[b] += 1\n        degree.sort()\n        return sum(i*x for i, x in enumerate(degree, 1))\n"
    },
    {
        "problem_name": "maximum-trailing-zeros-in-a-cornered-path",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nimport itertools\n\n\n# prefix sum\nclass Solution(object):\n    def maxTrailingZeros(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def factor(x):\n            cnt = [0]*2\n            for i, p in enumerate([2, 5]):\n                while x and x%p == 0:\n                    x //= p\n                    cnt[i] += 1\n            return cnt\n\n        def add(a, b):\n            return [x+y for x, y in itertools.izip(a, b)]\n\n        def sub(a, b):\n            return [x-y for x, y in itertools.izip(a, b)]\n\n        left = [[None for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))]\n        for i in xrange(len(grid)):\n            left[i][0] = factor(grid[i][0])\n            for j in xrange(1, len(grid[0])):\n                left[i][j] = add(left[i][j-1], factor(grid[i][j]))\n        result = 0\n        for j in xrange(len(grid[0])):\n            total = [0]*2\n            for i in xrange(len(grid)):\n                total = add(total, factor(grid[i][j]))\n            up = [0]*2\n            for i in xrange(len(grid)):\n                right = sub(left[i][-1], left[i][j-1] if j else [0]*2)\n                result = max(result, min(add(left[i][j], up)), min(add(right, up)))\n                up = add(up, factor(grid[i][j]))\n                down = sub(total, up)\n                result = max(result, min(add(left[i][j], down)), min(add(right, down)))\n        return result\n"
    },
    {
        "problem_name": "maximum-twin-sum-of-a-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution(object):\n    def pairSum(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: int\n        \"\"\"\n        def reverseList(head):\n            dummy = ListNode()\n            while head:\n                dummy.next, head.next, head = head, dummy.next, head.next\n            return dummy.next\n\n        dummy = ListNode(next=head)\n        slow = fast = dummy\n        while fast.next and fast.next.next:\n            slow, fast = slow.next, fast.next.next\n        result = 0\n        head2 = reverseList(slow)\n        while head:\n            result = max(result, head.val+head2.val)\n            head, head2 = head.next, head2.next\n        return result\n"
    },
    {
        "problem_name": "maximum-units-on-a-truck",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def maximumUnits(self, boxTypes, truckSize):\n        \"\"\"\n        :type boxTypes: List[List[int]]\n        :type truckSize: int\n        :rtype: int\n        \"\"\"\n        boxTypes.sort(key=lambda x: x[1], reverse=True)\n        result = 0\n        for box, units in boxTypes:\n            if truckSize > box:\n                truckSize -= box\n                result += box*units\n            else:\n                result += truckSize*units\n                break\n        return result\n"
    },
    {
        "problem_name": "maximum-vacation-days",
        "solution": "# Time:  O(n^2 * k)\n# Space: O(k)\n\nclass Solution(object):\n    def maxVacationDays(self, flights, days):\n        \"\"\"\n        :type flights: List[List[int]]\n        :type days: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not days or not flights:\n            return 0\n        dp = [[0] * len(days) for _ in xrange(2)]\n        for week in reversed(xrange(len(days[0]))):\n            for cur_city in xrange(len(days)):\n                dp[week % 2][cur_city] = days[cur_city][week] + dp[(week+1) % 2][cur_city]\n                for dest_city in xrange(len(days)):\n                    if flights[cur_city][dest_city] == 1:\n                        dp[week % 2][cur_city] = max(dp[week % 2][cur_city], \\\n                                                     days[dest_city][week] + dp[(week+1) % 2][dest_city])\n        return dp[0][0]\n\n"
    },
    {
        "problem_name": "maximum-value-after-insertion",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxValue(self, n, x):\n        \"\"\"\n        :type n: str\n        :type x: int\n        :rtype: str\n        \"\"\"\n        check = (lambda i: str(x) > n[i]) if n[0] != '-' else (lambda i: str(x) < n[i])\n        for i in xrange(len(n)):\n            if check(i):\n                break\n        else:\n            i = len(n)\n        return n[:i] + str(x) + n[i:]\n"
    },
    {
        "problem_name": "maximum-value-at-a-given-index-in-a-bounded-array",
        "solution": "# Time:  O(logm)\n# Space: O(1)\n\nclass Solution(object):\n    def maxValue(self, n, index, maxSum):\n        \"\"\"\n        :type n: int\n        :type index: int\n        :type maxSum: int\n        :rtype: int\n        \"\"\"\n        def check(n, index, maxSum, x):\n            y = max(x-index, 0)\n            total = (x+y)*(x-y+1)//2\n            y = max(x-((n-1)-index), 0)\n            total += (x+y)*(x-y+1)//2\n            return total-x <= maxSum\n\n        maxSum -= n\n        left, right = 0, maxSum\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(n, index, maxSum, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return 1+right\n"
    },
    {
        "problem_name": "maximum-value-of-a-string-in-an-array",
        "solution": "# Time:  O(n * l)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def maximumValue(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: int\n        \"\"\"\n        return max(int(s) if s.isdigit() else len(s) for s in strs)\n"
    },
    {
        "problem_name": "maximum-value-of-an-ordered-triplet-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def maximumTripletValue(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        result = 0\n        mx_diff = mx = NEG_INF\n        for x in nums:\n            if mx_diff != NEG_INF:\n                result = max(result, mx_diff*x)\n            if mx != NEG_INF:\n                mx_diff = max(mx_diff, mx-x)\n            mx = max(mx, x)\n        return result\n"
    },
    {
        "problem_name": "maximum-value-of-an-ordered-triplet-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def maximumTripletValue(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        NEG_INF = float(\"-inf\")\n        result = 0\n        mx_diff = mx = NEG_INF\n        for x in nums:\n            if mx_diff != NEG_INF:\n                result = max(result, mx_diff*x)\n            if mx != NEG_INF:\n                mx_diff = max(mx_diff, mx-x)\n            mx = max(mx, x)\n        return result\n"
    },
    {
        "problem_name": "maximum-value-of-k-coins-from-piles",
        "solution": "# Time:  O(min(n * k^2, m * k)), m = sum(len(pile) for pile in piles)\n# Space: O(k)\n\n# dp\nclass Solution(object):\n    def maxValueOfCoins(self, piles, k):\n        \"\"\"\n        :type piles: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        dp = [0]\n        for pile in piles:\n            new_dp = [0]*min(len(dp)+len(pile), k+1)\n            for i in xrange(len(dp)):\n                curr = 0\n                for j in xrange(min(k-i, len(pile))+1):\n                    new_dp[i+j] = max(new_dp[i+j], dp[i]+curr)\n                    curr += pile[j] if j < len(pile) else 0\n            dp = new_dp\n        return dp[-1]\n"
    },
    {
        "problem_name": "maximum-white-tiles-covered-by-a-carpet",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sliding window, optimized from solution3\nclass Solution(object):\n    def maximumWhiteTiles(self, tiles, carpetLen):\n        \"\"\"\n        :type tiles: List[List[int]]\n        :type carpetLen: int\n        :rtype: int\n        \"\"\"\n        tiles.sort()\n        result = right = gap = 0\n        for left, (l, _) in enumerate(tiles):\n            if left-1 >= 0:\n                gap -= tiles[left][0]-tiles[left-1][1]-1\n            r = l+carpetLen-1\n            while right+1 < len(tiles) and r+1 >= tiles[right+1][0]:\n                right += 1\n                gap += tiles[right][0]-tiles[right-1][1]-1\n            result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# sliding window, optimized from solution4\nclass Solution2(object):\n    def maximumWhiteTiles(self, tiles, carpetLen):\n        \"\"\"\n        :type tiles: List[List[int]]\n        :type carpetLen: int\n        :rtype: int\n        \"\"\"\n        tiles.sort()\n        result = left = gap = 0\n        for right in xrange(len(tiles)):\n            if right-1 >= 0:\n                gap += tiles[right][0]-tiles[right-1][1]-1\n            l = tiles[right][1]-carpetLen+1\n            while not (tiles[left][1]+1 >= l):\n                left += 1\n                gap -= tiles[left][0]-tiles[left-1][1]-1\n            result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport bisect\n\n\n# prefix sum, binary search\nclass Solution3(object):\n    def maximumWhiteTiles(self, tiles, carpetLen):\n        \"\"\"\n        :type tiles: List[List[int]]\n        :type carpetLen: int\n        :rtype: int\n        \"\"\"\n        tiles.sort()\n        prefix = [0]*(len(tiles)+1)\n        for i, (l, r) in enumerate(tiles):\n            prefix[i+1] = prefix[i]+(r-l+1)\n        result = 0\n        for left, (l, _) in enumerate(tiles):\n            r = l+carpetLen-1\n            right = bisect.bisect_right(tiles, [r+1])-1\n            extra = max(tiles[right][1]-r, 0)\n            result = max(result, (prefix[right+1]-prefix[left])-extra)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport bisect\n\n\n# prefix sum, binary search\nclass Solution4(object):\n    def maximumWhiteTiles(self, tiles, carpetLen):\n        \"\"\"\n        :type tiles: List[List[int]]\n        :type carpetLen: int\n        :rtype: int\n        \"\"\"\n        tiles.sort()\n        prefix = [0]*(len(tiles)+1)\n        for i, (l, r) in enumerate(tiles):\n            prefix[i+1] = prefix[i]+(r-l+1)\n        result = 0\n        for right, (_, r) in enumerate(tiles):\n            l = r-carpetLen+1\n            left = bisect.bisect_right(tiles, [l])\n            if left-1 >= 0 and tiles[left-1][1]+1 >= l:\n                left -= 1\n            extra = max(l-tiles[left][0], 0)\n            result = max(result, (prefix[right+1]-prefix[left])-extra)\n        return result\n"
    },
    {
        "problem_name": "maximum-width-of-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def widthOfBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node, i, depth, leftmosts):\n            if not node:\n                return 0\n            if depth >= len(leftmosts):\n                leftmosts.append(i)\n            return max(i-leftmosts[depth]+1, \\\n                       dfs(node.left, i*2, depth+1, leftmosts), \\\n                       dfs(node.right, i*2+1, depth+1, leftmosts))\n\n        leftmosts = []\n        return dfs(root, 1, 0, leftmosts)\n\n"
    },
    {
        "problem_name": "maximum-width-ramp",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def maxWidthRamp(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        s = []\n        for i in A:\n            if not s or A[s[-1]] > A[i]:\n                s.append(i)\n        for j in reversed(xrange(len(A))):\n            while s and A[s[-1]] <= A[j]:\n                result = max(result, j-s.pop())\n        return result\n"
    },
    {
        "problem_name": "maximum-xor-after-operations",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def maximumXOR(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return reduce(lambda x, y: x|y, nums)\n"
    },
    {
        "problem_name": "maximum-xor-for-each-query",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def getMaximumXor(self, nums, maximumBit):\n        \"\"\"\n        :type nums: List[int]\n        :type maximumBit: int\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(nums)\n        mask = 2**maximumBit-1\n        for i in xrange(len(nums)):\n            mask ^= nums[i]\n            result[-1-i] = mask\n        return result\n"
    },
    {
        "problem_name": "maximum-xor-of-two-non-overlapping-subtrees",
        "solution": "# Time:  O(nlogr), r is sum(values)\n# Space: O(n)\n\n# iterative dfs, trie, greedy\nclass Trie(object):\n    def __init__(self, bit_length):\n        self.__root = {}\n        self.__bit_length = bit_length\n        \n    def insert(self, num):\n        node = self.__root\n        for i in reversed(xrange(self.__bit_length)):\n            curr = (num>>i) & 1\n            if curr not in node:\n                node[curr] = {}\n            node = node[curr]\n                \n    def query(self, num):\n        if not self.__root: \n            return -1\n        node, result = self.__root, 0\n        for i in reversed(xrange(self.__bit_length)):\n            curr = (num>>i) & 1\n            if 1^curr in node:\n                node = node[1^curr]\n                result |= 1<<i\n            else:\n                node = node[curr]\n        return result\n\n\nclass Solution(object):\n    def maxXor(self, n, edges, values):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type values: List[int]\n        :rtype: int\n        \"\"\"\n        def iter_dfs():\n            lookup = [0]*len(values)\n            stk = [(1, 0, -1)]\n            while stk:\n                step, u, p = stk.pop()\n                if step == 1:\n                    stk.append((2, u, p))\n                    for v in adj[u]:\n                        if v == p:\n                            continue\n                        stk.append((1, v, u))\n                elif step == 2:\n                    lookup[u] = values[u]+sum(lookup[v] for v in adj[u] if v != p)\n            return lookup\n\n        def iter_dfs2():\n            trie = Trie(lookup[0].bit_length())\n            result = [0]\n            stk = [(1, (0, -1, result))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    u, p, ret = args\n                    ret[0] = max(trie.query(lookup[u]), 0)\n                    stk.append((3, (u,)))\n                    for v in adj[u]:\n                        if v == p:\n                            continue\n                        new_ret = [0]\n                        stk.append((2, (new_ret, ret)))\n                        stk.append((1, (v, u, new_ret)))\n                elif step == 2:\n                    new_ret, ret = args\n                    ret[0] = max(ret[0], new_ret[0])\n                elif step == 3:\n                    u = args[0]\n                    trie.insert(lookup[u])\n            return result[0]\n        \n        adj = [[] for _ in xrange(len(values))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        lookup = iter_dfs()\n        return iter_dfs2()\n\n\n# Time:  O(nlogr), r is sum(values)\n# Space: O(n)\n# dfs, trie, greedy\nclass Trie(object):\n    def __init__(self, bit_length):\n        self.__root = {}\n        self.__bit_length = bit_length\n        \n    def insert(self, num):\n        node = self.__root\n        for i in reversed(xrange(self.__bit_length)):\n            curr = (num>>i) & 1\n            if curr not in node:\n                node[curr] = {}\n            node = node[curr]\n                \n    def query(self, num):\n        if not self.__root: \n            return -1\n        node, result = self.__root, 0\n        for i in reversed(xrange(self.__bit_length)):\n            curr = (num>>i) & 1\n            if 1^curr in node:\n                node = node[1^curr]\n                result |= 1<<i\n            else:\n                node = node[curr]\n        return result\n\n\nclass Solution2(object):\n    def maxXor(self, n, edges, values):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type values: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(u, p):\n            lookup[u] = values[u]+sum(dfs(v, u) for v in adj[u] if v != p)\n            return lookup[u]\n\n        def dfs2(u, p):\n            result = max(trie.query(lookup[u]), 0)\n            for v in adj[u]:\n                if v == p:\n                    continue\n                result = max(result, dfs2(v, u))\n            trie.insert(lookup[u])\n            return result\n        \n        adj = [[] for _ in xrange(len(values))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        lookup = [0]*len(values)\n        dfs(0, -1)\n        trie = Trie(lookup[0].bit_length())\n        return dfs2(0, -1)\n"
    },
    {
        "problem_name": "maximum-xor-of-two-numbers-in-an-array",
        "solution": "# Time:  O(nlogr), r = max(nums)\n# Space: O(t)\n\nclass Solution(object):\n    def findMaximumXOR(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        class Trie(object):\n            def __init__(self, bit_length):\n                self.__nodes = []\n                self.__new_node()\n                self.__bit_length = bit_length\n            \n            def __new_node(self):\n                self.__nodes.append([-1]*2)\n                return len(self.__nodes)-1\n\n            def insert(self, num):\n                curr = 0\n                for i in reversed(xrange(self.__bit_length)):\n                    x = num>>i\n                    if self.__nodes[curr][x&1] == -1:\n                        self.__nodes[curr][x&1] = self.__new_node()\n                    curr = self.__nodes[curr][x&1]\n                        \n            def query(self, num):\n                result = curr = 0\n                for i in reversed(xrange(self.__bit_length)):\n                    result <<= 1\n                    x = num>>i\n                    if self.__nodes[curr][1^(x&1)] != -1:\n                        curr = self.__nodes[curr][1^(x&1)]\n                        result |= 1\n                    else:\n                        curr = self.__nodes[curr][x&1]\n                return result\n\n        trie = Trie(max(nums).bit_length())\n        result = 0\n        for num in nums:\n            trie.insert(num)\n            result = max(result, trie.query(num))\n        return result\n\n\n# Time:  O(nlogr), r = max(nums)\n# Space: O(n)\nclass Solution2(object):\n    def findMaximumXOR(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in reversed(xrange(max(nums).bit_length())):\n            result <<= 1\n            prefixes = set()\n            for n in nums:\n                prefixes.add(n >> i)\n            for p in prefixes:\n                if (result | 1) ^ p in prefixes:\n                    result |= 1\n                    break\n        return result\n"
    },
    {
        "problem_name": "maximum-xor-product",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def maximumXorProduct(self, a, b, n):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        for i in reversed(xrange(n)):\n            base = 1<<i\n            if min(a, b)&base == 0:\n                a, b = a^base, b^base\n        return (a%MOD)*(b%MOD)%MOD\n"
    },
    {
        "problem_name": "maximum-xor-with-an-element-from-array",
        "solution": "# Time:  O(nlogn + mlogm + nlogk + mlogk), k is max(max(nums), max(xi))\n# Space: O(nlogk)\n\nclass Trie(object):\n    def __init__(self, bit_length):\n        self.__root = {}\n        self.__bit_length = bit_length\n        \n    def insert(self, num):\n        node = self.__root\n        for i in reversed(xrange(self.__bit_length)):\n            curr = (num>>i) & 1\n            if curr not in node:\n                node[curr] = {}\n            node = node[curr]\n                \n    def query(self, num):\n        if not self.__root: \n            return -1\n        node, result = self.__root, 0\n        for i in reversed(xrange(self.__bit_length)):\n            curr = (num>>i) & 1\n            if 1^curr in node:\n                node = node[1^curr]\n                result |= 1<<i\n            else:\n                node = node[curr]\n        return result\n\n\nclass Solution(object):\n    def maximizeXor(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        max_val = max(nums[-1], max(queries, key=lambda x: x[0])[0])\n        queries = sorted(enumerate(queries), key=lambda x: x[1][1])        \n        trie = Trie(max_val.bit_length())\n        result = [-1]*len(queries)\n        j = 0\n        for i, (x, m) in queries:\n            while j < len(nums) and nums[j] <= m:\n                trie.insert(nums[j])\n                j += 1\n            result[i] = trie.query(x)\n        return result\n"
    },
    {
        "problem_name": "mean-of-array-after-removing-some-elements",
        "solution": "# Time:  O(n) on average, using Median of Medians could achieve O(n) (Intro Select)\n# Space: O(1)\n\nimport random\n\n\nclass Solution(object):\n    def trimMean(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: float\n        \"\"\"\n        P = 20\n        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            right = len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n        \n        k = len(arr)//P\n        nth_element(arr, k-1)\n        nth_element(arr, len(arr)-k, left=k)\n        return float(sum(arr[i] for i in xrange(k, len(arr)-k)))/(len(arr)-2*k)\n"
    },
    {
        "problem_name": "median-of-a-row-wise-sorted-matrix",
        "solution": "# Time:  O(logr * mlogn), r = O(right-left+1) = O(10^6), O(logr) = O(20)\n# Space: O(1)\n\nimport bisect\n\n\n# binary search\nclass Solution(object):\n    def matrixMedian(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def check(x):\n            return sum(bisect_right(row, x) for row in grid) > (len(grid)*len(grid[0]))//2\n\n        left, right = min(row[0] for row in grid), max(row[-1] for row in grid)\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "median-of-two-sorted-arrays",
        "solution": "# Time:  O(log(min(m, n)))\n# Space: O(1)\n\nclass Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        len1, len2 = len(nums1), len(nums2)\n        if (len1 + len2) % 2 == 1:\n            return self.getKth(nums1, nums2, (len1 + len2)/2 + 1)\n        else:\n            return (self.getKth(nums1, nums2, (len1 + len2)/2) +\n                    self.getKth(nums1, nums2, (len1 + len2)/2 + 1)) * 0.5\n\n    def getKth(self, A, B, k):\n        m, n = len(A), len(B)\n        if m > n:\n            m, n = n, m\n            A, B = B, A\n\n        left, right = 0, m - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if 0 <= k - 1 - mid < n and A[mid] >= B[k - 1 - mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        Ai_minus_1 = A[left - 1] if left - 1 >= 0 else float(\"-inf\")\n        Bj = B[k - 1 - left] if k - 1 - left >= 0 else float(\"-inf\")\n\n        return max(Ai_minus_1, Bj)\n\n\n# Time:  O(log(max(m, n)) * log(max_val - min_val))\n# Space: O(1)\n# Generic solution.\nclass Solution_Generic(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        array = [nums1, nums2]\n        total = sum(len(nums) for nums in array)\n        if total % 2 == 1:\n            return self.getKth(array, total//2 + 1)\n        else:\n            return (self.getKth(array, total//2) +\n                    self.getKth(array, total//2 + 1)) * 0.5\n\n    def getKth(self, arrays, k):\n        def binary_search(array, left, right, target, check):\n            while left <= right:\n                mid = left + (right-left)//2\n                if check(array, mid, target):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        def check(arrays, num, target):\n            res = 0\n            for array in arrays:\n                if array:  # count the number of values which are less or equal to num\n                    res += binary_search(array, 0, len(array) - 1, num,\n                                         lambda array, x, y: array[x] > y)\n            return res >= target\n\n        left, right = float(\"inf\"), float(\"-inf\")\n        for array in arrays:\n            if array:\n                left = min(left, array[0])\n                right = max(right, array[-1])\n        return binary_search(arrays, left, right, k, check)\n\nclass Solution_3(object):\n    def findMedianSortedArrays(self, A, B):\n\n        if A is None and B is None:\n            return -1.0\n        lenA = len(A)\n        lenB = len(B)\n        lenn = lenA + lenB\n\n        indexA,indexB,indexC = 0,0,0\n        C = [False for i in xrange(lenn)]\n        while indexA < lenA and indexB < lenB:\n            if A[indexA] < B[indexB]:\n                C[indexC] = A[indexA]\n                indexC += 1\n                indexA += 1\n            else:\n                C[indexC] = B[indexB]\n                indexC += 1\n                indexB += 1\n\n        while indexA < lenA:\n            C[indexC] = A[indexA]\n            indexC += 1\n            indexA += 1\n\n        while indexB < lenB:\n            C[indexC] = B[indexB]\n            indexC += 1\n            indexB += 1\n\n        indexM1 = (lenn - 1) / 2\n        indexM2 = lenn / 2\n\n        if (lenn % 2 == 0):\n            return (C[indexM1] + C[indexM2]) / 2.0\n        else:\n            return C[indexM2] / 1.0\n\n"
    },
    {
        "problem_name": "meeting-rooms-ii",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    # @param {Interval[]} intervals\n    # @return {integer}\n    def minMeetingRooms(self, intervals):\n        result, curr = 0, 0\n        line = [x for i, j in intervals for x in [[i, 1], [j, -1]]]\n        line.sort()\n        for _, num in line:\n            curr += num\n            result = max(result, curr)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nclass Solution2(object):\n    # @param {Interval[]} intervals\n    # @return {integer}\n    def minMeetingRooms(self, intervals):\n        starts, ends = [], []\n        for start, end in intervals:\n            starts.append(start)\n            ends.append(end)\n\n        starts.sort()\n        ends.sort()\n\n        s, e = 0, 0\n        min_rooms, cnt_rooms = 0, 0\n        while s < len(starts):\n            if starts[s] < ends[e]:\n                cnt_rooms += 1  # Acquire a room.\n                # Update the min number of rooms.\n                min_rooms = max(min_rooms, cnt_rooms)\n                s += 1\n            else:\n                cnt_rooms -= 1  # Release a room.\n                e += 1\n\n        return min_rooms\n\n\n# Time: O(nlogn)\n# Space: O(n)\nfrom heapq import heappush, heappop\n\n\nclass Solution3(object):\n    def minMeetingRooms(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n        \n        intervals.sort(key=lambda x: x[0])\n        free_rooms = []\n        \n        heappush(free_rooms, intervals[0][1])\n        for interval in intervals[1:]:\n            if free_rooms[0] <= interval[0]:\n                heappop(free_rooms)\n            \n            heappush(free_rooms, interval[1])\n        \n        return len(free_rooms)\n"
    },
    {
        "problem_name": "meeting-rooms-iii",
        "solution": "# Time:  O(mlogm + n + mlogn)\n# Space: O(n)\n\nimport heapq\n\n\n# one heap solution\nclass Solution(object):\n    def mostBooked(self, n, meetings):\n        \"\"\"\n        :type n: int\n        :type meetings: List[List[int]]\n        :rtype: int\n        \"\"\"\n        meetings.sort()\n        min_heap = [(meetings[0][0], i) for i in xrange(n)]\n        result = [0]*n\n        for s, e in meetings:\n            while min_heap and min_heap[0][0] < s:\n                _, i = heapq.heappop(min_heap)\n                heapq.heappush(min_heap, (s, i))\n            e2, i = heapq.heappop(min_heap)\n            heapq.heappush(min_heap, (e2+(e-s), i))\n            result[i] += 1\n        return max(xrange(n), key=lambda x:result[x])\n\n\n# Time:  O(mlogm + n + mlogn)\n# Space: O(n)\nimport heapq\n\n\n# two heaps solution\nclass Solution2(object):\n    def mostBooked(self, n, meetings):\n        \"\"\"\n        :type n: int\n        :type meetings: List[List[int]]\n        :rtype: \n        \"\"\"\n        meetings.sort()\n        unused, used = range(n), []\n        result = [0]*n\n        for s, e in meetings:\n            while used and used[0][0] <= s:\n                _, i = heapq.heappop(used)\n                heapq.heappush(unused, i)\n            if unused:\n                i = heapq.heappop(unused)\n                heapq.heappush(used, (e, i))\n            else:\n                e2, i = heapq.heappop(used)\n                heapq.heappush(used, (e2+(e-s), i))\n            result[i] += 1\n        return max(xrange(n), key=lambda x:result[x])\n"
    },
    {
        "problem_name": "meeting-rooms",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def canAttendMeetings(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        intervals.sort(key=lambda x: x[0])\n\n        for i in xrange(1, len(intervals)):\n            if intervals[i][0] < intervals[i-1][1]:\n                return False\n        return True\n"
    },
    {
        "problem_name": "meeting-scheduler",
        "solution": "# Time:  O(n) ~ O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def minAvailableDuration(self, slots1, slots2, duration):\n        \"\"\"\n        :type slots1: List[List[int]]\n        :type slots2: List[List[int]]\n        :type duration: int\n        :rtype: List[int]\n        \"\"\"\n        min_heap = list(filter(lambda slot: slot[1] - slot[0] >= duration, slots1 + slots2))\n        heapq.heapify(min_heap)  # Time: O(n)\n        while len(min_heap) > 1:\n            left = heapq.heappop(min_heap)  # Time: O(logn)\n            right = min_heap[0]\n            if left[1]-right[0] >= duration:\n                return [right[0], right[0]+duration] \n        return []   \n\n\n# Time:  O(nlogn)\n# Space: O(n)\nclass Solution2(object):\n    def minAvailableDuration(self, slots1, slots2, duration):\n        \"\"\"\n        :type slots1: List[List[int]]\n        :type slots2: List[List[int]]\n        :type duration: int\n        :rtype: List[int]\n        \"\"\"\n        slots1.sort(key = lambda x: x[0])\n        slots2.sort(key = lambda x: x[0])\n        i, j = 0, 0\n        while i < len(slots1) and j < len(slots2):\n            left = max(slots1[i][0], slots2[j][0])\n            right = min(slots1[i][1], slots2[j][1])\n            if left+duration <= right:\n                return [left, left+duration]\n            if slots1[i][1] < slots2[j][1]:\n                i += 1\n            else:\n                j += 1\n        return []\n"
    },
    {
        "problem_name": "merge-bsts-to-create-single-bst",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\nclass Solution(object):\n    def canMerge(self, trees):\n        \"\"\"\n        :type trees: List[TreeNode]\n        :rtype: TreeNode\n        \"\"\"\n        def find_leaves_and_roots(trees, leaf_vals_set, val_to_root):\n            for root in trees:\n                val_to_root[root.val] = root\n                q = [root]\n                while q:\n                    new_q = []\n                    for node in q:\n                        if node.left is None and node.right is None:\n                            if node is not root:\n                                leaf_vals_set.add(node.val)\n                            continue\n                        if node.left:\n                            new_q.append(node.left)\n                        if node.right:\n                            new_q.append(node.right)\n                    q = new_q\n\n        def find_root(trees, left_vals_set, val_to_root):\n            root = None\n            for node in trees:\n                if node.val in leaf_vals_set:\n                    continue\n                if root:  # multiple roots\n                    return None\n                root = node\n            return root\n\n        def merge_bsts(root, left_vals_set, val_to_root):\n            if not root:\n                return None\n            del val_to_root[root.val]\n            q = [(root, float(\"-inf\"), float(\"inf\"))]\n            while q:\n                new_q = []\n                for node, left, right in q:\n                    if not (left < node.val < right):\n                        return None\n                    if node.left:\n                        if node.left.val in leaf_vals_set and node.left.val in val_to_root:\n                            node.left = val_to_root[node.left.val]\n                            del val_to_root[node.left.val]\n                        new_q.append((node.left, left, node.val))\n                    if node.right:\n                        if node.right.val in leaf_vals_set and node.right.val in val_to_root:\n                            node.right = val_to_root[node.right.val]\n                            del val_to_root[node.right.val]\n                        new_q.append((node.right, node.val, right))\n                q = new_q\n            return root if not val_to_root else None\n\n        leaf_vals_set, val_to_root = set(), {}\n        find_leaves_and_roots(trees, leaf_vals_set, val_to_root)    \n        root = find_root(trees, leaf_vals_set, val_to_root)\n        return merge_bsts(root, leaf_vals_set, val_to_root)\n"
    },
    {
        "problem_name": "merge-in-between-linked-lists",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        pass\n\n\nclass Solution(object):\n    def mergeInBetween(self, list1, a, b, list2):\n        \"\"\"\n        :type list1: ListNode\n        :type a: int\n        :type b: int\n        :type list2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        prev_first, last = None, list1\n        for i in xrange(b):\n            if i == a-1:\n                prev_first = last\n            last = last.next\n        prev_first.next = list2\n        while list2.next:\n            list2 = list2.next\n        list2.next = last.next\n        last.next = None\n        return list1\n"
    },
    {
        "problem_name": "merge-intervals",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort()\n        result = []\n        for interval in intervals:\n            if not result or interval[0] > result[-1][1]:\n                result.append(interval)\n            else:\n                result[-1][1] = max(result[-1][1], interval[1])\n        return result\n"
    },
    {
        "problem_name": "merge-k-sorted-lists",
        "solution": "# Time:  O(nlogk)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\t\t\n        if self:\t\t\n            return \"{} -> {}\".format(self.val, self.next)\n\n\n# Merge two by two solution.\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        if not lists:\n            return None\n        left, right = 0, len(lists) - 1\n        while right > 0:\n            lists[left] = mergeTwoLists(lists[left], lists[right])\n            left += 1\n            right -= 1\n            if left >= right:\n                left = 0\n        return lists[0]\n\n\n# Time:  O(nlogk)\n# Space: O(logk)\n# Divide and Conquer solution.\nclass Solution2(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        def mergeTwoLists(l1, l2):\n            curr = dummy = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n\n        def mergeKListsHelper(lists, begin, end):\n            if begin > end:\n                return None\n            if begin == end:\n                return lists[begin]\n            return mergeTwoLists(mergeKListsHelper(lists, begin, (begin + end) / 2), \\\n                                 mergeKListsHelper(lists, (begin + end) / 2 + 1, end))\n\n        return mergeKListsHelper(lists, 0, len(lists) - 1)\n\n\n# Time:  O(nlogk)\n# Space: O(k)\n# Heap solution.\nimport heapq\nclass Solution3(object):\n    # @param a list of ListNode\n    # @return a ListNode\n    def mergeKLists(self, lists):\n        dummy = ListNode(0)\n        current = dummy\n\n        heap = []\n        for sorted_list in lists:\n            if sorted_list:\n                heapq.heappush(heap, (sorted_list.val, sorted_list))\n\n        while heap:\n            smallest = heapq.heappop(heap)[1]\n            current.next = smallest\n            current = current.next\n            if smallest.next:\n                heapq.heappush(heap, (smallest.next.val, smallest.next))\n\n        return dummy.next\n\n\n"
    },
    {
        "problem_name": "merge-nodes-in-between-zeros",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        pass\n\n\n# linked list\nclass Solution(object):\n    def mergeNodes(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        curr, zero = head.next, head\n        while curr:\n            if curr.val:\n                zero.val += curr.val\n            else:\n                zero.next = curr if curr.next else None\n                zero = curr\n            curr = curr.next\n        return head\n"
    },
    {
        "problem_name": "merge-operations-to-turn-array-into-a-palindrome",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# constructive algorithms, greedy, two pointers\nclass Solution(object):\n    def minimumOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        left, right = 0, len(nums)-1\n        l, r = nums[left], nums[right]\n        while left < right:\n            if l == r:\n                left += 1\n                right -= 1\n                l, r = nums[left], nums[right]\n                continue\n            if l < r:\n                left += 1\n                l += nums[left]\n            else:\n                right -= 1\n                r += nums[right]\n            result += 1\n        return result\n            \n"
    },
    {
        "problem_name": "merge-similar-items",
        "solution": "# Time:  O((m + n) * log(m + n))\n# Space: O(m + n)\n\n# freq table, sort\nclass Solution(object):\n    def mergeSimilarItems(self, items1, items2):\n        \"\"\"\n        :type items1: List[List[int]]\n        :type items2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        return sorted((Counter(dict(items1))+Counter(dict(items2))).iteritems())\n"
    },
    {
        "problem_name": "merge-sorted-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param A  a list of integers\n    # @param m  an integer, length of A\n    # @param B  a list of integers\n    # @param n  an integer, length of B\n    # @return nothing\n    def merge(self, A, m, B, n):\n        last, i, j = m + n - 1, m - 1, n - 1\n\n        while i >= 0 and j >= 0:\n            if A[i] > B[j]:\n                A[last] = A[i]\n                last, i = last - 1, i - 1\n            else:\n                A[last] = B[j]\n                last, j = last - 1, j - 1\n\n        while j >= 0:\n                A[last] = B[j]\n                last, j = last - 1, j - 1\n\n"
    },
    {
        "problem_name": "merge-strings-alternately",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nclass Solution(object):\n    def mergeAlternately(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: str\n        \"\"\"\n        result = []\n        i = 0\n        while i < len(word1) or i < len(word2):\n            if i < len(word1):\n                result.append(word1[i])\n            if i < len(word2):\n                result.append(word2[i])\n            i += 1\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "merge-triplets-to-form-target-triplet",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def mergeTriplets(self, triplets, target):\n        \"\"\"\n        :type triplets: List[List[int]]\n        :type target: List[int]\n        :rtype: bool\n        \"\"\"\n        result = [0]*3\n        for t in triplets:\n            if all(t[i] <= target[i] for i in xrange(3)):\n                result = [max(result[i], t[i]) for i in xrange(3)]\n        return result == target\n"
    },
    {
        "problem_name": "merge-two-2d-arrays-by-summing-values",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers\nclass Solution(object):\n    def mergeArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[List[int]]\n        :type nums2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i = j = 0\n        while i < len(nums1) or j < len(nums2):\n            if j == len(nums2) or (i < len(nums1) and nums1[i][0] < nums2[j][0]):\n                if result and result[-1][0] == nums1[i][0]:\n                    result[-1][1] += nums1[i][1]\n                else:\n                    result.append(nums1[i])\n                i += 1\n            else:\n                if result and result[-1][0] == nums2[j][0]:\n                    result[-1][1] += nums2[j][1]\n                else:\n                    result.append(nums2[j])\n                j += 1\n        return result\n"
    },
    {
        "problem_name": "merge-two-binary-trees",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def mergeTrees(self, t1, t2):\n        \"\"\"\n        :type t1: TreeNode\n        :type t2: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if t1 is None:\n            return t2\n        if t2 is None:\n            return t1\n        t1.val += t2.val\n        t1.left = self.mergeTrees(t1.left, t2.left)\n        t1.right = self.mergeTrees(t1.right, t2.right)\n        return t1\n\n"
    },
    {
        "problem_name": "merge-two-sorted-lists",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, self.next)\n\n\nclass Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        curr = dummy = ListNode(0)\n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        curr.next = l1 or l2\n        return dummy.next\n\n\n"
    },
    {
        "problem_name": "mice-and-cheese",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport random\n\n\n# greedy, quick select\nclass Solution(object):\n    def miceAndCheese(self, reward1, reward2, k):\n        \"\"\"\n        :type reward1: List[int]\n        :type reward2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n            \n            right = len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n    \n        for i in xrange(len(reward1)):\n            reward1[i] -= reward2[i]\n        nth_element(reward1, k-1, compare=lambda a, b: a > b)\n        return sum(reward2)+sum(reward1[i] for i in xrange(k))\n"
    },
    {
        "problem_name": "middle-of-the-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def middleNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        slow, fast = head, head\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        return slow\n\n"
    },
    {
        "problem_name": "min-cost-climbing-stairs",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minCostClimbingStairs(self, cost):\n        \"\"\"\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [0] * 3\n        for i in reversed(xrange(len(cost))):\n            dp[i%3] = cost[i] + min(dp[(i+1)%3], dp[(i+2)%3])\n        return min(dp[0], dp[1])\n\n"
    },
    {
        "problem_name": "min-cost-to-connect-all-points",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def minCostConnectPoints(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result, u = 0, 0  # we can start from any node as u\n        dist = [float(\"inf\")]*len(points)\n        lookup = set()\n        for _ in xrange(len(points)-1):\n            x0, y0 = points[u]\n            lookup.add(u)\n            for v, (x, y) in enumerate(points):\n                if v in lookup:\n                    continue\n                dist[v] = min(dist[v], abs(x-x0) + abs(y-y0))\n            val, u = min((val, v) for v, val in enumerate(dist)) \n            dist[u] = float(\"inf\")  # used\n            result += val\n        return result\n\n\n\n# Time:  O(eloge) = O(n^2 * logn)\n# Space: O(e) = O(n^2)\n# kruskal's algorithm\nclass UnionFind(object):  # Time: O(n * \u03b1(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:  # union by rank\n            self.set[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.set[y_root] = x_root\n        else:\n            self.set[y_root] = x_root\n            self.rank[x_root] += 1\n        return True\n\n\nclass Solution2(object):\n    def minCostConnectPoints(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        edges = []\n        for u in xrange(len(points)):\n            for v in xrange(u+1, len(points)):\n                edges.append((u, v, abs(points[v][0]-points[u][0]) + abs(points[v][1]-points[u][1])))\n        edges.sort(key=lambda x: x[2])\n        result = 0\n        union_find = UnionFind(len(points))\n        for u, v, val in edges:\n            if union_find.union_set(u, v):\n                result += val\n        return result\n\n"
    },
    {
        "problem_name": "min-max-game",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# simulation, optimized from solution2\nclass Solution(object):\n    def minMaxGame(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        while n != 1:\n            new_q = []\n            for i in xrange(n//2):\n                nums[i] = min(nums[2*i], nums[2*i+1]) if i%2 == 0 else max(nums[2*i], nums[2*i+1])\n            n //= 2\n        return nums[0]\n\n\n# Time:  O(n)\n# Space: O(n)\n# simulation\nclass Solution2(object):\n    def minMaxGame(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        q = nums[:]\n        while len(q) != 1:\n            new_q = []\n            for i in xrange(len(q)//2):\n                new_q.append(min(q[2*i], q[2*i+1]) if i%2 == 0 else max(q[2*i], q[2*i+1]))\n            q = new_q\n        return q[0]\n"
    },
    {
        "problem_name": "min-stack",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass MinStack(object):\n    def __init__(self):\n        self.min = None\n        self.stack = []\n\n    # @param x, an integer\n    # @return an integer\n    def push(self, x):\n        if not self.stack:\n            self.stack.append(0)\n            self.min = x\n        else:\n            self.stack.append(x - self.min)\n            if x < self.min:\n                self.min = x\n\n    # @return nothing\n    def pop(self):\n        x = self.stack.pop()\n        if x < 0:\n            self.min = self.min - x\n\n    # @return an integer\n    def top(self):\n        x = self.stack[-1]\n        if x > 0:\n            return x + self.min\n        else:\n            return self.min\n\n    # @return an integer\n    def getMin(self):\n        return self.min\n\n# Time:  O(n)\n# Space: O(n)\nclass MinStack2(object):\n    def __init__(self):\n        self.stack, self.minStack = [], []\n    # @param x, an integer\n    # @return an integer\n    def push(self, x):\n        self.stack.append(x)\n        if len(self.minStack):\n            if x < self.minStack[-1][0]:\n                self.minStack.append([x, 1])\n            elif x == self.minStack[-1][0]:\n                self.minStack[-1][1] += 1\n        else:\n            self.minStack.append([x, 1])\n\n    # @return nothing\n    def pop(self):\n        x = self.stack.pop()\n        if x == self.minStack[-1][0]:\n            self.minStack[-1][1] -= 1\n            if self.minStack[-1][1] == 0:\n                self.minStack.pop()\n\n    # @return an integer\n    def top(self):\n        return self.stack[-1]\n\n    # @return an integer\n    def getMin(self):\n        return self.minStack[-1][0]\n\n# time: O(1)\n# space: O(n)\n\nclass MinStack3(object):\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):\n        if self.stack:\n            current_min = min(x, self.stack[-1][0])\n            self.stack.append((current_min, x))\n        else:\n            self.stack.append((x, x))\n\n    def pop(self):\n        return self.stack.pop()[1]\n\n    def top(self):\n        return self.stack[-1][1]\n\n    def getMin(self):\n        return self.stack[-1][0]\n"
    },
    {
        "problem_name": "minesweeper",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\n# dfs\nclass Solution(object):\n    def updateBoard(self, board, click):\n        \"\"\"\n        :type board: List[List[str]]\n        :type click: List[int]\n        :rtype: List[List[str]]\n        \"\"\"\n        if board[click[0]][click[1]] == 'M':\n            board[click[0]][click[1]] = 'X'\n            return board\n        stk = [click]\n        while stk:\n            r, c = stk.pop()\n            cnt = 0\n            adj = []\n            for dr in xrange(-1, 2):\n                for dc in xrange(-1, 2):\n                    if dr == dc == 0:\n                        continue\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(board) and 0 <= nc < len(board[r])):\n                        continue\n                    if board[nr][nc] == 'M':\n                        cnt += 1\n                    elif board[nr][nc] == 'E':\n                        adj.append((nr, nc))\n            if cnt:\n                board[r][c] = chr(cnt + ord('0'))\n                continue\n            board[r][c] = 'B'\n            for nr, nc in adj:\n                board[nr][nc] = ' '\n                stk.append((nr, nc))\n        return board\n\n\n# Time:  O(m * n)\n# Space: O(m + n)\n# dfs\nclass Solution2(object):\n    def updateBoard(self, board, click):\n        \"\"\"\n        :type board: List[List[str]]\n        :type click: List[int]\n        :rtype: List[List[str]]\n        \"\"\"\n        if board[click[0]][click[1]] == 'M':\n            board[click[0]][click[1]] = 'X'\n            return board\n        q = [click]\n        while q:\n            new_q = []\n            for r, c in q:\n                cnt = 0\n                adj = []\n                for dr in xrange(-1, 2):\n                    for dc in xrange(-1, 2):\n                        if dr == dc == 0:\n                            continue\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(board) and 0 <= nc < len(board[r])):\n                            continue\n                        if board[nr][nc] == 'M':\n                            cnt += 1\n                        elif board[nr][nc] == 'E':\n                            adj.append((nr, nc))\n                if cnt:\n                    board[r][c] = chr(cnt + ord('0'))\n                    continue\n                board[r][c] = 'B'\n                for nr, nc in adj:\n                    board[nr][nc] = ' '\n                    new_q.append((nr, nc))\n            q = new_q\n        return board\n"
    },
    {
        "problem_name": "mini-parser",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass NestedInteger(object):\n   def __init__(self, value=None):\n       \"\"\"\n       If value is not specified, initializes an empty list.\n       Otherwise initializes a single integer equal to value.\n       \"\"\"\n\n   def isInteger(self):\n       \"\"\"\n       @return True if this NestedInteger holds a single integer, rather than a nested list.\n       :rtype bool\n       \"\"\"\n\n   def add(self, elem):\n       \"\"\"\n       Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n       :rtype void\n       \"\"\"\n\n   def setInteger(self, value):\n       \"\"\"\n       Set this NestedInteger to hold a single integer equal to value.\n       :rtype void\n       \"\"\"\n\n   def getInteger(self):\n       \"\"\"\n       @return the single integer that this NestedInteger holds, if it holds a single integer\n       Return None if this NestedInteger holds a nested list\n       :rtype int\n       \"\"\"\n\n   def getList(self):\n       \"\"\"\n       @return the nested list that this NestedInteger holds, if it holds a nested list\n       Return None if this NestedInteger holds a single integer\n       :rtype List[NestedInteger]\n       \"\"\"\n\n\nclass Solution(object):\n    def deserialize(self, s):\n        if not s:\n            return NestedInteger()\n\n        if s[0] != '[':\n            return NestedInteger(int(s))\n\n        stk = []\n\n        i = 0\n        for j in xrange(len(s)):\n            if s[j] == '[':\n                stk += NestedInteger(),\n                i = j+1\n            elif s[j] in ',]':\n                if s[j-1].isdigit():\n                    stk[-1].add(NestedInteger(int(s[i:j])))\n                if s[j] == ']' and len(stk) > 1:\n                    cur = stk[-1]\n                    stk.pop()\n                    stk[-1].add(cur)\n                i = j+1\n\n        return stk[-1]\n\n"
    },
    {
        "problem_name": "minimize-deviation-in-array",
        "solution": "# Time:  O((n * log(max_num)) * logn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def minimumDeviation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_heap = [-num*2 if num%2 else -num for num in nums]\n        heapq.heapify(max_heap)\n        min_elem = -max(max_heap)\n        result = float(\"inf\")\n        while len(max_heap) == len(nums):\n            num = -heapq.heappop(max_heap)\n            result = min(result, num-min_elem)\n            if not num%2:\n                min_elem = min(min_elem, num//2)\n                heapq.heappush(max_heap, -num//2)\n        return result\n"
    },
    {
        "problem_name": "minimize-hamming-distance-after-swap-operations",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def minimumHammingDistance(self, source, target, allowedSwaps):\n        \"\"\"\n        :type source: List[int]\n        :type target: List[int]\n        :type allowedSwaps: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def iter_flood_fill(adj, node, lookup, idxs):\n            stk = [node]\n            while stk:\n                node = stk.pop()\n                if node in lookup:\n                    continue\n                lookup.add(node)\n                idxs.append(node)\n                for child in adj[node]:\n                    stk.append(child)\n\n        adj = [set() for i in xrange(len(source))]\n        for i, j in allowedSwaps:\n            adj[i].add(j)\n            adj[j].add(i)\n        result = 0\n        lookup = set()\n        for i in xrange(len(source)):\n            if i in lookup:\n                continue\n            idxs = []\n            iter_flood_fill(adj, i, lookup, idxs)\n            source_cnt = collections.Counter([source[i] for i in idxs])\n            target_cnt = collections.Counter([target[i] for i in idxs])\n            diff = source_cnt-target_cnt\n            result += sum(diff.itervalues())\n        return result\n\n\n# Time:  O(n * \u03b1(n)) ~= O(n)\n# Space: O(n)\nimport collections\n\n\nclass UnionFind(object):  # Time: O(n * \u03b1(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:  # union by rank\n            self.set[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.set[y_root] = x_root\n        else:\n            self.set[y_root] = x_root\n            self.rank[x_root] += 1\n        return True\n\n\nclass Solution2(object):\n    def minimumHammingDistance(self, source, target, allowedSwaps):\n        \"\"\"\n        :type source: List[int]\n        :type target: List[int]\n        :type allowedSwaps: List[List[int]]\n        :rtype: int\n        \"\"\"\n        uf = UnionFind(len(source))\n        for x, y in allowedSwaps: \n            uf.union_set(x, y)\n        groups = collections.defaultdict(set)\n        for i in xrange(len(source)):\n            groups[uf.find_set(i)].add(i)\n        result = 0\n        for idxs in groups.itervalues():\n            source_cnt = collections.Counter([source[i] for i in idxs])\n            target_cnt = collections.Counter([target[i] for i in idxs])\n            diff = source_cnt-target_cnt\n            result += sum(diff.itervalues())\n        return result\n"
    },
    {
        "problem_name": "minimize-length-of-array-using-operations",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minimumArrayLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        mn = min(nums)\n        return (nums.count(mn)+1)//2 if all(x%mn == 0 for x in nums) else 1\n"
    },
    {
        "problem_name": "minimize-malware-spread-ii",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport collections\n\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\n\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        \"\"\"\n        :type graph: List[List[int]]\n        :type initial: List[int]\n        :rtype: int\n        \"\"\"\n        initial_set = set(initial)\n        clean = [i for i in xrange(len(graph)) if i not in initial_set]\n        union_find = UnionFind(len(graph))\n        for i in xrange(len(clean)):\n            for j in xrange(i+1, len(clean)):\n                if graph[clean[i]][clean[j]] == 1:\n                    union_find.union_set(clean[i], clean[j])\n        union_size = collections.Counter(union_find.find_set(i) for i in xrange(len(graph)))\n        \n        shared_union = collections.defaultdict(set)\n        for i in initial:\n            for j in clean:                  \n                if graph[i][j] == 1:\n                    x = union_find.find_set(j)\n                    shared_union[x].add(i)\n\n        result, total = float(\"inf\"), float(\"-inf\")\n        for i in initial:\n            lookup = set()\n            curr = 0\n            for j in clean:                  \n                if graph[i][j] == 1:\n                    x = union_find.find_set(j)\n                    if len(shared_union[x]) == 1 and \\\n                       x not in lookup:\n                        curr += union_size[x]\n                        lookup.add(x)\n            if curr > total or \\\n               (curr == total and i < result):\n                total = curr\n                result = i\n        return result\n"
    },
    {
        "problem_name": "minimize-malware-spread",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport collections\n\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\n\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        \"\"\"\n        :type graph: List[List[int]]\n        :type initial: List[int]\n        :rtype: int\n        \"\"\"\n        union_find = UnionFind(len(graph))\n        for i in xrange(len(graph)):\n            for j in xrange(i+1, len(graph)):\n                if graph[i][j] == 1:\n                    union_find.union_set(i, j)\n        union_size = collections.Counter(union_find.find_set(i) for i in xrange(len(graph)))\n        malware_count = collections.Counter(union_find.find_set(i) for i in initial)\n        return min(initial, key=lambda x: [malware_count[union_find.find_set(x)] > 1,\n                                           -union_size[union_find.find_set(x)],\n                                           x])\n"
    },
    {
        "problem_name": "minimize-manhattan-distances",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def minimumDistance(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def max_distance(exclude):\n            max_sum = max((x+y, i) for i, (x, y) in enumerate(points) if i != exclude)\n            min_sum = min((x+y, i) for i, (x, y) in enumerate(points) if i != exclude)\n            max_diff = max((x-y, i) for i, (x, y) in enumerate(points) if i != exclude)\n            min_diff = min((x-y, i) for i, (x, y) in enumerate(points) if i != exclude)\n            return max((max_sum[0]-min_sum[0], max_sum[1], min_sum[1]), \n                       (max_diff[0]-min_diff[0], max_diff[1], min_diff[1]))\n        \n        _, i, j = max_distance(-1)\n        return min(max_distance(i)[0], max_distance(j)[0])\n"
    },
    {
        "problem_name": "minimize-max-distance-to-gas-station",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\nimport math\n\n\nclass Solution(object):\n    def minmaxGasDist(self, stations, K):\n        \"\"\"\n        :type stations: List[int]\n        :type K: int\n        :rtype: float\n        \"\"\"\n        def check(x):\n            return sum(int(math.ceil((stations[i+1]-stations[i])/x))-1 for i in xrange(len(stations)-1)) <= K\n\n        left, right = 0, stations[-1]-stations[0]\n        while right-left > 1e-6:\n            mid = left + (right-left)/2.0\n            if check(mid):\n                right = mid\n            else:\n                left = mid\n        return left\n\n"
    },
    {
        "problem_name": "minimize-maximum-of-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minimizeArrayValue(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n\n        result = curr = 0\n        for i, x in enumerate(nums):\n            curr += x\n            result = max(result, ceil_divide(curr, i+1))\n        return result\n"
    },
    {
        "problem_name": "minimize-maximum-pair-sum-in-array",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def minPairSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return max(nums[i]+nums[-1-i] for i in xrange(len(nums)//2))\n"
    },
    {
        "problem_name": "minimize-maximum-value-in-a-grid",
        "solution": "# Time:  O((m * n) * log(m * n))\n# Space: O(m * n)\n\n# sort, greedy\nclass Solution(object):\n    def minScore(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        idxs = [(i, j) for i in xrange(len(grid)) for j in xrange(len(grid[0]))]\n        idxs.sort(key=lambda x: grid[x[0]][x[1]])\n        row_max, col_max = [0]*len(grid), [0]*len(grid[0])\n        for i, j in idxs:\n            grid[i][j] = row_max[i] = col_max[j] = max(row_max[i], col_max[j])+1\n        return grid\n"
    },
    {
        "problem_name": "minimize-or-of-remaining-elements-using-operations",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\n# bitmasks, greedy\nclass Solution(object):\n    def minOrAfterOperations(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        l = max(nums).bit_length()\n        mask = (1<<l)-1\n        for i in reversed(xrange(l)):\n            result <<= 1\n            curr, cnt = mask, 0\n            for x in nums:\n                curr &= x>>i\n                if curr&~result:\n                    cnt += 1\n                else:\n                    curr = mask\n            if cnt > k:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "minimize-product-sum-of-two-arrays",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# Same problem from https://codingcompetitions.withgoogle.com/codejam/round/00000000004330f6/0000000000432f33\n\nimport itertools\nimport operator\n\n\nclass Solution(object):\n    def minProductSum(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        def inner_product(vec1, vec2):\n            return sum(itertools.imap(operator.mul, vec1, vec2))\n\n\n        nums1.sort()\n        nums2.sort(reverse=True)\n        return inner_product(nums1, nums2)\n"
    },
    {
        "problem_name": "minimize-result-by-adding-parentheses-to-expression",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nimport itertools\n\n\n# brute force\nclass Solution(object):\n    def minimizeResult(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: str\n        \"\"\"\n        def stoi(s, i, j):\n            result = 0\n            for k in xrange(i, j):\n                result = result*10+(ord(s[k])-ord('0'))\n            return result\n\n        best = None\n        min_val = float(\"inf\")\n        pos = expression.index('+')\n        left, right = stoi(expression, 0, pos), stoi(expression, pos+1, len(expression))\n        base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1)\n        for i in xrange(pos):\n            base2 = base2_init\n            for j in xrange(pos+1, len(expression)):\n                a, b = divmod(left, base1)\n                c, d = divmod(right, base2)\n                val = max(a, 1)*(b+c)*max(d, 1)\n                if val < min_val:\n                    min_val = val\n                    best = (i, j)\n                base2 //= 10\n            base1 //= 10\n        return \"\".join(itertools.chain((expression[i] for i in xrange(best[0])),\n                                       '(', (expression[i] for i in xrange(best[0], best[1]+1)), ')',\n                                       (expression[i] for i in xrange(best[1]+1, len(expression)))))\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# brute force\nclass Solution2(object):\n    def minimizeResult(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: str\n        \"\"\"\n        best = None\n        min_val = float(\"inf\")\n        pos = expression.index('+')\n        left, right = int(expression[0:pos]), int(expression[pos+1:])  # Space: O(n)\n        base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1)\n        for i in xrange(pos):\n            base2 = base2_init\n            for j in xrange(pos+1, len(expression)):\n                a, b = divmod(left, base1)\n                c, d = divmod(right, base2)\n                val = max(a, 1)*(b+c)*max(d, 1)\n                if val < min_val:\n                    min_val = val\n                    best = (i, j)\n                base2 //= 10\n            base1 //= 10\n        return \"\".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]])  # Space: O(n)\n\n    \n# Time:  O(n^3)\n# Space: O(n)\n# brute force\nclass Solution3(object):\n    def minimizeResult(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: str\n        \"\"\"\n        best = None\n        min_val = float(\"inf\")\n        pos = expression.index('+')\n        for i in xrange(pos):\n            for j in xrange(pos+1, len(expression)):\n                val = (int(expression[:i] or \"1\")*\n                       (int(expression[i:pos])+int(expression[pos+1:j+1]))*\n                       int(expression[j+1:] or \"1\"))  # Space: O(n)\n                if val < min_val:\n                    min_val = val\n                    best = (i, j)\n        return \"\".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]])  # Space: O(n)\n"
    },
    {
        "problem_name": "minimize-rounding-error-to-meet-target",
        "solution": "# Time:  O(n) on average\n# Space: O(n)\n\nimport math\nimport random\n\n\nclass Solution(object):\n    def minimizeError(self, prices, target):\n        \"\"\"\n        :type prices: List[str]\n        :type target: int\n        :rtype: str\n        \"\"\"\n        def kthElement(nums, k, compare=lambda a, b: a < b):\n            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == k:\n                    return\n                elif new_pivot_idx > k:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < k.\n                    left = new_pivot_idx + 1\n        \n        errors = []\n        lower, upper = 0, 0\n        for i, p in enumerate(map(float, prices)):\n            lower += int(math.floor(p))\n            upper += int(math.ceil(p))\n            if p != math.floor(p):\n                errors.append(p-math.floor(p))\n        if not lower <= target <= upper:\n            return \"-1\"\n\n        lower_round_count = upper-target\n        kthElement(errors, lower_round_count)\n        result = 0.0\n        for i in xrange(len(errors)):\n            if i < lower_round_count:\n                result += errors[i]\n            else:\n                result += 1.0-errors[i]\n        return \"{:.3f}\".format(result)\n"
    },
    {
        "problem_name": "minimize-string-length",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# hash table\nclass Solution(object):\n    def minimizedStringLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len(set(s))\n"
    },
    {
        "problem_name": "minimize-the-difference-between-target-and-chosen-elements",
        "solution": "# Time:  O(t * m * n), t is target\n# Space: O(t)\n\nclass Solution(object):\n    def minimizeTheDifference(self, mat, target):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        chosen_min = sum(min(row) for row in mat)\n        if chosen_min >= target:\n            return chosen_min-target\n        dp = {0}\n        for row in mat:\n            dp = {total+x for total in dp for x in row if (total+x)-target < target-chosen_min}\n        return min(abs(target-total) for total in dp)\n"
    },
    {
        "problem_name": "minimize-the-maximum-difference-of-pairs",
        "solution": "# Time:  O(nlogn + nlogr), r = max(nums)-min(nums)\n# Space: O(1)\n\n# sort, binary search, greedy\nclass Solution(object):\n    def minimizeMax(self, nums, p):\n        \"\"\"\n        :type nums: List[int]\n        :type p: int\n        :rtype: int\n        \"\"\"\n        def check(x):\n            i = cnt = 0\n            while i+1 < len(nums) and cnt < p:\n                if nums[i+1]-nums[i] <= x:\n                    i += 1\n                    cnt += 1\n                i += 1\n            return cnt == p\n\n        nums.sort()\n        left, right = 0, nums[-1]-nums[0]\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "minimize-the-maximum-of-two-arrays",
        "solution": "# Time:  O(log(min(d1, d2)))\n# Space: O(1)\n\n# number theory\nclass Solution(object):\n    def minimizeSet(self, divisor1, divisor2, uniqueCnt1, uniqueCnt2):\n        \"\"\"\n        :type divisor1: int\n        :type divisor2: int\n        :type uniqueCnt1: int\n        :type uniqueCnt2: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        def lcm(a, b):\n            return a//gcd(a, b)*b\n\n        def count(cnt, d1, d2):\n            l = lcm(d1, d2)\n            return cnt+cnt//(l-1)-int(cnt%(l-1) == 0)\n        \n        return max(count(uniqueCnt1, divisor1, 1),\n                   count(uniqueCnt2, divisor2, 1),\n                   count(uniqueCnt1+uniqueCnt2, divisor1, divisor2))\n\n\n# Time:  O(log(min(d1, d2)) + logr)\n# Space: O(1)\n# binary search\nclass Solution2(object):\n    def minimizeSet(self, divisor1, divisor2, uniqueCnt1, uniqueCnt2):\n        \"\"\"\n        :type divisor1: int\n        :type divisor2: int\n        :type uniqueCnt1: int\n        :type uniqueCnt2: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        def lcm(a, b):\n            return a//gcd(a, b)*b\n\n        def check(cnt):\n            return (cnt-cnt//divisor1 >= uniqueCnt1 and\n                    cnt-cnt//divisor2 >= uniqueCnt2 and\n                    cnt-cnt//l >= uniqueCnt1+uniqueCnt2)\n\n        l = lcm(divisor1, divisor2)\n        left, right = 2, 2**31-1\n        while left <= right:\n            mid = left+(right-left)//2\n            if check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "minimize-the-total-price-of-the-trips",
        "solution": "# Time:  O(t * n)\n# Space: O(n)\n\n# iterative dfs, tree dp\nclass Solution(object):\n    def minimumTotalPrice(self, n, edges, price, trips):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type price: List[int]\n        :type trips: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def iter_dfs(u, target):\n            stk = [(1, (u, -1))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    u, p = args\n                    lookup[u] += 1\n                    if u == target:\n                        return\n                    stk.append((2, (u,)))\n                    for v in reversed(adj[u]):\n                        if v == p:\n                            continue\n                        stk.append((1, (v, u)))\n                elif step == 2:\n                    u = args[0]\n                    lookup[u] -= 1\n    \n            lookup[u] += 1\n            if u == target:\n                return True\n            for v in adj[u]:\n                if v == p:\n                    continue\n                if dfs(v, u, target):\n                    return True\n            lookup[u] -= 1\n            return False\n    \n        def iter_dfs2():\n            result = [price[0]*lookup[0], (price[0]//2)*lookup[0]]\n            stk = [(1, (0, -1, result))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    u, p, ret = args\n                    for v in reversed(adj[u]):\n                        if v == p:\n                            continue\n                        new_ret = [price[v]*lookup[v], (price[v]//2)*lookup[v]]\n                        stk.append((2, (new_ret, ret)))\n                        stk.append((1, (v, u, new_ret)))\n                elif step == 2:\n                    new_ret, ret = args\n                    ret[0] += min(new_ret)\n                    ret[1] += new_ret[0]\n            return min(result)\n\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        lookup = [0]*n\n        for u, v in trips:\n            iter_dfs(u, v)\n        return iter_dfs2()\n    \n\n# Time:  O(t * n)\n# Space: O(n)\n# dfs, tree dp\nclass Solution2(object):\n    def minimumTotalPrice(self, n, edges, price, trips):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type price: List[int]\n        :type trips: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def dfs(u, p, target):\n            lookup[u] += 1\n            if u == target:\n                return True\n            for v in adj[u]:\n                if v == p:\n                    continue\n                if dfs(v, u, target):\n                    return True\n            lookup[u] -= 1\n            return False\n    \n        def dfs2(u, p):\n            full, half = price[u]*lookup[u], price[u]//2*lookup[u]\n            for v in adj[u]:\n                if v == p:\n                    continue\n                f, h = dfs2(v, u)\n                full += min(f, h)\n                half += f\n            return full, half\n\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        lookup = [0]*n\n        for u, v in trips:\n            dfs(u, -1, v)\n        return min(dfs2(0, -1))\n"
    },
    {
        "problem_name": "minimize-xor",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# bit manipulation, greedy\nclass Solution(object):\n    def minimizeXor(self, num1, num2):\n        \"\"\"\n        :type num1: int\n        :type num2: int\n        :rtype: int\n        \"\"\"\n        def popcount(x):\n            return bin(x)[2:].count('1')\n        \n        cnt1, cnt2 = popcount(num1), popcount(num2)\n        result = num1\n        cnt = abs(cnt1-cnt2)\n        expect = 1 if cnt1 >= cnt2 else 0\n        i = 0\n        while cnt:\n            if ((num1>>i)&1) == expect:\n                cnt -= 1\n                result ^= 1<<i\n            i += 1\n        return result\n"
    },
    {
        "problem_name": "minimized-maximum-of-products-distributed-to-any-store",
        "solution": "# Time:  O(nlogm), m is the max of quantities\n# Space: O(1)\n\nclass Solution(object):\n    def minimizedMaximum(self, n, quantities):\n        \"\"\"\n        :type n: int\n        :type quantities: List[int]\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+(b-1))//b\n\n        def check(n, quantities, x):\n            return sum(ceil_divide(q, x) for q in quantities) <= n\n         \n        left, right = 1, max(quantities)\n        while left <= right:\n            mid = left+(right-left)//2\n            if check(n, quantities, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "minimizing-array-after-replacing-pairs-with-their-product",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minArrayLength(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if 0 in nums:\n            return 1\n        result = len(nums)\n        curr = nums[0]\n        for i in xrange(1, len(nums)):\n            if curr*nums[i] > k:\n                curr = nums[i]\n            else:\n                curr *= nums[i]\n                result -= 1\n        return result\n \n"
    },
    {
        "problem_name": "minimum-absolute-difference-between-elements-with-constraint",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nfrom sortedcontainers import SortedList\n\n\n# sorted list, binary search\nclass Solution(object):\n    def minAbsoluteDifference(self, nums, x):\n        \"\"\"\n        :type nums: List[int]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        result = float(\"inf\")\n        sl = SortedList()\n        for i in xrange(x, len(nums)):\n            sl.add(nums[i-x])\n            j = sl.bisect_left(nums[i])\n            if j-1 >= 0:\n                result = min(result, nums[i]-sl[j-1])\n            if j < len(sl):\n                result = min(result, sl[j]-nums[i])\n        return result\n"
    },
    {
        "problem_name": "minimum-absolute-difference-in-bst",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def inorderTraversal(root, prev, result):\n            if not root:\n                return (result, prev)\n\n            result, prev = inorderTraversal(root.left, prev, result)\n            if prev: result = min(result, root.val - prev.val)\n            return inorderTraversal(root.right, root, result)\n\n        return inorderTraversal(root, None, float(\"inf\"))[0]\n\n"
    },
    {
        "problem_name": "minimum-absolute-difference-queries",
        "solution": "# Time:  O(r * (n + q)), r is the max of nums\n# Space: O(r * n)\n\nclass Solution(object):\n    def minDifference(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        INF = float(\"inf\")\n        prefix = [[0]*(max(nums)+1)]\n        for num in nums:\n            prefix.append(prefix[-1][:])\n            prefix[-1][num] += 1\n        result = []\n        for l, r in queries:\n            min_diff, prev = INF, -1\n            for num in xrange(len(prefix[0])):\n                if not (prefix[l][num] < prefix[r+1][num]):\n                    continue\n                if prev != -1:\n                    min_diff = min(min_diff, num-prev)\n                prev = num\n            result.append(min_diff if min_diff != INF else -1)\n        return result\n\n\n# Time:  O(r + n + q * r * logn), r is the max of nums\n# Space: O(r + n)\nimport bisect\n\n\nclass Solution2(object):\n    def minDifference(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        INF = float(\"inf\")\n        idxs = [[] for _ in xrange(max(nums)+1)]\n        for i, num in enumerate(nums):\n            idxs[num].append(i)\n        result = []\n        for l, r in queries:\n            min_diff, prev = INF, -1\n            for num in xrange(len(idxs)):\n                i = bisect.bisect_left(idxs[num], l)\n                if not (i < len(idxs[num]) and idxs[num][i] <= r):\n                    continue\n                if prev != -1:\n                    min_diff = min(min_diff, num-prev)\n                prev = num\n            result.append(min_diff if min_diff != INF else -1)\n        return result\n"
    },
    {
        "problem_name": "minimum-absolute-difference",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def minimumAbsDifference(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        min_diff = float(\"inf\")\n        arr.sort()\n        for i in xrange(len(arr)-1):\n            diff = arr[i+1]-arr[i]\n            if diff < min_diff:\n                min_diff = diff\n                result = [[arr[i], arr[i+1]]]\n            elif diff == min_diff:\n                result.append([arr[i], arr[i+1]])\n        return result\n"
    },
    {
        "problem_name": "minimum-absolute-sum-difference",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport bisect\n\n\nclass Solution(object):\n    def minAbsoluteSumDiff(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        sorted_nums1 = sorted(nums1)\n        result = max_change = 0\n        for i in xrange(len(nums2)):\n            diff = abs(nums1[i]-nums2[i])\n            result = (result+diff)%MOD\n            if diff < max_change:\n                continue\n            j = bisect.bisect_left(sorted_nums1, nums2[i])\n            if j != len(sorted_nums1):\n                max_change = max(max_change, diff-abs(sorted_nums1[j]-nums2[i]))\n            if j != 0:\n                max_change = max(max_change, diff-abs(sorted_nums1[j-1]-nums2[i]))\n        return (result-max_change)%MOD\n"
    },
    {
        "problem_name": "minimum-add-to-make-parentheses-valid",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minAddToMakeValid(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        add, bal, = 0, 0\n        for c in S:\n            bal += 1 if c == '(' else -1\n            if bal == -1:\n                add += 1\n                bal += 1\n        return add + bal\n"
    },
    {
        "problem_name": "minimum-addition-to-make-integer-beautiful",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def makeIntegerBeautiful(self, n, target):\n        \"\"\"\n        :type n: int\n        :type target: int\n        :rtype: int\n        \"\"\"\n        total, m = 0, n\n        while m:\n            total += m%10\n            m //= 10\n        m, l = n, 0\n        while total > target:\n            while True:\n                total -= m%10\n                m //= 10\n                l += 1\n                if m%10 != 9:\n                    break\n            total += 1\n            m += 1\n        return m*10**l-n\n"
    },
    {
        "problem_name": "minimum-additions-to-make-valid-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def addMinimum(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        return 3*(sum(i-1 < 0 or word[i-1] >= word[i] for i in xrange(len(word))))-len(word)\n \n"
    },
    {
        "problem_name": "minimum-adjacent-swaps-for-k-consecutive-ones",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def minMoves(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def moves(i, j):\n            return prefix[j+1]-prefix[i]\n\n        idxs = [i for i, x in enumerate(nums) if x]\n        prefix = [0]*(len(idxs)+1)\n        for i in xrange(len(idxs)):\n            prefix[i+1] = prefix[i]+idxs[i]\n        result = float(\"inf\")\n        for i in xrange(len(idxs)-k+1):\n            result = min(result, -moves(i, i+k//2-1) + moves(i+(k+1)//2, i+k-1))  # take each i+k//2 as median, find min dist to median\n        result -= (k//2)*((k+1)//2)  # rollback extra moves to the expected positions\n        return result\n"
    },
    {
        "problem_name": "minimum-adjacent-swaps-to-make-a-valid-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array, greedy\nclass Solution(object):\n    def minimumSwaps(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        min_idx = min(xrange(len(nums)), key=nums.__getitem__)\n        max_idx = max(reversed(xrange(len(nums))), key=nums.__getitem__)\n        return ((len(nums)-1)-max_idx)+min_idx-int(max_idx < min_idx)\n"
    },
    {
        "problem_name": "minimum-adjacent-swaps-to-reach-the-kth-smallest-number",
        "solution": "# Time:  O((k + n) * n)\n# Space: O(n)\n\nclass Solution(object):\n    def getMinSwaps(self, num, k):\n        \"\"\"\n        :type num: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def next_permutation(nums, begin, end):\n            def reverse(nums, begin, end):\n                left, right = begin, end-1\n                while left < right:\n                    nums[left], nums[right] = nums[right], nums[left]\n                    left += 1\n                    right -= 1\n\n            k, l = begin-1, begin\n            for i in reversed(xrange(begin, end-1)):\n                if nums[i] < nums[i+1]:\n                    k = i\n                    break\n            else:\n                reverse(nums, begin, end)\n                return False\n            for i in reversed(xrange(k+1, end)):\n                if nums[i] > nums[k]:\n                    l = i\n                    break\n            nums[k], nums[l] = nums[l], nums[k]\n            reverse(nums, k+1, end)\n            return True\n        \n        new_num = list(num)\n        while k:\n            next_permutation(new_num, 0, len(new_num))\n            k -= 1\n        result = 0\n        for i in xrange(len(new_num)):\n            if new_num[i] == num[i]:\n                continue\n            #   // greedily move the one with the least cost from new_num to num without missing optimal cost\n            for j in xrange(i+1, len(new_num)):\n                if new_num[j] == num[i]:\n                    break\n            result += j-i\n            for j in reversed(xrange(i+1, j+1)):\n                new_num[j], new_num[j-1] = new_num[j-1], new_num[j]\n        return result\n"
    },
    {
        "problem_name": "minimum-amount-of-time-to-collect-garbage",
        "solution": "# Time:  O(n * l), l = max(len(g) for g in garbage) = O(10)\n# Space: O(1)\n\n# simulation, prefix sum\nclass Solution(object):\n    def garbageCollection(self, garbage, travel):\n        \"\"\"\n        :type garbage: List[str]\n        :type travel: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        lookup = {}\n        for i in xrange(len(garbage)):\n            for c in garbage[i]:\n                lookup[c] = i\n            if i+1 < len(travel):\n                travel[i+1] += travel[i]\n            result += len(garbage[i])\n        result += sum(travel[v-1] for _, v in lookup.iteritems() if v-1 >= 0)\n        return result\n\n\n# Time:  O(n * l), l = max(len(g) for g in garbage) = O(10)\n# Space: O(1)\n# simulation, prefix sum\nclass Solution2(object):\n    def garbageCollection(self, garbage, travel):\n        \"\"\"\n        :type garbage: List[str]\n        :type travel: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for t in 'MPG':\n            curr = 0\n            for i in xrange(len(garbage)):\n                cnt = garbage[i].count(t) \n                if cnt:\n                    result += curr+cnt\n                    curr = 0\n                if i < len(travel):\n                    curr += travel[i]\n        return result\n"
    },
    {
        "problem_name": "minimum-amount-of-time-to-fill-cups",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def fillCups(self, amount):\n        \"\"\"\n        :type amount: List[int]\n        :rtype: int\n        \"\"\"\n        return max(max(amount), (sum(amount)+1)//2)\n\n\n# Time:  O(1)\n# Space: O(1)\n# constructive algorithms\nclass Solution2(object):\n    def fillCups(self, amount):\n        \"\"\"\n        :type amount: List[int]\n        :rtype: int\n        \"\"\"\n        mx, total = max(amount), sum(amount)\n        return mx if sum(amount)-mx <= mx else (total+1)//2\n"
    },
    {
        "problem_name": "minimum-area-rectangle-ii",
        "solution": "# Time:  O(n^2) ~ O(n^3)\n# Space: O(n^2)\n\nimport collections\nimport itertools\n\n\nclass Solution(object):\n    def minAreaFreeRect(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: float\n        \"\"\"\n        points.sort()\n        points = [complex(*z) for z in points]\n        lookup = collections.defaultdict(list)\n        for P, Q in itertools.combinations(points, 2):\n            lookup[P-Q].append((P+Q) / 2)\n\n        result = float(\"inf\")\n        for A, candidates in lookup.iteritems():\n            for P, Q in itertools.combinations(candidates, 2):\n                if A.real * (P-Q).real + A.imag * (P-Q).imag == 0.0:\n                    result = min(result, abs(A) * abs(P-Q))\n        return result if result < float(\"inf\") else 0.0\n"
    },
    {
        "problem_name": "minimum-area-rectangle",
        "solution": "# Time:  O(n^1.5) on average\n#        O(n^2) on worst\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def minAreaRect(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n\n        lookup = {}\n        result = float(\"inf\")\n        for x in sorted(p):\n            p[x].sort()\n            for j in xrange(len(p[x])):\n                for i in xrange(j):\n                    y1, y2 = p[x][i], p[x][j]\n                    if (y1, y2) in lookup:\n                        result = min(result, (x-lookup[y1, y2]) * (y2-y1))\n                    lookup[y1, y2] = x\n        return result if result != float(\"inf\") else 0\n \n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution2(object):\n    def minAreaRect(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = set()\n        result = float(\"inf\")\n        for x1, y1 in points:\n            for x2, y2 in lookup:\n                if (x1, y2) in lookup and (x2, y1) in lookup:\n                    result = min(result, abs(x1-x2) * abs(y1-y2))\n            lookup.add((x1, y1))\n        return result if result != float(\"inf\") else 0\n"
    },
    {
        "problem_name": "minimum-array-end",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def minEnd(self, n, x):\n        \"\"\"\n        :type n: int\n        :type x: int\n        :rtype: int\n        \"\"\"\n        n -= 1\n        base_n = base_x = 1\n        while base_n <= n:\n            if (x&base_x) == 0:\n                if n&base_n:\n                    x |= base_x\n                base_n <<= 1\n            base_x <<= 1\n        return x\n"
    },
    {
        "problem_name": "minimum-array-length-after-pair-removals",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table, constructive algorithms\nclass Solution(object):\n    def minLengthAfterRemovals(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        mx = max(collections.Counter(nums).itervalues())\n        return mx-(len(nums)-mx) if mx > (len(nums)-mx) else len(nums)%2\n"
    },
    {
        "problem_name": "minimum-ascii-delete-sum-for-two-strings",
        "solution": "# Time:  O(m * n)\n# Space: O(n)\n\nclass Solution(object):\n    def minimumDeleteSum(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: int\n        \"\"\"\n        dp = [[0] * (len(s2)+1) for _ in xrange(2)]\n        for j in xrange(len(s2)):\n            dp[0][j+1] = dp[0][j] + ord(s2[j])\n\n        for i in xrange(len(s1)):\n            dp[(i+1)%2][0] = dp[i%2][0] + ord(s1[i])\n            for j in xrange(len(s2)):\n                if s1[i] == s2[j]:\n                    dp[(i+1)%2][j+1] = dp[i%2][j]\n                else:\n                    dp[(i+1)%2][j+1] = min(dp[i%2][j+1] + ord(s1[i]), \\\n                                           dp[(i+1)%2][j] + ord(s2[j]))\n\n        return dp[len(s1)%2][-1]\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\nclass Solution2(object):\n    def minimumDeleteSum(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: int\n        \"\"\"\n        dp = [[0] * (len(s2)+1) for _ in xrange(len(s1)+1)]\n        for i in xrange(len(s1)):\n            dp[i+1][0] = dp[i][0] + ord(s1[i])\n        for j in xrange(len(s2)):\n            dp[0][j+1] = dp[0][j] + ord(s2[j])\n\n        for i in xrange(len(s1)):\n            for j in xrange(len(s2)):\n                if s1[i] == s2[j]:\n                    dp[i+1][j+1] = dp[i][j]\n                else:\n                    dp[i+1][j+1] = min(dp[i][j+1] + ord(s1[i]), \\\n                                       dp[i+1][j] + ord(s2[j]))\n\n        return dp[-1][-1]\n\n"
    },
    {
        "problem_name": "minimum-average-difference",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# prefix sum\nclass Solution(object):\n    def minimumAverageDifference(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        total = sum(nums)\n        mn, idx = float(\"inf\"), -1\n        prefix = 0\n        for i, x in enumerate(nums):\n            prefix += x\n            a = prefix//(i+1)\n            b = (total-prefix)//(len(nums)-(i+1)) if i+1 < len(nums) else 0\n            diff = abs(a-b)\n            if diff < mn:\n                mn, idx = diff, i\n        return idx\n"
    },
    {
        "problem_name": "minimum-bit-flips-to-convert-number",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def minBitFlips(self, start, goal):\n        \"\"\"\n        :type start: int\n        :type goal: int\n        :rtype: int\n        \"\"\"\n        return bin(start^goal).count('1')\n"
    },
    {
        "problem_name": "minimum-changes-to-make-alternating-binary-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minOperations(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        cnt = sum(int(c) == i%2 for i, c in enumerate(s))\n        return min(cnt, len(s)-cnt)\n"
    },
    {
        "problem_name": "minimum-changes-to-make-k-semi-palindromes",
        "solution": "# Time:  O(n * nlogn + n^3 + n^2 * k) = O(n^3)\n# Space: O(n * nlogn) = O(n^2 * logn)\n\n# number theory, dp\nclass Solution(object):\n    def minimumChanges(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        divisors = [[] for _ in xrange(len(s)+1)]\n        for i in xrange(1, len(divisors)):  # Time: O(nlogn), Space: O(nlogn)\n            for j in xrange(i, len(divisors), i):\n                divisors[j].append(i)\n        dp = [[{} for _ in xrange(len(s))] for _ in xrange(len(s))]\n        for l in xrange(1, len(s)+1):  # Time: O(n * nlogn + n^3), Space: O(n * nlogn)\n            for left in xrange(len(s)-l+1):\n                right = left+l-1\n                for d in divisors[l]:\n                    dp[left][right][d] = (dp[left+d][right-d][d] if left+d < right-d else 0)+sum(s[left+i] != s[(right-(d-1))+i] for i in xrange(d))\n        dp2 = [[min(dp[i][j][d] for d in divisors[j-i+1] if d != j-i+1) if i < j else 0 for j in xrange(len(s))] for i in xrange(len(s))]  # Time: O(n^2), Space: O(n^2)\n        dp3 = [len(s)]*(len(s)+1)\n        dp3[0] = 0\n        for l in xrange(k):  # Time: O(k * n^2), Space: O(n)\n            new_dp3 = [len(s)]*(len(s)+1)\n            for i in xrange(len(s)):\n                for j in xrange(l*2, i):  # optimized for the fact that the length of semi-palindrome is at least 2\n                    new_dp3[i+1]= min(new_dp3[i+1], dp3[j]+dp2[j][i])\n            dp3 = new_dp3\n        return dp3[len(s)]\n\n\n# Time:  O(n * nlogn + n^3 + n^2 * k) = O(n^3)\n# Space: O(n * nlogn) = O(n^2 * logn)\n# number theory, dp\nclass Solution2(object):\n    def minimumChanges(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        divisors = [[] for _ in xrange(len(s)+1)]\n        for i in xrange(1, len(divisors)):  # Time: O(nlogn), Space: O(nlogn)\n            for j in xrange(i, len(divisors), i):\n                divisors[j].append(i)\n        dp = [[{} for _ in xrange(len(s))] for _ in xrange(len(s))]\n        for l in xrange(1, len(s)+1):  # Time: O(n * nlogn + n^3), Space: O(n * nlogn)\n            for left in xrange(len(s)-l+1):\n                right = left+l-1\n                for d in divisors[l]:\n                    dp[left][right][d] = (dp[left+d][right-d][d] if left+d < right-d else 0)+sum(s[left+i] != s[(right-(d-1))+i] for i in xrange(d))\n        dp2 = [[len(s)]*(k+1) for _ in xrange(len(s)+1)]\n        dp2[0][0] = 0\n        for i in xrange(len(s)):  # Time: O(n^2 * logn + n^2 * k), Space: O(n * k)\n            for j in xrange(i):\n                c = min(dp[j][i][d] for d in divisors[i-j+1] if d != i-j+1)\n                for l in xrange(k):\n                    dp2[i+1][l+1] = min(dp2[i+1][l+1], dp2[j][l]+c)\n        return dp2[len(s)][k]\n\n\n# Time:  O(n^2 * nlogn + n^2 * k) = O(n^3 * logn)\n# Space: O(nlogn + n * k)\n# number theory, dp\nclass Solution3(object):\n    def minimumChanges(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def min_dist(left, right):  # Time: O(nlogn)\n            return min(sum(s[left+i] != s[right-((i//d+1)*d-1)+(i%d)] for i in xrange((right-left+1)//2))\n for d in divisors[right-left+1])\n\n        divisors = [[] for _ in xrange(len(s)+1)]\n        for i in xrange(1, len(divisors)):  # Time: O(nlogn), Space: O(nlogn)\n            for j in xrange(i+i, len(divisors), i):\n                divisors[j].append(i)\n        dp = [[len(s)]*(k+1) for _ in xrange(len(s)+1)]\n        dp[0][0] = 0\n        for i in xrange(len(s)):  # Time: O(n^2 * nlogn + n^2 * k), Space: O(n * k)\n            for j in xrange(i):\n                c = min_dist(j, i)\n                for l in xrange(k):\n                    dp[i+1][l+1] = min(dp[i+1][l+1], dp[j][l]+c)\n        return dp[len(s)][k]\n"
    },
    {
        "problem_name": "minimum-common-value",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers\nclass Solution(object):\n    def getCommon(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        i = j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                return nums1[i]\n        return -1\n"
    },
    {
        "problem_name": "minimum-consecutive-cards-to-pick-up",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table\nclass Solution(object):\n    def minimumCardPickup(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = {}\n        result = float(\"inf\")\n        for i, x in enumerate(cards):\n            if x in lookup:\n                result = min(result, i-lookup[x]+1)\n            lookup[x] = i\n        return result if result != float(\"inf\") else -1\n"
    },
    {
        "problem_name": "minimum-cost-for-tickets",
        "solution": "# Time:  O(n)\n# space: O(1)\n\nclass Solution(object):\n    def mincostTickets(self, days, costs):\n        \"\"\"\n        :type days: List[int]\n        :type costs: List[int]\n        :rtype: int\n        \"\"\"\n        durations = [1, 7, 30]\n        W = durations[-1]\n        dp = [float(\"inf\") for i in xrange(W)]\n        dp[0] = 0\n        last_buy_days = [0, 0, 0]\n        for i in xrange(1,len(days)+1):\n            dp[i%W] = float(\"inf\")\n            for j in xrange(len(durations)):\n                while i-1 < len(days) and \\\n                      days[i-1] > days[last_buy_days[j]]+durations[j]-1:\n                    last_buy_days[j] += 1  # Time: O(n)\n                dp[i%W] = min(dp[i%W], dp[last_buy_days[j]%W]+costs[j])\n        return dp[len(days)%W]\n"
    },
    {
        "problem_name": "minimum-cost-homecoming-of-a-robot-in-a-grid",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nclass Solution(object):\n    def minCost(self, startPos, homePos, rowCosts, colCosts):\n        \"\"\"\n        :type startPos: List[int]\n        :type homePos: List[int]\n        :type rowCosts: List[int]\n        :type colCosts: List[int]\n        :rtype: int\n        \"\"\"\n        [x0, y0], [x1, y1] = startPos, homePos\n        return (sum(rowCosts[i] for i in xrange(min(x0, x1), max(x0, x1)+1))-rowCosts[x0]) + \\\n               (sum(colCosts[i] for i in xrange(min(y0, y1), max(y0, y1)+1))-colCosts[y0])\n"
    },
    {
        "problem_name": "minimum-cost-of-a-path-with-special-roads",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nimport collections\n\n\n# dijkstra's algorithm in a complete graph (no heap required)\nclass Solution(object):\n    def minimumCost(self, start, target, specialRoads):\n        \"\"\"\n        :type start: List[int]\n        :type target: List[int]\n        :type specialRoads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        start, target = tuple(start), tuple(target)\n        adj = collections.defaultdict(list, {target:[]})\n        for x1, y1, x2, y2, c in specialRoads:\n            adj[x1, y1].append((x2, y2, c))\n        dist = {start:0}\n        lookup = set()\n        while len(lookup) != len(dist):\n            d, x1, y1 = min((dist[x1, y1], x1, y1) for x1, y1 in dist.iterkeys() if (x1, y1) not in lookup)\n            lookup.add((x1, y1))\n            if (x1, y1) == target:\n                return d\n            for x2, y2, c in adj[x1, y1]:\n                if not ((x2, y2) not in dist or dist[x2, y2] > d+c):\n                    continue\n                dist[x2, y2] = d+c\n            for x2, y2 in adj.iterkeys():\n                if not ((x2, y2) not in dist or dist[x2, y2] > d+abs(x2-x1)+abs(y2-y1)):\n                    continue\n                dist[x2, y2] = d+abs(x2-x1)+abs(y2-y1)\n\n\n# Time:  O(n^2 * logn)\n# Space: O(n^2)\nimport collections\nimport heapq\n# dijkstra's algorithm\nclass Solution2(object):\n    def minimumCost(self, start, target, specialRoads):\n        \"\"\"\n        :type start: List[int]\n        :type target: List[int]\n        :type specialRoads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        start, target = tuple(start), tuple(target)\n        adj = collections.defaultdict(list, {target:[]})\n        for x1, y1, x2, y2, c in specialRoads:\n            adj[x1, y1].append((x2, y2, c))\n        min_heap = [(0, start)]\n        dist = {start:0}\n        while min_heap:\n            d, (x1, y1) = heapq.heappop(min_heap)\n            if d > dist[x1, y1]:\n                continue\n            if (x1, y1) == target:\n                return d\n            for x2, y2, c in adj[x1, y1]:\n                if not ((x2, y2) not in dist or dist[x2, y2] > d+c):\n                    continue\n                dist[x2, y2] = d+c\n                heapq.heappush(min_heap, (dist[x2, y2], (x2, y2)))\n            for x2, y2 in adj.iterkeys():\n                if not ((x2, y2) not in dist or dist[x2, y2] > d+abs(x2-x1)+abs(y2-y1)):\n                    continue\n                dist[x2, y2] = d+abs(x2-x1)+abs(y2-y1)\n                heapq.heappush(min_heap, (dist[x2, y2], (x2, y2)))\n        return -1\n"
    },
    {
        "problem_name": "minimum-cost-of-buying-candies-with-discount",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minimumCost(self, cost):\n        \"\"\"\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        cost.sort(reverse=True)\n        return sum(x for i, x in enumerate(cost) if i%3 != 2)\n"
    },
    {
        "problem_name": "minimum-cost-to-buy-apples",
        "solution": "# Time:  O(n * rlogn), r = len(roads)\n# Space: O(n)\n\nimport itertools\nimport heapq\n\n\n# dijkstra's algorithm\nclass Solution(object):\n    def minCost(self, n, roads, appleCost, k):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :type appleCost: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def dijkstra(start):\n            best = [float(\"inf\")]*len(adj)\n            best[start] = 0\n            min_heap = [(0, start)]\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if best[u] < curr:\n                    continue\n                for v, w in adj[u]:                \n                    if best[v] <= curr+w:\n                        continue\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (curr+w, v))\n            return best\n\n        adj = [[] for _ in xrange(n)]\n        for a, b, c in roads:\n            adj[a-1].append((b-1, c))\n            adj[b-1].append((a-1, c))\n        return [min(a+d*(k+1) for a, d in itertools.izip(appleCost, dijkstra(u))) for u in xrange(n)]\n"
    },
    {
        "problem_name": "minimum-cost-to-change-the-final-value-of-expression",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def minOperationsToFlip(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: int\n        \"\"\"\n        def compute(operands, operators):\n            right, left = operands.pop(), operands.pop()\n            operands.append(ops[operators.pop()](left, right))\n\n        ops = {'&':lambda x, y: [min(x[0], y[0]), min(x[1]+y[1], min(x[1], y[1])+1)],\n               '|':lambda x, y: [min(x[0]+y[0], min(x[0], y[0])+1), min(x[1], y[1])]}\n        precedence = {'&':0, '|':0}\n        operands, operators = [], []\n        for c in expression:\n            if c.isdigit():\n                operands.append([int(c != '0'), int(c != '1')])\n            elif c == '(':\n                operators.append(c)\n            elif c == ')':\n                while operators[-1] != '(':\n                    compute(operands, operators)\n                operators.pop()\n            elif c in precedence:\n                while operators and operators[-1] in precedence and \\\n                      precedence[operators[-1]] >= precedence[c]:\n                    compute(operands, operators)\n                operators.append(c)\n        while operators:\n            compute(operands, operators)\n        return max(operands[-1])\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def minOperationsToFlip(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: int\n        \"\"\"\n        stk = [[None]*3]\n        for c in expression:                                \n            if c == '(':                                            \n                stk.append([None]*3)\n            elif c in {')', '0', '1'}:\n                if c == ')':\n                    dp0, dp1, _ = stk.pop()\n                else:\n                    dp0, dp1 = int(c != '0'), int(c != '1')\n                if stk[-1][2] == '&':\n                    stk[-1] = [min(stk[-1][0], dp0),\n                               min(stk[-1][1]+dp1, min(stk[-1][1], dp1)+1),\n                               None]\n                elif stk[-1][2] == '|':\n                    stk[-1] = [min(stk[-1][0]+dp0, min(stk[-1][0], dp0)+1),\n                               min(stk[-1][1], dp1),\n                               None]\n                else:  # operand\n                    stk[-1] = [dp0, dp1, None]\n            else:\n                stk[-1][2] = c\n        return max(stk[0][0], stk[0][1])\n"
    },
    {
        "problem_name": "minimum-cost-to-connect-sticks",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def connectSticks(self, sticks):\n        \"\"\"\n        :type sticks: List[int]\n        :rtype: int\n        \"\"\"\n        heapq.heapify(sticks)\n        result = 0\n        while len(sticks) > 1:\n            x, y = heapq.heappop(sticks), heapq.heappop(sticks)\n            result += x+y\n            heapq.heappush(sticks, x+y)\n        return result\n"
    },
    {
        "problem_name": "minimum-cost-to-connect-two-groups-of-points",
        "solution": "# Time:  O(m * n * 2^n)\n# Space: O(2^n)\n\n# dp with rolling window\nclass Solution(object):\n    def connectTwoGroups(self, cost):\n        \"\"\"\n        :type cost: List[List[int]]\n        :rtype: int\n        \"\"\"\n        total = 2**len(cost[0])\n        dp = [[float(\"inf\")]*total for _ in xrange(2)]\n        dp[0][0] = 0\n        for i in xrange(len(cost)):\n            dp[(i+1)%2] = [float(\"inf\")]*total\n            for mask in xrange(total):\n                base = 1\n                for j in xrange(len(cost[0])):\n                    dp[i%2][mask|base] = min(dp[i%2][mask|base], cost[i][j]+dp[i%2][mask])\n                    dp[(i+1)%2][mask|base] = min(dp[(i+1)%2][mask|base], cost[i][j]+dp[i%2][mask])\n                    base <<= 1\n        return dp[len(cost)%2][-1]\n"
    },
    {
        "problem_name": "minimum-cost-to-convert-string-i",
        "solution": "# Time:  O(o + k * eloge + n), k = len(set(original)), e is the number of edges reachable from a given node u\n# Space: O(o + k * v), v is the number of nodes reachable from a given node u\n\nimport heapq\n\n\n# dijkstra's algorithm, memoization\nclass Solution(object):\n    def minimumCost(self, source, target, original, changed, cost):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :type original: List[str]\n        :type changed: List[str]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        def dijkstra(start):\n            best = {start:0}\n            min_heap = [(0, start)]\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if curr > best[u]:\n                    continue\n                if u not in dist:\n                    continue\n                for v, w in dist[u].iteritems():     \n                    if v in best and best[v] <= curr+w:\n                        continue\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (best[v], v))\n            return best\n\n        memo = {}\n        def memoization(u, v):\n            if u not in memo:\n                memo[u] = dijkstra(u)\n            return memo[u][v] if v in memo[u] else INF\n\n        dist = {}\n        for i in xrange(len(original)):\n            u, v = ord(original[i])-ord('a'), ord(changed[i])-ord('a')\n            if u not in dist:\n                dist[u] = {v:INF}\n            if v not in dist[u]:\n                dist[u][v] = INF\n            dist[u][v] = min(dist[u][v], cost[i])\n        result = sum(memoization(ord(source[i])-ord('a'), ord(target[i])-ord('a')) for i in xrange(len(source)))\n        return result if result != INF else -1\n\n\n# Time:  O(o + 26^3 + n)\n# Space: O(o + 26^2)\n# Floyd-Warshall algorithm \nclass Solution2(object):\n    def minimumCost(self, source, target, original, changed, cost):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :type original: List[str]\n        :type changed: List[str]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        def floydWarshall(dist):\n            for k in xrange(len(dist)):\n                for i in xrange(len(dist)):\n                    if dist[i][k] == INF:\n                        continue\n                    for j in xrange(len(dist[i])):\n                        if dist[k][j] == INF:\n                            continue\n                        dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])\n\n        dist = [[0 if u == v else INF for v in xrange(26)] for u in xrange(26)]\n        for i in xrange(len(original)):\n            u, v = ord(original[i])-ord('a'), ord(changed[i])-ord('a')\n            dist[u][v] = min(dist[u][v], cost[i])\n        floydWarshall(dist)\n        result = sum(dist[ord(source[i])-ord('a')][ord(target[i])-ord('a')] for i in xrange(len(source)))\n        return result if result != INF else -1\n"
    },
    {
        "problem_name": "minimum-cost-to-convert-string-ii",
        "solution": "# Time:  O(o * l + k * eloge + n * c * l), e is the number of edges reachable from a given node u, o = len(original), l = max(len(x) for x in original), k = len(lookups), c = len({len(x) for x in original})\n# Space: O(o * l + k * v + c + l), v is the number of nodes reachable from a given node u\n\nimport collections\nimport itertools\n\n\n# hash table, dijkstra's algorithm, dp, memoization\nclass Solution(object):\n    def minimumCost(self, source, target, original, changed, cost):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :type original: List[str]\n        :type changed: List[str]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        lookups = collections.defaultdict(dict)\n        for x in itertools.chain(original, changed):\n            l = len(x)\n            lookup = lookups[l]\n            if x not in lookup:\n                lookup[x] = len(lookup)\n        def dijkstra(dist, start):\n            best = [INF]*len(dist)\n            best[start] = 0\n            min_heap = [(0, start)]\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if curr > best[u]:\n                    continue\n                for v, w in enumerate(dist[u]):     \n                    if best[v] <= curr+w:\n                        continue\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (best[v], v))\n            return best\n\n        memo = {}\n        def memoization(l, dist, u, v):\n            if l not in memo:\n                memo[l] = {}\n            if u not in memo[l]:\n                memo[l][u] = dijkstra(dist, u)\n            return memo[l][u][v]\n\n        dists = {l:[[0 if u == v else INF for v in xrange(len(lookup))] for u in xrange(len(lookup))] for l, lookup in lookups.iteritems()}\n        for i in xrange(len(original)):\n            l = len(original[i])\n            lookup, dist = lookups[l], dists[l]\n            u, v = lookup[original[i]], lookup[changed[i]]\n            dist[u][v] = min(dist[u][v], cost[i])\n        candidates = {len(x) for x in original}\n        dp = [INF]*(max(len(x) for x in original)+1)\n        dp[0] = 0\n        for i in xrange(len(source)):\n            if dp[i%len(dp)] == INF:\n                continue\n            if source[i] == target[i]:\n                dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)])\n            for l in candidates:\n                if i+l > len(source):\n                    continue\n                lookup, dist = lookups[l], dists[l]\n                u, v = source[i:i+l], target[i:i+l]\n                if u in lookup and v in lookup:\n                    dp[(i+l)%len(dp)] = min(dp[(i+l)%len(dp)], dp[i%len(dp)]+memoization(l, dist, lookup[u], lookup[v]))\n            dp[i%len(dp)] = INF\n        return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1\n\n\n# Time:  O(o * l + k^3 + n * c * l), o = len(original), l = max(len(x) for x in original), k = len(lookups), c = len({len(x) for x in original})\n# Space: O(o * l + k^2 + c + l)\nimport collections\nimport itertools\n\n\n# hash table, Floyd-Warshall algorithm, dp\nclass Solution2(object):\n    def minimumCost(self, source, target, original, changed, cost):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :type original: List[str]\n        :type changed: List[str]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        def floydWarshall(dist):\n            for k in xrange(len(dist)):\n                for i in xrange(len(dist)):\n                    if dist[i][k] == INF:\n                        continue\n                    for j in xrange(len(dist[i])):\n                        if dist[k][j] == INF:\n                            continue\n                        dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])\n        \n        lookups = collections.defaultdict(dict)\n        for x in itertools.chain(original, changed):\n            l = len(x)\n            lookup = lookups[l]\n            if x not in lookup:\n                lookup[x] = len(lookup)\n        dists = {l:[[0 if u == v else INF for v in xrange(len(lookup))] for u in xrange(len(lookup))] for l, lookup in lookups.iteritems()}\n        for i in xrange(len(original)):\n            l = len(original[i])\n            lookup, dist = lookups[l], dists[l]\n            u, v = lookup[original[i]], lookup[changed[i]]\n            dist[u][v] = min(dist[u][v], cost[i])\n        for dist in dists.itervalues():\n            floydWarshall(dist)\n        candidates = {len(x) for x in original}\n        dp = [INF]*(max(len(x) for x in original)+1)\n        dp[0] = 0\n        for i in xrange(len(source)):\n            if dp[i%len(dp)] == INF:\n                continue\n            if source[i] == target[i]:\n                dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)])\n            for l in candidates:\n                if i+l > len(source):\n                    continue\n                lookup, dist = lookups[l], dists[l]\n                u, v = source[i:i+l], target[i:i+l]\n                if u in lookup and v in lookup:\n                    dp[(i+l)%len(dp)] = min(dp[(i+l)%len(dp)], dp[i%len(dp)]+dist[lookup[u]][lookup[v]])\n            dp[i%len(dp)] = INF\n        return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1\n\n\n# Time:  O(o * l + k * eloge + n * c * l), e is the number of edges reachable from a given node u, o = len(original), l = max(len(x) for x in original), k = len(lookups), c = len({len(x) for x in original})\n# Space: O(t + k * v + c + l), v is the number of nodes reachable from a given node u\nimport collections\nimport itertools\n\n\n# hash table, dijkstra's algorithm, dp, memoization\nclass Solution3(object):\n    def minimumCost(self, source, target, original, changed, cost):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :type original: List[str]\n        :type changed: List[str]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n\n        lookup = {}\n        for x in itertools.chain(original, changed):\n            if x in lookup:\n                continue\n            lookup[x] = len(lookup)\n        def dijkstra(start):\n            best = {start:0}\n            min_heap = [(0, start)]\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if curr > best[u]:\n                    continue\n                if u not in dist:\n                    continue\n                for v, w in dist[u].iteritems():     \n                    if v in best and best[v] <= curr+w:\n                        continue\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (best[v], v))\n            return best\n\n        memo = {}\n        def memoization(u, v):\n            if u not in lookup:\n                memo[u] = dijkstra(u)\n            return memo[u][v] if v in memo[u] else INF\n\n        dist = {}\n        for i in xrange(len(original)):\n            u, v = lookup[original[i]], lookup[changed[i]]\n            if u not in dist:\n                dist[u] = {v:INF}\n            if v not in dist[u]:\n                dist[u][v] = INF\n            dist[u][v] = min(dist[u][v], cost[i])\n        candidates = {len(x) for x in original}\n        dp = [INF]*(max(len(x) for x in original)+1)\n        dp[0] = 0\n        for i in xrange(len(source)):\n            if dp[i%len(dp)] == INF:\n                continue\n            if source[i] == target[i]:\n                dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)])\n            for l in candidates:\n                if i+l > len(source):\n                    continue\n                u, v = source[i:i+l], target[i:i+l]\n                if u in lookup and v in lookup:\n                    dp[(i+l)%len(dp)] = min(dp[(i+l)%len(dp)], dp[i%len(dp)]+memoization(lookup[u], lookup[v]))\n            dp[i%len(dp)] = INF\n        return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1\n\n\n# Time:  O(o * l + k^3 + n * c * l), o = len(original), l = max(len(x) for x in original), k = len(lookups), c = len({len(x) for x in original})\n# Space: O(o * l + k^2 + c + l)\nimport collections\nimport itertools\n\n\n# hash table, Floyd-Warshall algorithm, dp\nclass Solution4(object):\n    def minimumCost(self, source, target, original, changed, cost):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :type original: List[str]\n        :type changed: List[str]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        def floydWarshall(dist):\n            for k in dist.iterkeys():\n                for i in dist.iterkeys():\n                    if dist[i][k] == INF:\n                        continue\n                    for j in dist.iterkeys():\n                        if dist[k][j] == INF:\n                            continue\n                        dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])\n        \n        lookup = {}\n        buckets = collections.defaultdict(list)\n        for x in itertools.chain(original, changed):\n            l = len(x)\n            if x in lookup:\n                continue\n            lookup[x] = len(lookup)\n            buckets[len(x)].append(lookup[x])            \n        dists = {l:{u:{v:0 if u == v else INF for v in lookup} for u in lookup} for l, lookup in buckets.iteritems()}\n        for i in xrange(len(original)):\n            l = len(original[i])\n            dist = dists[l]\n            u, v = lookup[original[i]], lookup[changed[i]]\n            dist[u][v] = min(dist[u][v], cost[i])\n        for dist in dists.itervalues():\n            floydWarshall(dist)\n        candidates = {len(x) for x in original}\n        dp = [INF]*(max(len(x) for x in original)+1)\n        dp[0] = 0\n        for i in xrange(len(source)):\n            if dp[i%len(dp)] == INF:\n                continue\n            if source[i] == target[i]:\n                dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)])\n            for l in candidates:\n                if i+l > len(source):\n                    continue\n                dist = dists[l]\n                u, v = source[i:i+l], target[i:i+l]\n                if u in lookup and v in lookup:\n                    dp[(i+l)%len(dp)] = min(dp[(i+l)%len(dp)], dp[i%len(dp)]+dist[lookup[u]][lookup[v]])\n            dp[i%len(dp)] = INF\n        return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1\n\n\n# Time:  O(o * l + k * eloge + n * l), e is the number of edges reachable from a given node u, o = len(original), l = max(len(x) for x in original), k = trie.k\n# Space: O(t + k * v + l), v is the number of nodes reachable from a given node u\nimport itertools\nimport heapq\n\n\n# trie, dijkstra's algorithm, dp, memoization\nclass Solution5(object):\n    def minimumCost(self, source, target, original, changed, cost):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :type original: List[str]\n        :type changed: List[str]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        class Trie(object):\n            def __init__(self):\n                self.__nodes = []\n                self.__idxs = []\n                self.k = 0\n                self.__new_node()\n            \n            def __new_node(self):\n                self.__nodes.append([-1]*26)\n                self.__idxs.append(-1)\n                return len(self.__nodes)-1\n\n            def add(self, s):\n                curr = 0\n                for c in s:\n                    x = ord(c)-ord('a')\n                    if self.__nodes[curr][x] == -1:\n                        self.__nodes[curr][x] = self.__new_node()\n                    curr = self.__nodes[curr][x]\n                if self.__idxs[curr] == -1:\n                    self.__idxs[curr] = self.k\n                    self.k += 1\n                    return True, self.__idxs[curr]\n                return False, self.__idxs[curr]\n            \n            def query(self, s):\n                curr = 0\n                for c in s:\n                    curr = self.__nodes[curr][ord(c)-ord('a')]\n                return self.__idxs[curr]\n    \n            def next(self, curr, c):\n                return self.__nodes[curr][ord(c)-ord('a')]\n\n            def id(self, curr):\n                return self.__idxs[curr]\n\n        trie = Trie()\n        for x in itertools.chain(original, changed):\n            trie.add(x)\n        def dijkstra(start):\n            best = {start:0}\n            min_heap = [(0, start)]\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if curr > best[u]:\n                    continue\n                if u not in dist:\n                    continue\n                for v, w in dist[u].iteritems():     \n                    if v in best and best[v] <= curr+w:\n                        continue\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (best[v], v))\n            return best\n\n        memo = {}\n        def memoization(u, v):\n            if u not in memo:\n                memo[u] = dijkstra(u)\n            return memo[u][v] if v in memo[u] else INF\n\n        dist = {}\n        for i in xrange(len(original)):\n            u, v = trie.query(original[i]), trie.query(changed[i])\n            if u not in dist:\n                dist[u] = {v:INF}\n            if v not in dist[u]:\n                dist[u][v] = INF\n            dist[u][v] = min(dist[u][v], cost[i])\n        dp = [INF]*(max(len(x) for x in original)+1)\n        dp[0] = 0\n        for i in xrange(len(source)):\n            if dp[i%len(dp)] == INF:\n                continue\n            if source[i] == target[i]:\n                dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)])\n            u = v = 0\n            for j in xrange(i, len(source)):\n                u = trie.next(u, source[j])\n                v = trie.next(v, target[j])\n                if u == -1 or v == -1:\n                    break\n                if trie.id(u) != -1 and trie.id(v) != -1:\n                    dp[(j+1)%len(dp)] = min(dp[(j+1)%len(dp)], dp[i%len(dp)]+memoization(trie.id(u), trie.id(v)))\n            dp[i%len(dp)] = INF\n        return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1\n\n\n# Time:  O(o * l + k^3 + n * l), o = len(original), l = max(len(x) for x in original), k = trie.k\n# Space: O(t + k^2 + l)\nimport itertools\n\n\n# trie, Floyd-Warshall algorithm, dp\nclass Solution6(object):\n    def minimumCost(self, source, target, original, changed, cost):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :type original: List[str]\n        :type changed: List[str]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        class Trie(object):\n            def __init__(self):\n                self.__nodes = []\n                self.__idxs = []\n                self.k = 0\n                self.__new_node()\n            \n            def __new_node(self):\n                self.__nodes.append([-1]*26)\n                self.__idxs.append(-1)\n                return len(self.__nodes)-1\n\n            def add(self, s):\n                curr = 0\n                for c in s:\n                    x = ord(c)-ord('a')\n                    if self.__nodes[curr][x] == -1:\n                        self.__nodes[curr][x] = self.__new_node()\n                    curr = self.__nodes[curr][x]\n                if self.__idxs[curr] == -1:\n                    self.__idxs[curr] = self.k\n                    self.k += 1\n                    return True, self.__idxs[curr]\n                return False, self.__idxs[curr]\n            \n            def query(self, s):\n                curr = 0\n                for c in s:\n                    curr = self.__nodes[curr][ord(c)-ord('a')]\n                return self.__idxs[curr]\n    \n            def next(self, curr, c):\n                return self.__nodes[curr][ord(c)-ord('a')]\n\n            def id(self, curr):\n                return self.__idxs[curr]\n\n        def floydWarshall(dist):\n            for k in dist.iterkeys():\n                for i in dist.iterkeys():\n                    if dist[i][k] == INF:\n                        continue\n                    for j in dist.iterkeys():\n                        if dist[k][j] == INF:\n                            continue\n                        dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])\n        \n        trie = Trie()\n        buckets = collections.defaultdict(list)\n        for x in itertools.chain(original, changed):\n            not_duplicated, i = trie.add(x)\n            if not_duplicated:\n                buckets[len(x)].append(i)\n        dists = {l:{u:{v:0 if u == v else INF for v in lookup} for u in lookup} for l, lookup in buckets.iteritems()}\n        for i in xrange(len(original)):\n            l = len(original[i])\n            dist = dists[l]\n            u, v = trie.query(original[i]), trie.query(changed[i])\n            dist[u][v] = min(dist[u][v], cost[i])\n        for dist in dists.itervalues():\n            floydWarshall(dist)\n        dp = [INF]*(max(len(x) for x in original)+1)\n        dp[0] = 0\n        for i in xrange(len(source)):\n            if dp[i%len(dp)] == INF:\n                continue\n            if source[i] == target[i]:\n                dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)])\n            u = v = 0\n            for j in xrange(i, len(source)):\n                u = trie.next(u, source[j])\n                v = trie.next(v, target[j])\n                if u == -1 or v == -1:\n                    break\n                if trie.id(u) != -1 and trie.id(v) != -1:\n                    dp[(j+1)%len(dp)] = min(dp[(j+1)%len(dp)], dp[i%len(dp)]+dists[j-i+1][trie.id(u)][trie.id(v)])\n            dp[i%len(dp)] = INF\n        return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1\n"
    },
    {
        "problem_name": "minimum-cost-to-cut-a-stick",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\nclass Solution(object):\n    def minCost(self, n, cuts):\n        \"\"\"\n        :type n: int\n        :type cuts: List[int]\n        :rtype: int\n        \"\"\"\n        sorted_cuts = sorted(cuts + [0, n])\n        dp = [[0]*len(sorted_cuts) for _ in xrange(len(sorted_cuts))]\n        for l in xrange(2, len(sorted_cuts)):\n            for i in xrange(len(sorted_cuts)-l):\n                dp[i][i+l] = min(dp[i][j]+dp[j][i+l] for j in xrange(i+1, i+l)) + \\\n                             sorted_cuts[i+l]-sorted_cuts[i]\n        return dp[0][len(sorted_cuts)-1]\n"
    },
    {
        "problem_name": "minimum-cost-to-equalize-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# constructive algorithms, math\nclass Solution(object):\n    def minCostToEqualizeArray(self, nums, cost1, cost2):\n        \"\"\"\n        :type nums: List[int]\n        :type cost1: int\n        :type cost2: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        n = len(nums)\n        mx = max(nums)\n        total = mx*n-sum(nums)\n\n        # fill until mx with only cost1 operations\n        if n <= 2 or cost1*2 <= cost2:\n            return total*cost1%MOD\n    \n        result = float(\"inf\")\n        # fill until mx with more cost2 operations and fewer cost1 operations\n        mn = min(nums)\n        cnt1 = max((mx-mn)-(total-(mx-mn)), 0)\n        cnt2 = total-cnt1\n        result = min(result, (cnt1+cnt2%2)*cost1 + cnt2//2*cost2)\n\n        # fill until mx+x with most cost2 operations and fewest cost1 operations,\n        # where x is the  max of x s.t. cnt1+x >= (n-1)*x => cnt1 >= (n-2)*x\n        x, cnt1 = divmod(cnt1, (n-2))\n        total += n*x\n        cnt2 = total-cnt1\n        result = min(result, (cnt1+cnt2%2)*cost1 + (cnt2//2)*cost2)\n\n        # fill until mx+x+1 or mx+x+2 with nearly all cost2 operations and at most one cost1 operation\n        for _ in xrange(2):  # increase twice is for odd n\n            total += n\n            result = min(result, total%2*cost1 + total//2*cost2)\n        return result%MOD\n"
    },
    {
        "problem_name": "minimum-cost-to-hire-k-workers",
        "solution": "# Time:   O(nlogn)\n# Space : O(n)\n\nimport itertools\nimport heapq\n\n\nclass Solution(object):\n    def mincostToHireWorkers(self, quality, wage, K):\n        \"\"\"\n        :type quality: List[int]\n        :type wage: List[int]\n        :type K: int\n        :rtype: float\n        \"\"\"\n        result, qsum = float(\"inf\"), 0\n        max_heap = []\n        for r, q in sorted([float(w)/q, q] for w, q in itertools.izip(wage, quality)):\n            qsum += q\n            heapq.heappush(max_heap, -q)\n            if len(max_heap) > K:\n                qsum -= -heapq.heappop(max_heap)\n            if len(max_heap) == K:\n                result = min(result, qsum*r)\n        return result\n\n"
    },
    {
        "problem_name": "minimum-cost-to-make-all-characters-equal",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minimumCost(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return sum(min(i+1, len(s)-(i+1)) for i in xrange(len(s)-1) if s[i] != s[i+1])\n"
    },
    {
        "problem_name": "minimum-cost-to-make-array-equal",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport itertools\n\n\n# math, binary search\nclass Solution(object):\n    def minCost(self, nums, cost):\n        \"\"\"\n        :type nums: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        def f(x):\n            return sum(abs(y-x)*c for y, c in itertools.izip(nums, cost))\n\n        def check(x, t):\n            return sum(c for y, c in itertools.izip(nums, cost) if y <= x) >= t\n    \n        idxs = range(len(nums))\n        idxs.sort(key=lambda x: nums[x])\n        left, right = 0, len(idxs)-1\n        total = sum(cost)\n        median = (total+1)//2\n        while left <= right:\n            mid = left+(right-left)//2\n            if check(nums[idxs[mid]], median):\n                right = mid-1\n            else:\n                left = mid+1\n        return f(nums[idxs[left]])\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\n\n\n# binary search\nclass Solution2(object):\n    def minCost(self, nums, cost):\n        \"\"\"\n        :type nums: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        def f(x):\n            return sum(abs(y-x)*c for y, c in itertools.izip(nums, cost))\n    \n        def check(x):\n            return x+1 == len(idxs) or f(nums[idxs[x]]) < f(nums[idxs[x+1]])\n\n        idxs = range(len(nums))\n        idxs.sort(key=lambda x: nums[x])\n        left, right = 0, len(idxs)-1\n        while left <= right:\n            mid = left+(right-left)//2\n            if check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return f(nums[idxs[left]])\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# prefix sum\nclass Solution3(object):\n    def minCost(self, nums, cost):\n        \"\"\"\n        :type nums: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        idxs = range(len(nums))\n        idxs.sort(key=lambda x: nums[x])\n        prefix = [0]*(len(cost)+1)\n        left = 0\n        for i in xrange(len(cost)):\n            if i-1 >= 0:\n                left += prefix[i]*(nums[idxs[i]]-nums[idxs[i-1]])\n            prefix[i+1] = prefix[i]+cost[idxs[i]]\n        result = float(\"inf\")\n        suffix = right = 0\n        for i in reversed(xrange(len(cost))):\n            if i+1 < len(idxs):\n                right += suffix*(nums[idxs[i+1]]-nums[idxs[i]])\n            result = min(result, left+right)\n            if i-1 >= 0:\n                left -= prefix[i]*(nums[idxs[i]]-nums[idxs[i-1]])\n            suffix += cost[idxs[i]]\n        return result\n"
    },
    {
        "problem_name": "minimum-cost-to-make-array-equalindromic",
        "solution": "# Time:  O(n + logr)\n# Space: O(logr)\n\nimport random\n\n\n# lc0564\n# quick select, math, string\nclass Solution(object):\n    def minimumCost(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n    \n        def nearest_palindromic(x):\n            n = str(x)\n            l = len(n)\n            result = {10**l+1, 10**(l-1)-1}\n            prefix = int(n[:(l+1)/2])\n            for i in map(str, (prefix-1, prefix, prefix+1)):\n                result.add(int(i+[i, i[:-1]][l%2][::-1]))\n            return result\n\n        nth_element(nums, len(nums)//2)\n        median = nums[len(nums)//2]\n        if len(nums)%2 == 0:\n            nth_element(nums, len(nums)//2-1)\n            median = (median+nums[len(nums)//2-1])//2\n        return min(sum(abs(x-p) for x in nums) for p in nearest_palindromic(median))\n\n\n# Time:  O(nlogn + logr)\n# Space: O(logr)\n# lc0564\n# sort, math, string\nclass Solution2(object):\n    def minimumCost(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def nearest_palindromic(x):\n            n = str(x)\n            l = len(n)\n            result = {10**l+1, 10**(l-1)-1}\n            prefix = int(n[:(l+1)/2])\n            for i in map(str, (prefix-1, prefix, prefix+1)):\n                result.add(int(i+[i, i[:-1]][l%2][::-1]))\n            return result\n    \n        nums.sort()\n        median = nums[len(nums)//2]\n        if len(nums)%2 == 0:\n            median = (median+nums[len(nums)//2-1])//2\n        return min(sum(abs(x-p) for x in nums) for p in nearest_palindromic(median))\n"
    },
    {
        "problem_name": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\n# A* Search Algorithm without heap\nclass Solution(object):\n    def minCost(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        def a_star(grid, b, t):\n            f, dh = 0, 1\n            closer, detour = [b], []\n            lookup = set()\n            while closer or detour:\n                if not closer:\n                    f += dh\n                    closer, detour = detour, closer\n                b = closer.pop()\n                if b in lookup:\n                    continue\n                lookup.add(b)\n                if b == t:\n                    return f\n                for nd, (dr, dc) in enumerate(directions, 1):\n                    nb = (b[0]+dr, b[1]+dc)\n                    if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup):\n                        continue\n                    (closer if nd == grid[b[0]][b[1]] else detour).append(nb)\n            return -1\n\n        return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1))\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\nimport collections\n\n\n#  0-1 bfs solution\nclass Solution2(object):\n    def minCost(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        b, t = (0, 0), (len(grid)-1, len(grid[0])-1)\n        dq = collections.deque([(b, 0)])\n        lookup = set()\n        while dq:\n            b, d = dq.popleft()\n            if b in lookup:\n                continue\n            lookup.add(b)\n            if b == t:\n                return d\n            for nd, (dr, dc) in enumerate(directions, 1):\n                nb = (b[0]+dr, b[1]+dc)\n                if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup):\n                    continue\n                if nd == grid[b[0]][b[1]]:\n                    dq.appendleft((nb, d))\n                else:\n                    dq.append((nb, d+1))\n        return -1  # never reach here\n"
    },
    {
        "problem_name": "minimum-cost-to-merge-stones",
        "solution": "# Time:  O(n^3 / k)\n# Space: O(n^2)\n\nclass Solution(object):\n    def mergeStones(self, stones, K):\n        \"\"\"\n        :type stones: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        if (len(stones)-1) % (K-1):\n            return -1\n        prefix = [0]\n        for x in stones:\n            prefix.append(prefix[-1]+x)\n        dp = [[0]*len(stones) for _ in xrange(len(stones))]\n        for l in xrange(K-1, len(stones)):\n            for i in xrange(len(stones)-l):\n                dp[i][i+l] = min(dp[i][j]+dp[j+1][i+l] for j in xrange(i, i+l, K-1))\n                if l % (K-1) == 0:\n                    dp[i][i+l] += prefix[i+l+1] - prefix[i]\n        return dp[0][len(stones)-1]\n"
    },
    {
        "problem_name": "minimum-cost-to-reach-city-with-discounts",
        "solution": "# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,\n#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport collections\nimport heapq\n\n\nclass Solution(object):\n    def minimumCost(self, n, highways, discounts):\n        \"\"\"\n        :type n: int\n        :type highways: List[List[int]]\n        :type discounts: int\n        :rtype: int\n        \"\"\"\n        adj = [[] for _ in xrange(n)]\n        for u, v, w in highways:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        src, dst = 0, n-1\n        best = collections.defaultdict(lambda: collections.defaultdict(lambda: float(\"inf\")))\n        best[src][discounts] = 0\n        min_heap = [(0, src, discounts)]\n        while min_heap:\n            result, u, k = heapq.heappop(min_heap)\n            if best[u][k] < result:\n                continue\n            if u == dst:\n                return result\n            for v, w in adj[u]:\n                if result+w < best[v][k]:\n                    best[v][k] = result+w                    \n                    heapq.heappush(min_heap, (result+w, v, k))\n                if k > 0 and result+w//2 < best[v][k-1]:\n                    best[v][k-1] = result+w//2                   \n                    heapq.heappush(min_heap, (result+w//2, v, k-1))\n        return -1\n"
    },
    {
        "problem_name": "minimum-cost-to-reach-destination-in-time",
        "solution": "# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),\n#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport collections\nimport heapq\n\n\n# Dijkstra's algorithm\nclass Solution(object):\n    def minCost(self, maxTime, edges, passingFees):\n        \"\"\"\n        :type maxTime: int\n        :type edges: List[List[int]]\n        :type passingFees: List[int]\n        :rtype: int\n        \"\"\"        \n        adj = [[] for i in xrange(len(passingFees))]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        best = collections.defaultdict(lambda:float(\"inf\"))\n        best[0] = 0\n        min_heap = [(passingFees[0], 0, 0)]\n        while min_heap:\n            result, u, w = heapq.heappop(min_heap)\n            if w > maxTime:  # state with best[u] < w can't be filtered, which may have less cost\n                continue\n            if u == len(passingFees)-1:\n                return result\n            for v, nw in adj[u]:\n                if w+nw < best[v]:  # from less cost to more cost, only need to check state with less time\n                    best[v] = w+nw\n                    heapq.heappush(min_heap, (result+passingFees[v], v, w+nw))\n        return -1\n"
    },
    {
        "problem_name": "minimum-cost-to-separate-sentence-into-rows",
        "solution": "# Time:  O(s + n * k), n is the number of the word_lens\n# Space: O(k)\n\nclass Solution(object):\n    def minimumCost(self, sentence, k):\n        \"\"\"\n        :type sentence: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def lens(sentence):\n            j = len(sentence)-1\n            for i in reversed(xrange(-1, len(sentence))):\n                if i == -1 or sentence[i] == ' ':\n                    yield j-i\n                    j = i-1\n\n        word_lens, dp = [], []  # dp[i]: min cost of word_lens[-1-i:]\n        t = -1\n        for l in lens(sentence):\n            word_lens.append(l)\n            dp.append(float(\"inf\"))\n            t += l+1\n            if t <= k:\n                dp[-1] = 0\n                continue\n            total = l\n            for j in reversed(xrange(len(dp)-1)):\n                dp[-1] = min(dp[-1], dp[j] + (k-total)**2)\n                total += (word_lens[j]+1)\n                if total > k:\n                    word_lens = word_lens[j:]  # minimize len(word_lens) s.t. sum(word_lens) > k\n                    dp = dp[j:]\n                    break\n        return dp[-1] if dp else 0\n\n\n# Time:  O(s + n * k), n is the number of the word_lens\n# Space: O(n)\nclass Solution2(object):\n    def minimumCost(self, sentence, k):\n        \"\"\"\n        :type sentence: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        word_lens = []\n        j = 0\n        for i in xrange(len(sentence)+1):\n            if i != len(sentence) and sentence[i] != ' ':\n                continue\n            word_lens.append(i-j)\n            j = i+1\n        dp = [float(\"inf\")]*(len(word_lens))  # dp[i]: min cost of word_lens[i:]\n        i, total = len(word_lens)-1, -1\n        while i >= 0 and total + (word_lens[i]+1) <= k:  # find max i s.t. the length of the last line > k\n            total += (word_lens[i]+1)\n            dp[i] = 0\n            i -= 1\n        for i in reversed(xrange(i+1)):\n            total = word_lens[i]\n            for j in xrange(i+1, len(dp)):\n                dp[i] = min(dp[i], dp[j] + (k-total)**2)\n                total += (word_lens[j]+1)\n                if total > k:\n                    break\n        return dp[0]\n\n\n# Time:  O(s + n * k), n is the number of the word_lens\n# Space: O(n)\nclass Solution3(object):\n    def minimumCost(self, sentence, k):\n        \"\"\"\n        :type sentence: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        word_lens = []\n        j = 0\n        for i in xrange(len(sentence)+1):\n            if i != len(sentence) and sentence[i] != ' ':\n                continue\n            word_lens.append(i-j)\n            j = i+1\n        dp = [float(\"inf\")]*(1+(len(word_lens)-1))  # dp[i]: min cost of the first i word_lens where i in [0, len(words)-1]\n        dp[0] = 0\n        for i in xrange(1, (len(word_lens)-1)+1):\n            total = word_lens[i-1]\n            for j in reversed(xrange(i)):\n                dp[i] = min(dp[i], dp[j] + (k-total)**2)\n                if j-1 < 0:\n                    continue\n                total += (word_lens[j-1]+1)\n                if total > k:\n                    break\n        i, total = len(word_lens)-1, -1\n        while i >= 0 and total + (word_lens[i]+1) <= k:  # find max i s.t. the length of the last line > k\n            total += (word_lens[i]+1)\n            i -= 1\n        return min(dp[j] for j in xrange(i+1, len(dp)))\n"
    },
    {
        "problem_name": "minimum-cost-to-set-cooking-time",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# simulation\nclass Solution(object):\n    def minCostSetTime(self, startAt, moveCost, pushCost, targetSeconds):\n        \"\"\"\n        :type startAt: int\n        :type moveCost: int\n        :type pushCost: int\n        :type targetSeconds: int\n        :rtype: int\n        \"\"\"     \n        def cost(m, s):\n            if not (0 <= m <= 99 and s <= 99):\n                return float(\"inf\")\n            result = 0\n            curr = startAt\n            for x in map(int, list(str(m*100 + s))):\n                result += (moveCost if x != curr else 0)+pushCost\n                curr = x\n            return result\n\n        m, s = divmod(targetSeconds, 60)\n        return min(cost(m, s), cost(m-1, s+60))\n"
    },
    {
        "problem_name": "minimum-cost-to-split-an-array",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport collections\n\n\n# dp\nclass Solution(object):\n    def minCost(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        dp = [float(\"inf\")]*(len(nums)+1)\n        dp[0] = 0\n        for i in xrange(len(dp)-1):\n            cnt = [0]*len(nums)\n            d = 0\n            for j in xrange(i+1, len(dp)):\n                cnt[nums[j-1]] += 1\n                if cnt[nums[j-1]] == 1:\n                    d += 1\n                elif cnt[nums[j-1]] == 2:\n                    d -= 1\n                dp[j] = min(dp[j], dp[i]+k+((j-i)-d))\n        return dp[-1]\n"
    },
    {
        "problem_name": "minimum-cost-tree-from-leaf-values",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def mctFromLeafValues(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = [float(\"inf\")]\n        for x in arr:\n            while stk[-1] <= x:\n                result += stk.pop() * min(stk[-1], x)\n            stk.append(x)\n        while len(stk) > 2:\n            result += stk.pop() * stk[-1]\n        return result\n"
    },
    {
        "problem_name": "minimum-cost-walk-in-weighted-graph",
        "solution": "# Time:  O(n + e + q)\n# Space: O(n)\n\n# union find\nclass Solution(object):\n    def minimumCost(self, n, edges, query):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type query: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        class UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n            def __init__(self, n):\n                self.set = list(range(n))\n                self.rank = [0]*n\n                self.w = [-1]*n  # added\n\n            def find_set(self, x):\n                stk = []\n                while self.set[x] != x:  # path compression\n                    stk.append(x)\n                    x = self.set[x]\n                while stk:\n                    self.set[stk.pop()] = x\n                return x\n\n            def union_set(self, x, y, w):  # modified\n                x, y = self.find_set(x), self.find_set(y)\n                if x == y:\n                    self.w[x] &= w  # added\n                    return False\n                if self.rank[x] > self.rank[y]:  # union by rank\n                    x, y = y, x\n                self.set[x] = self.set[y]\n                if self.rank[x] == self.rank[y]:\n                    self.rank[y] += 1\n                self.w[y] &= self.w[x]&w  # added\n                return True\n            \n            def cost(self, x):  # added\n                return self.w[self.find_set(x)]\n\n        uf = UnionFind(n)\n        for u, v, w in edges:\n            uf.union_set(u, v, w)\n        result = [-1]*(len(query))\n        for i, (s, t) in enumerate(query):\n            if uf.find_set(s) != uf.find_set(t):\n                continue\n            result[i] = uf.cost(s) if s != t else 0\n        return result\n"
    },
    {
        "problem_name": "minimum-costs-using-the-train-line",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\n# dp\nclass Solution(object):\n    def minimumCosts(self, regular, express, expressCost):\n        \"\"\"\n        :type regular: List[int]\n        :type express: List[int]\n        :type expressCost: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        dp = [0, expressCost]  # dp[0]: min cost of regular route to curr stop, dp[1]: min cost of express route to curr stop\n        for r, e in itertools.izip(regular, express):\n            dp = [min(dp[0]+r, dp[1]+e), min(dp[0]+(r+expressCost), dp[1]+e)]\n            result.append(min(dp[0], dp[1]))\n        return result\n"
    },
    {
        "problem_name": "minimum-cuts-to-divide-a-circle",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def numberOfCuts(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return 0 if n == 1 else n if n%2 else n//2\n"
    },
    {
        "problem_name": "minimum-degree-of-a-connected-trio-in-a-graph",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\nclass Solution(object):\n    def minTrioDegree(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        adj = [set() for _ in xrange(n+1)]\n        degree = [0]*(n+1)\n        for u, v in edges:\n            adj[min(u, v)].add(max(u, v))\n            degree[u] += 1\n            degree[v] += 1\n        result = float(\"inf\")\n        for u in xrange(1, n+1):\n            for v in adj[u]:\n                for w in adj[u]:\n                    if v < w and w in adj[v]:\n                        result = min(result, degree[u]+degree[v]+degree[w] - 6)\n        return result if result != float(\"inf\") else -1\n"
    },
    {
        "problem_name": "minimum-deletion-cost-to-avoid-repeating-letters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minCost(self, s, cost):\n        \"\"\"\n        :type s: str\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        result = accu = max_cost = 0\n        for i in xrange(len(s)):\n            if i and s[i] != s[i-1]:\n                result += accu-max_cost\n                accu = max_cost = 0\n            accu += cost[i]\n            max_cost = max(max_cost, cost[i])\n        result += accu-max_cost\n        return result\n"
    },
    {
        "problem_name": "minimum-deletions-to-make-array-beautiful",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minDeletion(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(len(nums)-1):\n            result += int(i%2 == result%2 and nums[i] == nums[i+1])\n        return result+(len(nums)-result)%2\n"
    },
    {
        "problem_name": "minimum-deletions-to-make-array-divisible",
        "solution": "# Time:  O(n + m + logr), r is max(numsDivide)\n# Space: O(1)\n\n# gcd\nclass Solution(object):\n    def minOperations(self, nums, numsDivide):\n        \"\"\"\n        :type nums: List[int]\n        :type numsDivide: List[int]\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):  # Time: O(log(min(a, b)))\n            while b:\n                a, b = b, a%b\n            return a\n\n        g = reduce(gcd, numsDivide)\n        mn = float(\"inf\")\n        for x in nums:\n            if g%x == 0:\n                mn = min(mn, x)\n        return sum(x < mn for x in nums) if mn != float(\"inf\") else -1\n"
    },
    {
        "problem_name": "minimum-deletions-to-make-character-frequencies-unique",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\nimport string\n\nclass Solution(object):\n    def minDeletions(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        count = collections.Counter(s)\n        result = 0\n        lookup = set()\n        for c in string.ascii_lowercase:\n            for i in reversed(xrange(1, count[c]+1)):\n                if i not in lookup:\n                    lookup.add(i)\n                    break\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "minimum-deletions-to-make-string-balanced",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minimumDeletions(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = b_cnt = 0\n        for c in s:\n            if c == 'b':\n                b_cnt += 1\n            elif b_cnt:\n                b_cnt -= 1\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "minimum-deletions-to-make-string-k-special",
        "solution": "# Time:  O(n + 26)\n# Space: O(n + 26)\n\n# freq table, counting sort, two pointers\nclass Solution(object):\n    def minimumDeletions(self, word, k):\n        \"\"\"\n        :type word: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def counting_sort(arr, key=lambda x:x, reverse=False):  # Time: O(n), Space: O(n)\n            count = [0]*(max(arr, key=key)+1)\n            for x in arr:\n                count[key(x)] += 1\n            for i in xrange(1, len(count)):\n                count[i] += count[i-1]\n            result = [0]*len(arr)\n            if not reverse:\n                for x in reversed(arr):  # stable sort\n                    count[key(x)] -= 1\n                    result[count[key(x)]] = x\n            else:\n                for x in arr:  # stable sort\n                    count[key(x)] -= 1\n                    result[count[key(x)]] = x\n                result.reverse()\n            return result\n    \n        cnt = [0]*26\n        for x in word:\n            cnt[ord(x)-ord('a')] += 1\n        arr = counting_sort([x for x in cnt if x])\n        result = float(\"inf\")\n        right = prefix = 0\n        suffix = len(word)\n        prev = -1\n        for left in xrange(len(arr)):\n            if left+1 < len(arr) and arr[left+1] == arr[left]:\n                continue\n            while right < len(arr) and arr[right] <= arr[left]+k:\n                suffix -= arr[right]\n                right += 1\n            result = min(result, prefix+(suffix-(arr[left]+k)*(len(arr)-right)))\n            prefix += arr[left]*(left-prev)\n            prev = left\n        return result\n\n\n# Time:  O(n + 26 * log(26))\n# Space: O(26)\n# freq table, sort, two pointers\nclass Solution2(object):\n    def minimumDeletions(self, word, k):\n        \"\"\"\n        :type word: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        cnt = [0]*26\n        for x in word:\n            cnt[ord(x)-ord('a')] += 1\n        arr = sorted(x for x in cnt if x)\n        result = float(\"inf\")\n        right = prefix = 0\n        suffix = len(word)\n        prev = -1\n        for left in xrange(len(arr)):\n            if left+1 < len(arr) and arr[left+1] == arr[left]:\n                continue\n            while right < len(arr) and arr[right] <= arr[left]+k:\n                suffix -= arr[right]\n                right += 1\n            result = min(result, prefix+(suffix-(arr[left]+k)*(len(arr)-right)))\n            prefix += arr[left]*(left-prev)\n            prev = left\n        return result\n\n\n# Time:  O(n + 26^2)\n# Space: O(26)\n# freq table\nclass Solution3(object):\n    def minimumDeletions(self, word, k):\n        \"\"\"\n        :type word: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        cnt = [0]*26\n        for x in word:\n            cnt[ord(x)-ord('a')] += 1\n        return min(sum(y if y < x else max(y-(x+k), 0) for y in cnt if y) for x in cnt if x)\n"
    },
    {
        "problem_name": "minimum-depth-of-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h), h is height of binary tree\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return an integer\n    def minDepth(self, root):\n        if root is None:\n            return 0\n\n        if root.left and root.right:\n            return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n        else:\n            return max(self.minDepth(root.left), self.minDepth(root.right)) + 1\n\n"
    },
    {
        "problem_name": "minimum-difference-between-highest-and-lowest-of-k-scores",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def minimumDifference(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return min(nums[i]-nums[i-k+1] for i in xrange(k-1, len(nums)))\n"
    },
    {
        "problem_name": "minimum-difference-between-largest-and-smallest-value-in-three-moves",
        "solution": "# Time:  O(n + klogk)\n# Space: O(k)\n\nimport random\n\n\nclass Solution(object):\n    def minDifference(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):\n            def partition_around_pivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == n:\n                    return\n                elif new_pivot_idx > n:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < n\n                    left = new_pivot_idx + 1\n\n        k = 4\n        if len(nums) <= k:\n            return 0\n        nth_element(nums, 0, k, len(nums)-1)\n        nums[:k] = sorted(nums[:k])\n        nth_element(nums, k, max(k, len(nums)-k), len(nums)-1)\n        nums[-k:] = sorted(nums[-k:])\n        return min(nums[-k+i]-nums[i] for i in xrange(k))\n"
    },
    {
        "problem_name": "minimum-difference-in-sums-after-removal-of-elements",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\n# heap, prefix sum\nclass Solution(object):\n    def minimumDifference(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_heap = []\n        for i in xrange(len(nums)//3):\n            heapq.heappush(max_heap, -nums[i])\n        prefix = [0]*(len(nums)//3+1)\n        prefix[0] = -sum(max_heap)\n        for i in xrange(len(nums)//3):\n            x = -heapq.heappushpop(max_heap, -nums[i+len(nums)//3])\n            prefix[i+1] = prefix[i]-x+nums[i+len(nums)//3]\n\n        min_heap = []\n        for i in reversed(xrange(len(nums)//3*2, len(nums))):\n            heapq.heappush(min_heap, nums[i])\n        suffix = sum(min_heap)\n        result = prefix[len(nums)//3]-suffix\n        for i in reversed(xrange(len(nums)//3)):\n            x = heapq.heappushpop(min_heap, nums[i+len(nums)//3])\n            suffix += -x+nums[i+len(nums)//3]\n            result = min(result, prefix[i]-suffix)\n        return result\n"
    },
    {
        "problem_name": "minimum-difficulty-of-a-job-schedule",
        "solution": "# Time:  O(d * n^2)\n# Space: O(d * n)\n\nclass Solution(object):\n    def minDifficulty(self, jobDifficulty, d):\n        \"\"\"\n        :type jobDifficulty: List[int]\n        :type d: int\n        :rtype: int\n        \"\"\"\n        if len(jobDifficulty) < d:\n            return -1;\n        \n        dp = [[float(\"inf\")]*len(jobDifficulty) for _ in xrange(d)]\n        dp[0][0] = jobDifficulty[0]\n        for i in xrange(1, len(jobDifficulty)):\n            dp[0][i] = max(dp[0][i-1], jobDifficulty[i])\n        for i in xrange(1, d):\n            for j in xrange(i, len(jobDifficulty)):\n                curr_max = jobDifficulty[j]\n                for k in reversed(xrange(i, j+1)):\n                    curr_max = max(curr_max, jobDifficulty[k])\n                    dp[i][j] = min(dp[i][j], dp[i-1][k-1] + curr_max)\n        return dp[d-1][len(jobDifficulty)-1]\n"
    },
    {
        "problem_name": "minimum-distance-between-bst-nodes",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def minDiffInBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node):\n            if not node:\n                return\n            dfs(node.left)\n            self.result = min(self.result, node.val-self.prev)\n            self.prev = node.val\n            dfs(node.right)\n\n        self.prev = float('-inf')\n        self.result = float('inf')\n        dfs(root)\n        return self.result\n\n\n"
    },
    {
        "problem_name": "minimum-distance-to-the-target-element",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def getMinDistance(self, nums, target, start):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :type start: int\n        :rtype: int\n        \"\"\"\n        for i in xrange(len(nums)):\n            if (start-i >= 0 and nums[start-i] == target) or \\\n               (start+i < len(nums) and nums[start+i] == target):\n                break\n        return i\n"
    },
    {
        "problem_name": "minimum-distance-to-type-a-word-using-two-fingers",
        "solution": "# Time:  O(26n)\n# Space: O(26)\n\nclass Solution(object):\n    def minimumDistance(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        def distance(a, b):\n            return abs(a//6 - b//6) + abs(a%6 - b%6)\n\n        dp = [0]*26\n        for i in xrange(len(word)-1):\n            b, c = ord(word[i])-ord('A'), ord(word[i+1])-ord('A')\n            dp[b] = max(dp[a] - distance(a, c) + distance(b, c) for a in xrange(26))\n        return sum(distance(ord(word[i])-ord('A'), ord(word[i+1])-ord('A')) for i in xrange(len(word)-1)) - max(dp)\n\n\n# Time:  O(52n)\n# Space: O(52)\nclass Solution2(object):\n    def minimumDistance(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        def distance(a, b):\n            if -1 in [a, b]:\n                return 0\n            return abs(a//6 - b//6) + abs(a%6 - b%6)\n\n        dp = {(-1, -1): 0}\n        for c in word:\n            c = ord(c)-ord('A')\n            new_dp = {}\n            for a, b in dp:\n                new_dp[c, b] = min(new_dp.get((c, b), float(\"inf\")), dp[a, b] + distance(a, c))\n                new_dp[a, c] = min(new_dp.get((a, c), float(\"inf\")), dp[a, b] + distance(b, c))\n            dp = new_dp\n        return min(dp.itervalues())\n"
    },
    {
        "problem_name": "minimum-domino-rotations-for-equal-row",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def minDominoRotations(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        intersect = reduce(set.__and__, [set(d) for d in itertools.izip(A, B)])\n        if not intersect:\n            return -1\n        x = intersect.pop()\n        return min(len(A)-A.count(x), len(B)-B.count(x))\n"
    },
    {
        "problem_name": "minimum-edge-reversals-so-every-node-is-reachable",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# iterative dfs, tree dp\nclass Solution(object):\n    def minEdgeReversals(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def iter_dfs1():\n            result = 0\n            stk = [(0, -1)]\n            while stk:\n                u, p = stk.pop()\n                for v in adj[u].iterkeys():\n                    if v == p:\n                        continue\n                    result += adj[u][v]\n                    stk.append((v, u))\n            return result\n\n        def iter_dfs2(curr):\n            result = [-1]*n\n            stk = [(0, curr)]\n            while stk:\n                u, curr = stk.pop()\n                result[u] = curr\n                for v in adj[u].iterkeys():\n                    if result[v] == -1:\n                        stk.append((v, curr-adj[u][v]+adj[v][u]))\n            return result\n    \n        adj = collections.defaultdict(dict)\n        for u, v in edges:\n            adj[u][v] = 0\n            adj[v][u] = 1\n        return iter_dfs2(iter_dfs1())\n        \n\n# Time:  O(n)\n# Space: O(n)\n# dfs, tree dp\nclass Solution2(object):\n    def minEdgeReversals(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def dfs1(u, p):\n            return sum(adj[u][v]+dfs1(v, u) for v in adj[u] if v != p)\n\n        def dfs2(u, curr):\n            result[u] = curr\n            for v in adj[u]:\n                if result[v] == -1:\n                    dfs2(v, curr-adj[u][v]+adj[v][u])\n    \n        adj = collections.defaultdict(dict)\n        for u, v in edges:\n            adj[u][v] = 0\n            adj[v][u] = 1\n        result = [-1]*n\n        dfs2(0, dfs1(0, -1))\n        return result\n"
    },
    {
        "problem_name": "minimum-edge-weight-equilibrium-queries-in-a-tree",
        "solution": "# Time:  O(r * (n + q)), r = max(w for _, _, w in edges)\n# Space: O(r * n + q)\n\nimport collections\nfrom functools import partial\n\n\n# Template:\n# https://github.com/kamyu104/GoogleKickStart-2021/blob/main/Round%20H/dependent_events3.py\n# Tarjan's Offline LCA Algorithm\nclass UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n        self.ancestor = range(n)  # added\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x, y = self.find_set(x), self.find_set(y)\n        if x == y:\n            return False\n        if self.rank[x] > self.rank[y]:  # union by rank\n            x, y = y, x\n        self.set[x] = self.set[y]\n        if self.rank[x] == self.rank[y]:\n            self.rank[y] += 1\n        return True\n\n    def find_ancestor_of_set(self, x):  # added\n        return self.ancestor[self.find_set(x)]\n\n    def update_ancestor_of_set(self, x):  # added\n        self.ancestor[self.find_set(x)] = x\n\n\nclass TreeInfos(object):  # Time: O(N), Space: O(N + Q), N is the number of nodes\n    def __init__(self, adj, pairs):\n        def preprocess(u, p, w):  # modified\n            # depth of the node i\n            D[u] = 1 if p == -1 else D[p]+1\n            if w != -1:  # added\n                cnt[w] += 1\n            CNT[u] = cnt[:]  # added\n\n        def divide(u, p, w):  # modified\n            stk.append(partial(postprocess, u, w))  # modified\n            for i in reversed(xrange(len(adj[u]))):\n                v, nw = adj[u][i]\n                if v == p:\n                    continue\n                stk.append(partial(conquer, v, u))\n                stk.append(partial(divide, v, u, nw))  # modified\n            stk.append(partial(preprocess, u, p, w))  # modified\n\n        def conquer(u, p):\n            uf.union_set(u, p)\n            uf.update_ancestor_of_set(p)\n\n        def postprocess(u, w):  # modified\n            lookup[u] = True\n            for v in pairs[u]:\n                if not lookup[v]:\n                    continue\n                lca[min(u, v), max(u, v)] = uf.find_ancestor_of_set(v)\n            if w != -1:  # added\n                cnt[w] -= 1\n\n        N = len(adj)\n        D, uf, lca = [0]*N, UnionFind(N), {}\n        CNT = [[0]*MAX_W for _ in xrange(N)]  # added\n        cnt = [0]*MAX_W  # added\n        stk, lookup = [], [False]*N\n        stk.append(partial(divide, 0, -1, -1))  # modified\n        while stk:\n            stk.pop()()\n        self.D, self.lca = D, lca\n        self.CNT = CNT  # added\n\n\n# Tarjan's Offline LCA Algorithm\nMAX_W = 26\nclass Solution(object):\n    def minOperationsQueries(self, n, edges, queries):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = [[] for _ in xrange(n)]\n        for u, v, w in edges:\n            w -= 1\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        pairs = collections.defaultdict(set)\n        for a, b in queries:\n            pairs[a].add(b), pairs[b].add(a)\n        tree_infos = TreeInfos(adj, pairs)\n        result = [0]*len(queries)\n        for i, (a, b) in enumerate(queries):\n            lca = tree_infos.lca[min(a, b), max(a, b)]\n            result[i] = (tree_infos.D[a]+tree_infos.D[b]-2*tree_infos.D[lca])-max(tree_infos.CNT[a][w]+tree_infos.CNT[b][w]-2*tree_infos.CNT[lca][w] for w in xrange(MAX_W))\n        return result\n\n\n# Time:  O(r * (n + q) + nlogn + qlogn), r = max(w for _, _, w in edges)\n# Space: O(r * n + nlogn)\nimport collections\nfrom functools import partial\n\n\n# Template:\n# https://github.com/kamyu104/GoogleKickStart-2021/blob/main/Round%20H/dependent_events2.py\nclass TreeInfos2(object):  # Time: O(NlogN), Space: O(NlogN), N is the number of nodes\n    def __init__(self, adj):  # modified\n        def preprocess(u, p, w):\n            # depth of the node i\n            D[u] = 1 if p == -1 else D[p]+1\n            # ancestors of the node i\n            if p != -1:\n                P[u].append(p)\n            i = 0\n            while i < len(P[u]) and i < len(P[P[u][i]]):\n                P[u].append(P[P[u][i]][i])\n                i += 1\n            # the subtree of the node i is represented by traversal index L[i]..R[i]\n            C[0] += 1\n            L[u] = C[0]\n            if w != -1:  # added\n                cnt[w] += 1\n            CNT[u] = cnt[:]  # added\n\n        def divide(u, p, w):  # modified\n            stk.append(partial(postprocess, u, w))  # modified\n            for i in reversed(xrange(len(adj[u]))):\n                v, nw = adj[u][i]\n                if v == p:\n                    continue\n                stk.append(partial(divide, v, u, nw))  # modified\n            stk.append(partial(preprocess, u, p, w))  # modified\n\n        def postprocess(u, w):  # modified\n            R[u] = C[0]\n            if w != -1:  # added\n                cnt[w] -= 1\n\n        N = len(adj)\n        L, R, D, P, C = [0]*N, [0]*N, [0]*N, [[] for _ in xrange(N)], [-1]\n        CNT = [[0]*MAX_W for _ in xrange(N)]  # added\n        cnt = [0]*MAX_W  # added\n        stk = []\n        stk.append(partial(divide, 0, -1, -1))  # modified\n        while stk:\n            stk.pop()()\n        assert(C[0] == N-1)\n        self.L, self.R, self.D, self.P = L, R, D, P\n        self.CNT = CNT  # added\n\n    # Template:\n    # https://github.com/kamyu104/FacebookHackerCup-2019/blob/master/Final%20Round/little_boat_on_the_sea.py\n    def is_ancestor(self, a, b):  # includes itself\n        return self.L[a] <= self.L[b] <= self.R[b] <= self.R[a]\n\n    def lca(self, a, b):\n        if self.D[a] > self.D[b]:\n            a, b = b, a\n        if self.is_ancestor(a, b):\n            return a\n        for i in reversed(xrange(len(self.P[a]))):  # O(logN)\n            if i < len(self.P[a]) and not self.is_ancestor(self.P[a][i], b):\n                a = self.P[a][i]\n        return self.P[a][0]\n\n\n# binary lifting (online lca algorithm)\nMAX_W = 26\nclass Solution2(object):\n    def minOperationsQueries(self, n, edges, queries):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = [[] for _ in xrange(n)]\n        for u, v, w in edges:\n            w -= 1\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        tree_infos = TreeInfos2(adj)\n        result = [0]*len(queries)\n        for i, (a, b) in enumerate(queries):\n            lca = tree_infos.lca(a, b)\n            result[i] = (tree_infos.D[a]+tree_infos.D[b]-2*tree_infos.D[lca])-max(tree_infos.CNT[a][w]+tree_infos.CNT[b][w]-2*tree_infos.CNT[lca][w] for w in xrange(MAX_W))\n        return result\n"
    },
    {
        "problem_name": "minimum-elements-to-add-to-form-a-given-sum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minElements(self, nums, limit, goal):\n        \"\"\"\n        :type nums: List[int]\n        :type limit: int\n        :type goal: int\n        :rtype: int\n        \"\"\"\n        return (abs(sum(nums)-goal) + (limit-1))//limit\n"
    },
    {
        "problem_name": "minimum-equal-sum-of-two-arrays-after-replacing-zeros",
        "solution": "# Time:  O(n + m)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minSum(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        total1 = sum(max(x, 1) for x in nums1)\n        total2 = sum(max(x, 1) for x in nums2)\n        if total1 < total2:\n            return total2 if 0 in nums1 else -1\n        if total1 > total2:\n            return total1 if 0 in nums2 else -1\n        return total1\n"
    },
    {
        "problem_name": "minimum-factorization",
        "solution": "# Time:  O(loga)\n# Space: O(1)\n\nclass Solution(object):\n    def smallestFactorization(self, a):\n        \"\"\"\n        :type a: int\n        :rtype: int\n        \"\"\"\n        if a < 2:\n            return a\n        result, mul = 0, 1\n        for i in reversed(xrange(2, 10)):\n            while a % i == 0:\n                a /= i\n                result = mul*i + result\n                mul *= 10\n        return  result if a == 1 and result < 2**31 else 0\n\n\n"
    },
    {
        "problem_name": "minimum-falling-path-sum-ii",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nimport heapq\n\n\nclass Solution(object):\n    def minFallingPathSum(self, arr):\n        \"\"\"\n        :type arr: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for i in xrange(1, len(arr)):\n            smallest_two = heapq.nsmallest(2, arr[i-1])\n            for j in xrange(len(arr[0])):\n                arr[i][j] += smallest_two[1] if arr[i-1][j] == smallest_two[0] else smallest_two[0]\n        return min(arr[-1])\n"
    },
    {
        "problem_name": "minimum-falling-path-sum",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def minFallingPathSum(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for i in xrange(1, len(A)):\n            for j in xrange(len(A[i])):\n                A[i][j] += min(A[i-1][max(j-1, 0):j+2])\n        return min(A[-1])\n"
    },
    {
        "problem_name": "minimum-flips-in-binary-tree-to-get-result",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\nimport collections\n\n\n# tree dp with stack\nclass Solution(object):\n    def minimumFlips(self, root, result):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type result: bool\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        OP = {\n            2: lambda x, y: x or y,\n            3: lambda x, y: x and y,\n            4: lambda x, y: x^y ,\n            5: lambda x, y: not x if x is not None else not y\n        }\n        \n        def iter_dfs(root, result):\n            ret = collections.defaultdict(lambda: INF)\n            stk = [(1, (root, ret))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    node, ret = args\n                    if not node:\n                        ret[None] = 0 # null object pattern\n                        continue\n                    if node.left == node.right:\n                        ret[True] = node.val^1\n                        ret[False] = node.val^0\n                        continue\n                    ret1 = collections.defaultdict(lambda: INF)\n                    ret2 = collections.defaultdict(lambda: INF)\n                    stk.append((2, (node, ret1, ret2, ret)))\n                    stk.append((1, (node.right, ret2)))\n                    stk.append((1, (node.left, ret1)))\n                elif step == 2:\n                    node, ret1, ret2, ret = args\n                    for k1, v1 in ret1.iteritems():\n                        for k2, v2 in ret2.iteritems():\n                            ret[OP[node.val](k1, k2)] = min(ret[OP[node.val](k1, k2)], v1+v2)\n            return ret[result]\n\n        return iter_dfs(root, result)\n\n\nimport collections\n\n\n# tree dp with recursion\nclass Solution2(object):\n    def minimumFlips(self, root, result):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type result: bool\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        OP = {\n            2: lambda x, y: x or y,\n            3: lambda x, y: x and y,\n            4: lambda x, y: x^y ,\n            5: lambda x, y: not x if x is not None else not y\n        }\n        \n        def dfs(node):\n            if not node:\n                return {None: 0}  # null object pattern\n            if node.left == node.right:\n                return {True: node.val^1, False: node.val^0}\n            left = dfs(node.left)\n            right = dfs(node.right)\n            dp = collections.defaultdict(lambda: INF)\n            for k1, v1 in left.iteritems():\n                for k2, v2 in right.iteritems():\n                    dp[OP[node.val](k1, k2)] = min(dp[OP[node.val](k1, k2)], v1+v2)\n            return dp\n\n        return dfs(root)[result]\n"
    },
    {
        "problem_name": "minimum-flips-to-make-a-or-b-equal-to-c",
        "solution": "# Time:  O(31)\n# Space: O(1)\n\nclass Solution(object):\n    def minFlips(self, a, b, c):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type c: int\n        :rtype: int\n        \"\"\"\n        def number_of_1_bits(n):\n            result = 0\n            while n:\n                n &= n-1\n                result += 1\n            return result\n\n        return number_of_1_bits((a|b)^c) + number_of_1_bits(a&b&~c)\n\n\n# Time:  O(31)\n# Space: O(1)\nclass Solution2(object):\n    def minFlips(self, a, b, c):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type c: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(31):\n            a_i, b_i, c_i = map(lambda x: x&1, [a, b, c])\n            if (a_i | b_i) != c_i:\n                result += 2 if a_i == b_i == 1 else 1\n            a, b, c = a >> 1, b >> 1, c >> 1\n        return result\n"
    },
    {
        "problem_name": "minimum-fuel-cost-to-report-to-the-capital",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# iterative dfs\nclass Solution(object):\n    def minimumFuelCost(self, roads, seats):\n        \"\"\"\n        :type roads: List[List[int]]\n        :type seats: int\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n    \n        def iter_dfs():\n            result = 0\n            stk = [(1, (0, -1, 0, [1]))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    u, p, d, ret = args\n                    stk.append((3, (d, ret)))\n                    for v in adj[u]:\n                        if v == p:\n                            continue\n                        new_ret = [1]\n                        stk.append((2, (new_ret, ret)))\n                        stk.append((1, (v, u, d+1, new_ret)))\n                elif step == 2:\n                    new_ret, ret = args\n                    ret[0] += new_ret[0]\n                elif step == 3:\n                    d, ret = args\n                    if d:\n                        result += ceil_divide(ret[0], seats)\n            return result\n    \n        adj = [[] for _ in xrange(len(roads)+1)]\n        for u, v in roads:\n            adj[u].append(v)\n            adj[v].append(u)\n        return iter_dfs()\n\n\n# Time:  O(n)\n# Space: O(h)\n# dfs\nclass Solution(object):\n    def minimumFuelCost(self, roads, seats):\n        \"\"\"\n        :type roads: List[List[int]]\n        :type seats: int\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n    \n        def dfs(u, p, d):\n            cnt = 1+sum(dfs(v, u, d+1) for v in adj[u] if v != p)\n            if d:\n                result[0] += ceil_divide(cnt, seats)\n            return cnt\n    \n        adj = [[] for _ in xrange(len(roads)+1)]\n        for u, v in roads:\n            adj[u].append(v)\n            adj[v].append(u)\n        result = [0]\n        dfs(0, -1, 0)\n        return result[0]\n"
    },
    {
        "problem_name": "minimum-garden-perimeter-to-collect-enough-apples",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nimport math\n\n\nclass Solution(object):\n    def minimumPerimeter(self, neededApples):\n        \"\"\"\n        :type neededApples: int\n        :rtype: int\n        \"\"\"\n        # find min r, s.t. 4r^3+6r^2+2r-neededApples >= 0\n        # => by depressed cubic (https://en.wikipedia.org/wiki/Cubic_equation#Depressed_cubic)\n        #    let x = r+(6/(3*4)), r = x-(1/2)\n        #    4(x-(1/2))^3+6(x-(1/2))^2+2(x-(1/2))-neededApples\n        #    = 4(x^3-3/2x^2+3/4x-1/8)\n        #      + 6(x^2-x+1/4)\n        #      + 2(x-1/2)\n        #    = 4x^3-x-neededApples >= 0\n        #\n        # find x, s.t. 4x^3-x-neededApples = 0 <=> x^3+(-1/4)x+(-neededApples/4) = 0\n        # => by Cardano's formula (https://en.wikipedia.org/wiki/Cubic_equation#Cardano's_formula)\n        #    x^3 + px + q = 0, p = (-1/4), q = (-neededApples/4)\n        #    since (q/2)^2+(p/3)^3 = neededApples^2/64-1/1728 > 0 => only one real root\n        #    => x = (-q/2 + ((q/2)^2+(p/3)^3)^(1/2)) + (-q/2 - ((q/2)^2+(p/3)^3)^(1/2))\n        #       r = x-(1/2)\n        # => min r = ceil(r)\n\n        a, b, c, d = 4.0, 6.0, 2.0, float(-neededApples)\n        p = (3*a*c-b**2)/(3*a**2)  # -1/4.0\n        q = (2*b**3-9*a*b*c+27*a**2*d)/(27*a**3)  # -neededApples/4.0\n        assert((q/2)**2+(p/3)**3 > 0)  # case of only one real root\n        x = (-q/2 + ((q/2)**2+(p/3)**3)**0.5)**(1.0/3) + \\\n            (-q/2 - ((q/2)**2+(p/3)**3)**0.5)**(1.0/3)\n        return 8*int(math.ceil(x - b/(3*a)))\n                             \n\n# Time:  O(1)\n# Space: O(1)\nclass Solution2(object):\n    def minimumPerimeter(self, neededApples):\n        \"\"\"\n        :type neededApples: int\n        :rtype: int\n        \"\"\"\n        # r+r    , (r-1)+r, ..., 1+r, 0+r    , 1+r, ..., (r-1)+r, r+r\n        # r+(r-1),                    0+(r-1),                    r+(r-1)\n        #  .                           .                           .    \n        #  .                           .                           .    \n        #  .                           .                           .    \n        # r+1    , (r-1)+1, ..., 1+1, 1+0    , 1+1, ..., (r-1)+1, r+1\n        # r+0    , (r-1)+0, ..., 1+0, 0+0    , 1+0, ..., (r-1)+0, r+0\n        # r+1    , (r-1)+1, ..., 1+1, 1+0    , 1+1, ..., (r-1)+1, r+1\n        #  .                           .                           .    \n        #  .                           .                           .    \n        #  .                           .                           .       \n        # r+(r-1),                    0+(r-1),                    r+(r-1)\n        # r+r    , (r-1)+r, ..., 1+r, 0+r    , 1+r, ..., r+(r-1), r+r\n        #\n        # each up/down direction forms an arithmetic sequence, there are 2r+1 columns\n        # => 2*(1+r)*r/2 * (2r+1)\n        #\n        # each left/right direction forms an arithmetic sequence, there are 2r+1 rows\n        # => 2*(1+r)*r/2 * (2r+1)\n        #\n        # => total = 2 * 2*(1+r)*r/2 * (2r+1) = r*(2r+1)*(2r+2) = 4r^3+6r^2+2r\n        # => find min r, s.t. (2r)(2r+1)*(2r+2) >= 2*neededApples\n        # => find min x = 2r+2, s.t. (x-2)(x-1)(x) >= 2*neededApples\n\n        x = int((2*neededApples)**(1.0/3))\n        x -= x%2\n        assert((x-2)*(x-1)*x < 2*neededApples < (x+2)**3)\n        x += 2\n        if (x-2)*(x-1)*x < 2*neededApples:\n            x += 2\n        return 8*(x-2)//2\n\n\n# Time:  O(logn)\n# Space: O(1)\nclass Solution3(object):\n    def minimumPerimeter(self, neededApples):\n        \"\"\"\n        :type neededApples: int\n        :rtype: int\n        \"\"\"\n        # 2r  , 2r-1, ..., r+1, r  , r+1, ..., 2*r-1, 2*r\n        # 2r-1,                 r-1,                  2r-1\n        # .                     .                     .    \n        # .                     .                     .    \n        # .                     .                     .    \n        # r+1 ,    r, ...,   2, 1  ,   2, ...,   r  , r+1\n        # r   ,  r-1, ...,   1, 0  ,   1, ...,   r-1, r\n        # r+1 ,    r, ...,   2, 1  ,   2, ...,   r  , r+1\n        # .                     .                     .    \n        # .                     .                     .    \n        # .                     .                     .    \n        # 2r-1,                 r-1,                  2r-1\n        # 2r  , 2r-1, ..., r+1, r  , r+1, ..., 2*r-1, 2*r\n        #\n        # the sum of each row/col forms an arithmetic sequence\n        # => let ai = (((r + (r-1) + ... + r + 0) + (0 + 1 + 2 + ... + r)) - 0) + i*(2r+1)\n        #           = (2*(0+r)*(r+1)/2-0) + i*(2r+1)\n        #           = r*(r+1) + i*(2r+1)\n        # => total  = 2*(a0 + a1 + ... ar) - a0\n        #           = 2*(r*(r+1) + r*(r+1) + r*(2r+1)))*(r+1)/2 - r*(r+1)\n        #           = r*(4r+3)*(r+1)-r*(r+1)\n        #           = 4r^3+6r^2+2r\n        # => find min r, s.t. 4r^3+6r^2+2r >= neededApples\n\n        def check(neededApples, x):\n            return r*(2*r+1)*(2*r+2) >= neededApples\n\n        left, right = 1, int((neededApples/4.0)**(1.0/3))\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(neededApples, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return 8*left\n"
    },
    {
        "problem_name": "minimum-genetic-mutation",
        "solution": "# Time:  O(n * b), n is the length of gene string, b is size of bank\n# Space: O(b)\n\nfrom collections import deque\n\nclass Solution(object):\n    def minMutation(self, start, end, bank):\n        \"\"\"\n        :type start: str\n        :type end: str\n        :type bank: List[str]\n        :rtype: int\n        \"\"\"\n        lookup = {}\n        for b in bank:\n            lookup[b] = False\n\n        q = deque([(start, 0)])\n        while q:\n            cur, level = q.popleft()\n            if cur == end:\n                return level\n\n            for i in xrange(len(cur)):\n                for c in ['A', 'T', 'C', 'G']:\n                    if cur[i] == c:\n                        continue\n\n                    next_str = cur[:i] + c + cur[i+1:]\n                    if next_str in lookup and lookup[next_str] == False:\n                        q.append((next_str, level+1))\n                        lookup[next_str] = True\n\n        return -1\n\n"
    },
    {
        "problem_name": "minimum-health-to-beat-game",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minimumHealth(self, damage, armor):\n        \"\"\"\n        :type damage: List[int]\n        :type armor: int\n        :rtype: int\n        \"\"\"\n        return sum(damage)-min(max(damage), armor)+1\n"
    },
    {
        "problem_name": "minimum-height-trees",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def findMinHeightTrees(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if n == 1:\n            return [0]\n\n        neighbors = collections.defaultdict(set)\n        for u, v in edges:\n            neighbors[u].add(v)\n            neighbors[v].add(u)\n\n        pre_level, unvisited = [], set()\n        for i in xrange(n):\n            if len(neighbors[i]) == 1:  # A leaf.\n                pre_level.append(i)\n            unvisited.add(i)\n\n        # A graph can have 2 MHTs at most.\n        # BFS from the leaves until the number\n        # of the unvisited nodes is less than 3.\n        while len(unvisited) > 2:\n            cur_level = []\n            for u in pre_level:\n                unvisited.remove(u)\n                for v in neighbors[u]:\n                    if v in unvisited:\n                        neighbors[v].remove(u)\n                        if len(neighbors[v]) == 1:\n                            cur_level.append(v)\n            pre_level = cur_level\n\n        return list(unvisited)\n\n"
    },
    {
        "problem_name": "minimum-hours-of-training-to-win-a-competition",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\n# greedy\nclass Solution(object):\n    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):\n        \"\"\"\n        :type initialEnergy: int\n        :type initialExperience: int\n        :type energy: List[int]\n        :type experience: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for hp, ex in itertools.izip(energy, experience):\n            inc1 = max((hp+1)-initialEnergy, 0)\n            inc2 = max((ex+1)-initialExperience, 0)\n            result += inc1+inc2\n            initialEnergy += inc1-hp\n            initialExperience += inc2+ex\n        return result\n"
    },
    {
        "problem_name": "minimum-impossible-or",
        "solution": "# Time:  O(logr)\n# Space: O(1)\n\n# hash table, bit manipulations\nclass Solution(object):\n    def minImpossibleOR(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = set(nums)\n        return next(1<<i for i in xrange(31) if 1<<i not in lookup)\n"
    },
    {
        "problem_name": "minimum-incompatibility",
        "solution": "# Time:  O(sum(i*d * nCr(i*d, d) * nCr(n, i*d) for i in xrange(1, k+1))) < O(sum(n * 2^m * nCr(n, m) for m in xrange(n+1))) = O(n * 3^n)\n# Space: O(n * k)\n\nimport itertools\n\n\nclass Solution(object):\n    def minimumIncompatibility(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        inf = (len(nums)-1)*(len(nums)//k)+1\n        def backtracking(nums, d, lookup):\n            if not nums:\n                return 0\n            if nums not in lookup:\n                ret = inf\n                for new_nums in itertools.combinations(nums, d):\n                    new_nums_set = set(new_nums)\n                    if len(new_nums_set) < d:\n                        continue\n                    left = []\n                    for num in nums:\n                        if num in new_nums_set:\n                            new_nums_set.remove(num)\n                            continue\n                        left.append(num)\n                    ret = min(ret, max(new_nums)-min(new_nums) + backtracking(tuple(left), d, lookup))\n                lookup[nums] = ret\n            return lookup[nums]\n        \n        result = backtracking(tuple(nums), len(nums)//k, {})\n        return result if result != inf else -1\n\n\n# Time:  O(max(n * 2^n, 3^n))\n# Space: O(2^n)\nclass Solution_TLE(object):\n    def minimumIncompatibility(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        inf = (len(nums)-1)*(len(nums)//k)+1\n        POW = [1]\n        for i in xrange(len(nums)):\n            POW.append(POW[-1]<<1)\n        \n        def popcount(n):\n            result = 0\n            while n:\n                n &= n - 1\n                result += 1\n            return result\n    \n        def find_candidates(nums, k):\n            total = POW[len(nums)]-1\n            m = len(nums)//k\n            result = [inf]*(total+1)\n            for mask in xrange(total+1):\n                if popcount(mask) != m:\n                    continue\n                lookup = 0\n                mx, mn = 0, inf\n                for i in xrange(len(nums)):\n                    if mask&POW[i] == 0:\n                        continue\n                    if lookup&POW[nums[i]]:\n                        break\n                    lookup |= POW[nums[i]]\n                    mx = max(mx, nums[i])\n                    mn = min(mn, nums[i])\n                else:\n                    result[mask] = mx-mn\n            return result\n        \n        candidates = find_candidates(nums, k)\n        m = len(nums)//k\n        total = POW[len(nums)]-1\n        dp = [inf]*(total+1)\n        dp[0] = 0\n        for mask in xrange(total+1):\n            if popcount(mask) % m != 0:\n                continue\n            # submask enumeration:\n            # => sum(nCr(n, k) * 2^k for k in xrange(n+1)) = (1 + 2)^n = 3^n\n            # => Time: O(3^n), see https://cp-algorithms.com/algebra/all-submasks.html\n            submask = mask\n            while submask:\n                dp[mask] = min(dp[mask], dp[mask-submask] + candidates[submask])\n                submask = (submask-1)&mask\n        return dp[-1] if dp[-1] != inf else -1\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport collections\nimport sortedcontainers\n# wrong with greedy solution\n# nums = [15, 9, 7, 10, 15, 14, 12, 2, 10, 8, 10, 13, 4, 11, 2]\n# k = 5\n# greedy  => [[2, 4, 7], [2, 8, 9], [10, 11, 12], [10, 13, 15], [10, 14, 15]] => 24\n# correct => [[2, 4, 7], [2, 8, 10], [9, 10, 11], [10, 12, 15], [13, 14, 15]] => 22\n# optimized from Solution_Greedy, using SortedList (which is not supported in GoogleCodeJam / GoogleKickStart)\nclass Solution_Wrong_Greedy_SortedList(object):\n    def minimumIncompatibility(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def greedy(nums, k, is_reversed):\n            count = collections.Counter(nums)\n            if max(count.itervalues()) > k:\n                return -1\n            ordered_set = sortedcontainers.SortedList(count.iterkeys())\n            freq_to_nodes = collections.defaultdict(collections.OrderedDict)\n            for x in ordered_set:\n                freq_to_nodes[count[x]][x] = count[x]\n            stks = [[] for _ in xrange(k)] \n            curr = 0\n            while ordered_set:  # the while loop runs O(k) times\n                if len(stks)-curr in freq_to_nodes:  # fill the deterministic elements into the remaining subsets\n                    for x in freq_to_nodes[len(stks)-curr].iterkeys():  # total time = O(n)\n                        for i in xrange(curr, len(stks)):\n                            stks[i].append(x)\n                        count.pop(x)\n                        ordered_set.remove(x)\n                    freq_to_nodes.pop(len(stks)-curr)\n                # greedily fill the contiguous ordered elements into the first vacant subset until it is full,\n                # otherwise, the result sum would get larger => in fact, this is wrong\n                to_remove = []\n                direction = (lambda x:x) if not is_reversed else reversed\n                for x in direction(ordered_set):\n                    stks[curr].append(x)\n                    freq_to_nodes[count[x]].pop(x)\n                    if not freq_to_nodes[count[x]]:\n                        freq_to_nodes.pop(count[x])\n                    count[x] -= 1  # total time = O(n)\n                    if not count[x]:\n                        count.pop(x)\n                        to_remove.append(x)\n                    else:\n                        freq_to_nodes[count[x]][x] = count[x]\n                    if len(stks[curr]) == len(nums)//k:\n                        curr += 1\n                        break\n                for x in to_remove:\n                    ordered_set.remove(x)  # total time = O(nlogn)\n            return sum([max(stk)-min(stk) for stk in stks])\n\n        return min(greedy(nums, k, False), greedy(nums, k, True))  # two possible minimas\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport collections\nfrom random import randint, seed\n\n\n# Template modified from:\n# https://github.com/kamyu104/LeetCode-Solutions/blob/master/Python/design-skiplist.py\nclass SkipNode(object):\n    def __init__(self, level=0, val=None):\n        self.val = val\n        self.nexts = [None]*level\n        self.prevs = [None]*level\n\nclass SkipList(object):\n    P_NUMERATOR, P_DENOMINATOR = 1, 2  # P = 1/4 in redis implementation\n    MAX_LEVEL = 32  # enough for 2^32 elements\n\n    def __init__(self, end=float(\"inf\"), can_duplicated=False, cmp=lambda x, y: x < y):\n        seed(0)\n        self.__head = SkipNode()\n        self.__len = 0\n        self.__can_duplicated = can_duplicated\n        self.__cmp = cmp\n        self.add(end)\n        self.__end = self.find(end)\n\n    def begin(self):\n        return self.__head.nexts[0]\n    \n    def end(self):\n        return self.__end\n\n    def lower_bound(self, target):\n        return self.__lower_bound(target, self.__find_prev_nodes(target))\n\n    def find(self, target):\n        return self.__find(target, self.__find_prev_nodes(target))\n        \n    def add(self, val):\n        if not self.__can_duplicated and self.find(val):\n            return self.find(val), False\n        node = SkipNode(self.__random_level(), val)\n        if len(self.__head.nexts) < len(node.nexts): \n            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))\n        prevs = self.__find_prev_nodes(val)\n        for i in xrange(len(node.nexts)):\n            node.nexts[i] = prevs[i].nexts[i]\n            if prevs[i].nexts[i]:\n                prevs[i].nexts[i].prevs[i] = node\n            prevs[i].nexts[i] = node\n            node.prevs[i] = prevs[i]\n        self.__len += 1\n        return node if self.__can_duplicated else (node, True)\n\n    def remove(self, it):\n        prevs = it.prevs\n        curr = self.__find(it.val, prevs)\n        if not curr:\n            return self.__end\n        self.__len -= 1   \n        for i in reversed(xrange(len(curr.nexts))):\n            prevs[i].nexts[i] = curr.nexts[i]\n            if curr.nexts[i]:\n                curr.nexts[i].prevs[i] = prevs[i]\n            if not self.__head.nexts[i]:\n                self.__head.nexts.pop()\n        return curr.nexts[0]\n    \n    def __lower_bound(self, val, prevs):\n        if prevs:\n            candidate = prevs[0].nexts[0]\n            if candidate:\n                return candidate\n        return None\n\n    def __find(self, val, prevs):\n        candidate = self.__lower_bound(val, prevs)\n        if candidate and candidate.val == val:\n            return candidate\n        return None\n\n    def __find_prev_nodes(self, val):\n        prevs = [None]*len(self.__head.nexts)\n        curr = self.__head\n        for i in reversed(xrange(len(self.__head.nexts))):\n            while curr.nexts[i] and self.__cmp(curr.nexts[i].val, val):\n                curr = curr.nexts[i]\n            prevs[i] = curr\n        return prevs\n\n    def __random_level(self):\n        level = 1\n        while randint(1, SkipList.P_DENOMINATOR) <= SkipList.P_NUMERATOR and \\\n              level < SkipList.MAX_LEVEL:\n            level += 1\n        return level\n    \n    def __iter__(self):\n        it = self.begin()\n        while it != self.end():\n            yield it.val\n            it = it.nexts[0]\n\n    def __len__(self):\n        return self.__len-1  # excluding end node\n\n    def __str__(self):\n        result = []\n        for i in reversed(xrange(len(self.__head.nexts))):\n            result.append([])\n            curr = self.__head.nexts[i]\n            while curr:\n                result[-1].append(str(curr.val))\n                curr = curr.nexts[i]\n        return \"\\n\".join(map(lambda x: \"->\".join(x), result))\n\n# wrong with greedy solution\n# nums = [15, 9, 7, 10, 15, 14, 12, 2, 10, 8, 10, 13, 4, 11, 2]\n# k = 5\n# greedy  => [[2, 4, 7], [2, 8, 9], [10, 11, 12], [10, 13, 15], [10, 14, 15]] => 24\n# correct => [[2, 4, 7], [2, 8, 10], [9, 10, 11], [10, 12, 15], [13, 14, 15]] => 22\n# optimized from Solution_Wrong_Greedy, using SkipList\nclass Solution_Wrong_Greedy_SkipList(object):\n    def minimumIncompatibility(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def greedy(nums, k, is_reversed):\n            count = collections.Counter(nums)\n            if max(count.itervalues()) > k:\n                return -1\n            ordered_set = SkipList() if not is_reversed else SkipList(end=float(\"-inf\"), cmp=lambda x, y: x > y)\n            freq_to_nodes = collections.defaultdict(collections.OrderedDict)\n            for x in sorted(count.keys(), reverse=is_reversed):\n                ordered_set.add(x)\n                freq_to_nodes[count[x]][x] = count[x]\n            stks = [[] for _ in xrange(k)] \n            curr = 0\n            while ordered_set:  # the while loop runs O(k) times\n                if len(stks)-curr in freq_to_nodes:  # fill the deterministic elements into the remaining subsets\n                    for x in freq_to_nodes[len(stks)-curr].iterkeys():  # total time = O(n)\n                        for i in xrange(curr, len(stks)):\n                            stks[i].append(x)\n                        count.pop(x)\n                        ordered_set.remove(ordered_set.find(x))\n                    freq_to_nodes.pop(len(stks)-curr)\n                # greedily fill the contiguous ordered elements into the first vacant subset until it is full,\n                # otherwise, the result sum would get larger => in fact, this is wrong\n                it = ordered_set.begin()\n                while it != ordered_set.end():\n                    x = it.val\n                    stks[curr].append(x)\n                    freq_to_nodes[count[x]].pop(x)\n                    if not freq_to_nodes[count[x]]:\n                        freq_to_nodes.pop(count[x])\n                    count[x] -= 1  # total time = O(n)\n                    if not count[x]:\n                        count.pop(x)\n                        it = ordered_set.remove(it)  # total time = O(nlogn)\n                    else:\n                        freq_to_nodes[count[x]][x] = count[x]\n                        it = it.nexts[0]\n                    if len(stks[curr]) == len(nums)//k:\n                        curr += 1\n                        break\n            return sum([max(stk)-min(stk) for stk in stks])\n\n        return min(greedy(nums, k, False), greedy(nums, k, True))  # two possible minimas\n\n\n# Time:  O(nlogn + k * n), could be improved to O(nlogn) by skiplist or orderedlist\n# Space: O(n)\nimport collections\n# wrong with greedy solution\n# nums = [15, 9, 7, 10, 15, 14, 12, 2, 10, 8, 10, 13, 4, 11, 2]\n# k = 5\n# greedy  => [[2, 4, 7], [2, 8, 9], [10, 11, 12], [10, 13, 15], [10, 14, 15]] => 24\n# correct => [[2, 4, 7], [2, 8, 10], [9, 10, 11], [10, 12, 15], [13, 14, 15]] => 22\nclass Solution_Wrong_Greedy(object):\n    def minimumIncompatibility(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def greedy(nums, k, is_reversed):\n            count = collections.Counter(nums)\n            if max(count.itervalues()) > k:\n                return -1\n            sorted_keys = sorted(count.keys(), reverse=is_reversed)\n            stks = [[] for _ in xrange(k)] \n            curr, remain = 0, len(nums)\n            while remain:  # the while loop runs O(k) times, and the inner loops runs O(n) times\n                for x in sorted_keys:  # fill the deterministic elements into the remaining subsets\n                    if count[x] != len(stks)-curr:\n                        continue\n                    for i in xrange(curr, len(stks)):\n                        stks[i].append(x)\n                    remain -= count[x]\n                    count[x] = 0\n                # greedily fill the contiguous ordered elements into the first vacant subset until it is full,\n                # otherwise, the result sum would get larger => in fact, this is wrong\n                for x in sorted_keys:\n                    if not count[x]:\n                        continue\n                    stks[curr].append(x)\n                    remain -= 1\n                    count[x] -= 1\n                    if len(stks[curr]) == len(nums)//k:\n                        curr += 1\n                        break\n            return sum([max(stk)-min(stk) for stk in stks])\n\n        return min(greedy(nums, k, False), greedy(nums, k, True))  # two possible minimas\n\n"
    },
    {
        "problem_name": "minimum-increment-operations-to-make-array-beautiful",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def minIncrementOperations(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        W = 3\n        dp = [0]*W\n        for i, x in enumerate(nums):\n            dp[i%W] = min(dp[j%W] for j in xrange(i-W, i))+max(k-x, 0)\n        return min(dp)\n"
    },
    {
        "problem_name": "minimum-increment-to-make-array-unique",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def minIncrementForUnique(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        A.sort()\n        A.append(float(\"inf\"))\n        result, duplicate = 0, 0\n        for i in xrange(1, len(A)):\n            if A[i-1] == A[i]:\n                duplicate += 1\n                result -= A[i]\n            else:\n                move = min(duplicate, A[i]-A[i-1]-1)\n                duplicate -= move\n                result += move*A[i-1] + move*(move+1)//2\n        return result\n"
    },
    {
        "problem_name": "minimum-index-of-a-valid-split",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Boyer\u2013Moore majority vote algorithm, linear search\nclass Solution(object):\n    def minimumIndex(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def boyer_moore_majority_vote():\n            result, cnt = None, 0\n            for x in nums:\n                if not cnt:\n                    result = x\n                if x == result:\n                    cnt += 1\n                else:\n                    cnt -= 1\n            return result\n        \n        m = boyer_moore_majority_vote()\n        total, cnt = nums.count(m), 0\n        for i, x in enumerate(nums):\n            if x == m:\n                cnt += 1\n            if cnt*2 > i+1 and (total-cnt)*2 > len(nums)-(i+1):\n                return i\n        return -1\n"
    },
    {
        "problem_name": "minimum-index-sum-of-two-lists",
        "solution": "# Time:  O((m + n) * l), m is the size of list1, n is the size of list2\n# Space: O(m * l), l is the average length of string\n\nclass Solution(object):\n    def findRestaurant(self, list1, list2):\n        \"\"\"\n        :type list1: List[str]\n        :type list2: List[str]\n        :rtype: List[str]\n        \"\"\"\n        lookup = {}\n        for i, s in enumerate(list1):\n            lookup[s] = i\n\n        result = []\n        min_sum = float(\"inf\")\n        for j, s in enumerate(list2):\n            if j > min_sum:\n                break\n            if s in lookup:\n                if j + lookup[s] < min_sum:\n                    result = [s]\n                    min_sum = j + lookup[s]\n                elif j + lookup[s] == min_sum:\n                    result.append(s)\n        return result\n\n"
    },
    {
        "problem_name": "minimum-initial-energy-to-finish-tasks",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def minimumEffort(self, tasks):\n        \"\"\"\n        :type tasks: List[List[int]]\n        :rtype: int\n        \"\"\"\n        tasks.sort(key=lambda x: x[1]-x[0])  # sort by waste in asc\n        result = 0\n        # you can see proof here, https://leetcode.com/problems/minimum-initial-energy-to-finish-tasks/discuss/944633/Explanation-on-why-sort-by-difference\n        for a, m in tasks:  # we need to pick all the wastes, so greedily to pick the least waste first is always better\n            result = max(result+a, m)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(1)\nclass Solution2(object):\n    def minimumEffort(self, tasks):\n        \"\"\"\n        :type tasks: List[List[int]]\n        :rtype: int\n        \"\"\"\n        tasks.sort(key=lambda x: x[0]-x[1])  # sort by save in desc\n        result = curr = 0\n        for a, m in tasks:  # we need to pick all the saves, so greedily to pick the most save first is always better\n            result += max(m-curr, 0)\n            curr = max(curr, m)-a\n        return result\n"
    },
    {
        "problem_name": "minimum-insertion-steps-to-make-a-string-palindrome",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def minInsertions(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def longestCommonSubsequence(text1, text2):\n            if len(text1) < len(text2):\n                return self.longestCommonSubsequence(text2, text1)\n            dp = [[0 for _ in xrange(len(text2)+1)] for _ in xrange(2)]\n            for i in xrange(1, len(text1)+1):\n                for j in xrange(1, len(text2)+1):\n                    dp[i%2][j] = dp[(i-1)%2][j-1]+1 if text1[i-1] == text2[j-1] \\\n                                 else max(dp[(i-1)%2][j], dp[i%2][j-1])\n            return dp[len(text1)%2][len(text2)]\n\n        return len(s)-longestCommonSubsequence(s, s[::-1])\n"
    },
    {
        "problem_name": "minimum-insertions-to-balance-a-parentheses-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minInsertions(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        add, bal = 0, 0\n        for c in s:\n            if c == '(':\n                if bal > 0 and bal%2:\n                    add += 1\n                    bal -= 1\n                bal += 2\n            else:\n                bal -= 1\n                if bal < 0:\n                    add += 1\n                    bal += 2\n        return add + bal\n"
    },
    {
        "problem_name": "minimum-interval-to-include-each-query",
        "solution": "# Time:  O(nlogn + klogk + klogn)\n# space: O(n + k)\n\nimport heapq\n\n\nclass Solution(object):\n    def minInterval(self, intervals, queries):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        intervals.sort()\n        queries = [(q, i) for i, q in enumerate(queries)]\n        queries.sort()\n        min_heap = []\n        i = 0\n        result =[-1]*len(queries)\n        for q, idx in queries:\n            while i != len(intervals) and intervals[i][0] <= q:\n                heapq.heappush(min_heap, [intervals[i][1]-intervals[i][0]+1, i])\n                i += 1\n            while min_heap and intervals[min_heap[0][1]][1] < q:\n                heapq.heappop(min_heap)\n            result[idx] = min_heap[0][0] if min_heap else -1\n        return result\n"
    },
    {
        "problem_name": "minimum-jumps-to-reach-home",
        "solution": "# Time:  O(max(x, max(forbidden)) + a + (b+a))\n# Space: O(max(x, max(forbidden)) + a + (b+a))\n\nclass Solution(object):\n    def minimumJumps(self, forbidden, a, b, x):\n        \"\"\"\n        :type forbidden: List[int]\n        :type a: int\n        :type b: int\n        :type x: int\n        :rtype: int\n        \"\"\"\n        max_f = max(forbidden)\n        max_val = x+b if a >= b else max(x, max_f)+a+(b+a)  # a may be a non-periodic area, (a+b) is a periodic area which is divided by gcd(a, b) and all points are reachable\n        lookup = set()      \n        for pos in forbidden:\n            lookup.add((pos, True))\n            lookup.add((pos, False))\n        result = 0\n        q = [(0, True)]\n        lookup.add((0, True))\n        while q:\n            new_q = []\n            for pos, can_back in q:\n                if pos == x:\n                    return result\n                if pos+a <= max_val and (pos+a, True) not in lookup:\n                    lookup.add((pos+a, True))\n                    new_q.append((pos+a, True))\n                if not can_back:\n                    continue\n                if pos-b >= 0 and (pos-b, False) not in lookup:\n                    lookup.add((pos-b, False))\n                    new_q.append((pos-b, False))\n            q = new_q\n            result += 1\n        return -1\n"
    },
    {
        "problem_name": "minimum-knight-moves",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def minKnightMoves(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        # we can observe from:\n        # [0]\n        # [3, 2]\n        # [2,(1),4]\n        # [3, 2, 3, 2]\n        # [2, 3,(2) 3, 4]\n        # [3, 4, 3, 4, 3, 4]\n        # [4, 3, 4,(3),4, 5, 4]\n        # [5, 4, 5, 4, 5, 4, 5, 6]\n        # [4, 5, 4, 5,(4),5, 6, 5, 6]\n        # [5, 6, 5, 6, 5, 6, 5, 6, 7, 6]\n        # [6, 5, 6, 5, 6,(5),6, 7, 6, 7, 8]\n        # [7, 6, 7, 6, 7, 6, 7, 6, 7, 8, 7, 8]\n        # [6, 7, 6, 7, 6, 7,(6),7, 8, 7, 8, 9, 8]\n        # [7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 9, 8, 9, 10]\n        # [8, 7, 8, 7, 8, 7, 8,(7),8, 9, 8, 9, 10, 9, 10]\n        # [9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 10, 9, 10, 11, 10]\n\n        x, y = abs(x), abs(y)\n        if x < y:\n            x, y = y, x\n        lookup = {(1, 0):3, (2, 2):4}  # special cases\n        if (x, y) in lookup:\n            return lookup[(x, y)]\n        k = x-y\n        if y > k:\n            # if 2y > x, every period 3 of y (or k) with fixed another is increased by 2 (or 1)\n            # and start from (2k, k) with (k) when y = k (diagonal line)\n            # ex. (0, 0) ~ (12, 12) ~ ... : 0 => 2,4(special case),2 => 4,4,4 => 6,6,6 => 8,8,8 => ...\n            # ex. (2, 1) ~ (14, 13) ~ ... : 1 => 3,3,3 => 5,5,5 => 7,7,7 => 9,9,9 => ...\n            return k - 2*((k-y)//3)\n        # if 2y <= x, every period 4 of k (or y) with fixed another is increased by 2\n        # and start from (2k, k) with (k) when y = k (vertical line)\n        # ex. (0, 0) ~ (11, 0) ~ ... : 0,3(special case),2,3 => 2,3,4,5 => 4,5,6,7 => ...\n        # ex. (2, 1) ~ (13, 1) ~ ... : 1,2,3,4 => 3,4,5,6 => 5,6,7,8 => ...\n        return k - 2*((k-y)//4)\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\nclass Solution2(object):\n    def __init__(self):\n        self.__lookup = {(0, 0):0, (1, 1):2, (1, 0):3}  # special cases\n\n    def minKnightMoves(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        def dp(x, y):\n            x, y = abs(x), abs(y)\n            if x < y:\n                x, y = y, x\n            if (x, y) not in self.__lookup:  # greedy, smaller x, y is always better if not special cases\n                self.__lookup[(x, y)] = min(dp(x-1, y-2), dp(x-2, y-1)) + 1\n            return self.__lookup[(x, y)]\n        return dp(x, y)\n"
    },
    {
        "problem_name": "minimum-length-of-anagram-concatenation",
        "solution": "# Time:  O(sqrt(n) * n + (26 * sum(n/i for i in range(1, n+1) if n%i == 0))) < O(sqrt(n) * n + 26 * sum(n/i for i in range(1, n+1)) = O(sqrt(n) * n + 26 * nlogn)\n# Space: O(26)\n\n# number theory, freq table\nclass Solution(object):\n    def minAnagramLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def factors(n):\n            for i in xrange(1, n+1):\n                if i*i > n:\n                    break\n                if n%i:\n                    continue\n                yield i\n                if n//i != i:\n                    yield n//i\n                    \n        def check(l):\n            def count(i):\n                cnt = [0]*26\n                for j in xrange(i, i+l):\n                    cnt[ord(s[j])-ord('a')] += 1\n                return cnt\n    \n            cnt = count(0)\n            return all(count(i) == cnt for i in xrange(l, len(s), l))\n\n        return min(l for l in factors(len(s)) if check(l))\n"
    },
    {
        "problem_name": "minimum-length-of-string-after-deleting-similar-ends",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minimumLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(s)-1\n        while left < right:\n            if s[left] != s[right]:\n                break\n            c = s[left]\n            while left <= right:\n                if s[left] != c:\n                    break\n                left += 1\n            while left <= right:\n                if s[right] != c:\n                    break\n                right -= 1\n        return right-left+1\n"
    },
    {
        "problem_name": "minimum-levels-to-gain-more-points",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# prefix sum\nclass Solution(object):\n    def minimumLevels(self, possible):\n        \"\"\"\n        :type possible: List[int]\n        :rtype: int\n        \"\"\"\n        prefix = [0]*(len(possible)+1)\n        for i in xrange(len(possible)):\n            prefix[i+1] = prefix[i]+(+1 if possible[i] else -1)\n        return next((i+1 for i in xrange(len(possible)-1) if prefix[i+1] > prefix[-1]-prefix[i+1]), -1)\n"
    },
    {
        "problem_name": "minimum-limit-of-balls-in-a-bag",
        "solution": "# Time:  O(nlogm), m is the max of nums\n# Space: O(1)\n\nclass Solution(object):\n    def minimumSize(self, nums, maxOperations):\n        \"\"\"\n        :type nums: List[int]\n        :type maxOperations: int\n        :rtype: int\n        \"\"\"\n        def check(nums, maxOperations, x):\n            return sum((num+x-1)//x-1 for num in nums) <= maxOperations\n    \n        left, right = 1, max(nums)\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(nums, maxOperations, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "minimum-lines-to-represent-a-line-chart",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, math, gcd\nclass Solution(object):\n    def minimumLines(self, stockPrices):\n        \"\"\"\n        :type stockPrices: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n    \n        stockPrices.sort()\n        result = 0\n        prev = None\n        for i in xrange(1, len(stockPrices)):\n            dy, dx = stockPrices[i][1]-stockPrices[i-1][1], stockPrices[i][0]-stockPrices[i-1][0]\n            g = gcd(dy, dx)\n            if not prev or prev != (dy//g, dx//g):\n                prev = (dy//g, dx//g)\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "minimum-money-required-before-transactions",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy, constructive algorithms\nclass Solution(object):\n    def minimumMoney(self, transactions):\n        \"\"\"\n        :type transactions: List[List[int]]\n        :rtype: int\n        \"\"\"\n        return sum(max(a-b, 0) for a, b in transactions)+max(a-max(a-b, 0) for a, b in transactions)  # a-max(a-b, 0) = min(a, b)\n"
    },
    {
        "problem_name": "minimum-moves-to-capture-the-queen",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def minMovesToCaptureTheQueen(self, a, b, c, d, e, f):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type c: int\n        :type d: int\n        :type e: int\n        :type f: int\n        :rtype: int\n        \"\"\"\n        if a == e and not (a == c and (b-d)*(f-d) < 0):\n            return 1\n        if b == f and not (b == d and (a-c)*(e-c) < 0):\n            return 1\n        if c+d == e+f and not (c+d == a+b and (c-a)*(e-a) < 0):\n            return 1\n        if c-d == e-f and not (c-d == a-b and (d-b)*(f-b) < 0):\n            return 1\n        return 2\n"
    },
    {
        "problem_name": "minimum-moves-to-convert-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minimumMoves(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = i = 0\n        while i < len(s):\n            if s[i] == 'X':\n                result += 1\n                i += 3\n            else:\n                i += 1\n        return result\n"
    },
    {
        "problem_name": "minimum-moves-to-equal-array-elements-ii",
        "solution": "# Time:  O(n) on average\n# Space: O(1)\n\nfrom random import randint\n\n# Quick select solution.\nclass Solution(object):\n    def minMoves2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def kthElement(nums, k):\n            def PartitionAroundPivot(left, right, pivot_idx, nums):\n                pivot_value = nums[pivot_idx]\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if nums[i] > pivot_value:\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n                if new_pivot_idx == k:\n                    return nums[new_pivot_idx]\n                elif new_pivot_idx > k:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < k.\n                    left = new_pivot_idx + 1\n\n        median = kthElement(nums, len(nums)//2)\n        return sum(abs(num - median) for num in nums)\n\n    def minMoves22(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        median = sorted(nums)[len(nums) / 2]\n        return sum(abs(num - median) for num in nums)\n\n"
    },
    {
        "problem_name": "minimum-moves-to-equal-array-elements",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minMoves(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(nums) - len(nums) * min(nums)\n\n"
    },
    {
        "problem_name": "minimum-moves-to-make-array-complementary",
        "solution": "# Time:  O(n + k)\n# Space: O(k)\n\nclass Solution(object):\n    def minMoves(self, nums, limit):\n        \"\"\"\n        :type nums: List[int]\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        diff = [0]*(2*(limit+1))\n        for i in xrange(len(nums)//2):\n            left, right = nums[i], nums[-1-i]\n            diff[min(left, right)+1] -= 1        # if target total grows to min(left, right)+1, one less move\n            diff[left+right] -= 1                # if target total grows to left+right, one less move\n            diff[left+right+1] += 1              # if target total grows to left+right+1, one more move\n            diff[max(left, right)+limit+1] += 1  # if target total grows to max(left, right)+limit+1, one more move\n        result = count = len(nums)               # default is to move all nums\n        for total in xrange(2, 2*limit+1):       # enumerate all possible target totals\n            count += diff[total]\n            result = min(result, count)\n        return result\n"
    },
    {
        "problem_name": "minimum-moves-to-move-a-box-to-their-target-location",
        "solution": "# Time:  O(m^2 * n^2)\n# Space: O(m^2 * n^2)\n\n# A* Search Algorithm without heap\nclass Solution(object):\n    def minPushBox(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def dot(a, b):\n            return a[0]*b[0]+a[1]*b[1]\n\n        def can_reach(grid, b, p, t):\n            closer, detour = [p], []\n            lookup = set([b])\n            while closer or detour:\n                if not closer:\n                    closer, detour = detour, closer\n                p = closer.pop()\n                if p == t:\n                    return True\n                if p in lookup:\n                    continue\n                lookup.add(p)\n                for dx, dy in directions:\n                    np = (p[0]+dx, p[1]+dy)\n                    if not (0 <= np[0] < len(grid) and 0 <= np[1] < len(grid[0]) and\n                       grid[np[0]][np[1]] != '#' and np not in lookup):\n                        continue\n                    (closer if dot((dx, dy), (t[0]-p[0], t[1]-p[1])) > 0 else detour).append(np)\n            return False\n\n        def g(a, b):\n            return abs(a[0]-b[0])+abs(a[1]-b[1])\n        \n        def a_star(grid, b, p, t):\n            f, dh = g(b, t), 2\n            closer, detour = [(b, p)], []\n            lookup = set()\n            while closer or detour:\n                if not closer:\n                    f += dh\n                    closer, detour = detour, closer\n                b, p = closer.pop()\n                if b == t:\n                    return f\n                if (b, p) in lookup:\n                    continue\n                lookup.add((b, p))\n                for dx, dy in directions:\n                    nb, np = (b[0]+dx, b[1]+dy), (b[0]-dx, b[1]-dy)\n                    if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and\n                            0 <= np[0] < len(grid) and 0 <= np[1] < len(grid[0]) and\n                            grid[nb[0]][nb[1]] != '#' and grid[np[0]][np[1]] != '#' and\n                            (nb, b) not in lookup and can_reach(grid, b, p, np)):\n                        continue\n                    (closer if dot((dx, dy), (t[0]-b[0], t[1]-b[1])) > 0 else detour).append((nb, b))\n            return -1\n        \n        b, p, t = None, None, None\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j] == 'B':\n                    b = (i, j)\n                elif grid[i][j] == 'S':\n                    p = (i, j)\n                elif grid[i][j] == 'T':\n                    t = (i, j)\n        return a_star(grid, b, p, t)\n"
    },
    {
        "problem_name": "minimum-moves-to-pick-k-ones",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# prefix sum, greedy\nclass Solution(object):\n    def minimumMoves(self, nums, k, maxChanges):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type maxChanges: int\n        :rtype: int\n        \"\"\"\n        idxs = [i for i, x in enumerate(nums) if x]\n        prefix = [0]*(len(idxs)+1)\n        for i in xrange(len(idxs)):\n            prefix[i+1] = prefix[i]+idxs[i]\n        result = float(\"inf\")\n        cnt = max(k-maxChanges, 0)\n        for l in xrange(cnt, min(cnt+3, k, len(idxs))+1):\n            cnt1 = (k-l)*2\n            for i in xrange(len(idxs)-l+1):\n                cnt2 = (prefix[(i+l-1)+1]-prefix[(i+l-1)-(l//2-1)])-(prefix[(i+(l//2-1))+1]-prefix[i])\n                result = min(result, cnt2+cnt1)\n        return result\n"
    },
    {
        "problem_name": "minimum-moves-to-reach-target-score",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minMoves(self, target, maxDoubles):\n        \"\"\"\n        :type target: int\n        :type maxDoubles: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while target > 1 and maxDoubles:\n            result += 1+target%2\n            target //= 2\n            maxDoubles -= 1\n        return result+(target-1)\n"
    },
    {
        "problem_name": "minimum-moves-to-reach-target-with-rotations",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def minimumMoves(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        level, q, lookup = 0, [(0, 0, False)], set()\n        while q:\n            next_q = []\n            for r, c, is_vertical in q:\n                if (r, c, is_vertical) in lookup:\n                    continue\n                if (r, c, is_vertical) == (len(grid)-1, len(grid)-2, False):\n                    return level\n                lookup.add((r, c, is_vertical))\n                if not is_vertical:\n                    if c+2 != len(grid[0]) and grid[r][c+2] == 0:\n                        next_q.append((r, c+1, is_vertical))\n                    if r+1 != len(grid) and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:\n                        next_q.append((r+1, c, is_vertical))\n                        next_q.append((r, c, not is_vertical))\n                else:\n                    if r+2 != len(grid) and grid[r+2][c] == 0:\n                        next_q.append((r+1, c, is_vertical))\n                    if c+1 != len(grid) and grid[r][c+1] == 0 and grid[r+1][c+1] == 0:\n                        next_q.append((r, c+1, is_vertical))\n                        next_q.append((r, c, not is_vertical))\n            q = next_q\n            level += 1\n        return -1\n"
    },
    {
        "problem_name": "minimum-moves-to-spread-stones-over-grid",
        "solution": "# Time:  O(max(x^2 * y)) = O(n^3), n = len(grid)*len(grid[0]), y = len(zero), x = n-y\n# Space: O(max(x^2)) = O(n^2)\n\n# weighted bipartite matching solution\nclass Solution(object):\n    def minimumMoves(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # Template translated from:\n        # https://github.com/kth-competitive-programming/kactl/blob/main/content/graph/WeightedMatching.h\n        def hungarian(a):  # Time: O(n^2 * m), Space: O(n + m)\n            if not a:\n                return 0, []\n            n, m = len(a)+1, len(a[0])+1\n            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)\n            for i in xrange(1, n):\n                p[0] = i\n                j0 = 0  # add \"dummy\" worker 0\n                dist, pre = [float(\"inf\")]*m, [-1]*m\n                done = [False]*(m+1)\n                while True:  # dijkstra\n                    done[j0] = True\n                    i0, j1, delta = p[j0], None, float(\"inf\")\n                    for j in xrange(1, m):\n                        if done[j]:\n                            continue\n                        cur = a[i0-1][j-1]-u[i0]-v[j]\n                        if cur < dist[j]:\n                            dist[j], pre[j] = cur, j0\n                        if dist[j] < delta:\n                            delta, j1 = dist[j], j\n                    for j in xrange(m):\n                        if done[j]:\n                            u[p[j]] += delta\n                            v[j] -= delta\n                        else:\n                            dist[j] -= delta\n                    j0 = j1\n                    if not p[j0]:\n                        break\n                while j0:  # update alternating path\n                    j1 = pre[j0]\n                    p[j0], j0 = p[j1], j1\n            for j in xrange(1, m):\n                if p[j]:\n                    ans[p[j]-1] = j-1\n            return -v[0], ans  # min cost\n\n        def dist(a, b):\n            return abs(a[0]-b[0])+abs(a[1]-b[1])\n\n        src, dst = [], []\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j]-1 >= 0:\n                    src.extend([(i, j)]*(grid[i][j]-1))\n                else:\n                    dst.append((i, j))\n        adj = [[dist(src[i], dst[j]) for j in xrange(len(dst))] for i in xrange(len(src))]\n        return hungarian(adj)[0]\n\n\n# Time:  O(max(x^2 * y)) = O(n^2), n = len(grid)*len(grid[0]), y = len(zero), x = n-y\n# Space: O(max(x^2)) = O(n^2)\nfrom scipy.optimize import linear_sum_assignment as hungarian\nimport itertools\n\n\n# 3rd-party weighted bipartite matching solution\nclass Solution2(object):\n    def minimumMoves(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def dist(a, b):\n            return abs(a[0]-b[0])+abs(a[1]-b[1])\n\n        src, dst = [], []\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j]-1 >= 0:\n                    src.extend([(i, j)]*(grid[i][j]-1))\n                else:\n                    dst.append((i, j))\n        adj = [[dist(src[i], dst[j]) for j in xrange(len(dst))] for i in xrange(len(src))]\n        return sum(adj[i][j] for i, j in itertools.izip(*hungarian(adj)))    \n\n\n# Time:  O(max(x^y)) = O((n/2)^(n/2))) = O(5^5), n = len(grid)*len(grid[0]), y = len(zero), x = n-y\n# Space: O(y) = O(n) = O(9) = O(1)\n# backtracking\nclass Solution3(object):\n    def minimumMoves(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def dist(a, b):\n            return abs(a[0]-b[0])+abs(a[1]-b[1])\n\n        def backtracking(curr):\n            if curr == len(zero):\n                return 0\n            result = float(\"inf\")\n            i, j = zero[curr]\n            for ni in xrange(len(grid)):\n                for nj in xrange(len(grid[0])):\n                    if not (grid[ni][nj] >= 2):\n                        continue\n                    grid[ni][nj] -= 1\n                    result = min(result, dist((i, j), (ni, nj))+backtracking(curr+1))\n                    grid[ni][nj] += 1\n            return result\n\n        zero = [(i, j) for i in xrange(len(grid)) for j in xrange(len(grid[0])) if grid[i][j] == 0]\n        return backtracking(0)\n"
    },
    {
        "problem_name": "minimum-non-zero-product-of-the-array-elements",
        "solution": "# Time:  O(min(p, logM))\n# Space: O(1)\n\nclass Solution(object):\n    def minNonZeroProduct(self, p):\n        \"\"\"\n        :type p: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        # max_num = 2^p-1\n        max_num_mod = (pow(2, p, MOD)-1)%MOD  # max_num % MOD\n\n        # pair_product = max_num-1\n        pair_product_mod = (max_num_mod-1)%MOD  # (max_num_mod-1) % MOD\n\n        # since pair_product^MOD % MOD = pair_product_mod^MOD % MOD  = pair_product_mod\n        # => pair_product_mod^(MOD-1) % MOD = 1\n        # => pair_product_mod^(pair_cnt) % MOD = pair_product_mod^(pair_cnt%(MOD-1)) %MOD\n        pair_cnt_mod_m_1 = (pow(2, p-1, MOD-1)-1) % (MOD-1)  # pair_cnt%(MOD-1)\n\n        # the ans is:\n        #   max_num * pair_product^pair_cnt % MOD\n        # = max_num_mod * pair_product_mod^(pair_cnt_mod_m_1) % MOD\n        return (max_num_mod*pow(pair_product_mod, pair_cnt_mod_m_1, MOD)) % MOD\n"
    },
    {
        "problem_name": "minimum-number-game",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort\nclass Solution(object):\n    def numberGame(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        for i in xrange(0, len(nums), 2):\n            nums[i], nums[i+1] = nums[i+1], nums[i]\n        return nums\n"
    },
    {
        "problem_name": "minimum-number-of-arrows-to-burst-balloons",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def findMinArrowShots(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not points:\n            return 0\n\n        points.sort()\n\n        result = 0\n        i = 0\n        while i < len(points):\n            j = i + 1\n            right_bound = points[i][1]\n            while j < len(points) and points[j][0] <= right_bound:\n                right_bound = min(right_bound, points[j][1])\n                j += 1\n            result += 1\n            i = j\n        return result\n\n"
    },
    {
        "problem_name": "minimum-number-of-buckets-required-to-collect-rainwater-from-houses",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def minimumBuckets(self, street):\n        \"\"\"\n        :type street: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        street = list(street)\n        for i, c in enumerate(street):\n            if c != 'H' or (i and street[i-1] == 'B'):\n                continue\n            if i+1 < len(street) and street[i+1] == '.':\n                street[i+1] = 'B'\n                result += 1\n            elif i and street[i-1] == '.':\n                street[i-1] = 'B'\n                result += 1\n            else:\n                return -1\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-changes-to-make-binary-string-beautiful",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minChanges(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return sum(s[i] != s[i+1] for i in xrange(0, len(s), 2))\n"
    },
    {
        "problem_name": "minimum-number-of-coins-for-fruits-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# dp, mono deque\nclass Solution(object):\n    def minimumCoins(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [float(\"inf\")]*(len(prices)+1)\n        dp[0] = 0\n        dq = collections.deque()\n        j = 0\n        for i in xrange(len(prices)):\n            while dq and dp[dq[-1]]+prices[dq[-1]] >= dp[i]+prices[i]:\n                dq.pop()\n            dq.append(i)\n            while j+(j+1) < i:\n                assert(len(dq) != 0)\n                if dq[0] == j:\n                    dq.popleft()\n                j += 1\n            dp[i+1] = dp[dq[0]]+prices[dq[0]]\n        return dp[-1]\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# dp, sorted list\nfrom sortedcontainers import SortedList\n\n\nclass Solution2(object):\n    def minimumCoins(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [float(\"inf\")]*(len(prices)+1)\n        dp[0] = 0\n        sl = SortedList()\n        j = 0\n        for i in xrange(len(prices)):\n            sl.add((dp[i]+prices[i], i))\n            while j+(j+1) < i:\n                sl.remove(((dp[j]+prices[j], j)))\n                j += 1\n            dp[i+1] = sl[0][0]\n        return dp[-1]\n"
    },
    {
        "problem_name": "minimum-number-of-coins-for-fruits",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# dp, mono deque\nclass Solution(object):\n    def minimumCoins(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [float(\"inf\")]*(len(prices)+1)\n        dp[0] = 0\n        dq = collections.deque()\n        j = 0\n        for i in xrange(len(prices)):\n            while dq and dp[dq[-1]]+prices[dq[-1]] >= dp[i]+prices[i]:\n                dq.pop()\n            dq.append(i)\n            while j+(j+1) < i:\n                assert(len(dq) != 0)\n                if dq[0] == j:\n                    dq.popleft()\n                j += 1\n            dp[i+1] = dp[dq[0]]+prices[dq[0]]\n        return dp[-1]\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# dp, sorted list\nfrom sortedcontainers import SortedList\n\n\nclass Solution2(object):\n    def minimumCoins(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [float(\"inf\")]*(len(prices)+1)\n        dp[0] = 0\n        sl = SortedList()\n        j = 0\n        for i in xrange(len(prices)):\n            sl.add((dp[i]+prices[i], i))\n            while j+(j+1) < i:\n                sl.remove(((dp[j]+prices[j], j)))\n                j += 1\n            dp[i+1] = sl[0][0]\n        return dp[-1]\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# dp\nclass Solution3(object):\n    def minimumCoins(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [float(\"inf\")]*(len(prices)+1)\n        dp[0] = 0\n        for i in xrange(len(prices)):\n            for j in xrange(i//2, i+1):\n                dp[i+1] = min(dp[i+1], dp[j]+prices[j])\n        return dp[-1]\n"
    },
    {
        "problem_name": "minimum-number-of-coins-to-be-added",
        "solution": "# Time:  O(nlogn + logt)\n# Space: O(1)\n\n# lc0330\n# sort, greedy\nclass Solution(object):\n    def minimumAddedCoins(self, coins, target):\n        \"\"\"\n        :type coins: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        coins.sort()\n        result = reachable = 0\n        for x in coins:\n            # if x > target:\n            #     break\n            while not reachable >= x-1:\n                result += 1\n                reachable += reachable+1\n            reachable += x\n        while not reachable >= target:\n            result += 1\n            reachable += reachable+1\n        return result\n\n\n# Time:  O(nlogn + logt)\n# Space: O(1)\n# lc0330\n# sort, greedy\nclass Solution2(object):\n    def minimumAddedCoins(self, coins, target):\n        \"\"\"\n        :type coins: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        coins.sort()\n        result = reachable = 0\n        for x in coins:\n            while not reachable >= x-1:\n                result += 1\n                reachable += reachable+1\n                if reachable >= target:\n                    return result\n            reachable += x\n            if reachable >= target:\n                return result\n        while not reachable >= target:\n            result += 1\n            reachable += reachable+1\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-days-to-disconnect-island",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\n# template: https://github.com/kamyu104/GoogleCodeJam-Farewell-Rounds/blob/main/Round%20B/railroad_maintenance.py3\n# Reference: https://en.wikipedia.org/wiki/Biconnected_component#Algorithms\ndef iter_get_articulation_points(graph, v):  # modified\n    def iter_dfs(v, p):\n        stk = [(1, (v, p))]\n        while stk:\n            step, args = stk.pop()\n            if step == 1:\n                v, p = args\n                index[v] = index_counter[0]\n                lowlinks[v] = index_counter[0]\n                index_counter[0] += 1\n                children_count = [0]\n                is_cut = [False]\n                stk.append((4, (v, p, children_count, is_cut)))\n                for w in reversed(graph[v]):\n                    if w == p:\n                        continue\n                    stk.append((2, (w, v, children_count, is_cut)))\n            elif step == 2:\n                w, v, children_count, is_cut = args\n                if index[w] == -1:\n                    children_count[0] += 1\n                    stk.append((3, (w, v, is_cut)))\n                    stk.append((1, (w, v)))\n                else:\n                    lowlinks[v] = min(lowlinks[v], index[w])\n            elif step == 3:\n                w, v, is_cut = args\n                if lowlinks[w] >= index[v]:\n                    is_cut[0] = True\n                lowlinks[v] = min(lowlinks[v], lowlinks[w])\n            elif step == 4:\n                v, p, children_count, is_cut = args\n                if (p != -1 and is_cut[0]) or (p == -1 and children_count[0] >= 2):\n                    cutpoints.append(v)\n    index_counter, index, lowlinks = [0], [-1]*len(graph), [0]*len(graph)\n    cutpoints = []\n    iter_dfs(v, -1)  # modified\n    return cutpoints\n\n\n# flood fill, tarjan's algorithm, articulation points\nclass Solution(object):\n    def minDays(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n        def floodfill(grid, i, j, lookup):\n            stk = [(i, j)]\n            lookup[i][j] = 1\n            while stk:\n                i, j = stk.pop()\n                for di, dj in DIRECTIONS:\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < R and 0 <= nj < C and grid[ni][nj] and not lookup[ni][nj]):\n                        continue\n                    lookup[ni][nj] = 1\n                    stk.append((ni, nj))\n         \n        def count_islands(grid):\n            lookup = [[0]*C for _ in xrange(R)]\n            island_cnt = 0\n            for i in xrange(R):\n                for j in xrange(C):\n                    if grid[i][j] == 0 or lookup[i][j]:\n                        continue\n                    island_cnt += 1\n                    floodfill(grid, i, j, lookup)\n            return island_cnt\n\n        R, C = len(grid), len(grid[0])\n        if count_islands(grid) != 1:\n            return 0\n        adj = [[] for _ in xrange(R*C)]\n        cnt, idx = 0, -1\n        for i in xrange(R):\n            for j in xrange(C):\n                if grid[i][j] == 0:\n                    continue\n                cnt += 1\n                if idx == -1:\n                    idx = i*C+j\n                for di, dj in DIRECTIONS:\n                    ni, nj = i+di, j+dj\n                    if  0 <= ni < R and 0 <= nj < C and grid[ni][nj] == grid[i][j]:\n                        adj[i*C+j].append(ni*C+nj)\n        return 1 if cnt == 1 or iter_get_articulation_points(adj, idx) else 2\n\n\n# Time:  O((m * n) * log(m * n))\n# Space: O((m * n) * log(m * n))\n# Template: https://github.com/kamyu104/MetaHackerCup-2022/blob/main/Final%20Round/tile_transposing.py3\nclass PersistentUnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.size = [1]*n\n        self.snapshots = []  # added\n        self.undos = []  # added\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            y = stk.pop()\n            self.undos.append((~y, self.set[y]))  # added\n            self.set[y] = x\n        return x\n\n    def union_set(self, x, y):\n        x, y = self.find_set(x), self.find_set(y)\n        if x == y:\n            return False\n        if self.size[x] > self.size[y]:  # union by size\n            x, y = y, x\n        self.undos.append((x, y))  # added\n        self.set[x] = self.set[y]\n        self.size[y] += self.size[x]\n        return True\n\n    def total(self, x):\n        return self.size[self.find_set(x)]\n\n    def snapshot(self):  # added\n        self.snapshots.append(len(self.undos))\n\n    def rollback(self):  # added\n        for _ in xrange(len(self.undos)-self.snapshots.pop()):\n            x, y = self.undos.pop()\n            if x >= 0:\n                self.size[y] -= self.size[x]\n                self.set[x] = x\n            else:\n                self.set[~x] = y\n\n\n# flood fill, persistent union find\nclass Solution2(object):\n    def minDays(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n        def floodfill(grid, i, j, lookup):\n            stk = [(i, j)]\n            lookup[i][j] = 1\n            while stk:\n                i, j = stk.pop()\n                for di, dj in DIRECTIONS:\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < R and 0 <= nj < C and grid[ni][nj] and not lookup[ni][nj]):\n                        continue\n                    lookup[ni][nj] = 1\n                    stk.append((ni, nj))\n         \n        def count_islands(grid):\n            lookup = [[0]*C for _ in xrange(R)]\n            island_cnt = 0\n            for i in xrange(R):\n                for j in xrange(C):\n                    if grid[i][j] == 0 or lookup[i][j]:\n                        continue\n                    island_cnt += 1\n                    floodfill(grid, i, j, lookup)\n            return island_cnt\n    \n        def merge(i):\n            r, c = divmod(i, C)\n            for dr, dc in DIRECTIONS:\n                nr, nc = r+dr, c+dc\n                ni = nr*C+nc\n                if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] == grid[r][c] and lookup[ni]:\n                    uf.union_set(i, ni)\n\n        def check(i):\n            r, c = divmod(i, C)\n            if grid[r][c] == 0:\n                return False\n            lookup = set()\n            for dr, dc in DIRECTIONS:\n                nr, nc = r+dr, c+dc\n                if  0 <= nr < R and 0 <= nc < C and grid[nr][nc] == grid[r][c]:\n                    lookup.add(uf.find_set(nr*C+nc))\n            return len(lookup) != 1\n\n        def dfs(left, right):\n            if left == right:\n                return check(left)\n            mid = left + (right-left)//2\n            l1, r1, l2, r2 = left, mid, mid+1, right\n            for _ in xrange(2):\n                uf.snapshot()\n                for i in xrange(l1, r1+1):\n                    lookup[i] = True\n                    merge(i)\n                if dfs(l2, r2):\n                    return True\n                for i in xrange(l1, r1+1):\n                    lookup[i] = False\n                uf.rollback()\n                l1, r1, l2, r2 = l2, r2, l1, r1\n            return False\n\n        R, C = len(grid), len(grid[0])\n        if count_islands(grid) != 1:\n            return 0\n        uf = PersistentUnionFind(R*C)\n        lookup = [False]*(R*C)\n        return 1 if dfs(0, R*C-1) else 2\n\n\n# Time:  O(m^2 * n^2)\n# Space: O(m * n)\n# flood fill\nclass Solution3(object):\n    def minDays(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n        def floodfill(grid, i, j, lookup):\n            stk = [(i, j)]\n            lookup[i][j] = 1\n            while stk:\n                i, j = stk.pop()\n                for di, dj in DIRECTIONS:\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < R and 0 <= nj < C and grid[ni][nj] and not lookup[ni][nj]):\n                        continue\n                    lookup[ni][nj] = 1\n                    stk.append((ni, nj))\n         \n        def count_islands(grid):\n            lookup = [[0]*C for _ in xrange(R)]\n            island_cnt = 0\n            for i in xrange(R):\n                for j in xrange(C):\n                    if grid[i][j] == 0 or lookup[i][j]:\n                        continue\n                    island_cnt += 1\n                    floodfill(grid, i, j, lookup)\n            return island_cnt\n\n        R, C = len(grid), len(grid[0])\n        if count_islands(grid) != 1:\n            return 0\n        for i in xrange(R):\n            for j in xrange(C):\n                if grid[i][j] == 0:\n                    continue\n                grid[i][j] = 0\n                island_cnt = count_islands(grid)\n                grid[i][j] = 1\n                if island_cnt != 1:\n                    return 1\n        return 2\n"
    },
    {
        "problem_name": "minimum-number-of-days-to-eat-n-oranges",
        "solution": "# Time:  O((logn)^2)\n# Space: O((logn)^2)\n\n# complexity analysis: see https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/discuss/794847/Polylogarithmic-solution\nclass Solution(object):\n    def minDays(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def memoization(lookup, i):\n            if i <= 1:\n                return i\n            if i not in lookup:\n                lookup[i] = 1+min(i%2+memoization(lookup, i//2),\n                                  i%3+memoization(lookup, i//3))\n            return lookup[i]\n\n        lookup = {}\n        return memoization(lookup, n)\n\n\n# Time:  O((logn)^2)\n# Space: O((logn)^2)\nclass Solution2(object):\n    def minDays(self, n):\n        result = 0\n        q, lookup = [n], set([n])\n        while q:\n            new_q = []\n            for i in q: \n                if not i:\n                    return result\n                if i-1 not in lookup:\n                    lookup.add(i-1)\n                    new_q.append(i-1)\n                if i%2 == 0 and i//2 not in lookup:\n                    lookup.add(i//2)\n                    new_q.append(i//2)\n                if i%3 == 0 and i//3 not in lookup:\n                    lookup.add(i//3)\n                    new_q.append(i//3)\n            result += 1\n            q = new_q\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-days-to-make-m-bouquets",
        "solution": "# Time:  O(nlogd), d is the max day of bloomDay\n# Space: O(1)\n\nclass Solution(object):\n    def minDays(self, bloomDay, m, k):\n        \"\"\"\n        :type bloomDay: List[int]\n        :type m: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def check(bloomDay, m, k, x):\n            result = count = 0\n            for d in bloomDay:\n                count = count+1 if d <= x else 0\n                if count == k:\n                    count = 0\n                    result += 1\n                    if result == m:\n                        break\n            return result >= m\n\n        if m*k > len(bloomDay):\n            return -1\n        left, right = 1, max(bloomDay)\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(bloomDay, m, k, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix",
        "solution": "# Time:  O((m * n) * 2^(m * n))\n# Space: O((m * n) * 2^(m * n))\n\nimport collections\n\n\nclass Solution(object):\n    def minFlips(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 0), (0, 1), (1, 0), (0, -1), (-1, 0)]\n        start = sum(val << r*len(mat[0])+c for r, row in enumerate(mat) for c, val in enumerate(row))\n        q = collections.deque([(start, 0)])\n        lookup = {start}\n        while q:\n            state, step = q.popleft()\n            if not state:\n                return step\n            for r in xrange(len(mat)):\n                for c in xrange(len(mat[0])):\n                    new_state = state\n                    for dr, dc in directions:\n                        nr, nc = r+dr, c+dc\n                        if 0 <= nr < len(mat) and 0 <= nc < len(mat[0]):\n                            new_state ^= 1 << nr*len(mat[0])+nc\n                    if new_state in lookup:\n                        continue\n                    lookup.add(new_state)\n                    q.append((new_state, step+1))\n        return -1\n"
    },
    {
        "problem_name": "minimum-number-of-flips-to-make-the-binary-string-alternating",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minFlips(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = float(\"inf\")\n        cnt1 = cnt2 = 0\n        for i in xrange(2*len(s)-1 if len(s)%2 else len(s)):\n            if i >= len(s):\n                cnt1 -= int(s[i%len(s)])^((i-len(s))%2)^0\n                cnt2 -= int(s[i%len(s)])^((i-len(s))%2)^1\n            cnt1 += int(s[i%len(s)])^(i%2)^0\n            cnt2 += int(s[i%len(s)])^(i%2)^1\n            if i >= len(s)-1:\n                result = min(result, cnt1, cnt2)\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-frogs-croaking",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minNumberOfFrogs(self, croakOfFrogs):\n        \"\"\"\n        :type croakOfFrogs: str\n        :rtype: int\n        \"\"\"\n        S = \"croak\"\n        lookup = [0]*len(S)\n        result = 0\n        for c in croakOfFrogs:\n            i = S.find(c)\n            lookup[i] += 1\n            if lookup[i-1]:\n                lookup[i-1] -= 1\n            elif i == 0:\n                result += 1\n            else:\n                return -1\n        return result if result == lookup[-1] else -1\n"
    },
    {
        "problem_name": "minimum-number-of-groups-to-create-a-valid-assignment",
        "solution": "# Time:  O(min(cnt.values()) * n/min(cnt.values())) = O(n)\n# Space: O(n)\n\nimport collections\n\n\n# linear search, greedy, math\nclass Solution(object):\n    def minGroupsForValidAssignment(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n    \n        def count(x):\n            result = 0\n            for c in cnt.itervalues():\n                if c%x > c//x:\n                    return INF\n                result += ceil_divide(c, x+1)\n            return result\n\n        cnt = collections.Counter(nums)\n        for i in reversed(xrange(1, min(cnt.itervalues())+1)):\n            c = count(i)\n            if c != INF:\n                return c\n        return 0\n"
    },
    {
        "problem_name": "minimum-number-of-increments-on-subarrays-to-form-a-target-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minNumberOperations(self, target):\n        \"\"\"\n        :type target: List[int]\n        :rtype: int\n        \"\"\"\n        return target[0]+sum(max(target[i]-target[i-1], 0) for i in xrange(1, len(target)))\n\n\n# Time:  O(n)\n# Space: O(n)\nimport itertools\n\n\nclass Solution2(object):\n    def minNumberOperations(self, target):\n        \"\"\"\n        :type target: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(max(b-a, 0) for b, a in itertools.izip(target, [0]+target))\n"
    },
    {
        "problem_name": "minimum-number-of-k-consecutive-bit-flips",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minKBitFlips(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        result, curr = 0, 0\n        for i in xrange(len(A)):\n            if i >= K:\n                curr -= A[i-K]//2\n            if curr & 1 ^ A[i] == 0:\n                if i+K > len(A):\n                    return -1\n                A[i] += 2\n                curr, result = curr+1, result+1\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-keypresses",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\n# greedy, sort\nclass Solution(object):\n    def minimumKeypresses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return sum(cnt*(i//9+1) for i, cnt in enumerate(sorted(collections.Counter(s).itervalues(), reverse=True)))\n"
    },
    {
        "problem_name": "minimum-number-of-lines-to-cover-points",
        "solution": "# Time:  O(n^2 + n*2^n) = O(n*2^n)\n# Space: O(n^2)\n\nimport collections\n\n\n# math, hash table, bitmasks\nclass Solution(object):\n    def minimumLines(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):  # Time: O(log(a + b))\n            while b:\n                a, b = b, a % b\n            return a\n\n        def popcount(x):\n            result = 0\n            while x:\n                x &= (x-1)\n                result += 1\n            return result\n\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n        \n        lookup = collections.defaultdict(set)               \n        for i, (x1, y1) in enumerate(points):\n            for j in xrange(i+1, len(points)):\n                x2, y2 = points[j]\n                # (x-x1)/(x2-x1) = (y-y1)/(y2-y1)\n                # => (y2-y1)x - (x2-x1)y = x1(y2-y1) - y1(x2-x1)\n                a, b, c = (y2-y1), -(x2-x1), x1*(y2-y1)-y1*(x2-x1) \n                g = gcd(gcd(a, b), c)\n                a, b, c = a//g, b//g, c//g\n                lookup[(a, b, c)].add((x1, y1))\n                lookup[(a, b, c)].add((x2, y2))\n        lines = [l for l, p in lookup.iteritems() if len(p) > 2]  # filter to improve complexity\n        assert(len(lines) <= (len(points))//2)  # 1 extra colinear point per 2 points\n        result = float(\"inf\")\n        for mask in xrange(1<<len(lines)):\n            covered = set()\n            bit, i = 1, 0\n            while bit <= mask:\n                if mask&bit:\n                    covered.update(lookup[lines[i]])\n                bit <<= 1                        \n                i += 1\n            result = min(result, popcount(mask) + ceil_divide(len(points)-len(covered), 2))\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-moves-to-make-palindrome",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass BIT(object):  # 0-indexed\n    def __init__(self, n):\n        self.__bit = [0]*(n+1)\n\n    def add(self, i, val):\n        i += 1\n        while i < len(self.__bit):\n            self.__bit[i] += val\n            i += (i & -i)\n\n    def query(self, i):\n        i += 1\n        ret = 0\n        while i > 0:\n            ret += self.__bit[i]\n            i -= (i & -i)\n        return ret\n\n\n# greedy, bit, fenwick tree\nclass Solution(object):\n    def minMovesToMakePalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        idxs = [[] for _ in xrange(26)]\n        for i, c in enumerate(s):\n            idxs[ord(c)-ord('a')].append(i)\n        targets, pairs = [0]*len(s), []\n        for c, idx in enumerate(idxs):\n            for i in xrange(len(idx)//2):\n                pairs.append((idx[i], idx[~i]))\n            if len(idx)%2:\n                targets[idx[len(idx)//2]] = len(s)//2\n        pairs.sort()\n        for i, (l, r) in enumerate(pairs):\n            targets[l], targets[r] = i, (len(s)-1)-i\n        bit = BIT(len(s))\n        result = 0\n        for i in targets:\n            result += i-bit.query(i-1)  # move from bit.query(i-1) to i\n            bit.add(i, 1)\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# greedy\nclass Solution2(object):\n    def minMovesToMakePalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        s = list(s)\n        result = 0\n        while s:\n            i = s.index(s[-1])\n            if i == len(s)-1:\n                result += i//2\n            else:\n                result += i\n                s.pop(i)\n            s.pop()\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-moves-to-seat-everyone",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def minMovesToSeat(self, seats, students):\n        \"\"\"\n        :type seats: List[int]\n        :type students: List[int]\n        :rtype: int\n        \"\"\"\n        seats.sort()\n        students.sort()\n        return sum(abs(a-b) for a, b in itertools.izip(seats, students))\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-convert-time",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def convertTime(self, current, correct):\n        \"\"\"\n        :type current: str\n        :type correct: str\n        :rtype: int\n        \"\"\"\n        OPS = (60, 15, 5, 1)\n        diff = (int(correct[:2])*60+int(correct[3:]))-(int(current[:2])*60+int(current[3:]))\n        result = 0\n        for x in OPS:\n            q, diff = divmod(diff, x)\n            result += q\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-make-all-array-elements-equal-to-1",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n# math, number theory, constructive algorithms\nclass Solution(object):\n    def minOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        cnt = nums.count(1)\n        if cnt:\n            return len(nums)-cnt\n        result = float(\"inf\")\n        for i in xrange(len(nums)): \n            g = nums[i]\n            for j in range(i+1, len(nums)):\n                g = gcd(g, nums[j])\n                if g == 1:\n                    result = min(result, j-i)\n                    break\n        return result+(len(nums)-1) if result != float(\"inf\") else -1\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-make-array-continuous",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def minOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def unique(nums):\n            left = 0\n            for right in xrange(1, len(nums)):\n                if nums[left] != nums[right]:\n                    left += 1\n                    nums[left] = nums[right]\n            return left\n\n        def erase(nums, i):\n            while len(nums) > i+1:\n                nums.pop()\n\n        n = len(nums)\n        nums.sort()\n        erase(nums, unique(nums))\n        result = l = 0\n        for i in xrange(len(nums)):\n            if nums[i] <= nums[i-l]+n-1:\n                l += 1\n        return n-l\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nclass Solution2(object):\n    def minOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        nums = sorted(set(nums))\n        result = right = 0\n        for left in xrange(len(nums)):\n            while right < len(nums) and nums[right] <= nums[left]+n-1:\n                right += 1\n            result = max(result, right-left)\n        return n-result\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-make-array-empty",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table, greedy\nclass Solution(object):\n    def minOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n\n        cnt = collections.Counter(nums)\n        return sum(ceil_divide(x, 3) for x in cnt.itervalues()) if all(x >= 2 for x in cnt.itervalues()) else -1\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-make-array-xor-equal-to-k",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def minOperations(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def popcount(x):\n            return bin(x).count('1')\n    \n        return popcount(reduce(lambda x, y: x^y, nums, k))\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-make-arrays-similar",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nimport itertools\n\n\n# greedy, sort\nclass Solution(object):\n    def makeSimilar(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort(key=lambda x: (x%2, x))\n        target.sort(key=lambda x: (x%2, x))\n        return sum(abs(x-y)//2 for x, y in itertools.izip(nums, target))//2\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-make-string-sorted",
        "solution": "# Time:  O(26 * n) = O(n)\n# Space: O(max_n) = O(max_n)\n\ninv = [0, 1]\n\n\nclass Solution(object):\n    def makeStringSorted(self, s):  # count of prev_permutation\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def inverse(n, m):\n            i = len(inv)\n            while len(inv) <= n:  # lazy initialization\n                inv.append(inv[m%i]*(m-m//i) % m)  # https://cp-algorithms.com/algebra/module-inverse.html\n                i += 1\n            return inv[n]\n    \n        MOD = 10**9+7\n        count, result, comb_total = [0]*26, 0, 1\n        for i in reversed(xrange(len(s))):\n            num = ord(s[i])-ord('a') \n            count[num] += 1\n            comb_total = (comb_total*(len(s)-i))*inverse(count[num], MOD)\n            result = (result + (comb_total*sum(count[:num]))*inverse(len(s)-i, MOD)) % MOD\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-make-word-k-periodic",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def minimumOperationsToMakeKPeriodic(self, word, k):\n        \"\"\"\n        :type word: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(word[i:i+k]for i in xrange(0, len(word), k))\n        return len(word)//k-max(cnt.itervalues())\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-make-x-and-y-equal",
        "solution": "# Time:  O(x)\n# Space: O(x)\n\n# memoization\nclass Solution(object):\n    def minimumOperationsToMakeEqual(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        def memoization(x):\n            if y >= x:\n                return y-x\n            if x not in lookup:\n                lookup[x] = min(x-y, min(min(x%d, d-x%d)+memoization(x//d+int(d-x%d < x%d))+1 for d in (5, 11)))\n            return lookup[x]\n    \n        lookup = {}\n        return memoization(x)\n\n\n# Time:  O(x)\n# Space: O(x)\n# bfs\nclass Solution2(object):\n    def minimumOperationsToMakeEqual(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n\n        if y >= x:\n            return y-x\n        upper_bound = x+(x-y)\n        result = 0\n        lookup = {x}\n        q = [x]\n        while q:\n            new_q = []\n            for x in q:\n                if x == y:\n                    return result\n                candidates = [x+1, x-1]\n                for d in (5, 11):\n                    if x%d == 0:\n                        candidates.append(x//d)\n                for new_x in candidates:\n                    if not (0 <= new_x <= upper_bound and new_x not in lookup):\n                        continue\n                    lookup.add(new_x)\n                    new_q.append(new_x)\n            q = new_q\n            result += 1\n        return -1\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-move-all-balls-to-each-box",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minOperations(self, boxes):\n        \"\"\"\n        :type boxes: str\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(boxes)\n        for direction in (lambda x:x, reversed):\n            cnt = accu = 0\n            for i in direction(xrange(len(boxes))):\n                result[i] += accu\n                if boxes[i] == '1':\n                    cnt += 1\n                accu += cnt\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-reinitialize-a-permutation",
        "solution": "# Time:  O(sqrt(n))\n# Space: O(sqrt(n))\n\nclass Solution(object):\n    def reinitializePermutation(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # reference: https://cp-algorithms.com/algebra/discrete-log.html\n        def discrete_log(a, b, m):\n            a %= m\n            b %= m\n            n = int(m**0.5)+1\n            an = pow(a, n, m)\n            vals = {}\n            curr = b\n            for q in xrange(n+1):\n                vals[curr] = q\n                curr = curr*a % m\n            curr = 1\n            for p in xrange(1, n+1):\n                curr = curr*an % m\n                if curr in vals:\n                    return n*p-vals[curr]\n            return -1\n\n        return 1+discrete_log(2, n//2, n-1)  # find min x s.t. 2^x mod (n-1) = n/2, result is x + 1\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def reinitializePermutation(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 2:\n            return 1\n        result, i = 0, 1\n        while not result or i != 1:\n            i = (i*2)%(n-1)\n            result += 1\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution3(object):\n    def reinitializePermutation(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result, i = 0, 1\n        while not result or i != 1:  # find cycle length\n            i = (i//2 if not i%2 else n//2+(i-1)//2)\n            result += 1\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-satisfy-conditions",
        "solution": "# Time:  O(n * (m + 10))\n# Space: O(10)\n\n# dp\nclass Solution(object):\n    def minimumOperations(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        MAX_VALUE = 9\n        dp = [0]*(MAX_VALUE+1)\n        for j in xrange(len(grid[0])):\n            new_dp = [INF]*(MAX_VALUE+1)\n            cnt = [0]*(MAX_VALUE+1)\n            for i in xrange(len(grid)):\n                cnt[grid[i][j]] += 1\n            k1 = min(xrange(MAX_VALUE+1), key=lambda x: dp[x])\n            k2 = min((i for i in xrange(MAX_VALUE+1) if i != k1), key=lambda x: dp[x])\n            for i in xrange(MAX_VALUE+1):\n                new_dp[i] = min(new_dp[i], (dp[k1] if i != k1 else dp[k2])+(len(grid)-cnt[i]))\n            dp = new_dp\n        return min(dp)\n\n\n# Time:  O(n * (m + 100))\n# Space: O(10)\n# dp\nclass Solution2(object):\n    def minimumOperations(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        MAX_VALUE = 9\n        dp = [0]*(MAX_VALUE+1)\n        for j in xrange(len(grid[0])):\n            new_dp = [INF]*(MAX_VALUE+1)\n            cnt = [0]*(MAX_VALUE+1)\n            for i in xrange(len(grid)):\n                cnt[grid[i][j]] += 1\n            for i in xrange(MAX_VALUE+1):\n                new_dp[i] = min(new_dp[i], min(dp[k] for k in xrange(MAX_VALUE+1) if k != i)+(len(grid)-cnt[i]))\n            dp = new_dp\n        return min(dp)\n"
    },
    {
        "problem_name": "minimum-number-of-operations-to-sort-a-binary-tree-by-level",
        "solution": "# Time:  O(nlogn)\n# Space: O(w)\n\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\n# bfs, sort\nclass Solution(object):\n    def minimumOperations(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        result = 0\n        q = [root]\n        while q:\n            new_q = []\n            for node in q:\n                if node.left:\n                    new_q.append(node.left)\n                if node.right:\n                    new_q.append(node.right)\n            idx = range(len(q))\n            idx.sort(key=lambda x: q[x].val)\n            for i in xrange(len(q)):\n                while idx[i] != i:\n                    idx[idx[i]], idx[i] = idx[i], idx[idx[i]]\n                    result += 1\n            q = new_q\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-people-to-teach",
        "solution": "# Time:  O(n * m^2)\n# Space: O(n * m)\n\nimport collections\n\n\nclass Solution(object):\n    def minimumTeachings(self, n, languages, friendships):\n        \"\"\"\n        :type n: int\n        :type languages: List[List[int]]\n        :type friendships: List[List[int]]\n        :rtype: int\n        \"\"\"\n        language_sets = map(set, languages)  # Space: O(m * n)\n        candidates = set(i-1 for u, v in friendships if not language_sets[u-1] & language_sets[v-1] for i in [u, v])  # Time: O(m^2 * n), Space: O(m)\n        count = collections.Counter()\n        for i in candidates:  # Time: O(m * n)\n            count += collections.Counter(languages[i])\n        return len(candidates) - max(count.values() + [0])\n"
    },
    {
        "problem_name": "minimum-number-of-pushes-to-type-word-i",
        "solution": "# Time:  O(4)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minimumPushes(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n\n        return sum((i+1)*min(len(word)-i*(9-2+1), (9-2+1)) for i in xrange(ceil_divide(len(word), (9-2+1))))\n\n\n# Time:  O(26)\n# Space: O(26)\nimport collections\n\n\n# freq table, greedy\nclass Solution2(object):\n    def minimumPushes(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        return sum(x*(i//(9-2+1)+1) for i, x in enumerate(sorted(collections.Counter(word).itervalues(), reverse=True)))\n"
    },
    {
        "problem_name": "minimum-number-of-pushes-to-type-word-ii",
        "solution": "# Time:  O(n)\n# Space: O(26)\n\nimport collections\n\n\n# freq table, greedy\nclass Solution(object):\n    def minimumPushes(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        return sum(x*(i//(9-2+1)+1) for i, x in enumerate(sorted(collections.Counter(word).itervalues(), reverse=True)))\n"
    },
    {
        "problem_name": "minimum-number-of-refueling-stops",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def minRefuelStops(self, target, startFuel, stations):\n        \"\"\"\n        :type target: int\n        :type startFuel: int\n        :type stations: List[List[int]]\n        :rtype: int\n        \"\"\"\n        max_heap = []\n        stations.append((target, float(\"inf\")))\n\n        result = prev = 0\n        for location, capacity in stations:\n            startFuel -= location - prev\n            while max_heap and startFuel < 0:\n                startFuel += -heapq.heappop(max_heap)\n                result += 1\n            if startFuel < 0:\n                return -1\n            heapq.heappush(max_heap, -capacity)\n            prev = location\n\n        return result\n\n"
    },
    {
        "problem_name": "minimum-number-of-removals-to-make-mountain-array",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport bisect\n\n\nclass Solution(object):\n    def minimumMountainRemovals(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left_lis_len = [0]*len(nums)\n        lis = []\n        for i in xrange(len(nums)-1):\n            j = bisect.bisect_left(lis, nums[i])\n            if j == len(lis):\n                lis.append(nums[i])\n            else:\n                lis[j] = nums[i]\n            left_lis_len[i] = j\n        max_len = 0\n        lis = []\n        for i in reversed(xrange(1, len(nums))):\n            j = bisect.bisect_left(lis, nums[i])\n            if j == len(lis):\n                lis.append(nums[i])\n            else:\n                lis[j] = nums[i]\n            if i < len(nums)-1:\n                max_len = max(max_len, left_lis_len[i]+j)\n        return len(nums) - (1+max_len)\n"
    },
    {
        "problem_name": "minimum-number-of-steps-to-make-two-strings-anagram-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def minSteps(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        cnt1, cnt2 = collections.Counter(s), collections.Counter(t)\n        return sum((cnt1-cnt2).itervalues())+sum((cnt2-cnt1).itervalues())\n"
    },
    {
        "problem_name": "minimum-number-of-steps-to-make-two-strings-anagram",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def minSteps(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        diff = collections.Counter(s) - collections.Counter(t)\n        return sum(diff.itervalues())\n"
    },
    {
        "problem_name": "minimum-number-of-swaps-to-make-the-binary-string-alternating",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def cost(s, x): \n            diff = 0 \n            for c in s:\n                diff += int(c) != x\n                x ^= 1\n            return diff//2\n    \n        ones = s.count('1')\n        zeros = len(s)-ones \n        if abs(ones-zeros) > 1:\n            return -1\n        if ones > zeros:\n            return cost(s, 1)\n        if ones < zeros:\n            return cost(s, 0)\n        return min(cost(s, 1), cost(s, 0))\n"
    },
    {
        "problem_name": "minimum-number-of-swaps-to-make-the-string-balanced",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minSwaps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = curr = 0\n        for c in s:\n            if c == ']':\n                curr += 1\n                result = max(result, curr)\n            else:\n                curr -= 1\n        return (result+1)//2\n"
    },
    {
        "problem_name": "minimum-number-of-taps-to-open-to-water-a-garden",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def minTaps(self, n, ranges):\n        \"\"\"\n        :type n: int\n        :type ranges: List[int]\n        :rtype: int\n        \"\"\"\n        def jump_game(A):\n            jump_count, reachable, curr_reachable = 0, 0, 0\n            for i, length in enumerate(A):\n                if i > reachable:\n                    return -1\n                if i > curr_reachable:\n                    curr_reachable = reachable\n                    jump_count += 1\n                reachable = max(reachable, i+length)\n            return jump_count\n    \n        max_range = [0]*(n+1)\n        for i, r in enumerate(ranges):\n            left, right = max(i-r, 0), min(i+r, n)\n            max_range[left] = max(max_range[left], right-left)\n        return jump_game(max_range)\n"
    },
    {
        "problem_name": "minimum-number-of-vertices-to-reach-all-nodes",
        "solution": "# Time:  O(e)\n# Space: O(n)\n\nclass Solution(object):\n    def findSmallestSetOfVertices(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        lookup = set()\n        for u, v in edges:\n            lookup.add(v)\n        for i in xrange(n):\n            if i not in lookup:\n                result.append(i)\n        return result\n"
    },
    {
        "problem_name": "minimum-number-of-visited-cells-in-a-grid",
        "solution": "# Time:  O(m * n * alpha(m + n)) = O(m + n)\n# Space: O(m * n)\n\n# bfs, union find\nclass UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n        self.right = range(n)  # added\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x, y = self.find_set(x), self.find_set(y)\n        if x == y:\n            return False\n        if self.rank[x] > self.rank[y]:  # union by rank\n            x, y = y, x\n        self.set[x] = self.set[y]\n        if self.rank[x] == self.rank[y]:\n            self.rank[y] += 1\n        self.right[y] = max(self.right[x], self.right[y])  # added\n        return True\n\n    def right_set(self, x):  # added\n        return self.right[self.find_set(x)]\n\n\nclass Solution(object):\n    def minimumVisitedCells(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        uf1 = [UnionFind(n+1) for _ in xrange(m)]\n        uf2 = [UnionFind(m+1) for _ in xrange(n)]\n        d, i, j = 1, 0, 0\n        q = [(i, j)]\n        uf1[i].union_set(j, j+1)\n        uf2[j].union_set(i, i+1)\n        while q:\n            new_q = []\n            for i, j in q:\n                if (i, j) == (m-1, n-1):\n                    return d\n                while uf1[i].right_set(j) <= min(j+grid[i][j], n-1):\n                    k = uf1[i].right_set(j)\n                    new_q.append((i, k))\n                    uf2[k].union_set(i, i+1)\n                    uf1[i].union_set(k, k+1)\n                while uf2[j].right_set(i) <= min(i+grid[i][j], m-1):\n                    k = uf2[j].right_set(i)\n                    new_q.append((k, j))\n                    uf1[k].union_set(j, j+1)\n                    uf2[j].union_set(k, k+1)\n            q = new_q\n            d += 1\n        return -1\n\n\n# Time:  O(m * n * log(m + n))\n# Space: O(m * n)\nfrom sortedcontainers import SortedList\n\n\n# bfs, sorted list\nclass Solution2_TLE(object):\n    def minimumVisitedCells(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        sl1 = [SortedList(xrange(n)) for _ in xrange(m)]\n        sl2 = [SortedList(xrange(m)) for _ in xrange(n)]\n        d, i, j = 1, 0, 0\n        q = [(i, j)]\n        while q:\n            new_q = []\n            for i, j in q:\n                if (i, j) == (m-1, n-1):\n                    return d\n                for k in list(sl1[i].irange(j+1, min(j+grid[i][j], n-1))):\n                    new_q.append((i, k))\n                    sl2[k].remove(i)\n                    sl1[i].remove(k)\n                for k in list(sl2[j].irange(i+1, min(i+grid[i][j], m-1))):\n                    new_q.append((k, j))\n                    sl1[k].remove(j)\n                    sl2[j].remove(k)\n            q = new_q\n            d += 1\n        return -1\n"
    },
    {
        "problem_name": "minimum-number-of-work-sessions-to-finish-the-tasks",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(2^n)\n\nclass Solution(object):\n    def minSessions(self, tasks, sessionTime):\n        \"\"\"\n        :type tasks: List[int]\n        :type sessionTime: int\n        :rtype: int\n        \"\"\"\n        # dp[mask]: min used time by choosing tasks in mask bitset\n        dp = [float(\"inf\") for _ in xrange(1<<len(tasks))]\n        dp[0] = 0\n        for mask in xrange(len(dp)-1):\n            basis = 1\n            for task in tasks:\n                new_mask = mask|basis\n                basis <<= 1\n                if new_mask == mask:\n                    continue\n                if dp[mask]%sessionTime + task > sessionTime:\n                    task += sessionTime-dp[mask]%sessionTime  # take a break\n                dp[new_mask] = min(dp[new_mask], dp[mask]+task)\n        return (dp[-1]+sessionTime-1)//sessionTime\n\n\n# Time:  O(n * 2^n)\n# Space: O(2^n)\nclass Solution2(object):\n    def minSessions(self, tasks, sessionTime):\n        \"\"\"\n        :type tasks: List[int]\n        :type sessionTime: int\n        :rtype: int\n        \"\"\"\n        # dp[mask][0]: min number of sessions by choosing tasks in mask bitset\n        # dp[mask][1]: min used time of last session by choosing tasks in mask bitset\n        dp = [[float(\"inf\")]*2 for _ in xrange(1<<len(tasks))]\n        dp[0] = [0, sessionTime]\n        for mask in xrange(len(dp)-1):\n            basis = 1\n            for task in tasks:\n                new_mask = mask|basis\n                basis <<= 1\n                if new_mask == mask:\n                    continue\n                if dp[mask][1]+task <= sessionTime:\n                    dp[new_mask] = min(dp[new_mask], [dp[mask][0], dp[mask][1]+task])\n                else:\n                    dp[new_mask] = min(dp[new_mask], [dp[mask][0]+1, task])\n        return dp[-1][0]\n"
    },
    {
        "problem_name": "minimum-numbers-of-function-calls-to-make-target-array",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def minOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def popcount(n):\n            result = 0\n            while n:\n                n &= n-1\n                result += 1\n            return result\n\n        result, max_len = 0, 1\n        for num in nums:\n            result += popcount(num)\n            max_len = max(max_len, num.bit_length())\n        return result + (max_len-1)\n"
    },
    {
        "problem_name": "minimum-obstacle-removal-to-reach-corner",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\n# A* Search Algorithm without heap\nclass Solution(object):\n    def minimumObstacles(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        def a_star(grid, b, t):\n            f, dh = 0, 1\n            closer, detour = [b], []\n            lookup = set()\n            while closer or detour:\n                if not closer:\n                    f += dh\n                    closer, detour = detour, closer\n                b = closer.pop()\n                if b in lookup:\n                    continue\n                lookup.add(b)\n                if b == t:\n                    return f\n                for dr, dc in directions:\n                    nb = (b[0]+dr, b[1]+dc)\n                    if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup):\n                        continue\n                    (closer if not grid[b[0]][b[1]] else detour).append(nb)\n            return -1\n\n        return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1))\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\nimport collections\n\n\n# 0-1 bfs solution\nclass Solution2(object):\n    def minimumObstacles(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        b, t = (0, 0), (len(grid)-1, len(grid[0])-1)\n        dq = collections.deque([(b, 0)])\n        lookup = set()\n        while dq:\n            b, d = dq.popleft()\n            if b in lookup:\n                continue\n            lookup.add(b)\n            if b == t:\n                return d\n            for dr, dc in directions:\n                nb = (b[0]+dr, b[1]+dc)\n                if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup):\n                    continue\n                if not grid[b[0]][b[1]]:\n                    dq.appendleft((nb, d))\n                else:\n                    dq.append((nb, d+1))\n        return -1  # never reach here\n"
    },
    {
        "problem_name": "minimum-one-bit-operations-to-make-integers-zero",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# reference: https://en.wikipedia.org/wiki/Gray_code\nclass Solution(object):\n    def minimumOneBitOperations(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def gray_to_binary(n):\n            result = 0\n            while n:\n                result ^= n\n                n >>= 1\n            return result\n        \n        # [observation]\n        # n    f(n)\n        # 000    0\n        # 001    1\n        # 011    2\n        # 010    3\n        # 110    4\n        # 111    5\n        # 101    6\n        # 100    7\n\t# f(0XX...X) + f(1XX...X) = f(100...0) implies n is a gray code\n        # => f(n) is actually the inverse of gray code\n        return gray_to_binary(n)\n\n\n# Time:  O(logn)\n# Space: O(1)\nclass Solution2(object):\n    def minimumOneBitOperations(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # [observation1]:\n        # f(1) = 1\n        # f(10) = 2 * f(1) + 1 = 3\n        # f(100) = 2 * f(10) + 1 = 7\n        # by mathematical induction\n        # => f(2^k) = 2^(k+1)-1\n        #\n        # [observation2]\n        # n    f(n)\n        # 000    0\n        # 001    1\n        # 011    2\n        # 010    3\n        # 110    4\n        # 111    5\n        # 101    6\n        # 100    7\n        # let pos be an array of positions where the bit is 1 in ascending order:\n\t# f(0XX...X) + f(1XX...X) = f(100...0)\n        # f(1XX...X) = f(100...0) - f(0XX...X)\n        #            = (2^(pos[k-1]+1)-1) - f(0XX...X)\n        # by mathematical induction\n        # => f(n) = (2^(pos[k-1]+1)-1) - (2^(pos[k-2])+1) + ... + (-1)^(k-1) * (2^(pos[0]+1)-1)\n        result = 0\n        while n:\n            result = -result - (n^(n-1))  # 2^(pos[i]+1)-1\n            n &= n-1\n        return abs(result)\n"
    },
    {
        "problem_name": "minimum-operations-to-collect-elements",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\n# hash table\nclass Solution(object):\n    def minOperations(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        lookup = [False]*k\n        for i in reversed(xrange(len(nums))):\n            if nums[i] > len(lookup) or lookup[nums[i]-1]:\n                continue\n            lookup[nums[i]-1] = True\n            k -= 1\n            if not k:\n                break\n        return len(nums)-i\n"
    },
    {
        "problem_name": "minimum-operations-to-convert-number",
        "solution": "# Time:  O(n * m), m is max x\n# Space: O(m)\n\nclass Solution(object):\n    def minimumOperations(self, nums, start, goal):\n        \"\"\"\n        :type nums: List[int]\n        :type start: int\n        :type goal: int\n        :rtype: int\n        \"\"\"\n        MAX_X = 1000\n        nums = [y for y in nums if y and any(0 <= nx <= MAX_X for nx in (y, goal-y, goal+y, goal^y))]\n        q = [(start, 0)]\n        lookup = {start}\n        while q:\n            new_q = []\n            for x, steps in q:\n                for y in nums:\n                    for nx in (x+y, x-y, x^y):\n                        if nx == goal:\n                            return steps+1\n                        if not (0 <= nx <= MAX_X) or nx in lookup:\n                            continue\n                        lookup.add(nx)\n                        q.append((nx, steps+1))\n            q = new_q\n        return -1\n"
    },
    {
        "problem_name": "minimum-operations-to-exceed-threshold-value-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def minOperations(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return sum(x < k for x in nums)\n"
    },
    {
        "problem_name": "minimum-operations-to-exceed-threshold-value-ii",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\n# simulation, heap\nclass Solution(object):\n    def minOperations(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        heapq.heapify(nums)\n        while nums:\n            if nums[0] >= k:\n                break\n            mn1 = heapq.heappop(nums)\n            mn2 = heapq.heappop(nums)\n            heapq.heappush(nums, 2*mn1+mn2)\n            result += 1\n        return result\n"
    },
    {
        "problem_name": "minimum-operations-to-form-subsequence-with-target-sum",
        "solution": "# Time:  O(n)\n# Space: O(logn)\n\n# codeforces, https://codeforces.com/problemset/problem/1303/D\n# counting sort, greedy\nclass Solution(object):\n    def minOperations(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        def floor_log2_x(x):\n            return x.bit_length()-1\n\n        total = sum(nums)\n        if total < target:\n            return -1\n\n        cnt = [0]*(floor_log2_x(max(nums))+1)\n        for x in nums:\n            cnt[floor_log2_x(x)] += 1\n        result = 0\n        for i in reversed(xrange(len(cnt))):\n            for _ in xrange(cnt[i]):\n                x = 1<<i\n                if x <= target:\n                    target -= x\n                    total -= x\n                elif total-x >= target:\n                    total -= x\n                else:\n                    cnt[i-1] += 2\n                    result += 1\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# codeforces, https://codeforces.com/problemset/problem/1303/D\n# sort, greedy\nclass Solution2(object):\n    def minOperations(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        total = sum(nums)\n        if total < target:\n            return -1\n\n        nums.sort()\n        result = 0\n        while target:\n            x = nums.pop()\n            if x <= target:\n                target -= x\n                total -= x\n            elif total-x >= target:\n                total -= x\n            else:\n                nums.append(x//2)\n                nums.append(x//2)\n                result += 1\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport heapq\n\n\n# codeforces, https://codeforces.com/problemset/problem/1303/D\n# heap, greedy\nclass Solution3(object):\n    def minOperations(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        total = sum(nums)\n        if total < target:\n            return -1\n\n        result = 0\n        max_heap = [-x for x in nums]\n        heapq.heapify(max_heap)\n        while target:\n            x = -heapq.heappop(max_heap)\n            if x <= target:\n                target -= x\n                total -= x\n            elif total-x >= target:\n                total -= x\n            else:\n                heapq.heappush(max_heap, -x//2)\n                heapq.heappush(max_heap, -x//2)\n                result += 1\n        return result\n\n\n# Time:  O(nlogr)\n# Space: O(logr)\n# codeforces, https://codeforces.com/problemset/problem/1303/D\n# bitmasks, greedy\nclass Solution4(object):\n    def minOperations(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        def floor_log2_x(x):\n            return x.bit_length()-1\n\n        if sum(nums) < target:\n            return -1\n\n        cnt = [0]*(floor_log2_x(max(nums))+1)\n        for x in nums:\n            cnt[floor_log2_x(x)] += 1\n        result = i = 0\n        while i < len(cnt):\n            if target&(1<<i):\n                if not cnt[i]:\n                    j = next(j for j in xrange(i, len(cnt)) if cnt[j])\n                    result += j-i\n                    j = i\n                    cnt[i] -= 1\n                    continue\n                cnt[i] -= 1\n            if i+1 < len(cnt):\n                cnt[i+1] += cnt[i]//2\n            i += 1\n        return result\n"
    },
    {
        "problem_name": "minimum-operations-to-halve-array-sum",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\n# heap\nclass Solution(object):\n    def halveArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        target = sum(nums)/2.0\n        max_heap = [-x for x in nums]\n        heapq.heapify(max_heap)\n        result = 1\n        while max_heap:\n            x = -heapq.heappop(max_heap)/2.0\n            target -= x\n            if target <= 0.0:\n                break\n            heapq.heappush(max_heap, -x)\n            result += 1\n        return result\n"
    },
    {
        "problem_name": "minimum-operations-to-make-a-special-number",
        "solution": "# Time:  O(n)\n# Space; O(1)\n\n# math, greedy\nclass Solution(object):\n    def minimumOperations(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: int\n        \"\"\"\n        lookup = [0]*10\n        for i in reversed(xrange(len(num))):\n            if ((num[i] in \"05\" and lookup[0]) or\n                (num[i] in \"27\" and lookup[5])):\n                return (len(num)-i)-2\n            lookup[ord(num[i])-ord('0')] = 1\n        return len(num)-lookup[0]\n"
    },
    {
        "problem_name": "minimum-operations-to-make-a-subsequence",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport bisect\n\n\nclass Solution(object):\n    def minOperations(self, target, arr):\n        \"\"\"\n        :type target: List[int]\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = {x:i for i, x in enumerate(target)}\n        lis = []\n        for x in arr:\n            if x not in lookup:\n                continue\n            i = bisect.bisect_left(lis, lookup[x])\n            if i == len(lis):\n                lis.append(lookup[x])\n            else:\n                lis[i] = lookup[x]\n        return len(target)-len(lis)\n    \n    \n# Range Maximum Query\nclass SegmentTree(object):  # 0-based index\n    def __init__(self, N,\n                 build_fn=lambda x, y: [y]*(2*x),\n                 query_fn=lambda x, y: y if x is None else max(x, y),  # (lambda x, y: y if x is None else min(x, y))\n                 update_fn=lambda x, y: y,\n                 default_val=0):\n        self.N = N\n        self.H = (N-1).bit_length()\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        self.default_val = default_val\n        self.tree = build_fn(N, default_val)\n        self.lazy = [None]*N\n\n    def __apply(self, x, val):\n        self.tree[x] = self.update_fn(self.tree[x], val)\n        if x < self.N:\n            self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n    def update(self, L, R, h):  # Time: O(logN), Space: O(N)\n        def pull(x):\n            while x > 1:\n                x //= 2\n                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n                if self.lazy[x] is not None:\n                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\n\n        L += self.N\n        R += self.N\n        L0, R0 = L, R\n        while L <= R:\n            if L & 1:  # is right child\n                self.__apply(L, h) \n                L += 1\n            if R & 1 == 0:  # is left child\n                self.__apply(R, h)\n                R -= 1\n            L //= 2\n            R //= 2\n        pull(L0)\n        pull(R0)\n\n    def query(self, L, R):  # Time: O(logN), Space: O(N)\n        def push(x):\n            n = 2**self.H\n            while n != 1:\n                y = x // n\n                if self.lazy[y] is not None:\n                    self.__apply(y*2, self.lazy[y])\n                    self.__apply(y*2 + 1, self.lazy[y])\n                    self.lazy[y] = None\n                n //= 2\n\n        result = None\n        if L > R:\n            return result\n\n        L += self.N\n        R += self.N\n        push(L)\n        push(R)\n        while L <= R:\n            if L & 1:  # is right child\n                result = self.query_fn(result, self.tree[L])\n                L += 1\n            if R & 1 == 0:  # is left child\n                result = self.query_fn(result, self.tree[R])\n                R -= 1\n            L //= 2\n            R //= 2\n        return result\n    \n    def __str__(self):\n        showList = []\n        for i in xrange(self.N):\n            showList.append(self.query(i, i))\n        return \",\".join(map(str, showList))\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# segment tree solution\nclass Solution2(object):\n    def minOperations(self, target, arr):\n        \"\"\"\n        :type target: List[int]\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = {x:i for i, x in enumerate(target)}\n        st = SegmentTree(len(lookup))\n        for x in arr:\n            if x not in lookup:\n                continue\n            st.update(lookup[x], lookup[x], st.query(0, lookup[x]-1)+1 if lookup[x] >= 1 else 1)\n        return len(target)-(st.query(0, len(lookup)-1) if len(lookup) >= 1 else 0)\n"
    },
    {
        "problem_name": "minimum-operations-to-make-a-uni-value-grid",
        "solution": "# Time:  O(m * n) on average\n# Space: O(m * n)\n\nimport random\n\nclass Solution(object):\n    def minOperations(self, grid, x):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        nums = [v for row in grid for v in row]\n        if len(set(v%x for v in nums)) > 1:\n            return -1\n        nth_element(nums, len(nums)//2)\n        median = nums[len(nums)//2]\n        return sum(abs(v-median)//x for v in nums)\n"
    },
    {
        "problem_name": "minimum-operations-to-make-all-array-elements-equal",
        "solution": "# Time:  O(nlogn + qlogn)\n# Space: O(n)\n\n# sort, binary search, prefix sum\nclass Solution(object):\n    def minOperations(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums.sort()\n        prefix = [0]*(len(nums)+1)\n        for i in xrange(len(nums)):\n            prefix[i+1] = prefix[i]+nums[i]\n        result = [0]*len(queries)\n        for i, q in enumerate(queries):\n            j = bisect.bisect_left(nums, q)\n            result[i] = (q*j-prefix[j])+((prefix[-1]-prefix[j])-q*(len(nums)-j))\n        return result\n"
    },
    {
        "problem_name": "minimum-operations-to-make-array-equal-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\n# greedy\nclass Solution(object):\n    def minOperations(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        cnt1 = cnt2 = 0\n        for x, y in itertools.izip(nums1, nums2):\n            if y == x:\n                continue\n            if k == 0 or (y-x)%k:\n                return -1\n            if x < y:\n                cnt1 += (y-x)//k\n            else:\n                cnt2 += (x-y)//k\n        return cnt1 if cnt1 == cnt2 else -1\n"
    },
    {
        "problem_name": "minimum-operations-to-make-array-equal",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def minOperations(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # total = sum(2i+1 for i in xrange(n)) = n^2\n        # left_half_total = sum(2i+1 for i in xrange(n//2)) = (n//2)^2\n        # result = (n//2) * (total//n) - left_half_total = (n//2)*(n-n//2) = (n//2)*((n+1)//2)\n        return (n//2)*((n+1)//2)\n"
    },
    {
        "problem_name": "minimum-operations-to-make-median-of-array-equal-to-k",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport random\n\n\n# quick select, greedy\nclass Solution(object):\n    def minOperationsToMakeMedianK(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n            \n            right = len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n    \n        nth_element(nums, len(nums)//2)\n        return (sum(max(nums[i]-k, 0) for i in xrange(len(nums)//2+1))+\n                sum(max(k-nums[i], 0) for i in xrange(len(nums)//2, len(nums))))\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# sort, greedy\nclass Solution2(object):\n    def minOperationsToMakeMedianK(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return (sum(max(nums[i]-k, 0) for i in xrange(len(nums)//2+1))+\n                sum(max(k-nums[i], 0) for i in xrange(len(nums)//2, len(nums))))\n"
    },
    {
        "problem_name": "minimum-operations-to-make-numbers-non-positive",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\n# binary search, greedy\nclass Solution(object):\n    def minOperations(self, nums, x, y):\n        \"\"\"\n        :type nums: List[int]\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n\n        def check(total):\n            return sum(ceil_divide(max(v-min(ceil_divide(v, y), total)*y, 0), x-y) for v in nums) <= total\n    \n        left, right = 1, ceil_divide(max(nums), y)\n        while left <= right:\n            mid = left+(right-left)//2\n            if check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "minimum-operations-to-make-the-array-alternating",
        "solution": "# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def minimumOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        even_top = collections.Counter(nums[i] for i in xrange(0, len(nums), 2)).most_common(2)  # Time: O(nlogk)\n        odd_top = collections.Counter(nums[i] for i in xrange(1, len(nums), 2)).most_common(2)  # Time: O(nlogk)\n        if not odd_top or even_top[0][0] != odd_top[0][0]:\n            return len(nums)-even_top[0][1]-(odd_top[0][1] if odd_top else 0)\n        return min(len(nums)-even_top[0][1]-(odd_top[1][1] if len(odd_top) == 2 else 0),\n                   len(nums)-odd_top[0][1]-(even_top[1][1] if len(even_top) == 2 else 0))\n"
    },
    {
        "problem_name": "minimum-operations-to-make-the-array-increasing",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = prev = 0\n        for curr in nums:\n            if prev < curr:\n                prev = curr\n                continue\n            prev += 1\n            result += prev-curr                \n        return result\n"
    },
    {
        "problem_name": "minimum-operations-to-make-the-array-k-increasing",
        "solution": "# Time:  O(k * (n/k)log(n/k)) = O(nlog(n/k))\n# Space: O(n/k)\n\nimport bisect\n\n\nclass Solution(object):\n    def kIncreasing(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def longest_non_decreasing_subsequence(arr):\n            result = []\n            for x in arr:\n                right = bisect.bisect_right(result, x)\n                if right == len(result):\n                    result.append(x)\n                else:\n                    result[right] = x\n            return len(result)\n\n        return len(arr) - sum(longest_non_decreasing_subsequence((arr[j] for j in xrange(i, len(arr), k))) for i in xrange(k))\n"
    },
    {
        "problem_name": "minimum-operations-to-make-the-integer-zero",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math, linear search, bit manipulations\nclass Solution(object):\n    def makeTheIntegerZero(self, num1, num2):\n        \"\"\"\n        :type num1: int\n        :type num2: int\n        :rtype: int\n        \"\"\"\n        def popcount(x):\n            result = 0\n            while x:\n                x &= (x-1)\n                result += 1\n            return result\n\n        for i in xrange(1, 60+1):\n            if num1-i*num2 < 0:\n                break\n            if popcount(num1-i*num2) <= i <= num1-i*num2:\n                return i\n        return -1\n"
    },
    {
        "problem_name": "minimum-operations-to-maximize-last-elements-in-arrays",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\n# simulation\nclass Solution(object):\n    def minOperations(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = [0]*2\n        for x, y in itertools.izip(nums1, nums2):\n            if not (min(x, y) <= min(nums1[-1], nums2[-1]) and max(x, y) <= max(nums1[-1], nums2[-1])):\n                return -1\n            if not (x <= nums1[-1] and y <= nums2[-1]):\n                cnt[0] += 1\n            if not (x <= nums2[-1] and y <= nums1[-1]):\n                cnt[1] += 1\n        return min(cnt)\n\n\n# Time:  O(n)\n# Space: O(1)\nimport itertools\n\n\n# simulation\nclass Solution2(object):\n    def minOperations(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        def count(mx1, mx2):\n            return sum(1 if y <= mx1 and x <= mx2 else INF for x, y in itertools.izip(nums1, nums2) if not (x <= mx1 and y <= mx2))\n\n        result = min(count(nums1[-1], nums2[-1]), count(nums2[-1], nums1[-1]))\n        return result if result != INF else -1\n"
    },
    {
        "problem_name": "minimum-operations-to-reduce-an-integer-to-0",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# greedy, trick\n# reference: https://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3203994/java-c-python-1-line-solution/\nclass Solution(object):\n    def minOperations(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def popcount(x):\n            return bin(x)[2:].count('1')\n\n        return popcount(n^(n*0b11))\n\n\n# Time:  O(logn)\n# Space: O(1)\n# greedy\nclass Solution2(object):\n    def minOperations(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while n:\n            if n&1:\n                n >>= 1\n                n += n&1\n                result += 1\n            n >>= 1\n        return result\n"
    },
    {
        "problem_name": "minimum-operations-to-reduce-x-to-zero",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minOperations(self, nums, x):\n        \"\"\"\n        :type nums: List[int]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        target = sum(nums)-x\n        result = -1\n        curr = left = 0\n        for right in xrange(len(nums)):\n            curr += nums[right]\n            while left < len(nums) and curr > target:\n                curr -= nums[left]\n                left += 1\n            if curr == target:\n                result = max(result, right-left+1)\n        return len(nums)-result if result != -1 else -1\n"
    },
    {
        "problem_name": "minimum-operations-to-remove-adjacent-ones-in-matrix",
        "solution": "# Time:  O(E * sqrt(V)) = O(m * n * sqrt(m * n))\n# Space: O(V) = O(m * n)\n\nfrom functools import partial\n\n# Time:  O(E * sqrt(V))\n# Space: O(V)\n# Source code from http://code.activestate.com/recipes/123641-hopcroft-karp-bipartite-matching/\n# Hopcroft-Karp bipartite max-cardinality matching and max independent set\n# David Eppstein, UC Irvine, 27 Apr 2002\ndef bipartiteMatch(graph):\n    '''Find maximum cardinality matching of a bipartite graph (U,V,E).\n    The input format is a dictionary mapping members of U to a list\n    of their neighbors in V.  The output is a triple (M,A,B) where M is a\n    dictionary mapping members of V to their matches in U, A is the part\n    of the maximum independent set in U, and B is the part of the MIS in V.\n    The same object may occur in both U and V, and is treated as two\n    distinct vertices if this happens.'''\n    \n    # initialize greedy matching (redundant, but faster than full search)\n    matching = {}\n    for u in graph:\n        for v in graph[u]:\n            if v not in matching:\n                matching[v] = u\n                break\n    \n    while 1:\n        # structure residual graph into layers\n        # pred[u] gives the neighbor in the previous layer for u in U\n        # preds[v] gives a list of neighbors in the previous layer for v in V\n        # unmatched gives a list of unmatched vertices in final layer of V,\n        # and is also used as a flag value for pred[u] when u is in the first layer\n        preds = {}\n        unmatched = []\n        pred = dict([(u,unmatched) for u in graph])\n        for v in matching:\n            del pred[matching[v]]\n        layer = list(pred)\n        \n        # repeatedly extend layering structure by another pair of layers\n        while layer and not unmatched:\n            newLayer = {}\n            for u in layer:\n                for v in graph[u]:\n                    if v not in preds:\n                        newLayer.setdefault(v,[]).append(u)\n            layer = []\n            for v in newLayer:\n                preds[v] = newLayer[v]\n                if v in matching:\n                    layer.append(matching[v])\n                    pred[matching[v]] = v\n                else:\n                    unmatched.append(v)\n        \n        # did we finish layering without finding any alternating paths?\n        if not unmatched:\n            unlayered = {}\n            for u in graph:\n                for v in graph[u]:\n                    if v not in preds:\n                        unlayered[v] = None\n            return (matching,list(pred),list(unlayered))\n\n        # recursively search backward through layers to find alternating paths\n        # recursion returns true if found path, false otherwise\n        def recurse(v):\n            if v in preds:\n                L = preds[v]\n                del preds[v]\n                for u in L:\n                    if u in pred:\n                        pu = pred[u]\n                        del pred[u]\n                        if pu is unmatched or recurse(pu):\n                            matching[v] = u\n                            return 1\n            return 0\n        \n        def recurse_iter(v):\n            def divide(v):\n                if v not in preds:\n                    return\n                L = preds[v]\n                del preds[v]\n                for u in L :\n                    if u in pred and pred[u] is unmatched:  # early return\n                        del pred[u]\n                        matching[v] = u\n                        ret[0] = True\n                        return\n                stk.append(partial(conquer, v, iter(L)))\n\n            def conquer(v, it):\n                for u in it:\n                    if u not in pred:\n                        continue\n                    pu = pred[u]\n                    del pred[u]\n                    stk.append(partial(postprocess, v, u, it))\n                    stk.append(partial(divide, pu))\n                    return\n\n            def postprocess(v, u, it):\n                if not ret[0]:\n                    stk.append(partial(conquer, v, it))\n                    return\n                matching[v] = u\n\n            ret, stk = [False], []\n            stk.append(partial(divide, v))\n            while stk:\n                stk.pop()()\n            return ret[0]\n\n        for v in unmatched: recurse_iter(v)\n\n\nimport collections\n\n\nclass Solution(object):\n    def minimumOperations(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def iter_dfs(grid, i, j, lookup, adj):\n            if lookup[i][j]:\n                return\n            lookup[i][j] = True\n            stk = [(i, j, (i+j)%2)]\n            while stk:\n                i, j, color = stk.pop()\n                for di, dj in directions:\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj]):\n                        continue\n                    if not color:\n                        adj[len(grid[0])*ni+nj].append(len(grid[0])*i+j)\n                    if lookup[ni][nj]:\n                        continue\n                    lookup[ni][nj] = True\n                    stk.append((ni, nj, color^1))\n\n        adj = collections.defaultdict(list)\n        lookup = [[False]*len(grid[0]) for _ in xrange(len(grid))]\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if not grid[i][j]:\n                    continue\n                iter_dfs(grid, i, j, lookup, adj)\n        return len(bipartiteMatch(adj)[0])\n"
    },
    {
        "problem_name": "minimum-operations-to-write-the-letter-y-on-a-grid",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def minimumOperationsToWriteY(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        cnt = [[0]*3 for _ in xrange(2)]\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                cnt[(i <= (len(grid[0])-1)//2 and (i-j == 0 or i+j == len(grid[0])-1)) or (i > (len(grid[0])-1)//2 == j)][grid[i][j]] += 1\n        return len(grid)*len(grid[0])-max(cnt[0][i]+cnt[1][j] for i in xrange(3) for j in xrange(3) if i != j)\n"
    },
    {
        "problem_name": "minimum-path-cost-in-a-grid",
        "solution": "# Time:  O(m * n^2)\n# Space: O(n)\n\n# dp\nclass Solution(object):\n    def minPathCost(self, grid, moveCost):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type moveCost: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = [[0]*len(grid[0]) for _ in xrange(2)]\n        dp[0] = [grid[0][j] for j in xrange(len(grid[0]))]\n        for i in xrange(len(grid)-1):\n            for j in xrange(len(grid[0])):\n                dp[(i+1)%2][j] = min(dp[i%2][k]+moveCost[x][j] for k, x in enumerate(grid[i]))+grid[i+1][j]\n        return min(dp[(len(grid)-1)%2])\n"
    },
    {
        "problem_name": "minimum-path-cost-in-a-hidden-grid",
        "solution": "# Time:  O(m * n * log(m * n))\n# Space: O(m * n)\n\nclass GridMaster(object):\n    def canMove(self, direction):\n        pass\n\n    def move(self, direction):\n        pass\n\n    def isTarget(self):\n        pass\n\n\nimport collections\nimport heapq\n\n\nclass Solution(object):\n    def findShortestPath(self, master):\n        \"\"\"\n        :type master: GridMaster\n        :rtype: int\n        \"\"\"\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}\n\n        def dfs(pos, target, master, lookup, adj):\n            if target[0] is None and master.isTarget():\n                target[0] = pos\n            lookup.add(pos)\n            for d, (di, dj) in directions.iteritems():\n                if not master.canMove(d):\n                    continue\n                nei = (pos[0]+di, pos[1]+dj)\n                if nei in adj[pos]:\n                    continue\n                adj[pos][nei] = master.move(d)\n                if nei not in lookup:\n                    dfs(nei, target, master, lookup, adj)\n                adj[nei][pos] = master.move(rollback[d])\n                        \n        def dijkstra(adj, start, target):\n            dist = {start:0}\n            min_heap = [(0, start)]\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if dist[u] < curr:\n                    continue\n                for v, w in adj[u].iteritems():\n                    if v in dist and dist[v] <= curr+w:\n                        continue\n                    dist[v] = curr+w\n                    heapq.heappush(min_heap, (curr+w, v))\n            return dist[target] if target in dist else -1 \n        \n        start = (0, 0)\n        target = [None]\n        adj = collections.defaultdict(dict)\n        dfs(start, target, master, set(), adj)\n        if not target[0]:\n            return -1\n        return dijkstra(adj, start, target[0])\n"
    },
    {
        "problem_name": "minimum-path-sum",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nclass Solution(object):\n    # @param grid, a list of lists of integers\n    # @return an integer\n    def minPathSum(self, grid):\n        sum = list(grid[0])\n        for j in xrange(1, len(grid[0])):\n            sum[j] = sum[j - 1] + grid[0][j]\n\n        for i in xrange(1, len(grid)):\n            sum[0] += grid[i][0]\n            for j in xrange(1, len(grid[0])):\n                sum[j] = min(sum[j - 1], sum[j]) + grid[i][j]\n\n        return sum[-1]\n\n"
    },
    {
        "problem_name": "minimum-penalty-for-a-shop",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def bestClosingTime(self, customers):\n        \"\"\"\n        :type customers: str\n        :rtype: int\n        \"\"\"\n        result = mx = curr = 0\n        for i, x in enumerate(customers):\n            curr += 1 if x == 'Y' else -1\n            if curr > mx:\n                mx = curr\n                result = i+1\n        return result\n"
    },
    {
        "problem_name": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass BIT(object):  # Fenwick Tree, 1-indexed\n    def __init__(self, n):\n        self.__bit = [0] * n\n\n    def add(self, i, val):\n        while i < len(self.__bit):\n            self.__bit[i] += val\n            i += (i & -i)\n\n    def sum(self, i):\n        result = 0\n        while i > 0:\n            result += self.__bit[i]\n            i -= (i & -i)\n        return result\n\n\nclass Solution(object):\n    def minInteger(self, num, k):\n        \"\"\"\n        :type num: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        lookup = collections.defaultdict(list)\n        bit = BIT(len(num)+1)\n        for i in reversed(xrange(len(num))):\n            bit.add(i+1, 1)\n            lookup[int(num[i])].append(i+1)\n        result = []\n        for _ in xrange(len(num)):\n            for d in xrange(10):\n                if lookup[d] and bit.sum(lookup[d][-1]-1) <= k:\n                    k -= bit.sum(lookup[d][-1]-1)\n                    bit.add(lookup[d].pop(), -1)\n                    result.append(d)\n                    break\n        return \"\".join(map(str, result))\n"
    },
    {
        "problem_name": "minimum-processing-time",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, greedy\nclass Solution(object):\n    def minProcessingTime(self, processorTime, tasks):\n        \"\"\"\n        :type processorTime: List[int]\n        :type tasks: List[int]\n        :rtype: int\n        \"\"\"\n        K = 4\n        processorTime.sort()\n        tasks.sort(reverse=True)\n        result = 0\n        for i in xrange(len(processorTime)):\n            for j in xrange(K):\n                result = max(result, processorTime[i]+tasks[i*K+j])\n        return result\n"
    },
    {
        "problem_name": "minimum-recolors-to-get-k-consecutive-black-blocks",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# sliding window\nclass Solution(object):\n    def minimumRecolors(self, blocks, k):\n        \"\"\"\n        :type blocks: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = k\n        curr = 0\n        for i, x in enumerate(blocks):\n            curr += int(blocks[i] == 'W')\n            if i+1-k < 0:\n                continue\n            result = min(result, curr)\n            curr -= int(blocks[i+1-k] == 'W')\n        return result\n"
    },
    {
        "problem_name": "minimum-rectangles-to-cover-points",
        "solution": "# Time:  O(nlogn)\n# Spade: O(n)\n\n# sort, greedy\nclass Solution(object):\n    def minRectanglesToCoverPoints(self, points, w):\n        \"\"\"\n        :type points: List[List[int]]\n        :type w: int\n        :rtype: int\n        \"\"\"\n        points.sort(key=lambda x: x[0])\n        result = 0\n        left = -(w+1)\n        for right, _ in points:\n            if right-left <= w:\n                continue\n            left = right\n            result += 1\n        return result\n"
    },
    {
        "problem_name": "minimum-relative-loss-after-buying-chocolates",
        "solution": "# Time:  O((n + q) * logn)\n# Space: O(n)\n\n# sort, binary search, greedy, prefix sum\nclass Solution(object):\n    def minimumRelativeLosses(self, prices, queries):\n        \"\"\"\n        :type prices: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def binary_search(left, right, check):\n            while left <= right:\n                mid = left + (right-left)//2\n                if check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return left\n\n        prices.sort()\n        prefix = [0]*(len(prices)+1)\n        for i in xrange(len(prices)):\n            prefix[i+1] = prefix[i]+prices[i]\n        result = []\n        for k, m in queries:\n            cnt = binary_search(0, m-1, lambda x: k-(prices[-(m-x)]-k) <= prices[(x+1)-1]-0)\n            a = prefix[-1]-prefix[-1-(m-cnt)]-(m-cnt)*k\n            b = prefix[cnt]+(m-cnt)*k\n            result.append(b-a)\n        return result\n"
    },
    {
        "problem_name": "minimum-remove-to-make-valid-parentheses",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def minRemoveToMakeValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        result = list(s)\n        count = 0\n        for i, v in enumerate(result):\n            if v == '(':\n                count += 1\n            elif v == ')':\n                if count:\n                    count -= 1\n                else:\n                    result[i] = \"\"\n        if count:\n            for i in reversed(xrange(len(result))):\n                if result[i] == '(':\n                    result[i] = \"\"\n                    count -= 1\n                    if not count:\n                        break\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "minimum-replacements-to-sort-the-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy, math\nclass Solution(object):\n    def minimumReplacement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n\n        result = 0\n        curr = nums[-1]\n        for x in reversed(nums):\n            cnt = ceil_divide(x, curr)\n            result += cnt-1\n            curr = x//cnt\n        return result\n"
    },
    {
        "problem_name": "minimum-reverse-operations",
        "solution": "# Time:  O(n * alpha(n)) = O(n)\n# Space: O(n)\n\nclass UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n        self.right = range(n)  # added\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x, y = self.find_set(x), self.find_set(y)\n        if x == y:\n            return False\n        if self.rank[x] > self.rank[y]:  # union by rank\n            x, y = y, x\n        self.set[x] = self.set[y]\n        if self.rank[x] == self.rank[y]:\n            self.rank[y] += 1\n        self.right[y] = max(self.right[x], self.right[y])  # added\n        return True\n\n    def right_set(self, x):  # added\n        return self.right[self.find_set(x)]\n\n\n# bfs, union find\nclass Solution(object):\n    def minReverseOperations(self, n, p, banned, k):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :type banned: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        lookup = [False]*n\n        for i in banned:\n            lookup[i] = True\n        d = 0\n        result = [-1]*n\n        result[p] = d\n        uf = UnionFind(n+2)\n        uf.union_set(p, p+2)\n        q = [p]\n        d += 1\n        while q:\n            new_q = []\n            for p in q:\n                left, right = 2*max(p-(k-1), 0)+(k-1)-p, 2*min(p+(k-1), n-1)-(k-1)-p\n                p = uf.right_set(left)\n                while p <= right:\n                    if not lookup[p]:\n                        result[p] = d\n                        new_q.append(p)\n                    uf.union_set(p, p+2)\n                    p = uf.right_set(p)\n            q = new_q\n            d += 1\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nfrom sortedcontainers import SortedList\n\n\n# bfs, sorted list\nclass Solution2(object):\n    def minReverseOperations(self, n, p, banned, k):\n        \"\"\"\n        :type n: int\n        :type p: int\n        :type banned: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        lookup = [False]*n\n        for i in banned:\n            lookup[i] = True\n        d = 0\n        result = [-1]*n\n        result[p] = d\n        sl = [SortedList(i for i in xrange(0, n, 2)), SortedList(i for i in xrange(1, n, 2))]\n        sl[p%2].remove(p)\n        q = [p]\n        d += 1\n        while q:\n            new_q = []\n            for p in q:\n                left, right = 2*max(p-(k-1), 0)+(k-1)-p, 2*min(p+(k-1), n-1)-(k-1)-p\n                for p in list(sl[left%2].irange(left, right)):\n                    if not lookup[p]:\n                        result[p] = d\n                        new_q.append(p)\n                    sl[left%2].remove(p)\n            q = new_q\n            d += 1\n        return result\n"
    },
    {
        "problem_name": "minimum-right-shifts-to-sort-the-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def minimumRightShifts(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        i = next((i for i in xrange(len(nums)) if not nums[i] < nums[(i+1)%len(nums)]), len(nums))\n        j = next((j for j in xrange(i+1, len(nums)) if not nums[j%len(nums)] < nums[(j+1)%len(nums)]), len(nums))\n        return len(nums)-(i+1) if j == len(nums) else -1\n"
    },
    {
        "problem_name": "minimum-rounds-to-complete-all-tasks",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# math, freq table\nclass Solution(object):\n    def minimumRounds(self, tasks):\n        \"\"\"\n        :type tasks: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(tasks)\n        return sum((x+2)//3 for x in cnt.itervalues()) if 1 not in cnt.itervalues() else -1\n"
    },
    {
        "problem_name": "minimum-score-after-removals-on-a-tree",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\n# dfs with stack\nclass Solution(object):\n    def minimumScore(self, nums, edges):\n        \"\"\"\n        :type nums: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def is_ancestor(a, b):\n            return left[a] <= left[b] and right[b] <= right[a]\n\n        def iter_dfs():\n            cnt = 0\n            left = [0]*len(nums)\n            right = [0]*len(nums)\n            stk = [(1, (0, -1))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    u, p = args\n                    left[u] = cnt\n                    cnt += 1\n                    stk.append((2, (u, p)))\n                    for v in adj[u]:\n                        if v == p:\n                            continue\n                        stk.append((1, (v, u)))\n                elif step == 2:\n                    u, p = args\n                    for v in adj[u]:\n                        if v == p:\n                            continue\n                        nums[u] ^= nums[v]\n                    right[u] = cnt\n            return left, right\n                \n        adj = [[] for _ in xrange(len(nums))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        left, right = iter_dfs()\n        result = float(\"inf\")\n        for i in xrange(1, len(nums)):\n            for j in xrange(i+1, len(nums)):\n                if is_ancestor(i, j):\n                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]\n                elif is_ancestor(j, i):\n                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]\n                else:\n                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]\n                result = min(result, max(a, b, c)-min(a, b, c))\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# dfs with recursion\nclass Solution2(object):\n    def minimumScore(self, nums, edges):\n        \"\"\"\n        :type nums: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def is_ancestor(a, b):\n            return left[a] <= left[b] and right[b] <= right[a]\n\n        def dfs(u, p):\n            left[u] = cnt[0]\n            cnt[0] += 1\n            for v in adj[u]:\n                if v == p:\n                    continue\n                dfs(v, u)\n                nums[u] ^= nums[v]\n            right[u] = cnt[0]\n                \n        adj = [[] for _ in xrange(len(nums))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        cnt = [0]\n        left = [0]*len(nums)\n        right = [0]*len(nums)\n        dfs(0, -1)\n        result = float(\"inf\")\n        for i in xrange(1, len(nums)):\n            for j in xrange(i+1, len(nums)):\n                if is_ancestor(i, j):\n                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]\n                elif is_ancestor(j, i):\n                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]\n                else:\n                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]\n                result = min(result, max(a, b, c)-min(a, b, c))\n        return result\n            \n\n# Time:  O(n^2)\n# Space: O(n)\n# dfs with recursion\nclass Solution3(object):\n    def minimumScore(self, nums, edges):\n        \"\"\"\n        :type nums: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def dfs(u, p, result):\n            total = nums[u]\n            for v in adj[u]:\n                if v == p:\n                    continue\n                total ^= dfs(v, u, result)\n            result.append(total)\n            return total\n                \n        adj = [[] for _ in xrange(len(nums))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        total = reduce(lambda x, y: x^y, nums)\n        result = float(\"inf\")\n        for u, v in edges: \n            left = []\n            dfs(u, v, left)\n            right = []\n            dfs(v, u, right)\n            for candidates in (left, right):\n                total2 = candidates.pop()\n                for x in candidates:\n                    a, b, c = total^total2, x, total2^x\n                    result = min(result, max(a, b, c)-min(a, b, c))\n        return result\n            \n\n# Time:  O(n^2)\n# Space: O(n)\n# dfs with stk (slower, sometimes TLE)\nclass Solution4(object):\n    def minimumScore(self, nums, edges):\n        \"\"\"\n        :type nums: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def iter_dfs(nums, adj, u, p):\n            result = []\n            stk = [(1, (u, p, [0]))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    u, p, ret = args\n                    new_rets = []\n                    stk.append((2, (u, new_rets, ret)))\n                    for v in adj[u]:\n                        if v == p:\n                            continue\n                        new_rets.append([0])\n                        stk.append((1, (v, u, new_rets[-1])))\n                elif step == 2:\n                    u, new_rets, ret = args\n                    ret[0] = nums[u]\n                    for x in new_rets:\n                        ret[0] ^= x[0]\n                    result.append(ret[0])\n            return result\n                \n        adj = [[] for _ in xrange(len(nums))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        total = reduce(lambda x, y: x^y, nums)\n        result = float(\"inf\")\n        for u, v in edges: \n            for candidates in (iter_dfs(nums, adj, u, v), iter_dfs(nums, adj, v, u)):\n                total2 = candidates.pop()\n                for x in candidates:\n                    a, b, c = total^total2, x, total2^x\n                    result = min(result, max(a, b, c)-min(a, b, c))\n        return result\n"
    },
    {
        "problem_name": "minimum-score-by-changing-two-elements",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, greedy\nclass Solution(object):\n    def minimizeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return min(nums[-3+i]-nums[i] for i in xrange(3))\n"
    },
    {
        "problem_name": "minimum-score-of-a-path-between-two-cities",
        "solution": "# Time:  O(n + m), m = len(roads)\n# Space: O(n + m)\n\n# bfs\nclass Solution(object):\n    def minScore(self, n, roads):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def bfs():\n            lookup = [False]*len(adj)\n            q = [0]\n            lookup[0] = True\n            while q:\n                new_q = []\n                for u in q:\n                    for v, _ in adj[u]:\n                        if lookup[v]:\n                            continue\n                        lookup[v] = True\n                        new_q.append(v)\n                q = new_q\n            return lookup\n\n        adj = [[] for _ in xrange(n)]\n        for u, v, w in roads:\n            adj[u-1].append((v-1, w))\n            adj[v-1].append((u-1, w))\n        lookup = bfs()\n        return min(w for u, _, w in roads if lookup[u-1])\n"
    },
    {
        "problem_name": "minimum-score-triangulation-of-polygon",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\nclass Solution(object):\n    def minScoreTriangulation(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [[0 for _ in xrange(len(A))] for _ in xrange(len(A))]\n        for p in xrange(3, len(A)+1):\n            for i in xrange(len(A)-p+1):\n                j = i+p-1;\n                dp[i][j] = float(\"inf\")\n                for k in xrange(i+1, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j] + A[i]*A[j]*A[k])\n        return dp[0][-1]\n"
    },
    {
        "problem_name": "minimum-seconds-to-equalize-a-circular-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# hash table\nclass Solution(object):\n    def minimumSeconds(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = collections.defaultdict(int)\n        dist = collections.defaultdict(int)\n        for i in xrange(2*len(nums)):\n            x = nums[i%len(nums)]\n            dist[x] = max(dist[x], i-lookup[x])\n            lookup[x] = i\n        return min(dist.itervalues())//2\n"
    },
    {
        "problem_name": "minimum-sideway-jumps",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy solution\nclass Solution(object):\n    def minSideJumps(self, obstacles):\n        \"\"\"\n        :type obstacles: List[int]\n        :rtype: int\n        \"\"\"\n        result, lanes = 0, set([2])\n        for i in xrange(len(obstacles)-1):\n            lanes.discard(obstacles[i+1])\n            if lanes:\n                continue\n            result += 1\n            lanes = set(j for j in xrange(1, 4) if j not in [obstacles[i], obstacles[i+1]])\n        return result\n\n        \n# Time:  O(n)\n# Space: O(1)\n# dp solution\nclass Solution2(object):\n    def minSideJumps(self, obstacles):\n        \"\"\"\n        :type obstacles: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [1, 0, 1]        \n        for i in obstacles:\n            if i:\n                dp[i-1] = float(\"inf\")\n            for j in xrange(3):\n                if j+1 != i:\n                    dp[j] = min(dp[0]+(j != 0), dp[1]+(j != 1), dp[2]+(j != 2))\n        return min(dp)\n"
    },
    {
        "problem_name": "minimum-size-subarray-in-infinite-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers, sliding window\nclass Solution(object):\n    def minSizeSubarray(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        q, target = divmod(target, sum(nums))\n        if not target:\n            return q*len(nums)\n        result = INF\n        curr = left = 0\n        for right in xrange((len(nums)-1)+(len(nums)-1)):\n            curr += nums[right%len(nums)]\n            while curr > target:\n                curr -= nums[left%len(nums)]\n                left += 1\n            if curr == target:\n                result = min(result, right-left+1)\n        return result+q*len(nums) if result != INF else -1\n\n\n# Time:  O(n)\n# Space: O(n)\n# prefix sum, hash table\nclass Solution2(object):\n    def minSizeSubarray(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        q, target = divmod(target, sum(nums))\n        if not target:\n            return q*len(nums)\n        result = INF\n        lookup = {0:-1}\n        prefix = 0\n        for right in xrange((len(nums)-1)+(len(nums)-1)):\n            prefix += nums[right%len(nums)]\n            if prefix-target in lookup:\n                result = min(result, right-lookup[prefix-target])\n            lookup[prefix] = right\n        return result+q*len(nums) if result != INF else -1\n"
    },
    {
        "problem_name": "minimum-size-subarray-sum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {integer} s\n    # @param {integer[]} nums\n    # @return {integer}\n    def minSubArrayLen(self, s, nums):\n        start = 0\n        sum = 0\n        min_size = float(\"inf\")\n        for i in xrange(len(nums)):\n            sum += nums[i]\n            while sum >= s:\n                min_size = min(min_size, i - start + 1)\n                sum -= nums[start]\n                start += 1\n\n        return min_size if min_size != float(\"inf\") else 0\n\n# Time:  O(nlogn)\n# Space: O(n)\n# Binary search solution.\nclass Solution2(object):\n    # @param {integer} s\n    # @param {integer[]} nums\n    # @return {integer}\n    def minSubArrayLen(self, s, nums):\n        min_size = float(\"inf\")\n        sum_from_start = [n for n in nums]\n        for i in xrange(len(sum_from_start) - 1):\n            sum_from_start[i + 1] += sum_from_start[i]\n        for i in xrange(len(sum_from_start)):\n            end = self.binarySearch(lambda x, y: x <= y, sum_from_start, \\\n                                    i, len(sum_from_start), \\\n                                    sum_from_start[i] - nums[i] + s)\n            if end < len(sum_from_start):\n                min_size = min(min_size, end - i + 1)\n\n        return min_size if min_size != float(\"inf\") else 0\n\n    def binarySearch(self, compare, A, start, end, target):\n        while start < end:\n            mid = start + (end - start) / 2\n            if compare(target, A[mid]):\n                end = mid\n            else:\n                start = mid + 1\n        return start\n\n"
    },
    {
        "problem_name": "minimum-skips-to-arrive-at-meeting-on-time",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def minSkips(self, dist, speed, hoursBefore):\n        \"\"\"\n        :type dist: List[int]\n        :type speed: int\n        :type hoursBefore: int\n        :rtype: int\n        \"\"\"\n        def ceil(a, b):\n            return (a+b-1)//b\n\n        dp = [0]*((len(dist)-1)+1)  # dp[i]: (min time by i skips) * speed\n        for i, d in enumerate(dist):\n            for j in reversed(xrange(len(dp))):\n                dp[j] = ceil(dp[j]+d, speed)*speed if i < len(dist)-1 else dp[j]+d\n                if j-1 >= 0:\n                    dp[j] = min(dp[j], dp[j-1]+d)\n        target = hoursBefore*speed\n        for i in xrange(len(dist)):\n            if dp[i] <= target:\n                return i\n        return -1\n"
    },
    {
        "problem_name": "minimum-space-wasted-from-packaging",
        "solution": "# Time:  O(mlogm + nlogn + mlogn)\n# Space: O(1)\n\nimport bisect\n\n\nclass Solution(object):\n    def minWastedSpace(self, packages, boxes):\n        \"\"\"\n        :type packages: List[int]\n        :type boxes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        INF = float(\"inf\")\n\n        packages.sort()\n        result = INF\n        for box in boxes:\n            box.sort()\n            if box[-1] < packages[-1]:\n                continue\n            curr = left = 0\n            for b in box:\n                right = bisect.bisect_right(packages, b, left)\n                curr += b * (right-left)\n                left = right\n            result = min(result, curr)\n        return (result-sum(packages))%MOD if result != INF else -1\n"
    },
    {
        "problem_name": "minimum-speed-to-arrive-on-time",
        "solution": "# Time:  O(nlogr), r is the range of speed\n# Space: O(1)\n\nclass Solution(object):\n    def minSpeedOnTime(self, dist, hour):\n        \"\"\"\n        :type dist: List[int]\n        :type hour: float\n        :rtype: int\n        \"\"\"\n        def ceil(a, b):\n            return (a+b-1)//b\n\n        def total_time(dist, x):\n            return sum(ceil(dist[i], x) for i in xrange(len(dist)-1)) + float(dist[-1])/x\n\n        def check(dist, hour, x):\n            return total_time(dist, x) <= hour\n\n        MAX_SPEED = 10**7\n        if not check(dist, hour, MAX_SPEED):\n            return -1\n        left, right = 1, MAX_SPEED\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(dist, hour, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "minimum-split-into-subarrays-with-gcd-greater-than-one",
        "solution": "# Time:  O(nlogr), r = max(nums)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minimumSplits(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        result, g = 1, 0\n        for x in nums:\n            g = gcd(g, x)\n            if g == 1:\n                g = x\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "minimum-string-length-after-removing-substrings",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# stack\nclass Solution(object):\n    def minLength(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        stk = []\n        for c in s:\n            if stk and ((stk[-1] == 'A' and c == 'B') or (stk[-1] == 'C' and c == 'D')):\n                stk.pop()\n                continue\n            stk.append(c)\n        return len(stk)\n"
    },
    {
        "problem_name": "minimum-subarrays-in-a-valid-split",
        "solution": "# Time:  O(n^2 * logr), r = max(nums)\n# Space: O(n)\n\n# dp\nclass Solution(object):\n    def validSubarraySplit(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        dp = [float(\"inf\")]*(len(nums)+1)  # dp[i]: min number of subarrays in nums[:i]\n        dp[0] = 0\n        for i in xrange(1, len(nums)+1):\n            for j in xrange(i):\n                 if gcd(nums[j], nums[i-1]) != 1:\n                     dp[i] = min(dp[i], dp[j]+1)\n        return dp[-1] if dp[-1] != float(\"inf\") else -1\n"
    },
    {
        "problem_name": "minimum-subsequence-in-non-increasing-order",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def minSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result, total, curr = [], sum(nums), 0\n        nums.sort(reverse=True)\n        for i, x in enumerate(nums):\n            curr += x\n            if curr > total-curr:\n                break\n        return nums[:i+1]\n"
    },
    {
        "problem_name": "minimum-substring-partition-of-equal-character-frequency",
        "solution": "# Time:  O(n * (n + 26))\n# Space: O(n + 26)\n\n# dp, freq table\nclass Solution(object):\n    def minimumSubstringsInPartition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        dp = [INF]*(len(s)+1)\n        dp[0] = 0\n        for i in xrange(len(s)):\n            cnt = [0]*26\n            d = mx = 0\n            for j in reversed(xrange(i+1)):\n                k = ord(s[j])-ord('a')\n                if cnt[k] == 0:\n                    d += 1\n                cnt[k] += 1\n                mx = max(mx, cnt[k])\n                if d*mx == i-j+1:\n                    dp[i+1] = min(dp[i+1], dp[j]+1)\n        return dp[-1]\n"
    },
    {
        "problem_name": "minimum-sum-of-four-digit-number-after-splitting-digits",
        "solution": "# Time:  O(d) = O(1), d is the number of digits\n# Space: O(d) = O(1)\n\n# greedy\nclass Solution(object):\n    def minimumSum(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        def inplace_counting_sort(nums, reverse=False):  # Time: O(n)\n            count = [0]*(max(nums)+1)\n            for num in nums:\n                count[num] += 1\n            for i in xrange(1, len(count)):\n                count[i] += count[i-1]\n            for i in reversed(xrange(len(nums))):  # inplace but unstable sort\n                while nums[i] >= 0:\n                    count[nums[i]] -= 1\n                    j = count[nums[i]]\n                    nums[i], nums[j] = nums[j], ~nums[i]\n            for i in xrange(len(nums)):\n                nums[i] = ~nums[i]  # restore values\n            if reverse:  # unstable sort\n                nums.reverse()\n    \n        nums = map(int, list(str(num)))\n        inplace_counting_sort(nums)\n        a = b = 0\n        for x in nums:\n            a = a*10+x\n            a, b = b, a\n        return a+b\n\n\n# Time:  O(dlogd) = O(1), d is the number of digits\n# Space: O(d) = O(1)\n# greedy\nclass Solution2(object):\n    def minimumSum(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        nums = sorted(map(int, list(str(num))))\n        a = b = 0\n        for x in nums:\n            a = a*10+x\n            a, b = b, a\n        return a+b\n"
    },
    {
        "problem_name": "minimum-sum-of-mountain-triplets-i",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# prefix sum\nclass Solution(object):\n    def minimumSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n\n        right = [INF]*len(nums)\n        curr = INF\n        for i in reversed(xrange(len(nums))):\n            right[i] = curr\n            curr = min(curr, nums[i])\n        result = curr = INF\n        for i in xrange(len(nums)):\n            if curr < nums[i] > right[i]:\n                result = min(result, curr+nums[i]+right[i])\n            curr = min(curr, nums[i])\n        return result if result != INF else -1\n\n\n# Time:  O(n)\n# Space: O(n)\n# prefix sum\nclass Solution2(object):\n    def minimumSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n\n        left = [INF]*len(nums)\n        curr = INF\n        for i in xrange(len(nums)):\n            left[i] = curr\n            curr = min(curr, nums[i])\n        right = [INF]*len(nums)\n        curr = INF\n        for i in reversed(xrange(len(nums))):\n            right[i] = curr\n            curr = min(curr, nums[i])\n        result = INF\n        for i in xrange(len(nums)):\n            if left[i] < nums[i] > right[i]:\n                result = min(result, left[i]+nums[i]+right[i])\n        return result if result != INF else -1\n"
    },
    {
        "problem_name": "minimum-sum-of-mountain-triplets-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# prefix sum\nclass Solution(object):\n    def minimumSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n\n        right = [INF]*len(nums)\n        curr = INF\n        for i in reversed(xrange(len(nums))):\n            right[i] = curr\n            curr = min(curr, nums[i])\n        result = curr = INF\n        for i in xrange(len(nums)):\n            if curr < nums[i] > right[i]:\n                result = min(result, curr+nums[i]+right[i])\n            curr = min(curr, nums[i])\n        return result if result != INF else -1\n\n\n# Time:  O(n)\n# Space: O(n)\n# prefix sum\nclass Solution2(object):\n    def minimumSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n\n        left = [INF]*len(nums)\n        curr = INF\n        for i in xrange(len(nums)):\n            left[i] = curr\n            curr = min(curr, nums[i])\n        right = [INF]*len(nums)\n        curr = INF\n        for i in reversed(xrange(len(nums))):\n            right[i] = curr\n            curr = min(curr, nums[i])\n        result = INF\n        for i in xrange(len(nums)):\n            if left[i] < nums[i] > right[i]:\n                result = min(result, left[i]+nums[i]+right[i])\n        return result if result != INF else -1\n"
    },
    {
        "problem_name": "minimum-sum-of-squared-difference",
        "solution": "# Time:  O(nlogn + nlogr), r is max((abs(i-j) for i, j in itertools.izip(nums1, nums2))\n# Space: O(n)\n\nimport itertools\n\n\n# binary search\nclass Solution(object):\n    def minSumSquareDiff(self, nums1, nums2, k1, k2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k1: int\n        :type k2: int\n        :rtype: int\n        \"\"\"\n        def check(diffs, k, x):\n            return sum(max(d-x, 0) for d in diffs) <= k\n\n        diffs = sorted((abs(i-j) for i, j in itertools.izip(nums1, nums2)), reverse=True)\n        k = min(k1+k2, sum(diffs))\n        left, right = 0, diffs[0]\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(diffs, k, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        k -= sum(max(d-left, 0) for d in diffs)\n        for i in xrange(len(diffs)):\n            diffs[i] = min(diffs[i], left)-int(i < k)\n        return sum(d**2 for d in diffs)\n"
    },
    {
        "problem_name": "minimum-sum-of-values-by-dividing-array",
        "solution": "# Time:  O(n * m * logr), r = max(nums)\n# Space: O(n + logr)\n\nimport collections\n\n\n# dp, mono deque, two pointers\nclass Solution(object):\n    def minimumValueSum(self, nums, andValues):\n        \"\"\"\n        :type nums: List[int]\n        :type andValues: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        L = max(nums).bit_length()\n        def update(cnt, x, d):\n            for i in xrange(L):\n                if x&(1<<i):\n                    cnt[i] += d\n        \n        def mask(cnt, l):\n            return reduce(lambda accu, i: accu|(1<<i), (i for i  in xrange(L) if cnt[i] == l), 0)\n\n        dp = [INF]*(len(nums)+1)\n        dp[0] = 0\n        for j in xrange(len(andValues)):\n            new_dp = [INF]*(len(nums)+1)\n            cnt = [0]*L\n            l = [0]*len(dp)\n            dq = collections.deque()\n            left = idx = j\n            for right in xrange(j, len(nums)):\n                update(cnt, nums[right], +1)\n                if mask(cnt, right-left+1) <= andValues[j]:\n                    while left <= right:\n                        if mask(cnt, right-left+1) > andValues[j]:\n                            break\n                        update(cnt, nums[left], -1)\n                        left += 1\n                    left -= 1\n                    update(cnt, nums[left], +1)  # try to move to the last left s.t. mask(cnt, right-left+1) == andValues[j]\n                if (andValues[j]&nums[right]) == andValues[j]:\n                    l[right + 1] = l[right]+1\n                if mask(cnt, right-left+1) != andValues[j]:\n                    continue\n                # new_dp[right+1] = min(dp[left-l[left]], dp[left-l[left]+1], ..., dp[left])+nums[right]\n                while idx <= left:\n                    while dq and dp[dq[-1]] >= dp[idx]:\n                        dq.pop()\n                    dq.append(idx)\n                    idx += 1\n                while dq and dq[0] < left-l[left]:\n                    dq.popleft()\n                if dq:\n                    new_dp[right+1] = dp[dq[0]]+nums[right]\n            dp = new_dp\n        return dp[-1] if dp[-1] != INF else -1\n\n\n# Time:  O(n * m * (logn + logr)), r = max(nums)\n# Space: O(n + logr)\n# dp, sparse table\nclass Solution2(object):\n    def minimumValueSum(self, nums, andValues):\n        \"\"\"\n        :type nums: List[int]\n        :type andValues: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        # RMQ - Sparse Table\n        # Template: https://github.com/kamyu104/GoogleCodeJam-Farewell-Rounds/blob/main/Round%20D/genetic_sequences2.py3\n        # Time:  ctor:  O(NlogN) * O(fn)\n        #        query: O(fn)\n        # Space: O(NlogN)\n        class SparseTable(object):\n            def __init__(self, arr, fn):\n                self.fn = fn\n                self.bit_length = [0]\n                n = len(arr)\n                k = n.bit_length()-1  # log2_floor(n)\n                for i in xrange(k+1):\n                    self.bit_length.extend(i+1 for _ in xrange(min(1<<i, (n+1)-len(self.bit_length))))\n                self.st = [[0]*n for _ in xrange(k+1)]\n                self.st[0] = arr[:]\n                for i in xrange(1, k+1):  # Time: O(NlogN) * O(fn)\n                    for j in xrange((n-(1<<i))+1):\n                        self.st[i][j] = fn(self.st[i-1][j], self.st[i-1][j+(1<<(i-1))])\n        \n            def query(self, L, R):  # Time: O(fn)\n                i = self.bit_length[R-L+1]-1  # log2_floor(R-L+1)\n                return self.fn(self.st[i][L], self.st[i][R-(1<<i)+1])\n        \n        dp = [INF]*(len(nums)+1)\n        dp[0] = 0\n        for j in xrange(len(andValues)):\n            new_dp = [INF]*(len(nums)+1)\n            masks = []\n            st = SparseTable(dp, min)\n            for i in xrange(j, len(nums)):\n                masks.append([nums[i], i])\n                for x in masks:\n                    x[0] &= nums[i]\n                masks = [x for k, x in enumerate(masks) if k == 0 or masks[k-1][0] != masks[k][0]]\n                for k, [mask, left] in enumerate(masks):\n                    if mask == andValues[j]:\n                        # any j in range(left, right+1) has same and(nums[j:i+1]) = mask\n                        right = masks[k+1][1]-1 if k+1 != len(masks) else i\n                        new_dp[i+1] = min(new_dp[i+1], st.query(left, right)+nums[i])\n                        break\n            dp = new_dp\n        return dp[-1] if dp[-1] != INF else -1\n\n\n# Time:  O(n * m * logr), r = max(nums)\n# Space: O(n * m * logr)\nimport collections\n\n\n# memoization\nclass Solution3(object):\n    def minimumValueSum(self, nums, andValues):\n        \"\"\"\n        :type nums: List[int]\n        :type andValues: List[int]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        FULL_MASK = (1<<max(nums).bit_length())-1\n        def memoization(i, j, mask): \n            if i == len(nums) and j == len(andValues):\n                return 0\n            if i == len(nums) or j == len(andValues) or mask < andValues[j]:\n                return INF \n            if  mask not in lookup[i][j]:\n                curr = memoization(i+1, j, mask&nums[i])\n                if mask&nums[i] == andValues[j]:\n                    curr = min(curr, nums[i]+memoization(i+1, j+1, FULL_MASK))\n                lookup[i][j][mask] = curr\n            return lookup[i][j][mask]\n    \n        lookup = [[collections.defaultdict(int) for _ in xrange(len(andValues))] for _ in xrange(len(nums))]\n        result = memoization(0, 0, FULL_MASK)\n        return result if result != INF else -1\n"
    },
    {
        "problem_name": "minimum-swaps-to-arrange-a-binary-grid",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def minSwaps(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for target in reversed(xrange(1, len(grid))):\n            row_idx = len(grid)-1-target\n            while row_idx < len(grid):\n                row = grid[row_idx]\n                if not sum(itertools.islice(row, len(row)-target, len(row))):\n                    break\n                row_idx += 1\n            else:\n                return -1\n            while row_idx != len(grid)-1-target:\n                grid[row_idx], grid[row_idx-1] = grid[row_idx-1], grid[row_idx]\n                result += 1\n                row_idx -= 1\n        return result\n"
    },
    {
        "problem_name": "minimum-swaps-to-group-all-1s-together-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minSwaps(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = cnt = w = nums.count(1)\n        for i in xrange(len(nums)+(w-1)):\n            if i >= w:\n                cnt += nums[(i-w)%len(nums)]\n            cnt -= nums[i%len(nums)]\n            result = min(result, cnt)\n        return result\n"
    },
    {
        "problem_name": "minimum-swaps-to-group-all-1s-together",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minSwaps(self, data):\n        \"\"\"\n        :type data: List[int]\n        :rtype: int\n        \"\"\"\n        total_count = sum(data)\n        result, count, left = 0, 0, 0\n        for i in xrange(len(data)):\n            count += data[i]\n            if i-left+1 > total_count: \n                count -= data[left]\n                left += 1\n            result = max(result, count)\n        return total_count-result\n"
    },
    {
        "problem_name": "minimum-swaps-to-make-sequences-increasing",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minSwap(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        dp_no_swap, dp_swap = [0]*2, [1]*2\n        for i in xrange(1, len(A)):\n            dp_no_swap[i%2], dp_swap[i%2] = float(\"inf\"), float(\"inf\")\n            if A[i-1] < A[i] and B[i-1] < B[i]:\n                dp_no_swap[i%2] = min(dp_no_swap[i%2], dp_no_swap[(i-1)%2])\n                dp_swap[i%2] = min(dp_swap[i%2], dp_swap[(i-1)%2]+1)\n            if A[i-1] < B[i] and B[i-1] < A[i]:\n                dp_no_swap[i%2] = min(dp_no_swap[i%2], dp_swap[(i-1)%2])\n                dp_swap[i%2] = min(dp_swap[i%2], dp_no_swap[(i-1)%2]+1)\n        return min(dp_no_swap[(len(A)-1)%2], dp_swap[(len(A)-1)%2])\n\n"
    },
    {
        "problem_name": "minimum-swaps-to-make-strings-equal",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minimumSwap(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: int\n        \"\"\"\n        x1, y1 = 0, 0\n        for i in xrange(len(s1)):\n            if s1[i] == s2[i]:\n                continue\n            x1 += int(s1[i] == 'x')\n            y1 += int(s1[i] == 'y')\n        if x1%2 !=  y1%2:  # impossible\n            return -1\n        # case1: per xx or yy needs one swap, (x1//2 + y1//2) \n        # case2: per xy or yx needs two swaps, (x1%2 + y1%2)\n        return (x1//2 + y1//2) + (x1%2 + y1%2)\n"
    },
    {
        "problem_name": "minimum-time-difference",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def findMinDifference(self, timePoints):\n        \"\"\"\n        :type timePoints: List[str]\n        :rtype: int\n        \"\"\"\n        minutes = map(lambda x: int(x[:2]) * 60 + int(x[3:]), timePoints)\n        minutes.sort()\n        return min((y - x) % (24 * 60)  \\\n                   for x, y in zip(minutes, minutes[1:] + minutes[:1]))\n\n"
    },
    {
        "problem_name": "minimum-time-for-k-virus-variants-to-spread",
        "solution": "# Time:  O(nlogn * logr), r is the sum of range x size and range y size\n# Space: O(n)\n\n# Range Maximum Query\nclass SegmentTree(object):  # 0-based index\n    def __init__(self, N,\n                 build_fn=lambda x, y: [y]*(2*x),\n                 query_fn=lambda x, y: y if x is None else max(x, y),\n                 update_fn=lambda x, y: y if x is None else x+y,\n                 default_val=0):\n        self.N = N\n        self.H = (N-1).bit_length()\n        self.query_fn = query_fn\n        self.update_fn = update_fn\n        self.default_val = default_val\n        self.tree = build_fn(N, default_val)\n        self.lazy = [None]*N\n\n    def __apply(self, x, val):\n        self.tree[x] = self.update_fn(self.tree[x], val)\n        if x < self.N:\n            self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n    def update(self, L, R, h):  # Time: O(logN), Space: O(N)\n        def pull(x):\n            while x > 1:\n                x //= 2\n                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])\n                if self.lazy[x] is not None:\n                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])\n\n        L += self.N\n        R += self.N\n        L0, R0 = L, R\n        while L <= R:\n            if L & 1:  # is right child\n                self.__apply(L, h)\n                L += 1\n            if R & 1 == 0:  # is left child\n                self.__apply(R, h)\n                R -= 1\n            L //= 2\n            R //= 2\n        pull(L0)\n        pull(R0)\n\n    def query(self, L, R):  # Time: O(logN), Space: O(N)\n        def push(x):\n            n = 2**self.H\n            while n != 1:\n                y = x // n\n                if self.lazy[y] is not None:\n                    self.__apply(y*2, self.lazy[y])\n                    self.__apply(y*2 + 1, self.lazy[y])\n                    self.lazy[y] = None\n                n //= 2\n\n        result = None\n        if L > R:\n            return result\n\n        L += self.N\n        R += self.N\n        push(L)\n        push(R)\n        while L <= R:\n            if L & 1:  # is right child\n                result = self.query_fn(result, self.tree[L])\n                L += 1\n            if R & 1 == 0:  # is left child\n                result = self.query_fn(result, self.tree[R])\n                R -= 1\n            L //= 2\n            R //= 2\n        return result\n    \n    def __str__(self):\n        showList = []\n        for i in xrange(self.N):\n            showList.append(self.query(i, i))\n        return \",\".join(map(str, showList))\n\n\n# competitive programming solution\nclass Solution(object):\n    def minDayskVariants(self, points, k):\n        \"\"\"\n        :type points: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def add_rec(rec, intervals):\n            x0, y0, x1, y1 = rec\n            # add [y0, y1] by 1 in [x0, x1+1)\n            intervals.append([[x0,   +1], [y0, y1]])\n            intervals.append([[x1+1, -1], [y0, y1]])\n\n        def check(points, k, l):  # Time: O(nlogn), Space: O(n)\n            intervals = []\n            y_set = set()\n            for x, y in points:\n                add_rec([x-l, y-l, x+l, y+l], intervals)\n                y_set.add(y-l)\n                y_set.add(y+l)\n            intervals.sort()\n            y_to_idx = {y:i for i, y in enumerate(sorted(y_set))}  # coordinate compression\n            st = SegmentTree(len(y_to_idx))\n            for [_, v], [y0, y1] in intervals:  # line sweep\n                st.update(y_to_idx[y0], y_to_idx[y1], v)\n                if st.query(0, len(y_to_idx)-1) >= k:\n                    return True\n            return False\n                \n        points = [[x+y, x-y] for x, y in points]  # rotate\n        min_x = min(points)[0]\n        max_x = max(points)[0]\n        min_y = min(points, key=lambda x: x[1])[1]\n        max_y = max(points, key=lambda x: x[1])[1]\n        left, right = 0, ((max_x-min_x)+(max_y-min_y)+1)//2\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(points, k, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n\n\n# Time:  O(n^2 * logr), r is the sum of range x size and range y size\n# Space: O(n)\nimport collections\n\n\n# interview solution\nclass Solution2(object):\n    def minDayskVariants(self, points, k):\n        \"\"\"\n        :type points: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def add_rec(rec, intervals):\n            x0, y0, x1, y1 = rec\n            # add [y0, y1+1) by 1 in [x0, x1+1)\n            intervals[x0][y0] += 1\n            intervals[x0][y1+1] -= 1\n            intervals[x1+1][y0] -= 1\n            intervals[x1+1][y1+1] += 1\n\n        def check(points, k, l):  # Time: O(n^2), Space: O(n)\n            intervals = collections.defaultdict(lambda:collections.defaultdict(int))\n            y_set = set()\n            for x, y in points:\n                add_rec([x-l, y-l, x+l, y+l], intervals)\n                y_set.add(y-l)\n                y_set.add(y+l+1)\n            sorted_y = sorted(y_set)\n            sorted_x = sorted(intervals.iterkeys())\n            count = collections.Counter()\n            for x in sorted_x:  # line sweep\n                for y, c in intervals[x].iteritems():\n                    count[y] += c\n                cnt = 0\n                for y in sorted_y:\n                    cnt += count[y]\n                    if cnt >= k:\n                        return True\n            return False\n                \n        points = [[x+y, x-y] for x, y in points]  # rotate\n        min_x = min(points)[0]\n        max_x = max(points)[0]\n        min_y = min(points, key=lambda x: x[1])[1]\n        max_y = max(points, key=lambda x: x[1])[1]\n        left, right = 0, ((max_x-min_x)+(max_y-min_y)+1)//2\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(points, k, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "minimum-time-takes-to-reach-destination-without-drowning",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\n# simulation, bfs\nclass Solution(object):\n    def minimumSeconds(self, land):\n        \"\"\"\n        :type land: List[List[str]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n        lookup = [[-1 if land[i][j] == \"*\" else 0 for j in xrange(len(land[0]))] for i in xrange(len(land))]\n        q = [(i, j, -1) for i in xrange(len(land)) for j in xrange(len(land[0])) if land[i][j] == \"*\"]\n        q.append(next((i, j, 1) for i in xrange(len(land)) for j in xrange(len(land[0])) if land[i][j] == \"S\"))\n        lookup[q[-1][0]][q[-1][1]] = 1\n        while q:\n            new_q = []\n            for i, j, d in q:\n                if land[i][j] == \"D\":\n                    return d-1\n                for di, dj in DIRECTIONS:\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < len(land) and 0 <= nj < len(land[0]) and land[ni][nj] != \"X\" and lookup[ni][nj] != -1):\n                        continue\n                    if d != -1 and lookup[ni][nj] == 0:\n                        lookup[ni][nj] = 1\n                        new_q.append((ni, nj, d+1))\n                    elif d == -1 and land[ni][nj] != \"D\":\n                        lookup[ni][nj] = -1\n                        new_q.append((ni, nj, -1))\n            q = new_q\n        return -1\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\n# simulation, bfs\nclass Solution2(object):\n    def minimumSeconds(self, land):\n        \"\"\"\n        :type land: List[List[str]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n        lookup1 = [[0 if land[i][j] == \"*\" else -1 for j in xrange(len(land[0]))] for i in xrange(len(land))]\n        lookup2 = [[-1]*len(land[0]) for _ in xrange(len(land))]\n        q1 = [(i, j) for i in xrange(len(land)) for j in xrange(len(land[0])) if land[i][j] == \"*\"]\n        q2 = [next((i, j) for i in xrange(len(land)) for j in xrange(len(land[0])) if land[i][j] == \"S\")]\n        lookup2[q2[0][0]][q2[0][1]] = 0\n        while q1 or q2:\n            new_q1, new_q2 = [], []\n            for i, j in q1:\n                for di, dj in DIRECTIONS:\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < len(land) and 0 <= nj < len(land[0]) and land[ni][nj] != \"X\" and land[ni][nj] != \"D\" and lookup1[ni][nj] == -1):\n                        continue\n                    lookup1[ni][nj] = 0\n                    new_q1.append((ni, nj))\n            for i, j in q2:\n                if land[i][j] == \"D\":\n                    return lookup2[i][j]\n                for di, dj in DIRECTIONS:\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < len(land) and 0 <= nj < len(land[0]) and land[ni][nj] != \"X\" and lookup2[ni][nj] == lookup1[ni][nj] == -1):\n                        continue\n                    lookup2[ni][nj] = lookup2[i][j]+1\n                    new_q2.append((ni, nj))\n            q1, q2 = new_q1, new_q2\n        return -1\n"
    },
    {
        "problem_name": "minimum-time-to-build-blocks",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def minBuildTime(self, blocks, split):\n        \"\"\"\n        :type blocks: List[int]\n        :type split: int\n        :rtype: int\n        \"\"\"\n        heapq.heapify(blocks)\n        while len(blocks) != 1:\n            x, y = heapq.heappop(blocks), heapq.heappop(blocks)\n            heapq.heappush(blocks, y+split)\n        return heapq.heappop(blocks)\n"
    },
    {
        "problem_name": "minimum-time-to-collect-all-apples-in-a-tree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def minTime(self, n, edges, hasApple):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type hasApple: List[bool]\n        :rtype: int\n        \"\"\"\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        result = [0, 0]\n        s = [(1, (-1, 0, result))]\n        while s:\n            step, params = s.pop()\n            if step == 1:\n                par, node, ret = params\n                ret[:] = [0, int(hasApple[node])]\n                for nei in reversed(graph[node]):\n                    if nei == par:\n                        continue\n                    new_ret = [0, 0]\n                    s.append((2, (new_ret, ret)))\n                    s.append((1, (node, nei, new_ret)))\n            else:\n                new_ret, ret = params\n                ret[0] += new_ret[0]+new_ret[1]\n                ret[1] |= bool(new_ret[0]+new_ret[1])\n        return 2*result[0]\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution_Recu(object):\n    def minTime(self, n, edges, hasApple):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type hasApple: List[bool]\n        :rtype: int\n        \"\"\"\n        def dfs(graph, par, node, hasApple):\n            result, extra = 0, int(hasApple[node])\n            for nei in graph[node]:\n                if nei == par:\n                    continue\n                count, found = dfs(graph, node, nei, hasApple)\n                result += count+found\n                extra |= bool(count+found)\n            return result, extra\n        \n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        return 2*dfs(graph, -1, 0, hasApple)[0]\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def minTime(self, n, edges, hasApple):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type hasApple: List[bool]\n        :rtype: int\n        \"\"\"\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        result = [0]\n        s = [(1, (-1, 0, result))]\n        while s:\n            step, params = s.pop()\n            if step == 1:\n                par, node, ret = params\n                tmp = [int(hasApple[node])]\n                s.append((3, (tmp, ret)))\n                for nei in reversed(graph[node]):\n                    if nei == par:\n                        continue\n                    new_ret = [0]\n                    s.append((2, (new_ret, tmp, ret)))\n                    s.append((1, (node, nei, new_ret)))\n            elif step == 2:\n                new_ret, tmp, ret = params\n                ret[0] += new_ret[0]\n                tmp[0] |= bool(new_ret[0])\n            else:\n                tmp, ret = params\n                ret[0] += tmp[0]\n        return 2*max(result[0]-1, 0)\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2_Recu(object):\n    def minTime(self, n, edges, hasApple):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type hasApple: List[bool]\n        :rtype: int\n        \"\"\"\n        def dfs(graph, par, node, has_subtree):\n            result, extra = 0, int(hasApple[node])\n            for nei in graph[node]:\n                if nei == par:\n                    continue\n                count = dfs(graph, node, nei, hasApple)\n                result += count\n                extra |= bool(count)\n            return result+extra\n        \n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        return 2*max(dfs(graph, -1, 0, hasApple)-1, 0)\n"
    },
    {
        "problem_name": "minimum-time-to-complete-all-tasks",
        "solution": "# Time:  O(nlogn + n * r), r = max(e for _, e in tasks)\n# Space: O(r)\n\n# sort, greedy\nclass Solution(object):\n    def findMinimumTime(self, tasks):\n        \"\"\"\n        :type tasks: List[List[int]]\n        :rtype: int\n        \"\"\"\n        tasks.sort(key=lambda x: x[1])\n        lookup = set()\n        for s, e, d in tasks:\n            d -= sum(i in lookup for i in xrange(s, e+1))\n            for i in reversed(xrange(1, e+1)):\n                if d <= 0:\n                    break\n                if i in lookup:\n                    continue\n                lookup.add(i)\n                d -= 1\n        return len(lookup)\n"
    },
    {
        "problem_name": "minimum-time-to-complete-trips",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\n# binary search\nclass Solution(object):\n    def minimumTime(self, time, totalTrips):\n        \"\"\"\n        :type time: List[int]\n        :type totalTrips: int\n        :rtype: int\n        \"\"\"\n        def check(time, totalTrips, x):\n            return sum(x//t for t in time) >= totalTrips\n\n        left, right = 1, max(time)*totalTrips\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(time, totalTrips, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "minimum-time-to-eat-all-grains",
        "solution": "# Time:  O(mlogm + nlogn + (m + n) * logr), r = 2*(max(max(hens), max(grains))-min(min(hens), min(grains))\n# Space: O(1)\n\n# binary search, greedy\nclass Solution(object):\n    def minimumTime(self, hens, grains):\n        \"\"\"\n        :type hens: List[int]\n        :type grains: List[int]\n        :rtype: int\n        \"\"\"\n        def check(x):\n            i = 0\n            for h in hens:\n                if h-grains[i] > x:\n                    return False\n                elif h-grains[i] > 0:\n                    d = h-grains[i]\n                    c = max(x-2*d, (x-d)//2)  # max(go left then right, go right then left)\n                else:\n                    c = x                   \n                while i < len(grains) and grains[i] <= h+c:\n                    i += 1\n                if i == len(grains):\n                    return True\n            return False\n    \n        hens.sort()\n        grains.sort()\n        left, right = 0, 2*(max(grains[-1], hens[-1])-min(grains[0], hens[0]))\n        while left <= right:\n            mid = left+(right-left)//2\n            if check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n    \n"
    },
    {
        "problem_name": "minimum-time-to-finish-the-race",
        "solution": "# Time:  O((n + l) * logc)\n# Space: O(n + l + logc)\n\n# greedy, dp\nclass Solution(object):\n    def minimumFinishTime(self, tires, changeTime, numLaps):\n        \"\"\"\n        :type tires: List[List[int]]\n        :type changeTime: int\n        :type numLaps: int\n        :rtype: int\n        \"\"\"\n        def ceil_log2(x):\n            return (x-1).bit_length()\n\n        dp = [float(\"inf\")]*ceil_log2(changeTime+1)  # dp[i]: min time to complete i+1 laps without changing a tire\n        for f, r in tires:\n            total = curr = f\n            cnt = 0\n            while curr < changeTime+f:  # at worst (f, r) = (1, 2) => 2^(cnt-1) < changeTime+1 => cnt < ceil(log2(changeTime+1))\n                dp[cnt] = min(dp[cnt], total)\n                curr *= r\n                total += curr\n                cnt += 1\n        dp2 = [float(\"inf\")]*numLaps  # dp2[i]: min time to complete i+1 laps with changing zero or more tires\n        for i in xrange(numLaps):\n            dp2[i] = min((dp2[i-j-1]+changeTime if i-j-1 >= 0 else 0)+dp[j] for j in xrange(min(i+1, len(dp))))\n        return dp2[-1]\n"
    },
    {
        "problem_name": "minimum-time-to-kill-all-monsters",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(2^n)\n\n# bitmasks, dp\nclass Solution(object):\n    def minimumTime(self, power):\n        \"\"\"\n        :type power: List[int]\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n\n        INF = float(\"inf\")\n        dp = {0:0}\n        for gain in xrange(1, len(power)+1):\n            new_dp = collections.defaultdict(lambda:INF)\n            for mask in dp.iterkeys():\n                for i in xrange(len(power)):\n                    if mask&(1<<i) == 0:\n                        new_dp[mask|(1<<i)] = min(new_dp[mask|(1<<i)], dp[mask]+ceil_divide(power[i], gain))\n            dp = new_dp\n        return dp[(1<<len(power))-1]\n"
    },
    {
        "problem_name": "minimum-time-to-make-array-sum-at-most-x",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\n# greedy, sort, dp, linear search\nclass Solution(object):\n    def minimumTime(self, nums1, nums2, x):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        dp = [0]*(len(nums1)+1)\n        for i, (b, a) in enumerate(sorted(zip(nums2, nums1)), 1):\n            for j in reversed(xrange(1, i+1)):\n                dp[j] = max(dp[j], dp[j-1]+(a+j*b))\n        total1, total2 = sum(nums1), sum(nums2)\n        return next((j for j in xrange(len(dp)) if (total1+j*total2)-dp[j] <= x), -1)\n"
    },
    {
        "problem_name": "minimum-time-to-remove-all-cars-containing-illegal-goods",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def minimumTime(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        left = 0\n        result = left+(len(s)-0)\n        for i in xrange(1, len(s)+1):\n            left = min(left+2*(s[i-1] == '1'), i)\n            result = min(result, left+(len(s)-i))\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\n# dp\nclass Solution2(object):\n    def minimumTime(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, right = len(s), [0]*(len(s)+1)\n        for i in reversed(xrange(len(s))):\n            right[i] = min(right[i+1]+2*(s[i] == '1'), len(s)-i)\n        left = 0\n        result = left+right[0]\n        for i in xrange(1, len(s)+1):\n            left = min(left+2*(s[i-1] == '1'), i)     \n            result = min(result, left+right[i])\n        return result\n"
    },
    {
        "problem_name": "minimum-time-to-repair-cars",
        "solution": "# Time:  O(mx * log(mn * c^2)) = O(mx * (logc + log(mn))), c = cars, mx = max(ranks), mn = min(ranks)\n# Space: O(mx)\n\nimport collections\n\n\n# freq table, binary search\nclass Solution(object):\n    def repairCars(self, ranks, cars):\n        \"\"\"\n        :type ranks: List[int]\n        :type cars: int\n        :rtype: int\n        \"\"\"\n        def check(x):\n            return sum(int((x//k)**0.5)*v for k, v in cnt.iteritems()) >= cars\n\n        cnt = collections.Counter(ranks)\n        left, right = 1, min(cnt.iterkeys())*cars**2\n        while left <= right:\n            mid = left+(right-left)//2\n            if check(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n\n\n# Time:  O(c * log(mx)), c = cars, mx = max(ranks)\n# Space: O(mx)\nimport collections\nimport heapq\n\n\n# freq table, heap, simulation\nclass Solution2(object):\n    def repairCars(self, ranks, cars):\n        \"\"\"\n        :type ranks: List[int]\n        :type cars: int\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(ranks)\n        min_heap = [(r*1**2, 1) for r in cnt.iterkeys()]\n        heapq.heapify(min_heap)\n        while cars > 0:\n            t, k = heapq.heappop(min_heap)\n            r = t//k**2\n            cars -= cnt[r]\n            k += 1\n            heapq.heappush(min_heap, (r*k**2, k))\n        return t\n"
    },
    {
        "problem_name": "minimum-time-to-revert-word-to-initial-state-i",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# z-function\nclass Solution(object):\n    def minimumTimeToInitialState(self, word, k):\n        \"\"\"\n        :type word: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n    \n        def z_function(s):  # Time: O(n), Space: O(n)\n            z = [0]*len(s)\n            l, r = 0, 0\n            for i in xrange(1, len(z)):\n                if i <= r:\n                    z[i] = min(r-i+1, z[i-l])\n                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:\n                    z[i] += 1\n                if i+z[i]-1 > r:\n                    l, r = i, i+z[i]-1\n            return z\n\n        z = z_function(word)\n        for i in xrange(k, len(word), k):\n            if z[i] == len(word)-i:\n                return i//k\n        return ceil_divide(len(word), k)\n\n\n# Time:  O(n^2)\n# Space: O(1)\n# brute force\nclass Solution2(object):\n    def minimumTimeToInitialState(self, word, k):\n        \"\"\"\n        :type word: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n\n        for i in xrange(k, len(word), k):\n            if all(word[i+j] == word[j] for j in xrange(len(word)-i)):\n                return i//k\n        return ceil_divide(len(word), k)\n"
    },
    {
        "problem_name": "minimum-time-to-revert-word-to-initial-state-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# z-function\nclass Solution(object):\n    def minimumTimeToInitialState(self, word, k):\n        \"\"\"\n        :type word: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+b-1)//b\n    \n        def z_function(s):  # Time: O(n), Space: O(n)\n            z = [0]*len(s)\n            l, r = 0, 0\n            for i in xrange(1, len(z)):\n                if i <= r:\n                    z[i] = min(r-i+1, z[i-l])\n                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:\n                    z[i] += 1\n                if i+z[i]-1 > r:\n                    l, r = i, i+z[i]-1\n            return z\n\n        z = z_function(word)\n        for i in xrange(k, len(word), k):\n            if z[i] == len(word)-i:\n                return i//k\n        return ceil_divide(len(word), k)\n"
    },
    {
        "problem_name": "minimum-time-to-type-word-using-special-typewriter",
        "solution": "# Time:  O(n)\n# Space; O(1)\n\nclass Solution(object):\n    def minTimeToType(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        return (min((ord(word[0])-ord('a'))%26, (ord('a')-ord(word[0]))%26)+1) + \\\n               sum(min((ord(word[i])-ord(word[i-1]))%26, (ord(word[i-1])-ord(word[i]))%26)+1\n                   for i in xrange(1, len(word)))\n"
    },
    {
        "problem_name": "minimum-time-to-visit-a-cell-in-a-grid",
        "solution": "# Time:  O(m * n * log(m * n))\n# Space: O(m * n)\n\nimport heapq\n\n\n# dijkstra's algorithm\nclass Solution(object):\n    def minimumTime(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n        def dijkstra(start, target):\n            best = [[float(\"inf\")]*len(grid[0]) for _ in xrange(len(grid))]\n            best[start[0]][start[1]] = 0\n            min_heap = [(0, start[0], start[1])]\n            while min_heap:\n                curr, i, j = heapq.heappop(min_heap)\n                if best[i][j] < curr:\n                    continue\n                if (i, j) == target:\n                    break\n                for di, dj in DIRECTIONS:  \n                    ni, nj = i+di, j+dj   \n                    if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and best[ni][nj] > max(grid[ni][nj]+int(grid[ni][nj]%2 == best[i][j]%2), curr+1)):\n                        continue\n                    best[ni][nj] = max(grid[ni][nj]+int(grid[ni][nj]%2 == best[i][j]%2), curr+1)\n                    heapq.heappush(min_heap, (best[ni][nj], ni, nj))\n            return best[target[0]][target[1]]\n\n        if min(grid[0][1], grid[1][0]) > 1:\n            return -1\n        return dijkstra((0, 0), (len(grid)-1, len(grid[0])-1))\n"
    },
    {
        "problem_name": "minimum-time-to-visit-disappearing-nodes",
        "solution": "# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,\n#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport heapq\n\n\n# dijkstra's algorithm\nclass Solution(object):\n    def minimumTime(self, n, edges, disappear):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type disappear: List[int]\n        :rtype: List[int]\n        \"\"\"\n        INF = float(\"inf\")\n        def modified_dijkstra(start):\n            best = [-1]*n\n            best[start] = 0\n            min_heap = [(best[start], start)]\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if curr != best[u]:\n                    continue\n                for v, w in adj[u]: \n                    if not curr+w < min(best[v] if best[v] != -1 else INF, disappear[v]):  # modified\n                        continue\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (best[v], v))\n            return best\n        \n        adj = [[] for _ in xrange(n)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        return modified_dijkstra(0)\n"
    },
    {
        "problem_name": "minimum-time-visiting-all-points",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minTimeToVisitAllPoints(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        return sum(max(abs(points[i+1][0] - points[i][0]),\n                       abs(points[i+1][1] - points[i][1]))\n                   for i in xrange(len(points)-1))\n"
    },
    {
        "problem_name": "minimum-total-cost-to-make-arrays-unequal",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\nimport itertools\n\n\n# greedy\nclass Solution(object):\n    def minimumTotalCost(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter()\n        result = 0\n        for i, (x, y) in enumerate(itertools.izip(nums1, nums2)):\n            if x != y:\n                continue\n            cnt[x] += 1\n            result += i\n        if not cnt:\n            return 0\n        majority = max(cnt.iterkeys(), key=lambda x: cnt[x])\n        remain = cnt[majority]-(sum(cnt.itervalues())-cnt[majority])\n        if remain <= 0:\n            return result\n        for i, (x, y) in enumerate(itertools.izip(nums1, nums2)):\n            if x == y or majority in (x, y):\n                continue\n            result += i\n            remain -= 1\n            if not remain:\n                return result\n        return -1\n"
    },
    {
        "problem_name": "minimum-total-distance-traveled",
        "solution": "# Time:  O(mlogm + nlogn + m * n)\n# Space: O(n)\n\nimport collections\n\n\n# sort, dp, prefix sum, mono deque\nclass Solution(object):\n    def minimumTotalDistance(self, robot, factory):\n        \"\"\"\n        :type robot: List[int]\n        :type factory: List[List[int]]\n        :rtype: int\n        \"\"\"\n        robot.sort(), factory.sort()\n        dp = [float(\"inf\")]*(len(robot)+1)  # dp[j] at i: min of factory[:i+1] and robot[:j]\n        dp[0] = 0\n        for i in xrange(len(factory)):\n            prefix = 0\n            dq = collections.deque([(dp[0]-prefix, 0)])  # pattern of min in the sliding window with size (limit+1)\n            for j in xrange(1, len(robot)+1):\n                prefix += abs(robot[j-1]-factory[i][0])\n                if j-dq[0][1] == factory[i][1]+1:\n                    dq.popleft()\n                while dq and dq[-1][0] >= dp[j]-prefix:\n                    dq.pop()\n                dq.append((dp[j]-prefix, j))\n                dp[j] = dq[0][0]+prefix\n        return dp[-1]\n\n\n# Time:  O(mlogm + nlogn + m * n * l), l is the max limit\n# Space: O(n)\nimport collections\n\n\n# sort, dp\nclass Solution2(object):\n    def minimumTotalDistance(self, robot, factory):\n        \"\"\"\n        :type robot: List[int]\n        :type factory: List[List[int]]\n        :rtype: int\n        \"\"\"\n        robot.sort(), factory.sort()\n        dp = [float(\"inf\")]*(len(robot)+1)  # dp[j] at i: min of factory[:i+1] and robot[:j]\n        dp[0] = 0\n        for i in xrange(len(factory)):\n            for j in reversed(xrange(1, len(robot)+1)):\n                curr = 0\n                for k in xrange(min(factory[i][1], j)+1):\n                    dp[j] = min(dp[j], dp[j-k]+curr)\n                    if (j-1)-k >= 0:\n                        curr += abs(robot[(j-1)-k]-factory[i][0])\n        return dp[-1]\n"
    },
    {
        "problem_name": "minimum-total-space-wasted-with-k-resizing-operations",
        "solution": "# Time:  O(k * n^2)\n# Space: O(k * n)\n\nclass Solution(object):\n    def minSpaceWastedKResizing(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        k += 1\n        dp = [[INF]*(k+1) for _ in xrange(len(nums)+1)]\n        dp[0][0] = 0\n        for i in xrange(1, len(nums)+1):\n            total = max_num = 0\n            for j in reversed(xrange(1, i+1)):\n                total += nums[j-1]\n                max_num = max(max_num, nums[j-1])\n                for m in xrange(1, k+1):\n                    if dp[j-1][m-1] != INF:\n                        dp[i][m] = min(dp[i][m], dp[j-1][m-1] + (max_num*(i-j+1)-total))\n        return dp[-1][-1]\n"
    },
    {
        "problem_name": "minimum-unique-word-abbreviation",
        "solution": "# Time:  O((d + n) * 2^n)\n# Space: O(d)\n\n# optimized from Solution2\nclass Solution(object):\n    def minAbbreviation(self, target, dictionary):\n        \"\"\"\n        :type target: str\n        :type dictionary: List[str]\n        :rtype: str\n        \"\"\"\n        def bits_to_abbr_len(targets, bits):\n            total = 0\n            pre = 0\n            for i in xrange(len(target)):\n                if bits & 1:\n                    if i - pre > 0:\n                        total += len(str(i - pre))\n                    pre = i + 1\n                    total += 1\n                elif i == len(target) - 1:\n                    total += len(str(i - pre + 1))\n                bits >>= 1\n            return total\n\n        def bits_to_abbr(targets, bits):\n            abbr = []\n            pre = 0\n            for i in xrange(len(target)):\n                if bits & 1:\n                    if i - pre > 0:\n                        abbr.append(str(i - pre))\n                    pre = i + 1\n                    abbr.append(target[i])\n                elif i == len(target) - 1:\n                    abbr.append(str(i - pre + 1))\n                bits >>= 1\n            return \"\".join(abbr)\n  \n        diffs = []\n        for word in dictionary:\n            if len(word) != len(target):\n                continue\n            diffs.append(sum(2**i for i, c in enumerate(word) if target[i] != c))\n\n        if not diffs:\n            return str(len(target))\n\n        result = 2**len(target)-1\n        for mask in xrange(2**len(target)):\n            if all(d & mask for d in diffs) and bits_to_abbr_len(target, mask) < bits_to_abbr_len(target, result):\n                result = mask\n        return bits_to_abbr(target, result)\n    \n\n# Time:  O((d + n) * 2^n)\n# Space: O(d + n)\nclass Solution2(object):\n    def minAbbreviation(self, target, dictionary):\n        \"\"\"\n        :type target: str\n        :type dictionary: List[str]\n        :rtype: str\n        \"\"\"\n        def bits_to_abbr(targets, bits):\n            abbr = []\n            pre = 0\n            for i in xrange(len(target)):\n                if bits & 1:\n                    if i - pre > 0:\n                        abbr.append(str(i - pre))\n                    pre = i + 1\n                    abbr.append(target[i])\n                elif i == len(target) - 1:\n                    abbr.append(str(i - pre + 1))\n                bits >>= 1\n            return \"\".join(abbr)\n  \n        diffs = []\n        for word in dictionary:\n            if len(word) != len(target):\n                continue\n            diffs.append(sum(2**i for i, c in enumerate(word) if target[i] != c))\n\n        if not diffs:\n            return str(len(target))\n\n        result = target\n        for mask in xrange(2**len(target)):\n            abbr = bits_to_abbr(target, mask)\n            if all(d & mask for d in diffs) and len(abbr) < len(result):\n                result = abbr\n        return result\n\n"
    },
    {
        "problem_name": "minimum-value-to-get-positive-step-by-step-sum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minStartValue(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        min_prefix, prefix = 0, 0\n        for num in nums:\n            prefix += num\n            min_prefix = min(min_prefix, prefix)\n        return 1-min_prefix\n"
    },
    {
        "problem_name": "minimum-weighted-subgraph-with-the-required-paths",
        "solution": "# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),\n#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport heapq\n\n\n# dijkstra's algorithm\nclass Solution(object):\n    def minimumWeight(self, n, edges, src1, src2, dest):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type src1: int\n        :type src2: int\n        :type dest: int\n        :rtype: int\n        \"\"\"\n        def dijkstra(adj, start):\n            best = [float(\"inf\")]*len(adj)\n            best[start] = 0\n            min_heap = [(0, start)]\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if best[u] < curr:\n                    continue\n                for v, w in adj[u]:                \n                    if best[v] <= curr+w:\n                        continue\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (curr+w, v))\n            return best\n    \n        adj1, adj2 = [[[] for _ in xrange(n)] for _ in xrange(2)]\n        for u, v, w in edges:\n            adj1[u].append((v, w))\n            adj2[v].append((u, w))\n        dist1 = dijkstra(adj1, src1)\n        dist2 = dijkstra(adj1, src2)\n        dist3 = dijkstra(adj2, dest)\n        result = min(dist1[i]+dist2[i]+dist3[i] for i in xrange(n))\n        return result if result != float(\"inf\") else -1\n"
    },
    {
        "problem_name": "minimum-white-tiles-after-covering-with-carpets",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\n# dp\nclass Solution(object):\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\n        \"\"\"\n        :type floor: str\n        :type numCarpets: int\n        :type carpetLen: int\n        :rtype: int\n        \"\"\"\n        dp = [[0]*(numCarpets+1) for _ in xrange(len(floor)+1)]  # dp[i][j] : min number of white tiles in the first i floors with j carpets\n        for i in xrange(1, len(dp)):\n            dp[i][0] = dp[i-1][0] + int(floor[i-1])\n            for j in xrange(1, numCarpets+1):\n                dp[i][j] = min(dp[i-1][j] + int(floor[i-1]), dp[max(i-carpetLen, 0)][j-1])\n        return dp[-1][-1]\n"
    },
    {
        "problem_name": "minimum-window-subsequence",
        "solution": "# Time:  O(s * t)\n# Space: O(s)\n\nclass Solution(object):\n    def minWindow(self, S, T):\n        \"\"\"\n        :type S: str\n        :type T: str\n        :rtype: str\n        \"\"\"\n        lookup = [[None for _ in xrange(26)] for _ in xrange(len(S)+1)]\n        find_char_next_pos = [None]*26\n        for i in reversed(xrange(len(S))):\n            find_char_next_pos[ord(S[i])-ord('a')] = i+1\n            lookup[i] = list(find_char_next_pos)\n\n        min_i, min_len = None, float(\"inf\")\n        for i in xrange(len(S)):\n            if S[i] != T[0]:\n                continue\n            start = i\n            for c in T:\n                start = lookup[start][ord(c)-ord('a')]\n                if start == None:\n                    break\n            else:\n                if start-i < min_len:\n                    min_i, min_len = i, start-i\n        return S[min_i:min_i+min_len] if min_i is not None else \"\"\n\n    \n# Time:  O(s * t)\n# Space: O(s)\nclass Solution2(object):\n    def minWindow(self, S, T):\n        \"\"\"\n        :type S: str\n        :type T: str\n        :rtype: str\n        \"\"\"\n        dp = [[None for _ in xrange(len(S))] for _ in xrange(2)]\n        for j, c in enumerate(S):\n            if c == T[0]:\n                dp[0][j] = j\n\n        for i in xrange(1, len(T)):\n            prev = None\n            dp[i%2] = [None] * len(S)\n            for j, c in enumerate(S):\n                if prev is not None and c == T[i]:\n                    dp[i%2][j] = prev\n                if dp[(i-1)%2][j] is not None:\n                    prev = dp[(i-1)%2][j]\n\n        start, end = 0, len(S)\n        for j, i in enumerate(dp[(len(T)-1)%2]):\n            if i >= 0 and j-i < end-start:\n                start, end = i, j\n        return S[start:end+1] if end < len(S) else \"\"\n\n"
    },
    {
        "problem_name": "minimum-window-substring",
        "solution": "# Time:  O(n)\n# Space: O(k), k is the number of different characters\n\nimport collections\n\n\nclass Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        count, remain = collections.Counter(t), len(t)\n        i, left, right = 0, -1, -1\n        for j, c in enumerate(s):\n            remain -= count[c] > 0\n            count[c] -= 1\n            if remain:\n                continue\n            while count[s[i]] < 0:  # greedily discard uneeds\n                count[s[i]] += 1\n                i += 1\n            if right == -1 or j-i+1 < right-left+1:\n                left, right = i, j\n        return s[left:right+1]\n\n\n# Time:  O(n)\n# Space: O(k), k is the number of different characters\nclass Solution2(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        current_count = [0 for i in xrange(52)]\n        expected_count = [0 for i in xrange(52)]\n\n        for char in t:\n            expected_count[ord(char) - ord('a')] += 1\n\n        i, count, start, min_width, min_start = 0, 0, 0, float(\"inf\"), 0\n        while i < len(s):\n            current_count[ord(s[i]) - ord('a')] += 1\n            if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]:\n                count += 1\n\n            if count == len(t):\n                while expected_count[ord(s[start]) - ord('a')] == 0 or \\\n                      current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]:\n                    current_count[ord(s[start]) - ord('a')] -= 1\n                    start += 1\n\n                if min_width > i - start + 1:\n                    min_width = i - start + 1\n                    min_start = start\n            i += 1\n\n        if min_width == float(\"inf\"):\n            return \"\"\n\n        return s[min_start:min_start + min_width]\n\n\n"
    },
    {
        "problem_name": "minimum-xor-sum-of-two-arrays",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\n# weighted bipartite matching solution\nclass Solution(object):\n    def minimumXORSum(self, nums1, nums2):\n        # Template translated from:\n        # https://github.com/kth-competitive-programming/kactl/blob/main/content/graph/WeightedMatching.h\n        def hungarian(a):  # Time: O(n^2 * m), Space: O(n + m)\n            if not a:\n                return 0, []\n            n, m = len(a)+1, len(a[0])+1\n            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)\n            for i in xrange(1, n):\n                p[0] = i\n                j0 = 0  # add \"dummy\" worker 0\n                dist, pre = [float(\"inf\")]*m, [-1]*m\n                done = [False]*(m+1)\n                while True:  # dijkstra\n                    done[j0] = True\n                    i0, j1, delta = p[j0], None, float(\"inf\")\n                    for j in xrange(1, m):\n                        if done[j]:\n                            continue\n                        cur = a[i0-1][j-1]-u[i0]-v[j]\n                        if cur < dist[j]:\n                            dist[j], pre[j] = cur, j0\n                        if dist[j] < delta:\n                            delta, j1 = dist[j], j\n                    for j in xrange(m):\n                        if done[j]:\n                            u[p[j]] += delta\n                            v[j] -= delta\n                        else:\n                            dist[j] -= delta\n                    j0 = j1\n                    if not p[j0]:\n                        break\n                while j0:  # update alternating path\n                    j1 = pre[j0]\n                    p[j0], j0 = p[j1], j1\n            for j in xrange(1, m):\n                if p[j]:\n                    ans[p[j]-1] = j-1\n            return -v[0], ans  # min cost\n        \n        adj = [[0]*len(nums2) for _ in xrange(len(nums1))]\n        for i in xrange(len(nums1)):\n            for j in xrange(len(nums2)):\n                adj[i][j] = nums1[i]^nums2[j]\n        return hungarian(adj)[0]\n\n\n# Time:  O(n * 2^n)\n# Space: O(2^n)\n# dp solution\nclass Solution2(object):\n    def minimumXORSum(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [(float(\"inf\"), float(\"inf\"))]*(2**len(nums2))\n        dp[0] = (0, 0)\n        for mask in xrange(len(dp)):\n            bit = 1\n            for i in xrange(len(nums2)):\n                if (mask&bit) == 0:\n                    dp[mask|bit] = min(dp[mask|bit], (dp[mask][0]+(nums1[dp[mask][1]]^nums2[i]), dp[mask][1]+1))\n                bit <<= 1\n        return dp[-1][0]\n"
    },
    {
        "problem_name": "mirror-reflection",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def mirrorReflection(self, p, q):\n        \"\"\"\n        :type p: int\n        :type q: int\n        :rtype: int\n        \"\"\"\n        # explanation commented in the following solution\n        return 2 if (p & -p) > (q & -q) else 0 if (p & -p) < (q & -q) else 1\n\n\n# Time:  O(log(max(p, q))) = O(1) due to 32-bit integer\n# Space: O(1)\nclass Solution2(object):\n    def mirrorReflection(self, p, q):\n        \"\"\"\n        :type p: int\n        :type q: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        lcm = p*q // gcd(p, q)\n        # let a = lcm / p, b = lcm / q\n        if lcm // p % 2 == 1:\n            if lcm // q % 2 == 1:\n                return 1  # a is odd, b is odd <=> (p & -p) == (q & -q)\n            return 2  # a is odd, b is even <=> (p & -p) > (q & -q)\n        return 0  # a is even, b is odd <=> (p & -p) < (q & -q)\n\n"
    },
    {
        "problem_name": "missing-element-in-sorted-array",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def missingElement(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def missing_count(nums, x):\n            return (nums[x]-nums[0]+1)-(x-0+1)\n\n        def check(nums, k, x):\n            return k > missing_count(nums, x)\n\n        left, right = 0, len(nums)-1\n        while left <= right:  # find the largest right s.t. k > missingCount(nums, x)\n            mid = left + (right-left)//2\n            if not check(nums, k, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        assert(check(nums, k, right))\n        return nums[right] + (k-missing_count(nums, right))\n"
    },
    {
        "problem_name": "missing-number-in-arithmetic-progression",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def missingNumber(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        def check(arr, d, x):\n            return arr[x] != arr[0] + d*x\n\n        d = (arr[-1]-arr[0])//len(arr)\n        left, right = 0, len(arr)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(arr, d, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return arr[0] + d*left\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def missingNumber(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        return (min(arr)+max(arr))*(len(arr)+1)//2 - sum(arr)\n"
    },
    {
        "problem_name": "missing-number",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport operator\n\n\nclass Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return reduce(operator.xor, nums,\n                      reduce(operator.xor, xrange(len(nums) + 1)))\n\n\nclass Solution2(object):\n    def missingNumber(self, nums):\n        return sum(xrange(len(nums)+1)) - sum(nums)\n\n"
    },
    {
        "problem_name": "missing-ranges",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findMissingRanges(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: List[str]\n        \"\"\"\n        def getRange(lower, upper):\n            if lower == upper:\n                return \"{}\".format(lower)\n            else:\n                return \"{}->{}\".format(lower, upper)\n        ranges = []\n        pre = lower - 1\n\n        for i in xrange(len(nums) + 1):\n            if i == len(nums):\n                cur = upper + 1\n            else:\n                cur = nums[i]\n            if cur - pre >= 2:\n                ranges.append(getRange(pre + 1, cur - 1))\n\n            pre = cur\n\n        return ranges\n\n\n"
    },
    {
        "problem_name": "modify-graph-edge-weights",
        "solution": "# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,\n#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport heapq\n\n\n# dijkstra's algorithm\nclass Solution(object):\n    def modifiedGraphEdges(self, n, edges, source, destination, target):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type source: int\n        :type destination: int\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def dijkstra(start, x):\n            best = [target+1]*len(adj)\n            best[start] = 0\n            min_heap = [(0, start)]\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if curr > best[u]:\n                    continue\n                for v, w in adj[u]:       \n                    if w == -1:\n                        w = x\n                    if curr+w >= best[v]:\n                        continue\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (best[v], v))\n            return best\n        \n        adj = [[] for _ in xrange(n)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        left = dijkstra(source, 1)\n        if not (left[destination] <= target):\n            return []\n        right= dijkstra(destination, target+1)\n        if not (right[source] >= target):\n            return []\n        for e in edges:\n            if e[2] == -1:\n                e[2] = max(target-left[e[0]]-right[e[1]], target-left[e[1]]-right[e[0]], 1)\n        return edges\n"
    },
    {
        "problem_name": "modify-the-matrix",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def modifiedMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        for j in xrange(len(matrix[0])):\n            mx = max(matrix[i][j] for i in xrange(len(matrix)))\n            for i in xrange(len(matrix)):\n                if matrix[i][j] == -1:\n                    matrix[i][j] = mx\n        return matrix\n"
    },
    {
        "problem_name": "monotone-increasing-digits",
        "solution": "# Time:  O(logn) = O(1)\n# Space: O(logn) = O(1)\n\nclass Solution(object):\n    def monotoneIncreasingDigits(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        nums = map(int, list(str(N)))\n        leftmost_inverted_idx = len(nums)\n        for i in reversed(xrange(1, len(nums))):\n            if nums[i-1] > nums[i]:\n                leftmost_inverted_idx = i\n                nums[i-1] -= 1\n        for i in xrange(leftmost_inverted_idx, len(nums)):\n            nums[i] = 9\n        return int(\"\".join(map(str, nums)))\n\n"
    },
    {
        "problem_name": "monotonic-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isMonotonic(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: bool\n        \"\"\"\n        inc, dec = False, False\n        for i in xrange(len(A)-1):\n            if A[i] < A[i+1]:\n                inc = True\n            elif A[i] > A[i+1]:\n                dec = True\n        return not inc or not dec\n\n"
    },
    {
        "problem_name": "most-beautiful-item-for-each-query",
        "solution": "# Time:  O(nlogn + qlogn)\n# Space: O(1)\n\nimport bisect\n\n\nclass Solution(object):\n    def maximumBeauty(self, items, queries):\n        \"\"\"\n        :type items: List[List[int]]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        items.sort()\n        for i in xrange(len(items)-1):\n            items[i+1][1] = max(items[i+1][1], items[i][1])\n        result = []\n        for q in queries:\n            i = bisect.bisect_left(items, [q+1])\n            result.append(items[i-1][1] if i else 0)\n        return result\n"
    },
    {
        "problem_name": "most-common-word",
        "solution": "# Time:  O(m + n), m is the size of banned, n is the size of paragraph\n# Space: O(m + n)\n\nimport collections\n\n\nclass Solution(object):\n    def mostCommonWord(self, paragraph, banned):\n        \"\"\"\n        :type paragraph: str\n        :type banned: List[str]\n        :rtype: str\n        \"\"\"\n        lookup = set(banned)\n        counts = collections.Counter(word.strip(\"!?',.\")\n                                     for word in paragraph.lower().split())\n\n        result = ''\n        for word in counts:\n            if (not result or counts[word] > counts[result]) and \\\n               word not in lookup:\n                result = word\n        return result\n\n"
    },
    {
        "problem_name": "most-expensive-item-that-can-not-be-bought",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# Chicken McNugget Theorem\nclass Solution(object):\n    def mostExpensiveItem(self, primeOne, primeTwo):\n        \"\"\"\n        :type primeOne: int\n        :type primeTwo: int\n        :rtype: int\n        \"\"\"\n        # reference:\n        # - https://en.wikipedia.org/wiki/Coin_problem\n        # - https://mikebeneschan.medium.com/the-chicken-mcnugget-theorem-explained-2daca6fbbe1e\n        return primeOne*primeTwo-primeOne-primeTwo\n\n\n# Time:  O(p1 * p2)\n# Space: O(p1 + p2)\n# dp\nclass Solution2(object):\n    def mostExpensiveItem(self, primeOne, primeTwo):\n        \"\"\"\n        :type primeOne: int\n        :type primeTwo: int\n        :rtype: int\n        \"\"\"\n        dp = [False]*max(primeOne, primeTwo)\n        dp[0] = True\n        result = 1\n        for i in xrange(2, primeOne*primeTwo):\n            dp[i%len(dp)] = dp[(i-primeOne)%len(dp)] or dp[(i-primeTwo)%len(dp)]\n            if not dp[i%len(dp)]:\n                result = i\n        return result\n"
    },
    {
        "problem_name": "most-frequent-even-element",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def mostFrequentEven(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(x for x in nums if x%2 == 0)\n        return max(cnt.iterkeys(), key=lambda x: (cnt[x], -x)) if cnt else -1\n"
    },
    {
        "problem_name": "most-frequent-ids",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\nimport itertools\nimport heapq\n\n\n# heap\nclass Solution(object):\n    def mostFrequentIDs(self, nums, freq):\n        \"\"\"\n        :type nums: List[int]\n        :type freq: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        cnt = collections.Counter()\n        max_heap = []\n        for x, f in itertools.izip(nums, freq):\n            cnt[x] += f\n            heapq.heappush(max_heap, (-cnt[x], x))\n            while max_heap and -max_heap[0][0] != cnt[max_heap[0][1]]:\n                heapq.heappop(max_heap)\n            result.append(-max_heap[0][0] if max_heap else 0)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport collections\nimport itertools\nfrom sortedcontainers import SortedList\n\n\n# sorted list\nclass Solution2(object):\n    def mostFrequentIDs(self, nums, freq):\n        \"\"\"\n        :type nums: List[int]\n        :type freq: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        cnt = collections.Counter()\n        cnt2 = collections.Counter()\n        sl = SortedList()\n        for x, f in itertools.izip(nums, freq):\n            sl.discard((cnt[x], cnt2[cnt[x]]))\n            cnt2[cnt[x]] -= 1\n            if cnt2[cnt[x]]:\n                sl.add((cnt[x], cnt2[cnt[x]]))\n            cnt[x] += f\n            sl.discard((cnt[x], cnt2[cnt[x]]))\n            cnt2[cnt[x]] += 1\n            sl.add((cnt[x], cnt2[cnt[x]]))\n            result.append(sl[-1][0])\n        return result\n"
    },
    {
        "problem_name": "most-frequent-number-following-key-in-an-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def mostFrequent(self, nums, key):\n        \"\"\"\n        :type nums: List[int]\n        :type key: int\n        :rtype: int\n        \"\"\"\n        return collections.Counter(nums[i+1] for i in xrange(len(nums)-1) if nums[i] == key).most_common(1)[0][0]\n"
    },
    {
        "problem_name": "most-frequent-prime",
        "solution": "# Time:  precompute: O(10^MAX_N_M)\n#        runtime:    O(n * m * (n + m))\n# Space: O(10^MAX_N_M + n * m * (n + m))\n\nimport collections\n\n\n# number theory, freq table\ndef linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)\n    primes = []\n    spf = [-1]*(n+1)  # the smallest prime factor\n    for i in xrange(2, n+1):\n        if spf[i] == -1:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if i*p > n or p > spf[i]:\n                break\n            spf[i*p] = p\n    return spf\n\n\nMAX_M_N = 6\nSPF = linear_sieve_of_eratosthenes(10**MAX_M_N-1)\nclass Solution(object):\n    def mostFrequentPrime(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))\n        def numbers(i, j, di, dj):\n            curr = 0\n            while 0 <= i < len(mat) and 0 <= j < len(mat[0]):\n                curr = curr*10+mat[i][j]\n                yield curr\n                i, j = i+di, j+dj\n\n        cnt = collections.Counter(x for i in xrange(len(mat)) for j in xrange(len(mat[0])) for di, dj in DIRECTIONS for x in numbers(i, j, di, dj) if x > 10 and SPF[x] == x)\n        cnt[-1] = 0\n        return max(cnt.iterkeys(), key=lambda x: (cnt[x], x))\n\n\n# Time:  O(n * m * (n + m) * sqrt(10^MAX_N_M))\n# Space: O(n * m * (n + m))\nimport collections\n\n\n# number theory, freq table\ndef is_prime(n):\n    if n%2 == 0 or n%3 == 0:\n        return False\n    for i in xrange(5, n, 6):\n        if i*i > n:\n            break\n        if n%i == 0 or n%(i+2) == 0:\n            return False\n    return True  \n\n\nclass Solution2(object):\n    def mostFrequentPrime(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))\n        def numbers(i, j, di, dj):\n            curr = 0\n            while 0 <= i < len(mat) and 0 <= j < len(mat[0]):\n                curr = curr*10+mat[i][j]\n                yield curr\n                i, j = i+di, j+dj\n\n        cnt = collections.Counter(x for i in xrange(len(mat)) for j in xrange(len(mat[0])) for di, dj in DIRECTIONS for x in numbers(i, j, di, dj) if x > 10)\n        cnt[-1] = 0\n        return max((p for p in cnt.iterkeys() if is_prime(p) or p == -1), key=lambda x: (cnt[x], x))\n"
    },
    {
        "problem_name": "most-frequent-subtree-sum",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def findFrequentTreeSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        def countSubtreeSumHelper(root, counts):\n            if not root:\n                return 0\n            total = root.val + \\\n                    countSubtreeSumHelper(root.left, counts) + \\\n                    countSubtreeSumHelper(root.right, counts)\n            counts[total] += 1\n            return total\n\n        counts = collections.defaultdict(int)\n        countSubtreeSumHelper(root, counts)\n        max_count = max(counts.values()) if counts else 0\n        return [total for total, count in counts.iteritems() if count == max_count]\n\n"
    },
    {
        "problem_name": "most-popular-video-creator",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\nimport itertools\n\n\n# hash table\nclass Solution(object):\n    def mostPopularCreator(self, creators, ids, views):\n        \"\"\"\n        :type creators: List[str]\n        :type ids: List[str]\n        :type views: List[int]\n        :rtype: List[List[str]]\n        \"\"\"\n        cnt = collections.Counter()\n        lookup = collections.defaultdict(lambda: (float(\"inf\"), float(\"inf\")))\n        for c, i, v in itertools.izip(creators, ids, views):\n            cnt[c] += v\n            lookup[c] = min(lookup[c], (-v, i))\n        mx = max(cnt.itervalues())\n        return [[k, lookup[k][1]] for k, v in cnt.iteritems() if v == mx]\n"
    },
    {
        "problem_name": "most-profit-assigning-work",
        "solution": "# Time:  O(mlogm + nlogn), m is the number of workers,\n#                        , n is the number of jobs\n# Space: O(n)\n\nclass Solution(object):\n    def maxProfitAssignment(self, difficulty, profit, worker):\n        \"\"\"\n        :type difficulty: List[int]\n        :type profit: List[int]\n        :type worker: List[int]\n        :rtype: int\n        \"\"\"\n        jobs = zip(difficulty, profit)\n        jobs.sort()\n        worker.sort()\n        result, i, max_profit = 0, 0, 0\n        for ability in worker:\n            while i < len(jobs) and jobs[i][0] <= ability:\n                max_profit = max(max_profit, jobs[i][1])\n                i += 1\n            result += max_profit\n        return result\n\n"
    },
    {
        "problem_name": "most-profitable-path-in-a-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# iterative dfs\nclass Solution(object):\n    def mostProfitablePath(self, edges, bob, amount):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type bob: int\n        :type amount: List[int]\n        :rtype: int\n        \"\"\"\n        def iter_dfs():\n            lookup = [[float(\"-inf\"), float(\"inf\")] for _ in xrange(len(adj))]\n            stk = [(1, (0, -1, 0))]\n            while stk:\n                step, (u, p, ah) = stk.pop()\n                if step == 1:\n                    stk.append((2, (u, p, ah)))\n                    for v in adj[u]:\n                        if v == p:\n                            continue\n                        stk.append((1, (v, u, ah+1)))\n                elif step == 2:\n                    if len(adj[u])+(u == 0) == 1:\n                        lookup[u][0] = 0\n                    if u == bob:\n                        lookup[u][1] = 0\n                    for v in adj[u]:\n                        if v == p:\n                            continue\n                        lookup[u][0] = max(lookup[u][0], lookup[v][0])\n                        lookup[u][1] = min(lookup[u][1], lookup[v][1])\n                    if ah == lookup[u][1]:\n                        lookup[u][0] += amount[u]//2\n                    elif ah < lookup[u][1]:\n                        lookup[u][0] += amount[u]\n                    lookup[u][1] += 1\n            return lookup[0][0]\n\n        adj = [[] for _ in xrange(len(edges)+1)]\n        lookup = [False]*len(adj)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return iter_dfs()\n\n\n# Time:  O(n)\n# Space: O(h)\n# dfs\nclass Solution2(object):\n    def mostProfitablePath(self, edges, bob, amount):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type bob: int\n        :type amount: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(u, ah):\n            lookup[u] = True\n            result = 0 if len(adj[u])+(u == 0) == 1 else float(\"-inf\")\n            bh = 0 if u == bob else float(\"inf\")\n            for v in adj[u]:\n                if lookup[v]:\n                    continue\n                r, h = dfs(v, ah+1)\n                result = max(result, r)\n                bh = min(bh, h)\n            if ah == bh:\n                result += amount[u]//2\n            elif ah < bh:\n                result += amount[u]\n            return result, bh+1\n\n        adj = [[] for _ in xrange(len(edges)+1)]\n        lookup = [False]*len(adj)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return dfs(0, 0)[0]\n"
    },
    {
        "problem_name": "most-stones-removed-with-same-row-or-column",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\n\nclass Solution(object):\n    def removeStones(self, stones):\n        \"\"\"\n        :type stones: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MAX_ROW = 10000\n        union_find = UnionFind(2*MAX_ROW)\n        for r, c in stones:\n            union_find.union_set(r, c+MAX_ROW)\n        return len(stones) - len({union_find.find_set(r) for r, _ in stones})\n"
    },
    {
        "problem_name": "most-visited-sector-in-a-circular-track",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def mostVisited(self, n, rounds):\n        \"\"\"\n        :type n: int\n        :type rounds: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return range(rounds[0], rounds[-1]+1) or \\\n               range(1, rounds[-1]+1) + range(rounds[0], n+1)\n"
    },
    {
        "problem_name": "move-pieces-to-obtain-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers\nclass Solution(object):\n    def canChange(self, start, target):\n        \"\"\"\n        :type start: str\n        :type target: str\n        :rtype: bool\n        \"\"\"\n        i = j = 0\n        while True:\n            while i < len(start) and start[i] == '_':\n                i += 1\n            while j < len(target) and target[j] == '_':\n                j += 1\n            if i == len(start) and j == len(target):\n                break\n            if i == len(start) or j == len(target) or start[i] != target[j] or \\\n               (start[i] == 'L' and i < j) or (start[i] == 'R' and i > j):\n                    return False\n            i += 1\n            j += 1\n        return True\n"
    },
    {
        "problem_name": "move-sub-tree-of-n-ary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\n\n# one pass solution without recursion\nclass Solution(object):\n    def moveSubTree(self, root, p, q):\n        \"\"\"\n        :type root: Node\n        :type p: Node\n        :type q: Node\n        :rtype: Node\n        \"\"\"\n        def iter_find_parents(node, parent, p, q, is_ancestor, lookup):\n            stk = [(1, [node, None, False])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, parent, is_ancestor = params\n                    if node in (p, q):\n                        lookup[node] = parent\n                        if len(lookup) == 2:\n                            return is_ancestor\n                    stk.append((2, [node, is_ancestor, reversed(node.children)]))\n                else:\n                    node, is_ancestor, it = params\n                    child = next(it, None)\n                    if not child:\n                        continue\n                    stk.append((2, [node, is_ancestor, it]))\n                    stk.append((1, [child, node, is_ancestor or node == p]))\n            assert(False)\n            return False\n\n        lookup = {}\n        is_ancestor = iter_find_parents(root, None, p, q, False, lookup)\n        if p in lookup and lookup[p] == q:\n            return root\n        q.children.append(p)\n        if not is_ancestor:\n            lookup[p].children.remove(p)\n        else:\n            lookup[q].children.remove(q)\n            if p == root:\n                root = q\n            else:\n                lookup[p].children[lookup[p].children.index(p)] = q\n        return root\n\n\n# Time:  O(n)\n# Space: O(h)\n# one pass solution with recursion (bad in deep tree)\nclass Solution_Recu(object):\n    def moveSubTree(self, root, p, q):\n        \"\"\"\n        :type root: Node\n        :type p: Node\n        :type q: Node\n        :rtype: Node\n        \"\"\"\n        def find_parents(node, parent, p, q, is_ancestor, lookup):\n            if node in (p, q):\n                lookup[node] = parent\n                if len(lookup) == 2:\n                    return True, is_ancestor\n            for child in node.children:\n                found, new_is_ancestor = find_parents(child, node, p, q, is_ancestor or node == p, lookup)\n                if found:\n                    return True, new_is_ancestor\n            return False, False\n\n        lookup = {}\n        is_ancestor = find_parents(root, None, p, q, False, lookup)[1]\n        if p in lookup and lookup[p] == q:\n            return root\n        q.children.append(p)\n        if not is_ancestor:\n            lookup[p].children.remove(p)\n        else:\n            lookup[q].children.remove(q)\n            if p == root:\n                root = q\n            else:\n                lookup[p].children[lookup[p].children.index(p)] = q\n        return root\n\n\n# Time:  O(n)\n# Space: O(h)\n# two pass solution without recursion\nclass Solution2(object):\n    def moveSubTree(self, root, p, q):\n        \"\"\"\n        :type root: Node\n        :type p: Node\n        :type q: Node\n        :rtype: Node\n        \"\"\"\n        def iter_find_parents(node, parent, p, q, lookup):\n            stk = [(1, [node, None])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, parent = params\n                    if node in (p, q):\n                        lookup[node] = parent\n                        if len(lookup) == 2:\n                            return\n                    stk.append((2, [node, reversed(node.children)]))\n                else:\n                    node, it = params\n                    child = next(it, None)\n                    if not child:\n                        continue\n                    stk.append((2, [node, it]))\n                    stk.append((1, [child, node]))\n\n        def iter_is_ancestor(node, q):\n            stk = [(1, [node])]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node = params[0]\n                    stk.append((2, [reversed(node.children)]))\n                else:\n                    it = params[0]\n                    child = next(it, None)\n                    if not child:\n                        continue\n                    if child == q:\n                        return True\n                    stk.append((2, [it]))\n                    stk.append((1, [child]))\n            return False\n\n        lookup = {}\n        iter_find_parents(root, None, p, q, lookup)\n        if p in lookup and lookup[p] == q:\n            return root\n        q.children.append(p)\n        if not iter_is_ancestor(p, q):\n            lookup[p].children.remove(p)\n        else:\n            lookup[q].children.remove(q)\n            if p == root:\n                root = q\n            else:\n                lookup[p].children[lookup[p].children.index(p)] = q\n        return root\n\n\n# Time:  O(n)\n# Space: O(h)\n# two pass solution with recursion (bad in deep tree)\nclass Solution2_Recu(object):\n    def moveSubTree(self, root, p, q):\n        \"\"\"\n        :type root: Node\n        :type p: Node\n        :type q: Node\n        :rtype: Node\n        \"\"\"\n        def find_parents(node, parent, p, q, lookup):\n            if node in (p, q):\n                lookup[node] = parent\n                if len(lookup) == 2:\n                    return True\n            for child in node.children:\n                if find_parents(child, node, p, q, lookup):\n                    return True\n            return False\n\n        def is_ancestor(node, q):\n            for child in node.children:\n                if node == q or is_ancestor(child, q):\n                    return True\n            return False\n\n        lookup = {}\n        find_parents(root, None, p, q, lookup)\n        if p in lookup and lookup[p] == q:\n            return root\n        q.children.append(p)\n        if not is_ancestor(p, q):\n            lookup[p].children.remove(p)\n        else:\n            lookup[q].children.remove(q)\n            if p == root:\n                root = q\n            else:\n                lookup[p].children[lookup[p].children.index(p)] = q\n        return root\n"
    },
    {
        "problem_name": "move-zeroes",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[i], nums[pos] = nums[pos], nums[i]\n                pos += 1\n\n    def moveZeroes2(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort(cmp=lambda a, b: 0 if b else -1)\n\n\nclass Solution2(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i]:\n                nums[pos] = nums[i]\n                pos += 1\n\n        for i in xrange(pos, len(nums)):\n            nums[i] = 0\n\n\n"
    },
    {
        "problem_name": "movement-of-robots",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, math\nclass Solution(object):\n    def sumDistance(self, nums, s, d):\n        \"\"\"\n        :type nums: List[int]\n        :type s: str\n        :type d: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        for i in xrange(len(nums)):\n            nums[i] += d if s[i] == 'R' else -d\n        nums.sort()\n        return reduce(lambda x, y: (x+y)%MOD, ((i-(len(nums)-(i+1)))*x for i, x in enumerate(nums)))\n"
    },
    {
        "problem_name": "moving-average-from-data-stream",
        "solution": "# Time:  O(1)\n# Space: O(w)\n\nfrom collections import deque\n\nclass MovingAverage(object):\n\n    def __init__(self, size):\n        \"\"\"\n        Initialize your data structure here.\n        :type size: int\n        \"\"\"\n        self.__size = size\n        self.__sum = 0\n        self.__q = deque()\n\n    def next(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: float\n        \"\"\"\n        if len(self.__q) == self.__size:\n            self.__sum -= self.__q.popleft()\n        self.__sum += val\n        self.__q.append(val)\n        return 1.0 * self.__sum / len(self.__q)\n\n\n\n"
    },
    {
        "problem_name": "moving-stones-until-consecutive-ii",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def numMovesStonesII(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: List[int]\n        \"\"\"\n        stones.sort()\n        left, min_moves = 0, float(\"inf\")\n        max_moves = max(stones[-1]-stones[1], stones[-2]-stones[0]) - (len(stones)-2)\n        for right in xrange(len(stones)):\n            while stones[right]-stones[left]+1 > len(stones): # find window size <= len(stones)\n                left += 1\n            if len(stones)-(right-left+1) == 1 and stones[right]-stones[left]+1 == len(stones)-1:\n                min_moves = min(min_moves, 2)  # case (1, 2, 3, 4), 7\n            else:\n                min_moves = min(min_moves, len(stones)-(right-left+1))  # move stones not in this window\n        return [min_moves, max_moves]\n"
    },
    {
        "problem_name": "moving-stones-until-consecutive",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def numMovesStones(self, a, b, c):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type c: int\n        :rtype: List[int]\n        \"\"\"\n        s = [a, b, c]\n        s.sort()\n        if s[0]+1 == s[1] and s[1]+1 == s[2]:\n            return [0, 0]\n        return [1 if s[0]+2 >= s[1] or s[1]+2 >= s[2] else 2, s[2]-s[0]-2]\n\n\n# Time:  O(1)\n# Space: O(1)\nclass Solution2(object):\n    def numMovesStones(self, a, b, c):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type c: int\n        :rtype: List[int]\n        \"\"\"\n        stones = [a, b, c]\n        stones.sort()\n        left, min_moves = 0, float(\"inf\")\n        max_moves = (stones[-1]-stones[0]) - (len(stones)-1)\n        for right in xrange(len(stones)):\n            while stones[right]-stones[left]+1 > len(stones): # find window size <= len(stones)\n                left += 1\n            min_moves = min(min_moves, len(stones)-(right-left+1))  # move stones not in this window\n        return [min_moves, max_moves]\n"
    },
    {
        "problem_name": "multiply-strings",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nclass Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        result = [0]*(len(num1)+len(num2))\n        for i in reversed(xrange(len(num1))):\n            for j in reversed(xrange(len(num2))):\n                result[i+j+1] += int(num1[i])*int(num2[j])\n                result[i+j] += result[i+j+1]//10\n                result[i+j+1] %= 10\n        for i in xrange(len(result)):\n            if result[i]:\n                break\n        return \"\".join(map(lambda x: str(x), result[i:]))\n\n# Time:  O(m * n)\n# Space: O(m + n)\nclass Solution2(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        num1, num2 = num1[::-1], num2[::-1]\n        result = [0]*(len(num1)+len(num2))\n        for i in xrange(len(num1)):\n            for j in xrange(len(num2)):\n                result[i+j] += int(num1[i])*int(num2[j])\n                result[i+j+1] += result[i+j]//10\n                result[i+j] %= 10\n        for i in reversed(xrange(len(result))):\n            if result[i]:\n                break\n        return \"\".join(map(str, result[i::-1]))\n\n# Time:  O(m * n)\n# Space: O(m + n)\n# Using built-in bignum solution.\nclass Solution3(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        return str(int(num1) * int(num2))\n"
    },
    {
        "problem_name": "my-calendar-i",
        "solution": "# Time:  O(nlogn) on average, O(n^2) on worst case\n# Space: O(n)\n\nclass Node(object):\n    def __init__(self, start, end):\n        self.__start = start\n        self.__end = end\n        self.__left = None\n        self.__right = None\n\n\n    def insert(self, node):\n        if node.__start >= self.__end:\n            if not self.__right:\n                self.__right = node\n                return True\n            return self.__right.insert(node)\n        elif node.__end <= self.__start:\n            if not self.__left:\n                self.__left = node\n                return True\n            return self.__left.insert(node)\n        else:\n            return False\n\n\nclass MyCalendar(object):\n    def __init__(self):\n        self.__root = None\n\n\n    def book(self, start, end):\n        \"\"\"\n        :type start: int\n        :type end: int\n        :rtype: bool\n        \"\"\"\n        if self.__root is None:\n            self.__root = Node(start, end)\n            return True\n        return self.root.insert(Node(start, end))\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass MyCalendar2(object):\n\n    def __init__(self):\n        self.__calendar = []\n\n\n    def book(self, start, end):\n        \"\"\"\n        :type start: int\n        :type end: int\n        :rtype: bool\n        \"\"\"\n        for i, j in self.__calendar:\n            if start < j and end > i:\n                return False\n        self.__calendar.append((start, end))\n        return True\n\n\n\n"
    },
    {
        "problem_name": "my-calendar-ii",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass MyCalendarTwo(object):\n\n    def __init__(self):\n        self.__overlaps = []\n        self.__calendar = []\n\n\n    def book(self, start, end):\n        \"\"\"\n        :type start: int\n        :type end: int\n        :rtype: bool\n        \"\"\"\n        for i, j in self.__overlaps:\n            if start < j and end > i:\n                return False\n        for i, j in self.__calendar:\n            if start < j and end > i:\n                self.__overlaps.append((max(start, i), min(end, j)))\n        self.__calendar.append((start, end))\n        return True\n\n\n\n"
    },
    {
        "problem_name": "my-calendar-iii",
        "solution": "# Time:  O(nlogn) ~ O(n^2)\n# Space: O(n)\n\nimport bisect\n\n\nclass MyCalendarThree(object):\n\n    def __init__(self):\n        self.__books = [[-1, 0]]\n        self.__count = 0\n\n    def book(self, start, end):\n        \"\"\"\n        :type start: int\n        :type end: int\n        :rtype: int\n        \"\"\"\n        i = bisect.bisect_right(self.__books, [start, float(\"inf\")])\n        if self.__books[i-1][0] == start:\n            i -= 1\n        else:\n            self.__books.insert(i, [start, self.__books[i-1][1]])\n        j = bisect.bisect_right(self.__books, [end, float(\"inf\")])\n        if self.__books[j-1][0] == end:\n            j -= 1\n        else:\n            self.__books.insert(j, [end, self.__books[j-1][1]])            \n        for k in xrange(i, j):\n            self.__books[k][1] += 1\n            self.__count = max(self.__count, self.__books[k][1])\n        return self.__count\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass MyCalendarThree2(object):\n\n    def __init__(self):\n        self.__books = []\n\n\n    def book(self, start, end):\n        \"\"\"\n        :type start: int\n        :type end: int\n        :rtype: int\n        \"\"\"\n        i = bisect.bisect_left(self.__books, (start, 1))\n        if i < len(self.__books) and self.__books[i][0] == start:\n            self.__books[i] = (self.__books[i][0], self.__books[i][1]+1)\n        else:\n            self.__books.insert(i, (start, 1))\n\n        j = bisect.bisect_left(self.__books, (end, 1))\n        if j < len(self.__books) and self.__books[j][0] == end:\n            self.__books[j] = (self.__books[j][0], self.__books[j][1]-1)\n        else:\n            self.__books.insert(j, (end, -1))\n\n        result, cnt = 0, 0\n        for book in self.__books:\n            cnt += book[1]\n            result = max(result, cnt)\n        return result\n\n"
    },
    {
        "problem_name": "n-ary-tree-level-order-traversal",
        "solution": "# Time:  O(n)\n# Space: O(w)\n\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\n\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n        result, q = [], [root]\n        while q:\n            result.append([node.val for node in q])\n            q = [child for node in q for child in node.children if child]\n        return result\n\n"
    },
    {
        "problem_name": "n-ary-tree-postorder-traversal",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\n\nclass Solution(object):\n    def postorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        result, stack = [], [root]\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            for child in node.children:\n                if child:\n                    stack.append(child)\n        return result[::-1]\n\n\nclass Solution2(object):\n    def postorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        def dfs(root, result):\n            for child in root.children:\n                if child:\n                    dfs(child, result)\n            result.append(root.val)\n        \n        result = []\n        if root:\n            dfs(root, result)\n        return result\n\n"
    },
    {
        "problem_name": "n-ary-tree-preorder-traversal",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\n\nclass Solution(object):\n    def preorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        result, stack = [], [root]\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            for child in reversed(node.children):\n                if child:\n                    stack.append(child)\n        return result\n\n\nclass Solution2(object):\n    def preorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        def dfs(root, result):\n            result.append(root.val)\n            for child in root.children:\n                if child:\n                    dfs(child, result)\n        \n        result = []\n        if root:\n            dfs(root, result)\n        return result\n\n"
    },
    {
        "problem_name": "n-queens-ii",
        "solution": "# Time:  O(n!)\n# Space: O(n)\n\nclass Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def dfs(row):\n            if row == n:\n                return 1\n            result = 0\n            for i in xrange(n):\n                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:\n                    continue\n                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True\n                result += dfs(row+1)\n                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False\n            return result\n\n        result = []\n        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)\n        return dfs(0)\n\n"
    },
    {
        "problem_name": "n-queens",
        "solution": "# Time:  O(n^2 * n!)\n# Space: O(n)\n\nclass Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        def dfs(row):\n            if row == n:\n                result.append(map(lambda x: '.'*x + \"Q\" + '.'*(n-x-1), curr))\n                return\n            for i in xrange(n):\n                if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]:\n                    continue\n                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True\n                curr.append(i)\n                dfs(row+1)\n                curr.pop()\n                cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False\n\n        result, curr = [], []\n        cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)\n        dfs(0)\n        return result\n\n\n# For any point (x,y), if we want the new point (p,q) don't share the same row, column, or diagonal.\n# then there must have ```p+q != x+y``` and ```p-q!= x-y```\n# the former focus on eliminate 'left bottom right top' diagonal\n# the latter focus on eliminate 'left top right bottom' diagonal\n\n# - col_per_row: the list of column index per row\n# - cur_row\uff1acurrent row we are seraching for valid column\n# - xy_diff\uff1athe list of x-y\n# - xy_sum\uff1athe list of x+y\nclass Solution2(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        def dfs(col_per_row, xy_diff, xy_sum):\n            cur_row = len(col_per_row)\n            if cur_row == n:\n                ress.append(col_per_row)\n            for col in range(n):\n                if col not in col_per_row and cur_row-col not in xy_diff and cur_row+col not in xy_sum:\n                    dfs(col_per_row+[col], xy_diff+[cur_row-col], xy_sum+[cur_row+col])\n        ress = []\n        dfs([], [], [])\n        return [['.'*i + 'Q' + '.'*(n-i-1) for i in res] for res in ress]\n\n\n"
    },
    {
        "problem_name": "n-repeated-element-in-size-2n-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def repeatedNTimes(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        for i in xrange(2, len(A)):\n            if A[i-1] == A[i] or A[i-2] == A[i]:\n                return A[i]\n        return A[0]\n"
    },
    {
        "problem_name": "n-th-tribonacci-number",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def tribonacci(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))] \\\n                      for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n                     for col in ZB] for row in A]\n\n        T = [[1, 1, 0],\n             [1, 0, 1],\n             [1, 0, 0]]\n        return matrix_mult([[1, 0, 0]], matrix_expo(T, n))[0][1]  # [a1, a0, a(-1)] * T^n\n    \n    \n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def tribonacci(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        a, b, c = 0, 1, 1\n        for _ in xrange(n):\n            a, b, c = b, c, a+b+c\n        return a\n"
    },
    {
        "problem_name": "naming-a-company",
        "solution": "# Time:  O(26 * n * l)\n# Space: O(n * l)\n\n# hash table, math\nclass Solution(object):\n    def distinctNames(self, ideas):\n        \"\"\"\n        :type ideas: List[str]\n        :rtype: int\n        \"\"\"\n        lookup = [set() for _ in xrange(26)]\n        for x in ideas:\n            lookup[ord(x[0])-ord('a')].add(x[1:])\n        result = 0\n        for i in xrange(len(lookup)):\n            for j in xrange(i+1, len(lookup)):\n                common = len(lookup[i]&lookup[j])\n                result += (len(lookup[i])-common)*(len(lookup[j])-common)\n        return result*2\n"
    },
    {
        "problem_name": "nearest-exit-from-entrance-in-maze",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\n# bi-bfs solution\nclass Solution(object):\n    def nearestExit(self, maze, entrance):\n        \"\"\"\n        :type maze: List[List[str]]\n        :type entrance: List[int]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        visited = ' '\n        entrance = tuple(entrance)\n        left = set([entrance])\n        right = set([(r, 0) for r in xrange(len(maze)-1) if maze[r][0] == '.' and (r, 0) != entrance] +\n                    [(len(maze)-1, c) for c in xrange(len(maze[0])-1) if maze[len(maze)-1][c] == '.' and (len(maze)-1, c) != entrance] +\n                    [(r, len(maze[0])-1) for r in reversed(xrange(1, len(maze))) if maze[r][len(maze[0])-1] == '.' and (r, len(maze[0])-1) != entrance] +\n                    [(0, c) for c in reversed(xrange(1, len(maze[0]))) if maze[0][c] == '.' and (0, c) != entrance])\n        steps = 0\n        while left:\n            for (r, c) in left:\n                maze[r][c] = visited\n            new_left = set()\n            for (r, c) in left:\n                if (r, c) in right: \n                    return steps\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(maze) and\n                            0 <= nc < len(maze[0]) and\n                            maze[nr][nc] == '.'):\n                        continue\n                    new_left.add((nr, nc))\n            left = new_left\n            steps += 1\n            if len(left) > len(right): \n                left, right = right, left\n        return -1\n\n\n# Time:  O(m * n)\n# Space: O(m + n)\n# bfs solution\nclass Solution2(object):\n    def nearestExit(self, maze, entrance):\n        \"\"\"\n        :type maze: List[List[str]]\n        :type entrance: List[int]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        visited = ' '\n        entrance = tuple(entrance)\n        maze[entrance[0]][entrance[1]] = visited\n        q = [(entrance, 0)]\n        while q:\n            new_q = []\n            for (r, c), step in q:\n                if (r, c) != entrance and \\\n                   (r in (0, len(maze)-1) or c in (0, len(maze[0])-1)):\n                    return step\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(maze) and\n                            0 <= nc < len(maze[0]) and\n                            maze[nr][nc] == '.'):\n                        continue\n                    maze[nr][nc] = visited\n                    q.append(((nr, nc), step+1))\n            q = new_q\n        return -1\n"
    },
    {
        "problem_name": "neighboring-bitwise-xor",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def doesValidArrayExist(self, derived):\n        \"\"\"\n        :type derived: List[int]\n        :rtype: bool\n        \"\"\"\n        return reduce(lambda total, x: total^x, derived, 0) == 0\n"
    },
    {
        "problem_name": "neither-minimum-nor-maximum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# one pass, array\nclass Solution(object):\n    def findNonMinOrMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        mx, mn = float(\"-inf\"), float(\"inf\")\n        result = -1\n        for x in nums:\n            if mn < x < mx:\n                return x\n            if x < mn:\n                result = mn\n                mn = x\n            if x > mx:\n                result = mx\n                mx = x\n        return result if mn < result < mx else -1\n\n\n# Time:  O(n)\n# Space: O(1)\n# array\nclass Solution2(object):\n    def findNonMinOrMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        mx, mn = max(nums), min(nums)\n        return next((x for x in nums if x not in (mx, mn)), -1)\n"
    },
    {
        "problem_name": "nested-list-weight-sum-ii",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def depthSumInverse(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: int\n        \"\"\"\n        def depthSumInverseHelper(list, depth, result):\n            if len(result) < depth + 1:\n                result.append(0)\n            if list.isInteger():\n                result[depth] += list.getInteger()\n            else:\n                for l in list.getList():\n                    depthSumInverseHelper(l, depth + 1, result)\n\n        result = []\n        for list in nestedList:\n            depthSumInverseHelper(list, 0, result)\n\n        sum = 0\n        for i in reversed(xrange(len(result))):\n            sum += result[i] * (len(result) - i)\n        return sum\n\n"
    },
    {
        "problem_name": "nested-list-weight-sum",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def depthSum(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: int\n        \"\"\"\n        def depthSumHelper(nestedList, depth):\n            res = 0\n            for l in nestedList:\n                if l.isInteger():\n                    res += l.getInteger() * depth\n                else:\n                    res += depthSumHelper(l.getList(), depth + 1)\n            return res\n        return depthSumHelper(nestedList, 1)\n\n"
    },
    {
        "problem_name": "network-delay-time",
        "solution": "# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,\n#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport collections\nimport heapq\n\n# Dijkstra's algorithm\nclass Solution(object):\n    def networkDelayTime(self, times, N, K):\n        \"\"\"\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n        adj = [[] for _ in xrange(N)]\n        for u, v, w in times:\n            adj[u-1].append((v-1, w))\n\n        result = 0\n        lookup = set()\n        best = collections.defaultdict(lambda: float(\"inf\"))\n        best[K-1] = 0\n        min_heap = [(0, K-1)]\n        while min_heap and len(lookup) != N:\n            result, u = heapq.heappop(min_heap)\n            lookup.add(u)\n            if best[u] < result:\n                continue\n            for v, w in adj[u]:\n                if v in lookup: continue\n                if result+w < best[v]:\n                    best[v] = result+w\n                    heapq.heappush(min_heap, (result+w, v))\n        return result if len(lookup) == N else -1\n\n"
    },
    {
        "problem_name": "next-closest-time",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def nextClosestTime(self, time):\n        \"\"\"\n        :type time: str\n        :rtype: str\n        \"\"\"\n        h, m = time.split(\":\")\n        curr = int(h) * 60 + int(m)\n        result = None\n        for i in xrange(curr+1, curr+1441):\n            t = i % 1440\n            h, m = t // 60, t % 60\n            result = \"%02d:%02d\" % (h, m)\n            if set(result) <= set(time):\n                break\n        return result\n\n"
    },
    {
        "problem_name": "next-greater-element-i",
        "solution": "# Time:  O(m + n)\n# Space: O(m + n)\n\nclass Solution(object):\n    def nextGreaterElement(self, findNums, nums):\n        \"\"\"\n        :type findNums: List[int]\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        stk, lookup = [], {}\n        for num in nums:\n            while stk and num > stk[-1]:\n                lookup[stk.pop()] = num\n            stk.append(num)\n        while stk:\n            lookup[stk.pop()] = -1\n        return map(lambda x : lookup[x], findNums)\n\n"
    },
    {
        "problem_name": "next-greater-element-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def nextGreaterElements(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result, stk = [0] * len(nums), []\n        for i in reversed(xrange(2*len(nums))):\n            while stk and stk[-1] <= nums[i % len(nums)]:\n                stk.pop()\n            result[i % len(nums)] = stk[-1] if stk else -1\n            stk.append(nums[i % len(nums)])\n        return result\n\n"
    },
    {
        "problem_name": "next-greater-element-iii",
        "solution": "# Time:  O(logn) = O(1)\n# Space: O(logn) = O(1)\n\n\nclass Solution(object):\n    def nextGreaterElement(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        digits = map(int, list(str(n)))\n        k, l = -1, 0\n        for i in xrange(len(digits) - 1):\n            if digits[i] < digits[i + 1]:\n                k = i\n\n        if k == -1:\n            digits.reverse()\n            return -1\n\n        for i in xrange(k + 1, len(digits)):\n            if digits[i] > digits[k]:\n                l = i\n\n        digits[k], digits[l] = digits[l], digits[k]\n        digits[k + 1:] = digits[:k:-1]\n        result = int(\"\".join(map(str, digits)))\n        return -1 if result >= 0x7FFFFFFF else result\n\n"
    },
    {
        "problem_name": "next-greater-element-iv",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# mono stack\nclass Solution(object):\n    def secondGreaterElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result, stk1, stk2 = [-1]*len(nums), [], []\n        for i, x in enumerate(nums):\n            while stk2 and nums[stk2[-1]] < x:\n                result[stk2.pop()] = x\n            tmp = []\n            while stk1 and nums[stk1[-1]] < x:\n                tmp.append(stk1.pop())\n            stk1.append(i)\n            for x in reversed(tmp):\n                stk2.append(x)\n        return result\n"
    },
    {
        "problem_name": "next-greater-node-in-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def nextLargerNodes(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: List[int]\n        \"\"\"\n        result, stk = [], []\n        while head:\n            while stk and stk[-1][1] < head.val:\n                result[stk.pop()[0]] = head.val\n            stk.append([len(result), head.val])\n            result.append(0)\n            head = head.next\n        return result\n"
    },
    {
        "problem_name": "next-greater-numerically-balanced-number",
        "solution": "# Time:  O(logc) = O(1)\n# Space: O(c) = O(1)\n\nimport bisect\n\n\nclass Solution(object):\n    def nextBeautifulNumber(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # precomputed by generating all balanced's permutations in solution2\n        # candidates = sorted(set(int(\"\".join(perm)) for x in [1, 22, 122, 333, 1333, 4444, 14444, 22333, 55555, 122333, 155555, 224444, 666666] for perm in itertools.permutations(str(x)))) + [1224444]\n        candidates = [     1,     22,    122,    212,    221,    333  , 1333,   3133,   3313,   3331,\n                        4444,  14444,  22333,  23233,  23323,  23332,  32233,  32323,  32332,  33223,\n                       33232,  33322,  41444,  44144,  44414,  44441,  55555, 122333, 123233, 123323,\n                      123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233,\n                      213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332,\n                      232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444,\n                      244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233,\n                      321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312,\n                      323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321,\n                      333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442,\n                      444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444]\n        return candidates[bisect.bisect_right(candidates, n)]\n\n\n# Time:  O(l * c) = O(1), c is the count of all balanced's permutations, l is the max length of permutations\n# Space: O(l * b) = O(1), b is the count of balanced\nclass Solution2(object):\n    def nextBeautifulNumber(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def next_permutation(nums, begin, end):\n            def reverse(nums, begin, end):\n                left, right = begin, end-1\n                while left < right:\n                    nums[left], nums[right] = nums[right], nums[left]\n                    left += 1\n                    right -= 1\n\n            k, l = begin-1, begin\n            for i in reversed(xrange(begin, end-1)):\n                if nums[i] < nums[i+1]:\n                    k = i\n                    break\n            else:\n                reverse(nums, begin, end)\n                return False\n            for i in reversed(xrange(k+1, end)):\n                if nums[i] > nums[k]:\n                    l = i\n                    break\n            nums[k], nums[l] = nums[l], nums[k]\n            reverse(nums, k+1, end)\n            return True\n\n        # obtained by manually enumerating min number of permutations in each length\n        balanced = [1,\n                    22,\n                    122, 333,\n                    1333, 4444,\n                    14444, 22333, 55555,\n                    122333, 155555, 224444, 666666]\n        s = list(str(n))\n        result = 1224444\n        for x in balanced:\n            x = list(str(x))\n            if len(x) < len(s):\n                continue\n            if len(x) > len(s):\n                result = min(result, int(\"\".join(x)))\n                continue\n            while True:\n                if x > s:\n                    result = min(result, int(\"\".join(x)))\n                if not next_permutation(x, 0, len(x)):  # distinct permutations\n                    break\n        return result\n\n\n# Time:  O(l * c) = O(1), c is the count of all balanced's permutations, l is the max length of permutations\n# Space: O(l * b) = O(1), b is the count of balanced\nimport itertools\n\n\nclass Solution3(object):\n    def nextBeautifulNumber(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # obtained by manually enumerating min number of permutations in each length\n        balanced = [1,\n                    22,\n                    122, 333,\n                    1333, 4444,\n                    14444, 22333, 55555,\n                    122333, 155555, 224444, 666666]\n        s = tuple(str(n))\n        result = 1224444\n        for x in balanced:\n            x = tuple(str(x))\n            if len(x) < len(s):\n                continue\n            if len(x) > len(s):\n                result = min(result, int(\"\".join(x)))\n                continue\n            for perm in itertools.permutations(x):  # not distinct permutations\n                if perm > s:\n                    result = min(result, int(\"\".join(perm)))\n        return result\n"
    },
    {
        "problem_name": "next-palindrome-using-same-digits",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def nextPalindrome(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        def next_permutation(nums, begin, end):\n            def reverse(nums, begin, end):\n                left, right = begin, end-1\n                while left < right:\n                    nums[left], nums[right] = nums[right], nums[left]\n                    left += 1\n                    right -= 1\n\n            k, l = begin-1, begin\n            for i in reversed(xrange(begin, end-1)):\n                if nums[i] < nums[i+1]:\n                    k = i\n                    break\n            else:\n                reverse(nums, begin, end)\n                return False\n            for i in reversed(xrange(k+1, end)):\n                if nums[i] > nums[k]:\n                    l = i\n                    break\n            nums[k], nums[l] = nums[l], nums[k]\n            reverse(nums, k+1, end)\n            return True\n        \n        nums = list(num)\n        if not next_permutation(nums, 0, len(nums)//2):\n            return \"\"\n        for i in xrange(len(nums)//2):\n            nums[-1-i] = nums[i]\n        return \"\".join(nums)\n"
    },
    {
        "problem_name": "next-permutation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in reversed(xrange(len(nums)-1)):\n            if nums[i] < nums[i+1]:\n                k = i\n                break\n        else:\n            nums.reverse()\n            return\n\n        for i in reversed(xrange(k+1, len(nums))):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]\n        \n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k, l = -1, 0\n        for i in xrange(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n\n        if k == -1:\n            nums.reverse()\n            return\n\n        for i in xrange(k+1, len(nums)):\n            if nums[i] > nums[k]:\n                l = i\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k+1:] = nums[:k:-1]\n"
    },
    {
        "problem_name": "nim-game",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n % 4 != 0\n\n"
    },
    {
        "problem_name": "node-with-highest-edge-score",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# freq table\nclass Solution(object):\n    def edgeScore(self, edges):\n        \"\"\"\n        :type edges: List[int]\n        :rtype: int\n        \"\"\"\n        score = [0]*len(edges)\n        for u, v in enumerate(edges):\n            score[v] += u\n        return max(xrange(len(edges)), key=lambda x:score[x])\n    \n"
    },
    {
        "problem_name": "non-decreasing-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def checkPossibility(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        modified, prev = False, nums[0]\n        for i in xrange(1, len(nums)):\n            if prev > nums[i]:\n                if modified:\n                    return False\n                if i-2 < 0 or nums[i-2] <= nums[i]:\n                    prev = nums[i]    # nums[i-1] = nums[i], prev = nums[i]\n#               else:\n#                   prev = nums[i-1]  # nums[i] = nums[i-1], prev = nums[i]\n                modified = True\n            else:\n                prev = nums[i]\n        return True\n\n\n"
    },
    {
        "problem_name": "non-negative-integers-without-consecutive-ones",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def findIntegers(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        dp = [0] * 32\n        dp[0], dp[1] = 1, 2\n        for i in xrange(2, len(dp)):\n            dp[i] = dp[i-1] + dp[i-2]\n        result, prev_bit = 0, 0\n        for i in reversed(xrange(31)):\n            if (num & (1 << i)) != 0:\n                result += dp[i]\n                if prev_bit == 1:\n                    result -= 1\n                    break\n                prev_bit = 1\n            else:\n                prev_bit = 0\n        return result + 1\n\n"
    },
    {
        "problem_name": "non-overlapping-intervals",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def eraseOverlapIntervals(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        intervals.sort(key=lambda interval: interval.start)\n        result, prev = 0, 0\n        for i in xrange(1, len(intervals)):\n            if intervals[i].start < intervals[prev].end:\n                if intervals[i].end < intervals[prev].end:\n                    prev = i\n                result += 1\n            else:\n                prev = i\n        return result\n\n"
    },
    {
        "problem_name": "nth-digit",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def findNthDigit(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        digit_len = 1\n        while n > digit_len * 9 * (10 ** (digit_len-1)):\n            n -= digit_len  * 9 * (10 ** (digit_len-1))\n            digit_len += 1\n\n        num = 10 ** (digit_len-1) + (n-1)/digit_len\n\n        nth_digit = num / (10 ** ((digit_len-1) - ((n-1)%digit_len)))\n        nth_digit %= 10\n\n        return nth_digit\n\n"
    },
    {
        "problem_name": "nth-magical-number",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def nthMagicalNumber(self, N, A, B):\n        \"\"\"\n        :type N: int\n        :type A: int\n        :type B: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        def check(A, B, N, lcm, target):\n            return target//A + target//B - target//lcm >= N\n\n        lcm = A*B // gcd(A, B)\n        left, right = min(A, B), max(A, B)*N\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(A, B, N, lcm, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left % (10**9 + 7)\n\n"
    },
    {
        "problem_name": "number-complement",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        return 2 ** (len(bin(num)) - 2) - 1 - num\n\n\nclass Solution2(object):\n    def findComplement(self, num):\n        i = 1\n        while i <= num:\n            i <<= 1\n        return (i - 1) ^ num\n\n\nclass Solution3(object):\n    def findComplement(self, num):\n        bits = '{0:b}'.format(num)\n        complement_bits = ''.join('1' if bit == '0' else '0' for bit in bits)\n        return int(complement_bits, 2)\n\n"
    },
    {
        "problem_name": "number-of-1-bits",
        "solution": "# Time:  O(32), bit shift in python is not O(1), it's O(k), k is the number of bits shifted\n#             , see https://github.com/python/cpython/blob/2.7/Objects/longobject.c#L3652\n# Space: O(1)\n\nclass Solution(object):\n    # @param n, an integer\n    # @return an integer\n    def hammingWeight(self, n):\n        n = (n & 0x55555555) + ((n >> 1) & 0x55555555)\n        n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n        n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)\n        n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)\n        n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)\n        return n\n\n\n# Time:  O(logn/4) = O(32/4 + 8*4) = O(32)\n# Space: O(1) \n# https://github.com/gcc-mirror/gcc/blob/master/libgcc/libgcc2.c#L856\nclass Solution2(object):\n    def __init__(self):\n        self.__popcount_tab = \\\n        [ \\\n            0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5, \\\n            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6, \\\n            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6, \\\n            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7, \\\n            1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6, \\\n            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7, \\\n            2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7, \\\n            3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8 \\\n        ]\n\n    # @param n, an integer\n    # @return an integer\n    def hammingWeight(self, n):\n        result = 0\n        while n:\n            result += self.__popcount_tab[n & 0xff]\n            n >>= 8\n        return result\n\n    \n# Time:  O(logn) = O(32)\n# Space: O(1)\nclass Solution3(object):\n    # @param n, an integer\n    # @return an integer\n    def hammingWeight(self, n):\n        result = 0\n        while n:\n            n &= n - 1\n            result += 1\n        return result\n\n"
    },
    {
        "problem_name": "number-of-adjacent-elements-with-the-same-color",
        "solution": "# Time:  O(n + q)\n# Space: O(n)\n\n# array\nclass Solution(object):\n    def colorTheArray(self, n, queries):\n        \"\"\"\n        :type n: int\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def update(i):\n            if not nums[i]:\n                return 0\n            cnt = 0\n            if i-1 >= 0 and nums[i-1] == nums[i]:\n                cnt += 1\n            if i+1 < n and nums[i+1] == nums[i]:\n                cnt += 1\n            return cnt\n\n        nums = [0]*n\n        result = [0]*len(queries)\n        curr = 0\n        for idx, (i, c) in enumerate(queries):\n            curr -= update(i)\n            nums[i] = c\n            curr += update(i)\n            result[idx] = curr\n        return result\n"
    },
    {
        "problem_name": "number-of-arithmetic-triplets",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table\nclass Solution(object):\n    def arithmeticTriplets(self, nums, diff):\n        \"\"\"\n        :type nums: List[int]\n        :type diff: int\n        :rtype: int\n        \"\"\"\n        lookup = set(nums)\n        return sum((x-diff in lookup) and (x-2*diff in lookup) for x in nums)\n\n    \n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\n# dp\nclass Solution2(object):\n    def arithmeticTriplets(self, nums, diff):\n        \"\"\"\n        :type nums: List[int]\n        :type diff: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        cnt1 = collections.Counter()\n        cnt2 = collections.Counter()\n        for x in nums:\n            result += cnt2[x-diff]\n            cnt2[x] += cnt1[x-diff]\n            cnt1[x] += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-atoms",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\nimport re\n\n\nclass Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        parse = re.findall(r\"([A-Z][a-z]*)(\\d*)|(\\()|(\\))(\\d*)\", formula)\n        stk = [collections.Counter()]\n        for name, m1, left_open, right_open, m2 in parse:\n            if name:\n              stk[-1][name] += int(m1 or 1)\n            if left_open:\n              stk.append(collections.Counter())\n            if right_open:\n                top = stk.pop()\n                for k, v in top.iteritems():\n                  stk[-1][k] += v * int(m2 or 1)\n\n        return \"\".join(name + (str(stk[-1][name]) if stk[-1][name] > 1 else '') \\\n                       for name in sorted(stk[-1]))\n\n"
    },
    {
        "problem_name": "number-of-beautiful-integers-in-the-range",
        "solution": "# Time:  O(n^2 * k), n = len(str(high))\n# Space: O(n^2 * k)\n\n# memoization (faster but more space)\nclass Solution(object):\n    def numberOfBeautifulIntegers(self, low, high, k):\n        \"\"\"\n        :type low: int\n        :type high: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        TIGHT, UNTIGHT, UNBOUND = range(3)\n        def f(x):\n            digits = map(int, str(x))\n            lookup = [[[[-1]*k for _ in xrange(2*len(digits)+1)] for _ in xrange(3)] for _ in xrange(len(digits))]\n            def memoization(i, state, diff, total):\n                if i == len(digits):\n                    return int(state != UNBOUND and diff == total == 0)\n                if lookup[i][state][diff][total] == -1:\n                    result = int(i != 0 and diff == total == 0)  # count if the beautiful integer x s.t. len(str(x)) < len(digits)\n                    for d in xrange(1 if i == 0 else 0, 10):\n                        new_state = state\n                        if state == TIGHT and d != digits[i]:\n                            new_state = UNTIGHT if d < digits[i] else UNBOUND\n                        new_diff = diff+(1 if d%2 == 0 else -1)\n                        new_total = (total*10+d)%k\n                        result += memoization(i+1, new_state, new_diff, new_total)\n                    lookup[i][state][diff][total] = result\n                return lookup[i][state][diff][total]\n    \n            return memoization(0, TIGHT, 0, 0)\n\n        return f(high)-f(low-1)\n\n\n# Time:  O(n^2 * k), n = len(str(high))\n# Space: O(n * k)\n# dp (slower but less space)\nclass Solution2(object):\n    def numberOfBeautifulIntegers(self, low, high, k):\n        \"\"\"\n        :type low: int\n        :type high: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        TIGHT, UNTIGHT, UNBOUND = range(3)\n        def f(x):\n            digits = map(int, str(x))\n            dp = [[[0]*k for _ in xrange(2*len(digits)+1)] for _ in xrange(3)]\n            for tight in xrange(2):\n                for state in (TIGHT, UNTIGHT):\n                    dp[state][0][0] = 1\n            for i in reversed(xrange(len(digits))):\n                new_dp = [[[0]*k for _ in xrange(2*len(digits)+1)] for _ in xrange(3)]\n                for state in (TIGHT, UNTIGHT, UNBOUND):\n                    new_dp[state][0][0] = int(i != 0)  # count if the beautiful integer x s.t. len(str(x)) < len(digits)\n                    for d in xrange(1 if i == 0 else 0, 10):\n                        new_state = state\n                        if state == TIGHT and d != digits[i]:\n                            new_state = UNTIGHT if d < digits[i] else UNBOUND\n                        for diff in xrange(-len(digits), len(digits)+1):\n                            new_diff = diff+(1 if d%2 == 0 else -1)\n                            for total in xrange(k):\n                                new_total = (total*10+d)%k\n                                new_dp[state][diff][total] += dp[new_state][new_diff][new_total]\n                dp = new_dp\n            return dp[TIGHT][0][0]\n\n        return f(high)-f(low-1)\n\n\n# Time:  O(n^2 * k), n = len(str(high))\n# Space: O(n^2 * k)\n# memoization (faster but more space)\nclass Solution3(object):\n    def numberOfBeautifulIntegers(self, low, high, k):\n        \"\"\"\n        :type low: int\n        :type high: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def f(x):\n            digits = map(int, str(x))\n            lookup = [[[[[-1]*k for _ in xrange(2*len(digits)+1)] for _ in xrange(2)] for _ in xrange(2)] for _ in xrange(len(digits))]\n            def memoization(i, zero, tight, diff, total):\n                if i == len(digits):\n                    return int(zero == diff == total == 0)\n                if lookup[i][zero][tight][diff][total] == -1:\n                    result = 0\n                    for d in xrange((digits[i] if tight else 9)+1):\n                        new_zero = int(zero and d == 0)\n                        new_tight = int(tight and d == digits[i])\n                        new_diff = diff+((1 if d%2 == 0 else -1) if new_zero == 0 else 0)\n                        new_total = (total*10+d)%k\n                        result += memoization(i+1, new_zero, new_tight, new_diff, new_total)\n                    lookup[i][zero][tight][diff][total] = result\n                return lookup[i][zero][tight][diff][total]\n    \n            return memoization(0, 1, 1, 0, 0)\n\n        return f(high)-f(low-1)\n\n\n# Time:  O(n^2 * k), n = len(str(high))\n# Space: O(n * k)\n# dp (slower but less space)\nclass Solution4(object):\n    def numberOfBeautifulIntegers(self, low, high, k):\n        \"\"\"\n        :type low: int\n        :type high: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def f(x):\n            digits = map(int, str(x))\n            dp = [[[[0]*k for _ in xrange(2*len(digits)+1)] for _ in xrange(2)] for _ in xrange(2)]\n            for tight in xrange(2):\n                dp[0][tight][0][0] = 1\n            for i in reversed(xrange(len(digits))):\n                new_dp = [[[[0]*k for _ in xrange(2*len(digits)+1)] for _ in xrange(2)] for _ in xrange(2)]\n                for zero in xrange(2):\n                    for tight in xrange(2):\n                        for d in xrange((digits[i] if tight else 9)+1):\n                            new_zero = int(zero and d == 0)\n                            new_tight = int(tight and d == digits[i])\n                            for diff in xrange(-len(digits), len(digits)+1):\n                                new_diff = diff+((1 if d%2 == 0 else -1) if new_zero == 0 else 0)\n                                for total in xrange(k):\n                                    new_total = (total*10+d)%k\n                                    new_dp[zero][tight][diff][total] += dp[new_zero][new_tight][new_diff][new_total]\n                dp = new_dp\n            return dp[1][1][0][0]\n\n        return f(high)-f(low-1)\n"
    },
    {
        "problem_name": "number-of-beautiful-pairs",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\n# number theory, freq table\nclass Solution(object):\n    def countBeautifulPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        result = 0\n        cnt = [0]*10\n        for x in nums:\n            for i in xrange(1, 10):\n                if gcd(i, x%10) == 1:\n                    result += cnt[i]\n            while x >= 10:\n                x //= 10\n            cnt[x] += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-beautiful-partitions",
        "solution": "# Time:  O(n * k)\n# Space: O(n)\n\n# dp\nclass Solution(object):\n    def beautifulPartitions(self, s, k, minLength):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :type minLength: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        PRIMES = {'2', '3', '5', '7'}\n        dp = [0]*len(s)  # dp[i] at j : number of j beautiful partitions in s[:i+1] \n        for i in xrange(minLength-1, len(s)):\n            if s[0] in PRIMES and s[i] not in PRIMES:\n                dp[i] = 1\n        for j in xrange(2, k+1):\n            new_dp = [0]*len(s)\n            curr = int(j == 1)\n            for i in xrange(j*minLength-1, len(s)):\n                if s[i-minLength+1] in PRIMES:\n                    curr = (curr+dp[i-minLength])%MOD\n                if s[i] not in PRIMES:\n                    new_dp[i] = curr\n            dp = new_dp\n        return dp[-1]\n"
    },
    {
        "problem_name": "number-of-black-blocks",
        "solution": "# Time:  O(c), c = len(coordinates)\n# Space: O(c)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def countBlackBlocks(self, m, n, coordinates):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type coordinates: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        L = 2\n\n        cnt = collections.Counter()\n        for x, y in coordinates:\n            for nx in xrange(max(x-(L-1), 0), min(x+1, m-(L-1))):\n                for ny in xrange(max(y-(L-1), 0), min(y+1, n-(L-1))):\n                    cnt[nx, ny] += 1\n        result = [0]*(L**2+1)\n        for c in cnt.itervalues():\n            result[c] += 1\n        result[0] = (m-(L-1))*(n-(L-1))-sum(result[i] for i in xrange(1, len(result)))\n        return result\n"
    },
    {
        "problem_name": "number-of-boomerangs",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def numberOfBoomerangs(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result = 0\n\n        for i in xrange(len(points)):\n            group = collections.defaultdict(int)\n            for j in xrange(len(points)):\n                if j == i:\n                    continue\n                dx, dy =  points[i][0] - points[j][0], points[i][1] - points[j][1]\n                group[dx**2 + dy**2] += 1\n\n            for _, v in group.iteritems():\n                if v > 1:\n                    result += v * (v-1)\n\n        return result\n\n    def numberOfBoomerangs2(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        cnt = 0\n        for a, i in enumerate(points):\n            dis_list = []\n            for b, k in enumerate(points[:a] + points[a + 1:]):\n                dis_list.append((k[0] - i[0]) ** 2 + (k[1] - i[1]) ** 2)\n            for z in collections.Counter(dis_list).values():\n                if z > 1:\n                    cnt += z * (z - 1)\n        return cnt\n\n"
    },
    {
        "problem_name": "number-of-burgers-with-no-waste-of-ingredients",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\n        \"\"\"\n        :type tomatoSlices: int\n        :type cheeseSlices: int\n        :rtype: List[int]\n        \"\"\"\n        # let the number of jumbo burger be x, the number of small burger be y:\n        #   4x + 2y = t\n        #   x + y = c\n        #   =>\n        #   x = t/2-c\n        #   y = 2c-t/2\n        # since x, y are natural numbers\n        #   => t/2 is integer, t/2-c >= 0, 2c-t/2 >= 0\n        #   => t%2 == 0, 2c <= t <= 4c\n        return [tomatoSlices//2-cheeseSlices, 2*cheeseSlices - tomatoSlices//2] \\\n               if tomatoSlices%2 == 0 and 2*cheeseSlices <= tomatoSlices <= 4*cheeseSlices \\\n               else []\n"
    },
    {
        "problem_name": "number-of-changing-keys",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def countKeyChanges(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return sum(s[i].lower() != s[i+1].lower() for i in xrange(len(s)-1))\n"
    },
    {
        "problem_name": "number-of-closed-islands",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def closedIsland(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def fill(grid, i, j):\n            if not (0 <= i < len(grid) and \n                    0 <= j < len(grid[0]) and \n                    grid[i][j] == 0):\n                return False\n            grid[i][j] = 1\n            for dx, dy in directions:\n                fill(grid, i+dx, j+dy)\n            return True\n\n        for j in xrange(len(grid[0])):\n            fill(grid, 0, j)\n            fill(grid, len(grid)-1, j)\n        for i in xrange(1, len(grid)):\n            fill(grid, i, 0)\n            fill(grid, i, len(grid[0])-1)\n        result = 0\n        for i in xrange(1, len(grid)-1):\n            for j in xrange(1, len(grid[0])-1):\n                if fill(grid, i, j):\n                    result += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-common-factors",
        "solution": "# Time:  O(log(min(a, b)) + sqrt(gcd))\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def commonFactors(self, a, b):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):  # Time: O(log(min(a, b)))\n            while b:\n                a, b = b, a%b\n            return a\n        \n        g = gcd(a, b)\n        result = 0\n        x = 1\n        while x*x <= g:\n            if g%x == 0:\n                result += 1 if g//x == x else 2\n            x += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-connected-components-in-an-undirected-graph",
        "solution": "# Time:  O(nlog*n) ~= O(n), n is the length of the positions\n# Space: O(n)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n       if self.set[x] != x:\n           self.set[x] = self.find_set(self.set[x])  # path compression.\n       return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n            self.count -= 1\n\n\nclass Solution(object):\n    def countComponents(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        union_find = UnionFind(n)\n        for i, j in edges:\n            union_find.union_set(i, j)\n        return union_find.count\n\n"
    },
    {
        "problem_name": "number-of-corner-rectangles",
        "solution": "# Time:  O(n * m^2), n is the number of rows with 1s, m is the number of cols with 1s\n# Space: O(n * m)\n\nclass Solution(object):\n    def countCornerRectangles(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        rows = [[c for c, val in enumerate(row) if val]\n                for row in grid]\n        result = 0\n        for i in xrange(len(rows)):\n            lookup = set(rows[i])\n            for j in xrange(i):\n                count = sum(1 for c in rows[j] if c in lookup)\n                result += count*(count-1)/2\n        return result\n\n"
    },
    {
        "problem_name": "number-of-days-between-two-dates",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def __init__(self):\n        def dayOfMonth(M):\n            return (28 if (M == 2) else 31-(M-1)%7%2)\n\n        self.__lookup = [0]*12\n        for M in xrange(1, len(self.__lookup)):\n            self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M)\n\n    def daysBetweenDates(self, date1, date2):\n        \"\"\"\n        :type date1: str\n        :type date2: str\n        :rtype: int\n        \"\"\"\n        def num_days(date):\n            Y, M, D = map(int, date.split(\"-\"))\n            leap = 1 if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0\n            return (Y-1)*365 + ((Y-1)//4 - (Y-1)//100 + (Y-1)//400) + self.__lookup[M-1]+D+leap\n     \n        return abs(num_days(date1) - num_days(date2))\n\n\n# Time:  O(1)\n# Space: O(1)\nimport datetime\n\n\nclass Solution2(object):\n    def daysBetweenDates(self, date1, date2):        \n        delta = datetime.datetime.strptime(date1, \"%Y-%m-%d\")\n        delta -= datetime.datetime.strptime(date2, \"%Y-%m-%d\")\n        return abs(delta.days)\n"
    },
    {
        "problem_name": "number-of-days-in-a-month",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfDays(self, Y, M):\n        \"\"\"\n        :type Y: int\n        :type M: int\n        :rtype: int\n        \"\"\"\n        leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0\n        return (28+leap if (M == 2) else 31-(M-1)%7%2)\n        \n"
    },
    {
        "problem_name": "number-of-dice-rolls-with-target-sum",
        "solution": "# Time:  O(d * f * t)\n# Space: O(t)\n\nclass Solution(object):\n    def numRollsToTarget(self, d, f, target):\n        \"\"\"\n        :type d: int\n        :type f: int\n        :type target: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [[0 for _ in xrange(target+1)] for _ in xrange(2)]\n        dp[0][0] = 1\n        for i in xrange(1, d+1):\n            dp[i%2] = [0 for _ in xrange(target+1)]\n            for k in xrange(1, f+1):\n                for j in xrange(k, target+1):\n                    dp[i%2][j] = (dp[i%2][j] + dp[(i-1)%2][j-k]) % MOD\n        return dp[d%2][target] % MOD\n"
    },
    {
        "problem_name": "number-of-different-integers-in-a-string",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def numDifferentIntegers(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        result, num = set(), None\n        for i in xrange(len(word)+1):\n            c = word[i] if i < len(word) else ' '\n            if c.isdigit():\n                num = 10*num+int(c) if num is not None else int(c)\n            elif num is not None:\n                result.add(num)\n                num = None\n        return len(result)\n"
    },
    {
        "problem_name": "number-of-different-subsequences-gcds",
        "solution": "# Time:  O(n + m * (1 + 1/2 + 1/3 + ... + 1/m)) = O(n + mlogm), m is max of nums\n# Space: O(n)\n\nimport fractions\n\n\nclass Solution(object):\n    def countDifferentSubsequenceGCDs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_num, nums_set = max(nums), set(nums)\n        result = 0\n        for i in xrange(1, max_num+1):\n            d = 0\n            for x in xrange(i, max_num+1, i):\n                if x not in nums_set:\n                    continue\n                d = fractions.gcd(d, x)  # total time: O(log(min(d, x)) = O(logd), where d keeps the same or gets smaller\n                if d == i:\n                    result += 1\n                    break\n        return result\n"
    },
    {
        "problem_name": "number-of-digit-one",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        DIGIT = 1\n        is_zero = int(DIGIT == 0)\n        result = is_zero\n        base = 1\n        while n >= base:\n            result += (n//(10*base)-is_zero)*base + \\\n                      min(base, max(n%(10*base) - DIGIT*base + 1, 0))\n            base *= 10\n        return result\n\n"
    },
    {
        "problem_name": "number-of-distinct-averages",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# sort, two pointers, hash table\nclass Solution(object):\n    def distinctAverages(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = set()\n        nums.sort()\n        left, right = 0, len(nums)-1\n        while left < right:\n            lookup.add(nums[left]+nums[right])\n            left, right = left+1, right-1\n        return len(lookup)\n"
    },
    {
        "problem_name": "number-of-distinct-binary-strings-after-applying-operations",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# combinatorics\nclass Solution(object):\n    def countDistinctStrings(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        return pow(2, len(s)-k+1, MOD)\n"
    },
    {
        "problem_name": "number-of-distinct-islands-ii",
        "solution": "# Time:  O((m * n) * log(m * n))\n# Space: O(m * n)\n\nclass Solution(object):\n    def numDistinctIslands2(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def dfs(i, j, grid, island):\n            if not (0 <= i < len(grid) and \\\n                    0 <= j < len(grid[0]) and \\\n                    grid[i][j] > 0):\n                return False\n            grid[i][j] *= -1\n            island.append((i, j))\n            for d in directions:\n                dfs(i+d[0], j+d[1], grid, island)\n            return True\n\n        def normalize(island):\n            shapes = [[] for _ in xrange(8)]\n            for x, y in island:\n                rotations_and_reflections = [[ x,  y], [ x, -y], [-x, y], [-x, -y],\n                                             [ y,  x], [ y, -x], [-y, x], [-y, -x]]\n                for i in xrange(len(rotations_and_reflections)):\n                    shapes[i].append(rotations_and_reflections[i])\n            for shape in shapes:\n                shape.sort()  # Time: O(ilogi), i is the size of the island, the max would be (m * n)\n                origin = list(shape[0])\n                for p in shape:\n                    p[0] -= origin[0]\n                    p[1] -= origin[1]\n            return min(shapes)\n\n        islands = set()\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                island = []\n                if dfs(i, j, grid, island):\n                    islands.add(str(normalize(island)))\n        return len(islands)\n\n"
    },
    {
        "problem_name": "number-of-distinct-islands",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nclass Solution(object):\n    def numDistinctIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = {'l':[-1,  0], 'r':[ 1,  0], \\\n                      'u':[ 0,  1], 'd':[ 0, -1]}\n\n        def dfs(i, j, grid, island):\n            if not (0 <= i < len(grid) and \\\n                    0 <= j < len(grid[0]) and \\\n                    grid[i][j] > 0):\n                return False\n            grid[i][j] *= -1\n            for k, v in directions.iteritems():\n                island.append(k)\n                dfs(i+v[0], j+v[1], grid, island)\n            return True\n\n        islands = set()\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                island = []\n                if dfs(i, j, grid, island):\n                    islands.add(\"\".join(island))\n        return len(islands)\n\n"
    },
    {
        "problem_name": "number-of-distinct-roll-sequences",
        "solution": "# Time:  O(6^3 * n)\n# Space: O(6^2)\n\nimport collections\n\n\n# dp\nclass Solution(object):\n    def distinctSequences(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        if n == 1:\n            return 6\n        MOD = 10**9 + 7\n        dp = [[0]*6 for _ in xrange(6)]\n        for i in xrange(6):\n            for j in xrange(6):\n                if i != j and gcd(i+1, j+1) == 1:\n                    dp[i][j] = 1\n        for _ in xrange(n-2):\n            new_dp = [[0]*6 for _ in xrange(6)]\n            for i in xrange(6):\n                for j in xrange(6):\n                    if not dp[i][j]:\n                        continue\n                    for k in xrange(6):\n                        if not dp[j][k]:\n                            continue\n                        if k != i:\n                            new_dp[i][j] = (new_dp[i][j]+dp[j][k]) % MOD\n            dp = new_dp\n        return sum(dp[i][j] for i in xrange(6) for j in xrange(6)) % MOD\n"
    },
    {
        "problem_name": "number-of-distinct-subarrays-with-at-most-k-odd-integers",
        "solution": "# Time:  O(n^2)\n# Space: O(t), t is the size of trie\n\nimport collections\n\n\n# sliding window + trie solution\nclass Solution(object):\n    def distinctSubarraysWithAtMostKOddIntegers(self, A, K):\n        def countDistinct(A, left, right, trie):  # Time: O(n), Space: O(t)\n            result = 0\n            for i in reversed(xrange(left, right+1)):\n                if A[i] not in trie:\n                    result += 1\n                trie = trie[A[i]]\n            return result\n\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        result, left, count = 0, 0, 0\n        for right in xrange(len(A)):\n            count += A[right]%2\n            while count > K:\n                count -= A[left]%2\n                left += 1\n            result += countDistinct(A, left, right, trie)\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(t), t is the size of trie\n# suffix tree solution\nclass Solution2(object):\n    def distinctSubarraysWithAtMostKOddIntegers(self, A, K):\n        def countDistinct(A, left, right, trie):  # Time: O(n), Space: O(t)\n            result = 0\n            for i in xrange(left, right+1):\n                if A[i] not in trie:\n                    result += 1\n                trie = trie[A[i]]\n            return result\n\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        result = 0\n        for left in xrange(len(A)):\n            count = 0\n            for right in xrange(left, len(A)):\n                count += A[right]%2\n                if count > K:\n                    right -= 1\n                    break\n            result += countDistinct(A, left, right, trie)\n        return result\n"
    },
    {
        "problem_name": "number-of-distinct-substrings-in-a-string",
        "solution": "# Time:  O(n^2)\n# Space: O(t), t is the number of trie nodes\n\nclass Solution(object):\n    def countDistinct(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        count = 0\n        trie = {}\n        for i in xrange(len(s)):\n            curr = trie\n            for j in xrange(i, len(s)):\n                if s[j] not in curr:\n                    count += 1\n                    curr[s[j]] = {}\n                curr = curr[s[j]]\n        return count\n"
    },
    {
        "problem_name": "number-of-divisible-substrings",
        "solution": "# Time:  O(d * n)\n# Space: O(n)\n\nimport collections\n\n\n# prefix sum, freq table\nclass Solution(object):\n    def countDivisibleSubstrings(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        for d in xrange(1, 10):\n            prefix = 0\n            cnt = collections.Counter([0+d*(-1+1)])\n            for i, x in enumerate(word):\n                prefix += (ord(x)-ord('a')+1)//3+1\n                result += cnt[prefix-d*(i+1)]\n                cnt[prefix-d*(i+1)] += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-divisible-triplet-sums",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def divisibleTripletCount(self, nums, d):\n        \"\"\"\n        :type nums: List[int]\n        :type d: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        cnt = collections.Counter()\n        for i in xrange(len(nums)):\n            for j in xrange(i+1, len(nums)):\n                if (nums[i]+nums[j])%d in cnt:\n                    result += cnt[(nums[i]+nums[j])%d]\n            cnt[-nums[i]%d] += 1\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\nimport collections\n\n\n# freq table\nclass Solution2(object):\n    def divisibleTripletCount(self, nums, d):\n        \"\"\"\n        :type nums: List[int]\n        :type d: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        cnt = collections.Counter()\n        for i in xrange(len(nums)):\n            if nums[i]%d in cnt:\n                result += cnt[nums[i]%d]\n            for j in xrange(i):\n                cnt[-(nums[i]+nums[j])%d] += 1\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\nimport collections\n\n\n# freq table\nclass Solution3(object):\n    def divisibleTripletCount(self, nums, d):\n        \"\"\"\n        :type nums: List[int]\n        :type d: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(len(nums)):\n            cnt = collections.Counter()\n            for j in xrange(i+1, len(nums)):\n                result += cnt[nums[j]%d]\n                cnt[-(nums[i]+nums[j])%d] += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-employees-who-met-the-target",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def numberOfEmployeesWhoMetTarget(self, hours, target):\n        \"\"\"\n        :type hours: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return sum(x >= target for x in hours)\n"
    },
    {
        "problem_name": "number-of-enclaves",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nclass Solution(object):\n    def numEnclaves(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n        def dfs(A, i, j):\n            if not (0 <= i < len(A) and 0 <= j < len(A[0]) and A[i][j]):\n                return\n            A[i][j] = 0\n            for d in directions:\n                dfs(A, i+d[0], j+d[1])\n        \n        for i in xrange(len(A)):\n            dfs(A, i, 0)\n            dfs(A, i, len(A[0])-1)\n        for j in xrange(1, len(A[0])-1):\n            dfs(A, 0, j)\n            dfs(A, len(A)-1, j)\n        return sum(sum(row) for row in A)\n  \n"
    },
    {
        "problem_name": "number-of-equal-count-substrings",
        "solution": "# Time:  O(26 * n) = O(n)\n# Space: O(26) = O(1)\n\nclass Solution(object):\n    def equalCountSubstrings(self, s, count):\n        \"\"\"\n        :type s: str\n        :type count: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        for l in xrange(1, min(len(set(s)), len(s)//count)+1):\n            cnt, equal_cnt = collections.Counter(), 0\n            for i, c in enumerate(s):\n                cnt[c] += 1\n                equal_cnt += (cnt[c] == count)\n                if i >= count*l:\n                    equal_cnt -= (cnt[s[i-count*l]] == count)\n                    cnt[s[i-count*l]] -= 1\n                result += (equal_cnt == l)\n        return result\n"
    },
    {
        "problem_name": "number-of-equal-numbers-blocks",
        "solution": "# Time:  O(klogn), k = len(set(nums))\n# Space: O(1)\n\n# Definition for BigArray.\nclass BigArray:\n    def at(self, index):\n        pass\n    def size(self):\n        pass\n\n\n# binary search\nclass Solution(object):\n    def countBlocks(self, nums):\n        \"\"\"\n        :type nums: BigArray\n        :rtype: int\n        \"\"\"\n        def binary_search_right(left, right, check):\n            while left <= right:\n                mid = left + (right-left)//2\n                if not check(mid):\n                    right = mid-1\n                else:\n                    left = mid+1\n            return right\n\n        n = nums.size()\n        result = left = 0\n        while left != n:\n            target = nums.at(left)\n            left = binary_search_right(left, n-1, lambda x: nums.at(x) == target)+1\n            result += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-equivalent-domino-pairs",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def numEquivDominoPairs(self, dominoes):\n        \"\"\"\n        :type dominoes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        counter = collections.Counter((min(x), max(x)) for x in dominoes)\n        return sum(v*(v-1)//2 for v in counter.itervalues())\n"
    },
    {
        "problem_name": "number-of-even-and-odd-bits",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# bit manipulation\nclass Solution(object):\n    def evenOddBit(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        def popcount(x):\n            return bin(x)[2:].count('1')\n\n        return [popcount(n&0b0101010101), popcount(n&0b1010101010)]\n"
    },
    {
        "problem_name": "number-of-excellent-pairs",
        "solution": "# Time:  O(n + (logn)^2) = O(n)\n# Space: O(n + logn) = O(n)\n\nimport collections\n\n\n# bit manipulation, freq table, combinatorics\nclass Solution(object):\n    def countExcellentPairs(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def popcount(x):\n            return bin(x)[2:].count('1')\n\n        cnt = collections.Counter(popcount(x) for x in set(nums))\n        return sum(cnt[i]*cnt[j] for i in cnt.iterkeys() for j in cnt.iterkeys() if i+j >= k)\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# bit manipulation, sort, two pointers\nclass Solution2(object):\n    def countExcellentPairs(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def popcount(x):\n            return bin(x)[2:].count('1')\n\n        sorted_cnts = sorted(popcount(x) for x in set(nums))\n        result = 0\n        left, right = 0, len(sorted_cnts)-1\n        while left <= right:\n            if sorted_cnts[left]+sorted_cnts[right] < k:\n                left += 1\n            else:\n                result += 1+2*((right-1)-left+1)\n                right -= 1\n        return result\n"
    },
    {
        "problem_name": "number-of-flowers-in-full-bloom",
        "solution": "# Time:  O(nlogn + mlogn)\n# Space: O(n)\n\nimport bisect\n\n\n# line sweep, binary search\nclass Solution(object):\n    def fullBloomFlowers(self, flowers, persons):\n        \"\"\"\n        :type flowers: List[List[int]]\n        :type persons: List[int]\n        :rtype: List[int]\n        \"\"\"\n        cnt = collections.Counter()\n        for s, e in flowers:\n            cnt[s] += 1\n            cnt[e+1] -= 1\n        events = sorted(cnt.iterkeys())\n        prefix = [0]\n        for x in events:\n            prefix.append(prefix[-1]+cnt[x])\n        return [prefix[bisect.bisect_right(events, t)] for t in persons]\n\n\n# Time:  O(nlogn + mlogn)\n# Space: O(n)\nimport bisect\n\n\n# binary search\nclass Solution(object):\n    def fullBloomFlowers(self, flowers, persons):\n        \"\"\"\n        :type flowers: List[List[int]]\n        :type persons: List[int]\n        :rtype: List[int]\n        \"\"\"\n        starts, ends = [], []\n        for s, e in flowers:\n            starts.append(s)\n            ends.append(e+1)\n        starts.sort()\n        ends.sort()\n        return [bisect.bisect_right(starts, t)-bisect.bisect_right(ends, t) for t in persons]\n"
    },
    {
        "problem_name": "number-of-good-binary-strings",
        "solution": "# Time:  O(n), n = maxLength\n# Space: O(w), w = max(oneGroup, zeroGroup)+1\n\n# dp\nclass Solution(object):\n    def goodBinaryStrings(self, minLength, maxLength, oneGroup, zeroGroup):\n        \"\"\"\n        :type minLength: int\n        :type maxLength: int\n        :type oneGroup: int\n        :type zeroGroup: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result = 0\n        w = max(oneGroup, zeroGroup)+1\n        dp = [0]*w\n        for i in xrange(maxLength+1):\n            dp[i%w] = 1 if i == 0 else 0\n            if i-oneGroup >= 0:\n                dp[i%w] = (dp[i%w]+dp[(i-oneGroup)%w])%MOD\n            if i-zeroGroup >= 0:\n                dp[i%w] = (dp[i%w]+dp[(i-zeroGroup)%w])%MOD\n            if i >= minLength:\n                result = (result+dp[i%w])%MOD\n        return result\n\n\n# Time:  O(n), n = maxLength\n# Space: O(w), w = max(oneGroup, zeroGroup)+1\n# dp\nclass Solution(object):\n    def goodBinaryStrings(self, minLength, maxLength, oneGroup, zeroGroup):\n        \"\"\"\n        :type minLength: int\n        :type maxLength: int\n        :type oneGroup: int\n        :type zeroGroup: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result = 0\n        w = max(oneGroup, zeroGroup)+1\n        dp = [0]*w\n        dp[0] = 1\n        for i in xrange(maxLength+1):\n            if i >= minLength:\n                result = (result+dp[i%w])%MOD\n            if i+oneGroup <= maxLength:\n                dp[(i+oneGroup)%w] = (dp[(i+oneGroup)%w]+dp[i%w])%MOD\n            if i+zeroGroup <= maxLength:\n                dp[(i+zeroGroup)%w] = (dp[(i+zeroGroup)%w]+dp[i%w])%MOD\n            dp[i%w] = 0\n        return result\n"
    },
    {
        "problem_name": "number-of-good-leaf-nodes-pairs",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nimport collections\n\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def countPairs(self, root, distance):\n        \"\"\"\n        :type root: TreeNode\n        :type distance: int\n        :rtype: int\n        \"\"\"\n        def iter_dfs(distance, root):\n            result = 0\n            stk = [(1, (root, [collections.Counter()]))]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, ret = params\n                    if not node:\n                        continue\n                    if not node.left and not node.right:\n                        ret[0][0] = 1\n                        continue\n                    left, right = [collections.Counter()], [collections.Counter()]\n                    stk.append((2, (left, right, ret)))\n                    stk.append((1, (node.right, right)))\n                    stk.append((1, (node.left, left)))\n                else:\n                    left, right, ret = params\n                    for left_d, left_c in left[0].iteritems():\n                        for right_d,right_c in right[0].iteritems():\n                            if left_d+right_d+2 <= distance:\n                                result += left_c*right_c\n                    ret[0] = collections.Counter({k+1:v for k,v in (left[0]+right[0]).iteritems()})\n            return result\n        \n        return iter_dfs(distance, root)\n\n\n# Time:  O(n)\n# Space: O(h)\nimport collections\n\n\nclass Solution2(object):\n    def countPairs(self, root, distance):\n        \"\"\"\n        :type root: TreeNode\n        :type distance: int\n        :rtype: int\n        \"\"\"\n        def dfs(distance, node):\n            if not node:\n                return 0, collections.Counter()\n            if not node.left and not node.right:\n                return 0, collections.Counter([0])\n            left, right = dfs(distance, node.left), dfs(distance, node.right)\n            result = left[0]+right[0]\n            for left_d, left_c in left[1].iteritems():\n                for right_d,right_c in right[1].iteritems():\n                    if left_d+right_d+2 <= distance:\n                        result += left_c*right_c\n            return result, collections.Counter({k+1:v for k,v in (left[1]+right[1]).iteritems()})\n        \n        return dfs(distance, root)[0]\n"
    },
    {
        "problem_name": "number-of-good-pairs",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def numIdenticalPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(c*(c-1)//2 for c in collections.Counter(nums).itervalues())\n"
    },
    {
        "problem_name": "number-of-good-paths",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n    def __init__(self, vals):\n        self.set = range(len(vals))\n        self.rank = [0]*len(vals)\n        self.cnt = [collections.Counter({v:1}) for v in vals]   # added\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y, v):  # modified\n        x, y = self.find_set(x), self.find_set(y)\n        if x == y:\n            return 0  # modified\n        if self.rank[x] > self.rank[y]:  # union by rank\n            x, y = y, x\n        self.set[x] = self.set[y]\n        if self.rank[x] == self.rank[y]:\n            self.rank[y] += 1\n        cx, cy = self.cnt[x][v], self.cnt[y][v]  # added\n        self.cnt[y] = collections.Counter({v:cx+cy})  # added\n        return cx*cy  # modified\n\n\n# tree, sort, union find\nclass Solution(object):\n    def numberOfGoodPaths(self, vals, edges):\n        \"\"\"\n        :type vals: List[int]\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        edges.sort(key=lambda x: max(vals[x[0]], vals[x[1]]))\n        uf = UnionFind(vals)\n        return len(vals)+sum(uf.union_set(i, j, max(vals[i], vals[j])) for i, j in edges)\n"
    },
    {
        "problem_name": "number-of-good-ways-to-split-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def numSplits(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        left_count, right_count = collections.Counter(), collections.Counter(s)\n        result = 0\n        for c in s:\n            left_count[c] += 1\n            right_count[c] -= 1\n            if not right_count[c]:\n                del right_count[c]\n            if len(left_count) == len(right_count):\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-great-partitions",
        "solution": "# Time:  O(n * k)\n# Space: O(k)\n\n# knapsack dp\nclass Solution(object):\n    def countPartitions(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        if sum(nums) < 2*k:\n            return 0\n        dp = [0]*k\n        dp[0] = 1\n        for x in nums:\n            for i in reversed(xrange(k-x)):\n                dp[i+x] = (dp[i+x]+dp[i])%MOD\n        return (pow(2, len(nums), MOD)-2*reduce(lambda total, x: (total+x)%MOD, dp, 0))%MOD\n"
    },
    {
        "problem_name": "number-of-increasing-paths-in-a-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\n# topological sort, bottom-up dp\nclass Solution(object):\n    def countPaths(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        in_degree = [[0]*len(grid[0]) for _ in xrange(len(grid))]\n        q = []\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                for di, dj in directions:\n                    ni, nj = i+di, j+dj\n                    if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[i][j] > grid[ni][nj]:\n                        in_degree[i][j] += 1\n                if not in_degree[i][j]:\n                    q.append((i, j))\n        dp = [[1]*len(grid[0]) for _ in xrange(len(grid))]\n        result = 0\n        while q:\n            new_q = []\n            for i, j in q:\n                result = (result+dp[i][j])%MOD\n                for di, dj in directions:\n                    ni, nj = i+di, j+dj\n                    if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[i][j] < grid[ni][nj]):\n                        continue\n                    dp[ni][nj] = (dp[ni][nj]+dp[i][j])%MOD\n                    in_degree[ni][nj] -= 1\n                    if not in_degree[ni][nj]:\n                        new_q.append((ni, nj))\n            q = new_q\n        return result\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\n# top-down dp, memoization\nclass Solution2(object):\n    def countPaths(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def memoization(grid, i, j, lookup):\n            if not lookup[i][j]:\n                lookup[i][j] = 1\n                for di, dj in directions:\n                    ni, nj = i+di, j+dj\n                    if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[i][j] < grid[ni][nj]:\n                        lookup[i][j] = (lookup[i][j]+memoization(grid, ni, nj, lookup)) % MOD\n            return lookup[i][j]\n\n        lookup = [[0]*len(grid[0]) for _ in xrange(len(grid))]\n        return sum(memoization(grid, i, j, lookup) for i in xrange(len(grid)) for j in xrange(len(grid[0]))) % MOD\n"
    },
    {
        "problem_name": "number-of-islands-ii",
        "solution": "# Time:  O(klog*k) ~= O(k), k is the length of the positions\n# Space: O(k)\n\nclass Solution(object):\n    def numIslands2(self, m, n, positions):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def node_id(node, n):\n            return node[0] * n + node[1]\n\n        def find_set(x):\n           if set[x] != x:\n               set[x] = find_set(set[x])  # path compression.\n           return set[x]\n\n        def union_set(x, y):\n            x_root, y_root = find_set(x), find_set(y)\n            set[min(x_root, y_root)] = max(x_root, y_root)\n\n        numbers = []\n        number = 0\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n        set = {}\n        for position in positions:\n            node = (position[0], position[1])\n            set[node_id(node, n)] = node_id(node, n)\n            number += 1\n\n            for d in directions:\n                neighbor = (position[0] + d[0], position[1] + d[1])\n                if 0 <= neighbor[0] < m and 0 <= neighbor[1] < n and \\\n                   node_id(neighbor, n) in set:\n                   if find_set(node_id(node, n)) != find_set(node_id(neighbor, n)):\n                       # Merge different islands, amortised time: O(log*k) ~= O(1)\n                       union_set(node_id(node, n), node_id(neighbor, n))\n                       number -= 1\n            numbers.append(number)\n\n        return numbers\n\n"
    },
    {
        "problem_name": "number-of-islands",
        "solution": "# Time:  O(m * n * \u03b1(m * n)) ~= O(m * n)\n# Space: O(m * n)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n       if self.set[x] != x:\n           self.set[x] = self.find_set(self.set[x])  # path compression.\n       return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n            self.count -= 1\n\n\nclass Solution(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        def index(n, i, j):\n            return i*n + j\n    \n        if not grid:\n            return 0\n\n        zero_count = 0\n        union_find = UnionFind(len(grid)*len(grid[0]))\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j] == '1':\n                    if i and grid[i-1][j] == '1':\n                        union_find.union_set(index(len(grid[0]), i-1, j),\n                                             index(len(grid[0]),i, j))\n                    if j and grid[i][j-1] == '1':\n                        union_find.union_set(index(len(grid[0]), i, j-1),\n                                             index(len(grid[0]), i, j))\n                else:\n                    zero_count += 1        \n        return union_find.count-zero_count\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\n# dfs solution\nclass Solution2(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def dfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] = '0'\n            stk = [(i, j)]\n            while stk:\n                r, c = stk.pop()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    stk.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if dfs(grid, i, j):\n                    count += 1\n        return count\n\n \n# Time:  O(m * n)\n# Space: O(m * n)\nimport collections\n\n\n# bfs solution\nclass Solution3(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def bfs(grid, i, j):\n            if grid[i][j] == '0':\n                return False\n            grid[i][j] ='0'\n            q = collections.deque([(i, j)])\n            while q:\n                r, c = q.popleft()\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] == '1'):\n                        continue\n                    grid[nr][nc] = '0'\n                    q.append((nr, nc))\n            return True\n\n        count = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if bfs(grid, i, j):\n                    count += 1\n        return count\n"
    },
    {
        "problem_name": "number-of-laser-beams-in-a-bank",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfBeams(self, bank):\n        \"\"\"\n        :type bank: List[str]\n        :rtype: int\n        \"\"\"\n        result = prev = 0\n        for x in bank:\n            cnt = x.count('1')\n            if not cnt:\n                continue\n            result += prev*cnt\n            prev = cnt\n        return result\n"
    },
    {
        "problem_name": "number-of-lines-to-write-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfLines(self, widths, S):\n        \"\"\"\n        :type widths: List[int]\n        :type S: str\n        :rtype: List[int]\n        \"\"\"\n        result = [1, 0]\n        for c in S:\n            w = widths[ord(c)-ord('a')]\n            result[1] += w\n            if result[1] > 100:\n                result[0] += 1\n                result[1] = w\n        return result\n\n"
    },
    {
        "problem_name": "number-of-longest-increasing-subsequence",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def findNumberOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, max_len = 0, 0\n        dp = [[1, 1] for _ in xrange(len(nums))]  # {length, number} pair\n        for i in xrange(len(nums)):\n            for j in xrange(i):\n                if nums[i] > nums[j]:\n                    if dp[i][0] == dp[j][0]+1:\n                        dp[i][1] += dp[j][1]\n                    elif dp[i][0] < dp[j][0]+1:\n                        dp[i] = [dp[j][0]+1, dp[j][1]]\n            if max_len == dp[i][0]:\n                result += dp[i][1]\n            elif max_len < dp[i][0]:\n                max_len = dp[i][0]\n                result = dp[i][1]\n        return result\n\n"
    },
    {
        "problem_name": "number-of-matching-subsequences",
        "solution": "# Time:  O(n + w), n is the size of S, w is the size of words\n# Space: O(k), k is the number of words\n\nimport collections\n\n\nclass Solution(object):\n    def numMatchingSubseq(self, S, words):\n        \"\"\"\n        :type S: str\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        waiting = collections.defaultdict(list)\n        for word in words:\n            it = iter(word)\n            waiting[next(it, None)].append(it)\n        for c in S:\n            for it in waiting.pop(c, ()):\n                waiting[next(it, None)].append(it)\n        return len(waiting[None])\n\n"
    },
    {
        "problem_name": "number-of-music-playlists",
        "solution": "# Time:  O(n * l)\n# Space: O(l)\n\nclass Solution(object):\n    def numMusicPlaylists(self, N, L, K):\n        \"\"\"\n        :type N: int\n        :type L: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n        M = 10**9+7\n        dp = [[0 for _ in xrange(1+L)] for _ in xrange(2)]\n        dp[0][0] = dp[1][1] = 1\n        for n in xrange(1, N+1):\n            dp[n % 2][n] = (dp[(n-1) % 2][n-1] * n) % M\n            for l in xrange(n+1, L+1):\n                dp[n % 2][l] = ((dp[n % 2][l-1] * max(n-K, 0)) % M + \\\n                                (dp[(n-1) % 2][l-1] * n) % M) % M\n        return dp[N % 2][L]\n\n"
    },
    {
        "problem_name": "number-of-nodes-in-the-sub-tree-with-the-same-label",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def countSubTrees(self, n, edges, labels):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type labels: str\n        :rtype: List[int]\n        \"\"\"\n        def iter_dfs(labels, adj, node, parent, result):\n            stk = [(1, (node, parent, [0]*26))]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    node, parent, ret = params\n                    stk.append((4, (node, ret)))\n                    stk.append((2, (node, parent, reversed(adj[node]), ret)))\n                elif step == 2:\n                    node, parent, it, ret = params\n                    child = next(it, None)\n                    if not child or child == parent:\n                        continue\n                    ret2 = [0]*26\n                    stk.append((2, (node, parent, it, ret)))\n                    stk.append((3, (ret2, ret)))\n                    stk.append((1, (child, node, ret2)))\n                elif step == 3:\n                    ret2, ret = params\n                    for k in xrange(len(ret2)):\n                        ret[k] += ret2[k]\n                else:\n                    node, ret = params\n                    ret[ord(labels[node]) - ord('a')] += 1\n                    result[node] += ret[ord(labels[node]) - ord('a')]\n        \n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        result = [0]*n\n        iter_dfs(labels, adj, 0, -1, result)\n        return result\n\n\n# Time:  O(n)\n# Space: O(h)\nimport collections\n\n\nclass Solution2(object):\n    def countSubTrees(self, n, edges, labels):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type labels: str\n        :rtype: List[int]\n        \"\"\"\n        def dfs(labels, adj, node, parent, result):\n            count = [0]*26\n            for child in adj[node]:\n                if child == parent:\n                    continue\n                new_count = dfs(labels, adj, child, node, result)\n                for k in xrange(len(new_count)):\n                    count[k] += new_count[k]\n            count[ord(labels[node]) - ord('a')] += 1\n            result[node] = count[ord(labels[node]) - ord('a')]\n            return count\n        \n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        result = [0]*n\n        dfs(labels, adj, 0, -1, result)\n        return result\n"
    },
    {
        "problem_name": "number-of-nodes-with-value-one",
        "solution": "# Time:  O(q + n)\n# Space: O(n)\n\nimport collections\n\n\n# bfs\nclass Solution(object):\n    def numberOfNodes(self, n, queries):\n        \"\"\"\n        :type n: int\n        :type queries: List[int]\n        :rtype: int\n        \"\"\"\n        def bfs():\n            result = 0\n            q = [(1, 0)]\n            while q:\n                new_q = []\n                for u, curr in q:\n                    curr ^= cnt[u]%2\n                    result += curr\n                    for v in xrange(2*u, min(2*u+1, n)+1):\n                        q.append((v, curr))\n                q = new_q\n            return result\n\n        cnt = collections.Counter(queries)\n        return bfs()\n\n\n# Time:  O(q + n)\n# Space: O(q + logn)\nimport collections\n\n\n# iterative dfs\nclass Solution2(object):\n    def numberOfNodes(self, n, queries):\n        \"\"\"\n        :type n: int\n        :type queries: List[int]\n        :rtype: int\n        \"\"\"\n        def iter_dfs():\n            result = 0\n            stk = [(1, 0)]\n            while stk:\n                u, curr = stk.pop()\n                curr ^= cnt[u]%2\n                result += curr\n                for v in reversed(xrange(2*u, min(2*u+1, n)+1)):\n                    stk.append((v, curr))\n            return result\n\n        cnt = collections.Counter(queries)\n        return iter_dfs()\n\n\n# Time:  O(q + n)\n# Space: O(q + logn)\nimport collections\n\n\n# dfs\nclass Solution3(object):\n    def numberOfNodes(self, n, queries):\n        \"\"\"\n        :type n: int\n        :type queries: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(u, curr):\n            curr ^= cnt[u]%2\n            return curr+sum(dfs(v, curr) for v in xrange(2*u, min(2*u+1, n)+1))\n    \n        cnt = collections.Counter(queries)\n        return dfs(1, 0)\n"
    },
    {
        "problem_name": "number-of-operations-to-make-network-connected",
        "solution": "# Time:  O(|E| + |V|)\n# Space: O(|V|)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[max(x_root, y_root)] = min(x_root, y_root)\n        self.count -= 1\n        return True\n\n\nclass Solution(object):\n    def makeConnected(self, n, connections):\n        \"\"\"\n        :type n: int\n        :type connections: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if len(connections) < n-1:\n            return -1\n        union_find = UnionFind(n)\n        for i, j in connections:\n            union_find.union_set(i, j)\n        return union_find.count - 1\n\n\n# Time:  O(|E| + |V|)\n# Space: O(|V|)\nimport collections\n\n\nclass Solution2(object):\n    def makeConnected(self, n, connections):\n        \"\"\"\n        :type n: int\n        :type connections: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def dfs(i, lookup):\n            if i in lookup:\n                return 0\n            lookup.add(i)\n            if i in G:\n                for j in G[i]:\n                    dfs(j, lookup)\n            return 1\n\n        if len(connections) < n-1:\n            return -1\n        G = collections.defaultdict(list)\n        for i, j in connections:\n            G[i].append(j)\n            G[j].append(i)\n        lookup = set()\n        return sum(dfs(i, lookup) for i in xrange(n)) - 1\n"
    },
    {
        "problem_name": "number-of-orders-in-the-backlog",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def getNumberOfBacklogOrders(self, orders):\n        \"\"\"\n        :type orders: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        buy, sell  = [], []  # max_heap, min_heap\n        for p, a, t in orders:\n            if t == 0:\n                heapq.heappush(buy, [-p, a])\n            else:\n                heapq.heappush(sell, [p, a])\n            while sell and buy and sell[0][0] <= -buy[0][0]:\n                k = min(buy[0][1], sell[0][1])\n                tmp = heapq.heappop(buy)\n                tmp[1] -= k\n                if tmp[1]:\n                    heapq.heappush(buy, tmp)\n                tmp = heapq.heappop(sell)\n                tmp[1] -= k\n                if tmp[1]:\n                    heapq.heappush(sell, tmp)\n        return reduce(lambda x, y: (x+y) % MOD, (a for _, a in buy + sell))\n"
    },
    {
        "problem_name": "number-of-pairs-of-interchangeable-rectangles",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\nimport fractions\n\n\nclass Solution(object):\n    def interchangeableRectangles(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: int\n        \"\"\"\n        count = collections.defaultdict(int)\n        for w, h in rectangles:\n            g = fractions.gcd(w, h)  # Time: O(logx) ~= O(1)\n            count[(w//g, h//g)] += 1\n        return sum(c*(c-1)//2 for c in count.itervalues())\n"
    },
    {
        "problem_name": "number-of-pairs-of-strings-with-concatenation-equal-to-target",
        "solution": "# Time:  O(n * l), n is the size of nums, l is the average length of the digit string in nums\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def numOfPairs(self, nums, target):\n        \"\"\"\n        :type nums: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        lookup = collections.Counter()\n        result = 0\n        for num in nums:\n            cnt1, cnt2 = lookup[-(len(target)-len(num))], lookup[len(target)-len(num)]\n            if target.startswith(num):\n                result += cnt1\n                lookup[len(num)] += 1\n            if target.endswith(num):\n                result += cnt2\n                lookup[-len(num)] += 1\n        return result\n\n\n# Time:  O(n * l), n is the size of nums, l is the average length of the digit string in nums\n# Space: O(n)\nimport collections\n\n\nclass Solution2(object):\n    def numOfPairs(self, nums, target):\n        \"\"\"\n        :type nums: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        prefix, suffix = collections.Counter(), collections.Counter()\n        result = 0\n        for num in nums:\n            if target.startswith(num):\n                result += suffix[len(target)-len(num)]\n            if target.endswith(num):\n                result += prefix[len(target)-len(num)]\n            if target.startswith(num):\n                prefix[len(num)] += 1\n            if target.endswith(num):\n                suffix[len(num)] += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-pairs-satisfying-inequality",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nfrom sortedcontainers import SortedList\nimport itertools\n\n\n# sorted list, binary search\nclass Solution(object):\n    def numberOfPairs(self, nums1, nums2, diff):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type diff: int\n        :rtype: int\n        \"\"\"\n        sl = SortedList()\n        result = 0\n        for x, y in itertools.izip(nums1, nums2):\n            result += sl.bisect_right((x-y)+diff)\n            sl.add(x-y)\n        return result\n\n    \n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\nimport bisect\n\n\nclass BIT(object):  # 0-indexed.\n    def __init__(self, n):\n        self.__bit = [0]*(n+1)  # Extra one for dummy node.\n\n    def add(self, i, val):\n        i += 1  # Extra one for dummy node.\n        while i < len(self.__bit):\n            self.__bit[i] += val\n            i += (i & -i)\n\n    def query(self, i):\n        i += 1  # Extra one for dummy node.\n        ret = 0\n        while i > 0:\n            ret += self.__bit[i]\n            i -= (i & -i)\n        return ret\n\n\n# bit, fenwick tree, coordinate compression\nclass Solution2(object):\n    def numberOfPairs(self, nums1, nums2, diff):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type diff: int\n        :rtype: int\n        \"\"\"\n        sorted_nums = sorted(set(x-y for x, y in itertools.izip(nums1, nums2)))\n        num_to_idx = {x:i for i, x in enumerate(sorted_nums)}\n        result = 0\n        bit = BIT(len(num_to_idx))\n        for x, y in itertools.izip(nums1, nums2):\n            result += bit.query(bisect.bisect_right(sorted_nums, (x-y)+diff)-1)\n            bit.add(num_to_idx[x-y], 1)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\n\n\n# merge sort, two pointers\nclass Solution3(object):\n    def numberOfPairs(self, nums1, nums2, diff):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type diff: int\n        :rtype: int\n        \"\"\"\n        def merge_sort(nums, left, right, result):\n            if left == right:\n                return\n            mid = left+(right-left)//2\n            merge_sort(nums, left, mid, result)\n            merge_sort(nums, mid+1, right, result)\n            r = mid+1\n            for l in xrange(left, mid+1):\n                while r < right+1 and nums[l]-nums[r] > diff:\n                    r += 1\n                result[0] += right-r+1\n            tmp = []\n            l, r = left, mid+1\n            while l < mid+1 or r < right+1:\n                if r >= right+1 or (l < mid+1 and nums[l] <= nums[r]):\n                    tmp.append(nums[l])\n                    l += 1\n                else:\n                    tmp.append(nums[r])\n                    r += 1\n            nums[left:right+1] = tmp\n\n        nums = [x-y for x, y in itertools.izip(nums1, nums2)]\n        result = [0]\n        merge_sort(nums, 0, len(nums)-1, result)\n        return result[0]\n"
    },
    {
        "problem_name": "number-of-paths-with-max-score",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def pathsWithMaxScore(self, board):\n        \"\"\"\n        :type board: List[str]\n        :rtype: List[int]\n        \"\"\"\n        MOD = 10**9+7\n        directions = [[1, 0], [0, 1], [1, 1]]\n        dp = [[[0, 0] for r in xrange(len(board[0])+1)]\n              for r in xrange(2)]\n        dp[(len(board)-1)%2][len(board[0])-1] = [0, 1]\n        for r in reversed(xrange(len(board))):\n            for c in reversed(xrange(len(board[0]))):\n                if board[r][c] in \"XS\":\n                    continue\n                dp[r%2][c] = [0, 0]\n                for dr, dc in directions:\n                    if dp[r%2][c][0] < dp[(r+dr)%2][c+dc][0]:\n                        dp[r%2][c] = dp[(r+dr)%2][c+dc][:]\n                    elif dp[r%2][c][0] == dp[(r+dr)%2][c+dc][0]:\n                        dp[r%2][c][1] = (dp[r%2][c][1]+dp[(r+dr)%2][c+dc][1]) % MOD\n                if dp[r%2][c][1] and board[r][c] != 'E':\n                    dp[r%2][c][0] += int(board[r][c])\n        return dp[0][0]\n"
    },
    {
        "problem_name": "number-of-people-aware-of-a-secret",
        "solution": "# Time:  O(n)\n# Space: O(f)\n\n# dp\nclass Solution(object):\n    def peopleAwareOfSecret(self, n, delay, forget):\n        \"\"\"\n        :type n: int\n        :type delay: int\n        :type forget: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [0]*forget\n        dp[0] = 1\n        for i in xrange(1, n):\n            dp[i%forget] = ((dp[(i-1)%forget] if i-1 else 0)-dp[i%forget]+dp[(i-delay)%forget]) % MOD\n        return sum(dp)%MOD\n"
    },
    {
        "problem_name": "number-of-people-that-can-be-seen-in-a-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\n# mono stack, optimized from solution2\nclass Solution(object):\n    def seePeople(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def count(h, stk):\n            cnt = 0\n            while stk and stk[-1] < h:\n                stk.pop()\n                cnt += 1\n            if stk:\n                cnt += 1\n            if not stk or stk[-1] != h:\n                stk.append(h)\n            return cnt\n            \n        result = [[0]*len(heights[0]) for _ in xrange(len(heights))]\n        for i in xrange(len(heights)):\n            stk = []\n            for j in reversed(xrange(len(heights[0]))):\n                result[i][j] += count(heights[i][j], stk)     \n        for j in xrange(len(heights[0])):\n            stk = []\n            for i in reversed(xrange(len(heights))):\n                result[i][j] += count(heights[i][j], stk)             \n        return result\n\n\n# Time:  O(m * n)\n# Space: O(m + n)\n# mono stack\nclass Solution2(object):\n    def seePeople(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def count(heights, i, stk):\n            cnt = 0\n            while stk and heights(stk[-1]) < heights(i):\n                stk.pop()\n                cnt += 1\n            if stk:\n                cnt += 1\n            if stk and heights(stk[-1]) == heights(i):\n                stk.pop()\n            stk.append(i)\n            return cnt\n            \n        result = [[0]*len(heights[0]) for _ in xrange(len(heights))]\n        for i in xrange(len(heights)):\n            stk = []\n            for j in reversed(xrange(len(heights[0]))):\n                result[i][j] += count(lambda x: heights[i][x], j, stk)     \n        for j in xrange(len(heights[0])):\n            stk = []\n            for i in reversed(xrange(len(heights))):\n                result[i][j] += count(lambda x: heights[x][j], i, stk)             \n        return result\n\n\n# Time:  O(m * n)\n# Space: O(m + n)\n# mono stack\nclass Solution3(object):\n    def seePeople(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def count(heights, i, stk, add):\n            while stk and heights(stk[-1]) < heights(i):\n                increase(stk.pop())\n            if stk:\n                increase(stk[-1])\n            if stk and heights(stk[-1]) == heights(i):\n                stk.pop()\n            stk.append(i)\n            \n        result = [[0]*len(heights[0]) for _ in xrange(len(heights))]\n        for i in xrange(len(heights)):\n            stk = []\n            def increase(x): result[i][x] += 1\n            for j in xrange(len(heights[0])):\n                count(lambda x: heights[i][x], j, stk, add)\n        for j in xrange(len(heights[0])):\n            stk = []\n            def increase(x): result[x][j] += 1\n            for i in xrange(len(heights)):\n                count(lambda x: heights[x][j], i, stk, add)\n        return result\n"
    },
    {
        "problem_name": "number-of-possible-sets-of-closing-branches",
        "solution": "# Time:  O(r + 2^n * n^2)\n# Space: O(n^3)\n\n# graph, bitmasks, Floyd-Warshall algorithm, backtracking\nclass Solution(object):\n    def numberOfSets(self, n, maxDistance, roads):\n        \"\"\"\n        :type n: int\n        :type maxDistance: int\n        :type roads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def check(mask, dist):\n            return all(dist[i][j] <= maxDistance for i in xrange(n) if mask&(1<<i) for j in xrange(i+1, n) if mask&(1<<j))\n\n        def floydWarshall(dist, k):\n            for i in xrange(len(dist)):\n                for j in xrange(i+1, len(dist[i])):\n                    dist[j][i] = dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])\n\n        def backtracking(i, mask, dist):\n            if i == n:\n                result[0] += check(mask, dist)\n                return\n            for j in xrange(2):\n                new_dist = [d[:] for d in dist]\n                if j:\n                    floydWarshall(new_dist, i)\n                backtracking(i+1, mask|(j<<i), new_dist)\n    \n        dist = [[0 if u == v else float(\"inf\") for v in xrange(n)] for u in xrange(n)]\n        for u, v, w in roads:\n            dist[u][v] = min(dist[u][v], w)\n            dist[v][u] = min(dist[v][u], w)\n        result = [0]\n        backtracking(0, 0, [d[:] for d in dist])\n        return result[0]\n    \n\n# Time:  O(r + 2^n * n^3)\n# Space: O(n^2)\n# bitmasks, Floyd-Warshall algorithm\nclass Solution2(object):\n    def numberOfSets(self, n, maxDistance, roads):\n        \"\"\"\n        :type n: int\n        :type maxDistance: int\n        :type roads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def check(mask, dist):\n            return all(dist[i][j] <= maxDistance for i in xrange(n) if mask&(1<<i) for j in xrange(i+1, n) if mask&(1<<j))\n\n        def floydWarshall(mask, dist):\n            for k in xrange(len(dist[0])):\n                if mask&(1<<k) == 0:\n                    continue\n                for i in xrange(len(dist)):\n                    if mask&(1<<i) == 0:  # optional, to speed up performance\n                        continue\n                    for j in xrange(i+1, len(dist[i])):\n                        if mask&(1<<j) == 0:  # optional, to speed up performance\n                             continue\n                        dist[j][i] = dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])\n            return check(mask, dist)\n\n        dist = [[0 if u == v else float(\"inf\") for v in xrange(n)] for u in xrange(n)]\n        for u, v, w in roads:\n            dist[u][v] = min(dist[u][v], w)\n            dist[v][u] = min(dist[v][u], w)\n        return sum(floydWarshall(mask, [d[:] for d in dist]) for mask in xrange(1<<n))\n    \n"
    },
    {
        "problem_name": "number-of-recent-calls",
        "solution": "# Time:  O(1) on average\n# Space: O(w), w means the size of the last milliseconds.\n\nimport collections\n\n\nclass RecentCounter(object):\n\n    def __init__(self):\n        self.__q = collections.deque()\n\n    def ping(self, t):\n        \"\"\"\n        :type t: int\n        :rtype: int\n        \"\"\"\n        self.__q.append(t)\n        while self.__q[0] < t-3000:\n            self.__q.popleft()\n        return len(self.__q)\n"
    },
    {
        "problem_name": "number-of-rectangles-that-can-form-the-largest-square",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countGoodRectangles(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result = mx = 0\n        for l, w in rectangles:\n            side = min(l, w)\n            if side > mx:\n                result, mx = 1, side\n            elif side == mx:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-restricted-paths-from-first-to-last-node",
        "solution": "# Time:  O(|E| * log|V|)\n# Space: O(|E| + |V|)\n\nimport heapq\n\n\nclass Solution(object):\n    def countRestrictedPaths(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        adj = [[] for _ in xrange(n)]\n        for u, v, w in edges:\n            adj[u-1].append((v-1, w))\n            adj[v-1].append((u-1, w))\n        dist = [float(\"inf\")]*n\n        dp = [0]*n\n        dist[n-1] = 0\n        dp[n-1] = 1\n        min_heap = [(0, n-1)]\n        while min_heap:\n            w, u = heapq.heappop(min_heap)\n            if w > dist[u]:\n                continue\n            for v, d in adj[u]:\n                if w+d < dist[v]:\n                    dist[v] = w+d\n                    heapq.heappush(min_heap, (dist[v], v))\n                elif w > dist[v]:\n                    dp[u] = (dp[u]+dp[v])%MOD\n            if u == 0:  # early return\n                break\n        return dp[0]\n"
    },
    {
        "problem_name": "number-of-same-end-substrings",
        "solution": "# Time:  O(26 * (n + q))\n# Space: O(26 * n)\n\n# freq table, prefix sum\nclass Solution(object):\n    def sameEndSubstringCount(self, s, queries):\n        \"\"\"\n        :type s: str\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        prefix = [[0]*26]\n        for i in xrange(len(s)):\n            prefix.append(prefix[-1][:])\n            prefix[-1][ord(s[i])-ord('a')] += 1\n        result = [0]*len(queries)\n        for i, (l, r) in enumerate(queries):\n            for j in xrange(26):\n                cnt = prefix[r+1][j]-prefix[l][j]\n                result[i] += (1+cnt)*cnt//2\n        return result\n"
    },
    {
        "problem_name": "number-of-segments-in-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = int(len(s) and s[-1] != ' ')\n        for i in xrange(1, len(s)):\n            if s[i] == ' ' and s[i-1] != ' ':\n                result += 1\n        return result\n\n    def countSegments2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len([i for i in s.strip().split(' ') if i])\n\n"
    },
    {
        "problem_name": "number-of-self-divisible-permutations",
        "solution": "# Time:  O(n^2 * logn + n * 2^n) = O(n * 2^n)\n# Space: O(n^2 + 2^n) = O(2^n)\n\n# bitmasks, dp\nclass Solution(object):\n    def selfDivisiblePermutationCount(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def popcount(x):\n            return bin(x).count('1')\n\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        lookup = [[gcd(i+1, j+1) == 1 for j in xrange(n)] for i in xrange(n)]\n        dp = [0]*(1<<n)\n        dp[0] = 1\n        for mask in xrange(1<<n):\n            i = popcount(mask)\n            for j in xrange(n):\n                if mask&(1<<j) == 0 and lookup[i][j]:\n                    dp[mask|(1<<j)] += dp[mask]\n        return dp[-1]\n"
    },
    {
        "problem_name": "number-of-senior-citizens",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def countSeniors(self, details):\n        \"\"\"\n        :type details: List[str]\n        :rtype: int\n        \"\"\"\n        return sum(x[-4:-2] > \"60\" for x in details)\n"
    },
    {
        "problem_name": "number-of-sets-of-k-non-overlapping-line-segments",
        "solution": "# Time:  O(1), excluding precomputation time\n# Space: O(n)\n\n# precompute\nMOD = 10**9+7\nMAX_N = 1000\nfact = [0]*(2*MAX_N-1+1)\ninv = [0]*(2*MAX_N-1+1)\ninv_fact = [0]*(2*MAX_N-1+1)\nfact[0] = inv_fact[0] = fact[1] = inv_fact[1] = inv[1] = 1\nfor i in xrange(2, len(fact)):\n    fact[i] = fact[i-1]*i % MOD\n    inv[i] = inv[MOD%i]*(MOD-MOD//i) % MOD  # https://cp-algorithms.com/algebra/module-inverse.html\n    inv_fact[i] = inv_fact[i-1]*inv[i] % MOD\n\nclass Solution(object):\n    def numberOfSets(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nCr(n, k, mod):\n            return (fact[n]*inv_fact[n-k] % mod) * inv_fact[k] % mod\n    \n        # find k segments with 1+ length and (k+1) spaces with 0+ length s.t. total length is n-1\n        # => find k segments with 0+ length and (k+1) spaces with 0+ length s.t. total length is n-k-1\n        # => find the number of combinations of 2k+1 variables with total sum n-k-1\n        # => H(2k+1, n-k-1)\n        # => C((2k+1) + (n-k-1) - 1, n-k-1)\n        # => C(n+k-1, n-k-1) = C(n+k-1, 2k)\n        return nCr(n+k-1, 2*k, MOD)\n\n\n# Time:  O(min(k, min(n - k)))\n# Space: O(1)\nclass Solution2(object):\n    def numberOfSets(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def nCr(n, r):  # Time: O(n), Space: O(1)\n            if n-r < r:\n                return nCr(n, n-r)\n            c = 1\n            for k in xrange(1, r+1):\n                c *= n-k+1\n                c //= k\n            return c\n        \n        # find k segments with 1+ length and (k+1) spaces with 0+ length s.t. total length is n-1\n        # => find k segments with 0+ length and (k+1) spaces with 0+ length s.t. total length is n-k-1\n        # => find the number of combinations of 2k+1 variables with total sum n-k-1\n        # => H(2k+1, n-k-1)\n        # => C((2k+1) + (n-k-1) - 1, n-k-1)\n        # => C(n+k-1, n-k-1) = C(n+k-1, 2k)\n        return nCr(n+k-1, 2*k) % MOD\n"
    },
    {
        "problem_name": "number-of-ships-in-a-rectangle",
        "solution": "# Time:  O(s * log(m * n)), s is the max number of ships, which is 10 in this problem\n# Space: O(log(m * n))\n\n# \"\"\"\n# This is Sea's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\nclass Sea(object):\n   def hasShips(self, topRight, bottomLeft):\n       \"\"\"\n       :type topRight: Point\n\t\t :type bottomLeft: Point\n       :rtype bool\n       \"\"\"\n       pass\n\nclass Point(object):\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\nclass Solution(object):\n    def countShips(self, sea, topRight, bottomLeft):\n        \"\"\"\n        :type sea: Sea\n        :type topRight: Point\n        :type bottomLeft: Point\n        :rtype: integer\n        \"\"\"\n        result = 0\n        if topRight.x >= bottomLeft.x and \\\n           topRight.y >= bottomLeft.y and \\\n           sea.hasShips(topRight, bottomLeft):\n            if (topRight.x, topRight.y) == (bottomLeft.x, bottomLeft.y):\n                return 1\n            mid_x, mid_y = (topRight.x+bottomLeft.x)//2, (topRight.y+bottomLeft.y)//2\n            result += self.countShips(sea, topRight, Point(mid_x+1, mid_y+1))\n            result += self.countShips(sea, Point(mid_x, topRight.y), Point(bottomLeft.x, mid_y+1))\n            result += self.countShips(sea, Point(topRight.x, mid_y), Point(mid_x+1, bottomLeft.y))\n            result += self.countShips(sea, Point(mid_x, mid_y), bottomLeft)\n        return result\n"
    },
    {
        "problem_name": "number-of-single-divisor-triplets",
        "solution": "# Time:  O(d^3), d is the number of distinct nums\n# Space: O(d)\n\nimport collections\nimport itertools\n\n# combinatorics\nclass Solution(object):\n    def singleDivisorTriplet(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def check(a, b, c):\n            return sum((a+b+c)%x == 0 for x in (a, b, c)) == 1\n\n        cnt = collections.Counter(nums)\n        return 6*(sum(cnt[a]*cnt[b]*cnt[c] for a, b, c in itertools.combinations(cnt.keys(), 3) if check(a, b, c)) +\n                  sum(cnt[a]*(cnt[a]-1)//2*cnt[b] for a, b in itertools.permutations(cnt.keys(), 2) if check(a, a, b)))\n"
    },
    {
        "problem_name": "number-of-smooth-descent-periods-of-a-stock",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def getDescentPeriods(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        result = l = 0\n        for i in xrange(len(prices)):\n            l += 1\n            if i+1 == len(prices) or prices[i]-1 != prices[i+1]:\n                result += l*(l+1)//2\n                l = 0\n        return result\n"
    },
    {
        "problem_name": "number-of-spaces-cleaning-robot-cleaned",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfCleanRooms(self, room):\n        \"\"\"\n        :type room: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        result = r = c = d = 0\n        while not room[r][c]&(1<<(d+1)):\n            result += (room[r][c]>>1) == 0\n            room[r][c] |= (1<<(d+1))\n            dr, dc = directions[d]\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < len(room) and 0 <= nc < len(room[0]) and not (room[nr][nc]&1):\n                r, c = nr, nc\n            else:\n                d = (d+1)%4\n        return result\n"
    },
    {
        "problem_name": "number-of-squareful-arrays",
        "solution": "# Time:  O(n!)\n# Space: O(n^2)\n\nimport collections\n\n\nclass Solution(object):\n    def numSquarefulPerms(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(candidate, x, left, count, result):\n            count[x] -= 1\n            if left == 0:\n                result[0] += 1\n            for y in candidate[x]:\n                if count[y]:\n                    dfs(candidate, y, left-1, count, result)\n            count[x] += 1\n\n        count = collections.Counter(A)\n        candidate = {i: {j for j in count if int((i+j)**0.5) ** 2 == i+j} \n                           for i in count}\n\n        result = [0]\n        for x in count:\n            dfs(candidate, x, len(A)-1, count, result)\n        return result[0]\n"
    },
    {
        "problem_name": "number-of-steps-to-reduce-a-number-in-binary-representation-to-one",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numSteps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, carry = 0, 0\n        for i in reversed(xrange(1, len(s))):\n            if int(s[i]) + carry == 1:\n                carry = 1  # once it was set, it would keep carrying forever\n                result += 2\n            else:\n                result += 1\n        return result+carry\n"
    },
    {
        "problem_name": "number-of-steps-to-reduce-a-number-to-zero",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfSteps (self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while num:\n            result += 2 if num%2 else 1\n            num //= 2\n        return max(result-1, 0)\n"
    },
    {
        "problem_name": "number-of-strings-that-appear-as-substrings-in-word",
        "solution": "# Time:  O(n * l + m), n is the number of patterns\n#                    , l is the max length of patterns\n#                    , m is the length of word     \n# Space: O(t)        , t is the total size of ac automata trie\n\nimport collections\n\n\nclass AhoNode(object):\n    def __init__(self):\n        self.children = collections.defaultdict(AhoNode)\n        self.indices = []\n        self.suffix = None\n        self.output = None\n\n\nclass AhoTrie(object):\n    def step(self, letter):\n        while self.__node and letter not in self.__node.children:\n            self.__node = self.__node.suffix\n        self.__node = self.__node.children[letter] if self.__node else self.__root\n        return self.__get_ac_node_outputs(self.__node)\n    \n    def __init__(self, patterns):\n        self.__root = self.__create_ac_trie(patterns)\n        self.__node = self.__create_ac_suffix_and_output_links(self.__root)\n        self.__lookup = set()  # modified\n    \n    def __create_ac_trie(self, patterns):  # Time: O(n * l), Space: O(t)\n        root = AhoNode()\n        for i, pattern in enumerate(patterns):\n            node = root\n            for c in pattern:\n                node = node.children[c]\n            node.indices.append(i)\n        return root\n\n    def __create_ac_suffix_and_output_links(self, root):  # Time: O(n * l), Space: O(t)\n        queue = collections.deque()\n        for node in root.children.itervalues():\n            queue.append(node)\n            node.suffix = root\n\n        while queue:\n            node = queue.popleft()\n            for c, child in node.children.iteritems():\n                queue.append(child)\n                suffix = node.suffix\n                while suffix and c not in suffix.children:\n                    suffix = suffix.suffix\n                child.suffix = suffix.children[c] if suffix else root\n                child.output = child.suffix if child.suffix.indices else child.suffix.output\n                \n        return root\n\n    def __get_ac_node_outputs(self, node):  # Total Time: O(n), modified\n        result = []\n        if node not in self.__lookup:  # modified\n            self.__lookup.add(node)  # modified\n            for i in node.indices:\n                result.append(i)\n            output = node.output\n            while output and output not in self.__lookup:  # modified\n                self.__lookup.add(output)  # modified\n                for i in output.indices:\n                    result.append(i)\n                output = output.output\n        return result\n\n\n# ac automata solution\nclass Solution(object):\n    def numOfStrings(self, patterns, word):\n        \"\"\"\n        :type patterns: List[str]\n        :type word: str\n        :rtype: int\n        \"\"\"\n        trie = AhoTrie(patterns)\n        return sum(len(trie.step(c)) for c in word)\n\n\n# Time:  O(n * (l + m)), n is the number of patterns\n#                      , l is the max length of patterns\n#                      , m is the length of word\n# Space: O(l)\n# kmp solution\nclass Solution2(object):\n    def numOfStrings(self, patterns, word):\n        \"\"\"\n        :type patterns: List[str]\n        :type word: str\n        :rtype: int\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j != -1 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n            \n        def kmp(text, pattern):\n            if not pattern:\n                return 0\n            prefix = getPrefix(pattern)\n            if len(text) < len(pattern):\n                return -1\n            j = -1\n            for i in xrange(len(text)):\n                while j != -1 and pattern[j+1] != text[i]:\n                    j = prefix[j]\n                if pattern[j+1] == text[i]:\n                    j += 1\n                if j+1 == len(pattern):\n                    return i-j\n            return -1\n        \n        return sum(kmp(word, pattern) != -1 for pattern in patterns)\n\n\n# Time:  O(n * m * l), n is the number of patterns\n#                    , l is the max length of patterns\n#                    , m is the length of word\n# Space: O(1)\n# built-in solution\nclass Solution3(object):\n    def numOfStrings(self, patterns, word):\n        return sum(pattern in word for pattern in patterns)\n"
    },
    {
        "problem_name": "number-of-strings-which-can-be-rearranged-to-contain-substring",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# combinatorics, principle of inclusion-exclusion\nclass Solution(object):\n    def stringCount(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        return (pow(26, n, MOD)-\n                (25+25+25+n)*pow(25, n-1, MOD)+      # no l, t, e, ee\n                (24+24+24+n+n+0)*pow(24, n-1, MOD)-  # no l|t, l|e, t|e, l|ee, t|ee, e|ee\n                (23+n+0+0)*pow(23, n-1, MOD))%MOD    # no l|t|e, l|t|ee, l|e|ee, t|e|ee\n\n\n# Time:  O(2^4 * n) = O(n)\n# Space: O(2^4) = O(1)\n# bitmasks, dp\nclass Solution2(object):\n    def stringCount(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        L, E, EE, T = [1<<i for i in xrange(4)]\n        dp = [0]*(1<<4)\n        dp[0] = 1\n        for _ in xrange(n):\n            new_dp = [0]*(1<<4)\n            for mask in xrange(len(dp)):\n                new_dp[mask|L] = (new_dp[mask|L]+dp[mask])%MOD\n                if not (mask & E):\n                    new_dp[mask|E] = (new_dp[mask|E]+dp[mask])%MOD\n                else:\n                    new_dp[mask|EE] = (new_dp[mask|EE]+dp[mask])%MOD\n                new_dp[mask|T] = (new_dp[mask|T]+dp[mask])%MOD\n                new_dp[mask] = (new_dp[mask]+23*dp[mask])%MOD\n            dp = new_dp\n        return dp[-1]\n"
    },
    {
        "problem_name": "number-of-students-doing-homework-at-a-given-time",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def busyStudent(self, startTime, endTime, queryTime):\n        \"\"\"\n        :type startTime: List[int]\n        :type endTime: List[int]\n        :type queryTime: int\n        :rtype: int\n        \"\"\"\n        return sum(s <= queryTime <= e for s, e in itertools.izip(startTime, endTime))\n"
    },
    {
        "problem_name": "number-of-students-unable-to-eat-lunch",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def countStudents(self, students, sandwiches):\n        \"\"\"\n        :type students: List[int]\n        :type sandwiches: List[int]\n        :rtype: int\n        \"\"\"\n        count = collections.Counter(students)\n        for i, s in enumerate(sandwiches):\n            if not count[s]:\n                break\n            count[s] -= 1\n        else:\n            i = len(sandwiches)\n        return len(sandwiches)-i\n"
    },
    {
        "problem_name": "number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def numOfSubarrays(self, arr, k, threshold):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        result, curr = 0, sum(itertools.islice(arr, 0, k-1))\n        for i in xrange(k-1, len(arr)):\n            curr += arr[i]-(arr[i-k] if i-k >= 0 else 0)\n            result += int(curr >= threshold*k)\n        return result\n    \n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def numOfSubarrays(self, arr, k, threshold):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        accu = [0]\n        for x in arr:\n            accu.append(accu[-1]+x)\n        result = 0\n        for i in xrange(len(accu)-k):\n            if accu[i+k]-accu[i] >= threshold*k:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-sub-arrays-with-odd-sum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numOfSubarrays(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result, accu = 0, 0\n        dp = [1, 0]\n        for x in arr:\n            accu ^= x&1\n            dp[accu] += 1\n            result = (result + dp[accu^1]) % MOD\n        return result\n"
    },
    {
        "problem_name": "number-of-subarrays-having-even-product",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp, math\nclass Solution(object):\n    def evenProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = (len(nums)+1)*len(nums)//2\n        cnt = 0\n        for x in nums:\n            cnt = cnt+1 if x%2 else 0\n            result -= cnt\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\n# dp, math\nclass Solution2(object):\n    def evenProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = cnt = 0\n        for i, x in enumerate(nums):\n            if x%2 == 0:\n                cnt = i+1\n            result += cnt\n        return result\n"
    },
    {
        "problem_name": "number-of-subarrays-that-match-a-pattern-i",
        "solution": "# Time:  O(n)\n# Space: O(m)\n\n# kmp\nclass Solution(object):\n    def countMatchingSubarrays(self, nums, pattern):\n        \"\"\"\n        :type nums: List[int]\n        :type pattern: List[int]\n        :rtype: int\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j+1 > 0 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        def KMP(text, pattern):\n            prefix = getPrefix(pattern)\n            j = -1\n            for i, x in enumerate(text):\n                while j+1 > 0 and pattern[j+1] != x:\n                    j = prefix[j]\n                if pattern[j+1] == x:\n                    j += 1\n                if j+1 == len(pattern):\n                    yield i-j\n                    j = prefix[j]\n\n        return sum(1 for _ in KMP((cmp(nums[i+1], nums[i]) for i in xrange(len(nums)-1)), pattern))\n\n\n# Time:  O(n * m)\n# Space: O(1)\n# brute force\nclass Solution2(object):\n    def countMatchingSubarrays(self, nums, pattern):\n        \"\"\"\n        :type nums: List[int]\n        :type pattern: List[int]\n        :rtype: int\n        \"\"\"\n        def check(i):\n            return all(nums[i+j] == pattern[j] for j in xrange(len(pattern)))\n    \n        for i in xrange(len(nums)-1):\n            nums[i] = cmp(nums[i+1], nums[i])\n        return sum(check(i) for i in xrange(len(nums)-len(pattern)+1))\n"
    },
    {
        "problem_name": "number-of-subarrays-that-match-a-pattern-ii",
        "solution": "# Time:  O(n)\n# Space: O(m)\n\n# kmp\nclass Solution(object):\n    def countMatchingSubarrays(self, nums, pattern):\n        \"\"\"\n        :type nums: List[int]\n        :type pattern: List[int]\n        :rtype: int\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j+1 > 0 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        def KMP(text, pattern):\n            prefix = getPrefix(pattern)\n            j = -1\n            for i, x in enumerate(text):\n                while j+1 > 0 and pattern[j+1] != x:\n                    j = prefix[j]\n                if pattern[j+1] == x:\n                    j += 1\n                if j+1 == len(pattern):\n                    yield i-j\n                    j = prefix[j]\n\n        return sum(1 for _ in KMP((cmp(nums[i+1], nums[i]) for i in xrange(len(nums)-1)), pattern))\n"
    },
    {
        "problem_name": "number-of-subarrays-with-bounded-maximum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numSubarrayBoundedMax(self, A, L, R):\n        \"\"\"\n        :type A: List[int]\n        :type L: int\n        :type R: int\n        :rtype: int\n        \"\"\"\n        def count(A, bound):\n            result, curr = 0, 0\n            for i in A :\n                curr = curr + 1 if i <= bound else 0\n                result += curr\n            return result\n\n        return count(A, R) - count(A, L-1)\n\n"
    },
    {
        "problem_name": "number-of-subarrays-with-gcd-equal-to-k",
        "solution": "# Time:  O(nlogr), r = max(nums)\n# Space: O(logr)\n\n# dp\nclass Solution(object):\n    def subarrayGCD(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        result = 0\n        dp = collections.Counter()\n        for x in nums:\n            new_dp = collections.Counter()\n            if x%k == 0:\n                dp[x] += 1\n                for g, cnt in dp.iteritems():\n                    new_dp[gcd(g, x)] += cnt\n            dp = new_dp\n            result += dp[k]\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(1)\n# brute force\nclass Solution2(object):\n    def subarrayGCD(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        result = 0\n        for i in xrange(len(nums)):\n            g = 0\n            for j in xrange(i, len(nums)):\n                if nums[j]%k:\n                    break\n                g = gcd(g, nums[j])\n                result += int(g == k)\n        return result\n"
    },
    {
        "problem_name": "number-of-subarrays-with-lcm-equal-to-k",
        "solution": "# Time:  O(n * sqrt(k) * logk)\n# Space: O(sqrt(k))\n\nimport collections\n\n\n# dp\nclass Solution(object):\n    def subarrayLCM(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        def lcm(a, b):\n            return a//gcd(a, b)*b\n\n        result = 0\n        dp = collections.Counter()\n        for x in nums:\n            new_dp = collections.Counter()\n            if k%x == 0:\n                dp[x] += 1\n                for l, cnt in dp.iteritems():\n                    new_dp[lcm(l, x)] += cnt\n            dp = new_dp\n            result += dp[k]\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(1)\n# brute force\nclass Solution2(object):\n    def subarrayLCM(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        def lcm(a, b):\n            return a//gcd(a, b)*b\n\n        result = 0\n        for i in xrange(len(nums)):\n            l = 1\n            for j in xrange(i, len(nums)):\n                if k%nums[j]:\n                    break\n                l = lcm(l, nums[j])\n                result += int(l == k)\n        return result\n"
    },
    {
        "problem_name": "number-of-submatrices-that-sum-to-target",
        "solution": "# Time:  O(m^2*n), m is min(r, c), n is max(r, c)\n# Space: O(n), which doesn't include transposed space\n\nimport collections\n\n\nclass Solution(object):\n    def numSubmatrixSumTarget(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if len(matrix) > len(matrix[0]):\n            return self.numSubmatrixSumTarget(map(list, zip(*matrix)), target)\n        \n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[i])-1):\n                matrix[i][j+1] += matrix[i][j]\n\n        result = 0\n        for i in xrange(len(matrix)):\n            prefix_sum = [0]*len(matrix[i])\n            for j in xrange(i, len(matrix)):\n                lookup = collections.defaultdict(int)\n                lookup[0] = 1\n                for k in xrange(len(matrix[j])):\n                    prefix_sum[k] += matrix[j][k]\n                    if prefix_sum[k]-target in lookup:\n                        result += lookup[prefix_sum[k]-target]\n                    lookup[prefix_sum[k]] += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-subsequences-that-satisfy-the-given-sum-condition",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def numSubseq(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        nums.sort()\n        result = 0\n        left, right = 0, len(nums)-1\n        while left <= right:\n            if nums[left]+nums[right] > target:\n                right -= 1\n            else:\n                result = (result+pow(2, right-left, MOD))%MOD\n                left += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-substrings-containing-all-three-characters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 0, [-1]*3\n        for right, c in enumerate(s):\n            left[ord(c)-ord('a')] = right\n            result += min(left)+1\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def numberOfSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left, count = 0, 0, [0]*3\n        for right, c in enumerate(s):\n            count[ord(s[right])-ord('a')] += 1\n            while all(count):\n                count[ord(s[left])-ord('a')] -= 1\n                left += 1\n            result += left\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution3(object):\n    def numberOfSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, right, count = 0, 0, [0]*3\n        for left, c in enumerate(s):\n            while right < len(s) and not all(count):\n                count[ord(s[right])-ord('a')] += 1\n                right += 1\n            if all(count):\n                result += (len(s)-1) - (right-1) + 1\n            count[ord(c)-ord('a')] -= 1\n        return result\n"
    },
    {
        "problem_name": "number-of-substrings-with-fixed-ratio",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# freq table, prefix sum\nclass Solution(object):\n    def fixedRatio(self, s, num1, num2):\n        \"\"\"\n        :type s: str\n        :type num1: int\n        :type num2: int\n        :rtype: int\n        \"\"\"\n        lookup = collections.Counter()\n        lookup[0] = 1\n        result = curr = 0\n        for c in s:\n            curr += -num2 if c == '0' else +num1\n            result += lookup[curr]\n            lookup[curr] += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-substrings-with-only-1s",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numSub(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result, count = 0, 0\n        for c in s:\n            count = count+1 if c == '1' else 0\n            result = (result+count)%MOD\n        return result\n"
    },
    {
        "problem_name": "number-of-unequal-triplets-in-array",
        "solution": "# Time:  O(n * k) = O(3 * n)\n# Space: O(n + k) = O(n)\n\nimport collections\n\n\n# freq table, dp\nclass Solution(object):\n    def unequalTriplets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        K = 3\n        cnt = collections.Counter()\n        dp = [0]*K  # dp[i]: number of unequal (i+1)-plets\n        for x in nums:\n            cnt[x] += 1\n            other_cnt = 1\n            for i in xrange(K):\n                dp[i] += other_cnt\n                other_cnt = dp[i]-cnt[x]*other_cnt\n        return dp[K-1]\n"
    },
    {
        "problem_name": "number-of-unique-categories",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n# Definition for a category handler.\nclass CategoryHandler:\n    def haveSameCategory(self, a, b):\n        pass\n\n\n# brute force\nclass Solution(object):\n    def numberOfCategories(self, n, categoryHandler):\n        \"\"\"\n        :type n: int\n        :type categoryHandler: CategoryHandler\n        :rtype: int\n        \"\"\"\n        return sum(all(not categoryHandler.haveSameCategory(j, i) for j in xrange(i)) for i in xrange(n))\n"
    },
    {
        "problem_name": "number-of-unique-flavors-after-sharing-k-candies",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def shareCandies(self, candies, k):\n        \"\"\"\n        :type candies: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(candies[i] for i in xrange(k, len(candies)))\n        result = curr = len(cnt)\n        for i in xrange(k, len(candies)):\n            cnt[candies[i]] -= 1\n            curr += (cnt[candies[i-k]] == 0) - (cnt[candies[i]] == 0)\n            cnt[candies[i-k]] += 1\n            result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "number-of-unique-good-subsequences",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfUniqueGoodSubsequences(self, binary):\n        \"\"\"\n        :type binary: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        ends0, ends1 = 0, 0\n        has_zero = False\n        for b in binary:\n            if b == '1':\n                ends1 = (ends0+ends1+1)%MOD  # curr subsequences end with 1 is all prev distinct subsequences appended by 1 and plus \"1\"\n            else:\n                ends0 = (ends0+ends1)%MOD  # curr subsequences end with 0 is all prev distinct subsequences appended by 0 and don't plus \"0\"\n                has_zero = True\n        return (ends0+ends1+int(has_zero))%MOD  # add \"0\" if has_zero\n"
    },
    {
        "problem_name": "number-of-valid-clock-times",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# combinatorics\nclass Solution(object):\n    def countTime(self, time):\n        \"\"\"\n        :type time: str\n        :rtype: int\n        \"\"\"\n        result = 1\n        if time[4] == '?':\n            result *= 10\n        if time[3] == '?':\n            result *= 6\n        if time[1] == time[0] == '?':\n            result *= 24\n        elif time[1] == '?':\n            result *= 10 if time[0] != '2' else 4\n        elif time[0] == '?':\n            result *= 3 if time[1] < '4' else 2\n        return result\n"
    },
    {
        "problem_name": "number-of-valid-move-combinations-on-chessboard",
        "solution": "# Time:  O(n^p) = O(1), n is the max number of possible moves for each piece, and n is at most 29\n#                     , p is the number of pieces, and p is at most 4\n# Space: O(1)\n\nclass Solution(object):\n    def countCombinations(self, pieces, positions):\n        \"\"\"\n        :type pieces: List[str]\n        :type positions: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = {\"rook\": [(0, 1), (1, 0), (0, -1), (-1, 0)],\n                      \"bishop\": [(1, 1), (1, -1), (-1, 1), (-1, -1)],\n                      \"queen\" : [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]}\n        all_mask = 2**7-1  # at most 7 seconds in 8x8 board\n        def backtracking(pieces, positions, i, lookup):\n            if i == len(pieces):\n                return 1\n            result = 0\n            r, c = positions[i]\n            r, c = r-1, c-1\n            mask = all_mask\n            if not (lookup[r][c]&mask):\n                lookup[r][c] += mask  # stopped at (r, c)\n                result += backtracking(pieces, positions, i+1, lookup)\n                lookup[r][c] -= mask          \n            for dr, dc in directions[pieces[i]]:\n                bit, nr, nc = 1, r+dr, c+dc\n                mask = all_mask  # (mask&bit == 1): (log2(bit)+1)th second is occupied\n                while 0 <= nr < 8 and 0 <= nc < 8 and not (lookup[nr][nc]&bit):\n                    lookup[nr][nc] += bit\n                    mask -= bit\n                    if not (lookup[nr][nc]&mask):  # stopped at (nr, nc)\n                        lookup[nr][nc] += mask\n                        result += backtracking(pieces, positions, i+1, lookup)\n                        lookup[nr][nc] -= mask\n                    bit, nr, nc = bit<<1, nr+dr, nc+dc\n                while bit>>1:\n                    bit, nr, nc = bit>>1, nr-dr, nc-dc\n                    lookup[nr][nc] -= bit\n            return result\n\n        return backtracking(pieces, positions, 0, [[0]*8 for _ in range(8)])\n"
    },
    {
        "problem_name": "number-of-valid-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def validSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        s = []\n        for num in nums:\n            while s and s[-1] > num:\n                s.pop()\n            s.append(num);\n            result += len(s)\n        return result\n"
    },
    {
        "problem_name": "number-of-valid-words-for-each-puzzle",
        "solution": "# Time:  O(n*l + m*L), m is the number of puzzles, L is the length of puzzles\n#                    , n is the number of words, l is the max length of words\n# Space: O(L!)\n\nclass Solution(object):\n    def findNumOfValidWords(self, words, puzzles):\n        \"\"\"\n        :type words: List[str]\n        :type puzzles: List[str]\n        :rtype: List[int]\n        \"\"\"\n        L = 7\n        def search(node, puzzle, start, first, met_first):\n            result = 0\n            if \"_end\" in node and met_first:\n                result += node[\"_end\"];\n            for i in xrange(start, len(puzzle)):\n                if puzzle[i] not in node:\n                    continue\n                result += search(node[puzzle[i]], puzzle, i+1,\n                                 first, met_first or (puzzle[i] == first))\n            return result\n\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        for word in words:\n            count = set(word)\n            if len(count) > L:\n                continue\n            word = sorted(count)\n            end = reduce(dict.__getitem__, word, trie)\n            end[\"_end\"] = end[\"_end\"]+1 if \"_end\" in end else 1\n        result = []\n        for puzzle in puzzles:\n            first = puzzle[0]\n            result.append(search(trie, sorted(puzzle), 0, first, False))\n        return result\n\n\n# Time:  O(m*2^(L-1) + n*(l+m)), m is the number of puzzles, L is the length of puzzles\n#                              , n is the number of words, l is the max length of words\n# Space: O(m*2^(L-1))\nimport collections\n\n\nclass Solution2(object):\n    def findNumOfValidWords(self, words, puzzles):\n        \"\"\"\n        :type words: List[str]\n        :type puzzles: List[str]\n        :rtype: List[int]\n        \"\"\"\n        L = 7\n        lookup = collections.defaultdict(list)\n        for i in xrange(len(puzzles)):\n            bits = []\n            base = 1 << (ord(puzzles[i][0])-ord('a'))\n            for j in xrange(1, L):\n                bits.append(ord(puzzles[i][j])-ord('a'))\n            for k in xrange(2**len(bits)):\n                bitset = base\n                for j in xrange(len(bits)):\n                    if k & (1<<j):\n                        bitset |= 1<<bits[j]\n                lookup[bitset].append(i)\n        result = [0]*len(puzzles)\n        for word in words:\n            bitset = 0\n            for c in word:\n                bitset |= 1<<(ord(c)-ord('a'))\n            if bitset not in lookup:\n                continue\n            for i in lookup[bitset]:\n                result[i] += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-valid-words-in-a-sentence",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countValidWords(self, sentence):\n        \"\"\"\n        :type sentence: str\n        :rtype: int\n        \"\"\"\n        result = token = hyphen = 0\n        for i in xrange(len(sentence)+1):\n            if i == len(sentence) or sentence[i] == ' ':\n                if token == 1:\n                    result += 1\n                token = hyphen = 0\n                continue\n            if sentence[i].isdigit() or \\\n               (sentence[i] in \"!.,\" and not (i == len(sentence)-1 or sentence[i+1] == ' ')) or \\\n               (sentence[i] == '-' and not (hyphen == 0 and 0 < i < len(sentence)-1 and sentence[i-1].isalpha() and sentence[i+1].isalpha())):\n                token = -1\n                continue\n            if token == 0:\n                token = 1\n            if sentence[i] == '-':\n                hyphen = 1\n        return result\n"
    },
    {
        "problem_name": "number-of-visible-people-in-a-queue",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def canSeePersonsCount(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(heights)\n        stk = []\n        for i, h in enumerate(heights):\n            while stk and heights[stk[-1]] < h:\n                result[stk.pop()] += 1\n            if stk:\n                result[stk[-1]] += 1\n            if stk and heights[stk[-1]] == h:\n                stk.pop()\n            stk.append(i)\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def canSeePersonsCount(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(heights)\n        stk = []\n        for i in reversed(xrange(len(heights))):\n            cnt = 0\n            while stk and heights[stk[-1]] < heights[i]:\n                stk.pop()\n                cnt += 1\n            result[i] = cnt+1 if stk else cnt\n            if stk and heights[stk[-1]] == heights[i]:\n                stk.pop()\n            stk.append(i)\n        return result\n"
    },
    {
        "problem_name": "number-of-ways-of-cutting-a-pizza",
        "solution": "# Time:  O(m * n * k * (m + n))\n# Space: O(m * n * k)\n\nclass Solution(object):\n    def ways(self, pizza, k):\n        \"\"\"\n        :type pizza: List[str]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        prefix = [[0]*len(pizza[0]) for _ in xrange(len(pizza))]\n        for j in reversed(xrange(len(pizza[0]))):\n            accu = 0\n            for i in reversed(xrange(len(pizza))):\n                accu += int(pizza[i][j] == 'A')\n                prefix[i][j] = (prefix[i][j+1] if (j+1 < len(pizza[0])) else 0) + accu\n        dp = [[[0]*k for _ in xrange(len(pizza[0]))] for _ in xrange(len(pizza))]\n        for i in reversed(xrange(len(pizza))):\n            for j in reversed(xrange(len(pizza[0]))):\n                dp[i][j][0] = 1\n                for m in xrange(1, k):\n                    for n in xrange(i+1, len(pizza)):\n                        if prefix[i][j] == prefix[n][j]:\n                            continue\n                        if prefix[n][j] == 0:\n                            break\n                        dp[i][j][m] = (dp[i][j][m] + dp[n][j][m-1]) % MOD\n                    for n in xrange(j+1, len(pizza[0])):\n                        if prefix[i][j] == prefix[i][n]:\n                            continue\n                        if prefix[i][n] == 0:\n                            break\n                        dp[i][j][m] = (dp[i][j][m] + dp[i][n][m-1]) % MOD\n        return dp[0][0][k-1]\n"
    },
    {
        "problem_name": "number-of-ways-to-arrive-at-destination",
        "solution": "# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),\n#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport heapq\n\n\nclass Solution(object):\n    def countPaths(self, n, roads):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        def dijkstra(adj, start, target):\n            best = collections.defaultdict(lambda:float(\"inf\"))\n            best[start] = 0\n            min_heap = [(0, start)]\n            dp = [0]*(len(adj))  # modified, add dp to keep number of ways\n            dp[0] = 1\n            while min_heap:\n                curr, u = heapq.heappop(min_heap)\n                if best[u] < curr:\n                    continue\n                if u == target:  # modified, early return\n                    break\n                for v, w in adj[u]:                \n                    if v in best and best[v] <= curr+w:\n                        if best[v] == curr+w:  # modified, update number of ways in this minimal time\n                            dp[v] = (dp[v]+dp[u])%MOD\n                        continue\n                    dp[v] = dp[u]  # modified, init number of ways in this minimal time\n                    best[v] = curr+w\n                    heapq.heappush(min_heap, (curr+w, v))\n            return dp[target]\n\n        adj = [[] for i in xrange(n)]\n        for u, v, w in roads:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        return dijkstra(adj, 0, n-1)\n"
    },
    {
        "problem_name": "number-of-ways-to-build-house-of-cards",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\n# dp\nclass Solution(object):\n    def houseOfCards(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [0]*(n+1)  # dp[i]: number of ways with i cards and at most t triangles in the first row\n        dp[0] = 1\n        for t in xrange(1, (n+1)//3+1):\n            for i in reversed(xrange(3*t-1, n+1)):\n                dp[i] += dp[i-(3*t-1)]\n        return dp[n]\n\n\n# Time:  O(n^3)\n# Space: O(n^2)\n# dp\nclass Solution_TLE(object):\n    def houseOfCards(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [[0]*(n+1) for _ in xrange((n+1)//3+1)]  # dp[t][i]: number of ways with i cards and t triangles in the first row\n        dp[0][0] = 1\n        for t in xrange(1, (n+1)//3+1):\n            for i in xrange(3*t-1, n+1):\n                dp[t][i] = sum(dp[j][i-(3*t-1)] for j in xrange(t))\n        return sum(dp[t][n] for t in xrange((n+1)//3+1))\n"
    },
    {
        "problem_name": "number-of-ways-to-build-sturdy-brick-wall",
        "solution": "# Time:  O(h * p^2), p is the number of patterns\n# Space: O(p^2)\n\n# bitmask, backtracking, dp\nclass Solution(object):\n    def buildWall(self, height, width, bricks):\n        \"\"\"\n        :type height: int\n        :type width: int\n        :type bricks: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def backtracking(height, width, bricks, total, mask, lookup, patterns):\n            if mask in lookup:\n                return\n            lookup.add(mask)\n            if total >= width:\n                if total == width:\n                    patterns.append(mask^(1<<width))\n                return\n            for x in bricks:\n                backtracking(height, width, bricks, total+x, mask|(1<<(total+x)), lookup, patterns)\n\n        patterns, lookup = [], set()\n        backtracking(height, width, bricks, 0, 0, lookup, patterns)\n        adj = [[j for j, r2 in enumerate(patterns) if not (r1 & r2)] for r1 in patterns]\n        dp = [[1]*len(patterns), [0]*len(patterns)]\n        for i in xrange(height-1):\n            dp[(i+1)%2] = [sum(dp[i%2][k] for k in adj[j]) % MOD for j in xrange(len(patterns))]\n        return sum(dp[(height-1)%2]) % MOD\n\n\n# Time:  O(p^3 * logh), p is the number of patterns, p may be up to 512\n# Space: O(p^3)\n# bitmask, backtracking, matrix exponentiation\nclass Solution_TLE(object):\n    def buildWall(self, height, width, bricks):\n        \"\"\"\n        :type height: int\n        :type width: int\n        :type bricks: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def backtracking(height, width, bricks, total, mask, lookup, patterns):\n            if mask in lookup:\n                return\n            lookup.add(mask)\n            if total >= width:\n                if total == width:\n                    patterns.append(mask^(1<<width))\n                return\n            for x in bricks:\n                backtracking(height, width, bricks, total+x, mask|(1<<(total+x)), lookup, patterns)\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A]\n \n        def matrix_expo(A, K):\n            result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        patterns, lookup = [], set()\n        backtracking(height, width, bricks, 0, 0, lookup, patterns)\n        return reduce(lambda x,y: (x+y)%MOD,\n                      matrix_mult([[1]*len(patterns)],\n                                   matrix_expo([[int((mask1 & mask2) == 0)\n                                                 for mask2 in patterns] \n                                                 for mask1 in patterns], height-1))[0],\n                      0)  # Time: O(p^3 * logh), Space: O(p^2)\n"
    },
    {
        "problem_name": "number-of-ways-to-buy-pens-and-pencils",
        "solution": "# Time:  O(min(t / c1, c2 / g)) = O(sqrt(t)), c1 = max(cost1, cost2)\n#                                           , c2 = min(cost1, cost2)\n#                                           ,  g = gcd(c1, c2)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def waysToBuyPensPencils(self, total, cost1, cost2):\n        \"\"\"\n        :type total: int\n        :type cost1: int\n        :type cost2: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n        \n        def ceil_divide(a, b):\n            return (a+b-1)//b\n\n        def arithmetic_progression_sum(a, d, l):\n            return (a+(a+(l-1)*d))*l//2\n            \n        if cost1 < cost2:\n            cost1, cost2 = cost2, cost1\n        lcm = cost1*cost2//gcd(cost1, cost2)\n        result = 0\n        d = lcm//cost2\n        for i in xrange(min(total//cost1+1, lcm//cost1)):\n            # total, cost1, cost2 = 120, 7, 5\n            # => cnt decreases by a fixed value every lcm(cost1, cost2) \n            # => arithmetic progressions of cnts are as follows\n            #      ----- l -----  x\n            #  |   24, 17, 10, 3 120\n            #  |   22, 15,  8, 1 113\n            # cnt  21, 14,  7,   106\n            #  |   19, 12,  5,    99\n            #  |   18, 11,  4,    92\n            cnt = (total-i*cost1)//cost2+1\n            l = ceil_divide(cnt, d)\n            result += arithmetic_progression_sum(cnt, -d, l)\n        return result\n\n\n# Time:  O(t / c1), c1 = max(cost1, cost2)\n#                 , c2 = min(cost1, cost2)\n# Space: O(1)\n# math\nclass Solution2(object):\n    def waysToBuyPensPencils(self, total, cost1, cost2):\n        \"\"\"\n        :type total: int\n        :type cost1: int\n        :type cost2: int\n        :rtype: int\n        \"\"\"\n        if cost1 < cost2:\n            cost1, cost2 = cost2, cost1\n        return sum((total-i*cost1)//cost2+1 for i in xrange(total//cost1+1))\n"
    },
    {
        "problem_name": "number-of-ways-to-divide-a-long-corridor",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy, combinatorics\nclass Solution(object):\n    def numberOfWays(self, corridor):\n        \"\"\"\n        :type corridor: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result, cnt, j = 1, 0, -1\n        for i, x in enumerate(corridor):\n            if x != 'S':\n                continue\n            cnt += 1\n            if cnt >= 3 and cnt%2:\n                result = result*(i-j)%MOD\n            j = i\n        return result if cnt and cnt%2 == 0 else 0\n"
    },
    {
        "problem_name": "number-of-ways-to-earn-points",
        "solution": "# Time:  O(n * t * c)\n# Space: O(t)\n\n# knapsack dp\nclass Solution(object):\n    def waysToReachTarget(self, target, types):\n        \"\"\"\n        :type target: int\n        :type types: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [0]*(target+1)\n        dp[0] = 1\n        for c, m in types:\n            for i in reversed(xrange(1, target+1)):\n                for j in xrange(1, min(i//m, c)+1):\n                    dp[i] = (dp[i]+dp[i-j*m])%MOD\n        return dp[-1]\n\n\n# Time:  O(n * t * c)\n# Space: O(t)\n# knapsack dp\nclass Solution2(object):\n    def waysToReachTarget(self, target, types):\n        \"\"\"\n        :type target: int\n        :type types: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [0]*(target+1)\n        dp[0] = 1\n        for c, m in types:\n            new_dp = [0]*(target+1)\n            for i in xrange(target+1):\n                for j in xrange(min((target-i)//m, c)+1):\n                    new_dp[i+j*m] = (new_dp[i+j*m]+dp[i])%MOD\n            dp = new_dp\n        return dp[-1]\n"
    },
    {
        "problem_name": "number-of-ways-to-form-a-target-string-given-a-dictionary",
        "solution": "# Time:  O(l * (w + n)), l is the length of a word, w is the number of words, n is the length of target\n# Space: O(n)\n\nimport collections\n\n\n# optimized from Solution2\nclass Solution(object):\n    def numWays(self, words, target):\n        \"\"\"\n        :type words: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [0]*(len(target)+1)\n        dp[0] = 1\n        for i in xrange(len(words[0])):\n            count = collections.Counter(w[i] for w in words)\n            for j in reversed(xrange(len(target))):\n                dp[j+1] += dp[j]*count[target[j]] % MOD\n        return dp[-1] % MOD\n\n\n# Time:  O(l * (w + n)), l is the length of a word, w is the number of words, n is the length of target\n# Space: O(n)\nimport collections\n\n\nclass Solution2(object):\n    def numWays(self, words, target):\n        \"\"\"\n        :type words: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        # dp[i+1][j+1]: number of ways of target[0..j] using count[0..i].\n        dp = [[0]*(len(target)+1) for _ in xrange(2)]\n        for i in xrange(len(dp)):\n            dp[i][0] = 1\n        for i in xrange(len(words[0])):\n            count = collections.Counter(w[i] for w in words)\n            for j in reversed(xrange(len(target))):\n                dp[(i+1)%2][j+1] = dp[i%2][j+1]+dp[i%2][j]*count[target[j]] % MOD\n        return dp[(len(words[0]))%2][-1] % MOD\n"
    },
    {
        "problem_name": "number-of-ways-to-paint-n-3-grid",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def numOfWays(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def matrix_expo(A, K):\n            result = [[int(i==j) for j in xrange(len(A))]\n                       for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD\n                     for col in ZB] for row in A]\n        \n        MOD = 10**9 + 7\n        T = [[3, 2],\n             [2, 2]]\n        return sum(matrix_mult([[6, 6]], matrix_expo(T, n-1))[0]) % MOD  # [a1, a0] * T^(n-1)\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def numOfWays(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        aba, abc = 6, 6\n        for _ in xrange(n-1):\n            aba, abc = (3*aba%MOD + 2*abc%MOD)%MOD, \\\n                       (2*abc%MOD + 2*aba%MOD)%MOD\n        return (aba+abc)%MOD\n"
    },
    {
        "problem_name": "number-of-ways-to-reach-a-position-after-exactly-k-steps",
        "solution": "# Time:  O(k)\n# Space: O(k)\n\n# combinatorics\nclass Solution(object):\n    def numberOfWays(self, startPos, endPos, k):\n        \"\"\"\n        :type startPos: int\n        :type endPos: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        fact, inv, inv_fact = [[1]*2 for _ in xrange(3)]\n        def nCr(n, k):\n            while len(inv) <= n:  # lazy initialization\n                fact.append(fact[-1]*len(inv) % MOD)\n                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD)  # https://cp-algorithms.com/algebra/module-inverse.html\n                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)\n            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD\n\n        r = k-abs(endPos-startPos)\n        return nCr(k, r//2) if r >= 0 and r%2 == 0 else 0  \n"
    },
    {
        "problem_name": "number-of-ways-to-reach-destination-in-the-grid",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\n# dp, matrix exponentiation\nclass Solution(object):\n    def numberOfWays(self, n, m, k, source, dest):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :type k: int\n        :type source: List[int]\n        :type dest: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A]\n \n        def matrix_expo(A, K):\n            result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        T = [[0, m-1, n-1,           0],\n             [1, m-2,   0,         n-1],\n             [1,   0, n-2,         m-1],\n             [0,   1,   1, (n-2)+(m-2)]]\n        dp = [0]*4  # dp[0] = both_same, dp[1] = row_same, dp[2] = col_same, dp[3] = no_same\n        if source == dest:\n            dp[0] = 1\n        elif source[0] == dest[0]:\n            dp[1] = 1\n        elif source[1] == dest[1]:\n            dp[2] = 1\n        else:\n            dp[3] = 1\n        dp = matrix_mult([dp], matrix_expo(T, k))[0]  # [dp[0], dp[1], dp[2], dp[3]] * T^k\n        return dp[0]\n\n\n# Time:  O(n)\n# Space: O(1)\n# dp\nclass Solution2(object):\n    def numberOfWays(self, n, m, k, source, dest):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :type k: int\n        :type source: List[int]\n        :type dest: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        both_same = row_same = col_same = no_same = 0\n        if source == dest:\n            both_same = 1\n        elif source[0] == dest[0]:\n            row_same = 1\n        elif source[1] == dest[1]:\n            col_same = 1\n        else:\n            no_same = 1\n        for _ in xrange(k):\n            both_same, row_same, col_same, no_same = (row_same+col_same)%MOD, (both_same*(m-1)+row_same*(m-2)+no_same)%MOD, (both_same*(n-1)+col_same*(n-2)+no_same)%MOD, (row_same*(n-1)+col_same*(m-1)+no_same*((n-2)+(m-2)))%MOD\n        return both_same\n"
    },
    {
        "problem_name": "number-of-ways-to-rearrange-sticks-with-k-sticks-visible",
        "solution": "# Time:  O(n * k)\n# Space: O(k)\n\nclass Solution(object):\n    def rearrangeSticks(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [[0 for _ in xrange(k+1)] for _ in xrange(2)]\n        dp[1][1] = 1\n        for i in xrange(2, n+1):\n            for j in xrange(1, min(i, k)+1):\n                # choose the tallest as the last one which would be visible:    dp[i-1][j-1]\n                # choose the non-tallest as the last one which would be hidden: (i-1)*dp[i-1][j]\n                dp[i%2][j] = (dp[(i-1)%2][j-1]+(i-1)*dp[(i-1)%2][j]) % MOD \n        return dp[n%2][k]\n"
    },
    {
        "problem_name": "number-of-ways-to-reconstruct-a-tree",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def checkWays(self, pairs):\n        \"\"\"\n        :type pairs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        adj = collections.defaultdict(set)\n        for x, y in pairs:\n            adj[x].add(y)\n            adj[y].add(x)\n        n, mul = len(adj), False\n        lookup = set()\n        for node in sorted(adj.iterkeys(), key=lambda i: len(adj[i]), reverse=True):\n            lookup.add(node)\n            parent = 0\n            for x in adj[node]:\n                if x not in lookup:\n                    continue\n                if parent == 0 or len(adj[x]) < len(adj[parent]):\n                    parent = x\n            if parent:\n                if any(True for x in adj[node] if x != parent and x not in adj[parent]):\n                    return 0\n                mul |= len(adj[parent]) == len(adj[node])\n            elif len(adj[node]) != n-1:\n                return 0\n        return 1 + mul\n"
    },
    {
        "problem_name": "number-of-ways-to-reorder-array-to-get-same-bst",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nMAX_N = 1000\nMOD = 10**9+7\ndp = [[0]*MAX_N for _ in xrange(MAX_N)]\nfor i in xrange(len(dp)):\n    dp[i][0] = 1\n    for j in xrange(1, i+1):\n        dp[i][j] = (dp[i-1][j-1] + dp[i-1][j])%MOD\n\n\nclass Solution(object):\n    def numOfWays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def iter_dfs(nums):\n            result = [0]\n            stk = [[1, [nums, result]]]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    nums, ret = params\n                    if len(nums) <= 2:\n                        ret[0] = 1\n                        continue\n                    left = [v for v in nums if v < nums[0]]\n                    right = [v for v in nums if v > nums[0]]\n                    ret[0] = dp[len(left)+len(right)][len(left)]\n                    ret1, ret2 = [0], [0]\n                    stk.append([2, [ret1, ret2, ret]])\n                    stk.append([1, [right, ret2]])\n                    stk.append([1, [left, ret1]])\n                elif step == 2:\n                    ret1, ret2, ret = params\n                    ret[0] = ret[0]*ret1[0] % MOD\n                    ret[0] = ret[0]*ret2[0] % MOD\n            return result[0]\n\n        return (iter_dfs(nums)-1)%MOD\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\nclass Solution(object):\n    def numOfWays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(nums):\n            if len(nums) <= 2:\n                return 1\n            left = [v for v in nums if v < nums[0]]\n            right = [v for v in nums if v > nums[0]]\n            result = dp[len(left)+len(right)][len(left)]\n            result = result*dfs(left) % MOD\n            result = result*dfs(right) % MOD\n            return result\n\n        return (dfs(nums)-1)%MOD\n"
    },
    {
        "problem_name": "number-of-ways-to-select-buildings",
        "solution": "# Time:  O(k * n) = O(n)\n# Space: O(k) = O(1)\n\n# dp\nclass Solution(object):\n    def numberOfWays(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        K = 3\n        dp = [[0]*2 for _ in xrange(K)]  # dp[i][j]: number of ways of selecting i+1 buildings ending with type j\n        for c in s:\n            j = ord(c)-ord('0')\n            dp[0][j] += 1\n            for i in xrange(1, len(dp)):\n                dp[i][j] += dp[i-1][1^j]\n        return dp[-1][0]+dp[-1][1]\n"
    },
    {
        "problem_name": "number-of-ways-to-separate-numbers",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nclass Solution(object):\n    def numberOfCombinations(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def find_longest_common_prefix(num):\n            lcp = [[0]*(len(num)+1) for _ in xrange(len(num)+1)]  # lcp[i][j]: longest length of the common prefix which starts at num[i], num[j]\n            for i in reversed(xrange(len(lcp)-1)):\n                for j in reversed(xrange(len(lcp[0])-1)):\n                    if num[i] == num[j]:\n                        lcp[i][j] = lcp[i+1][j+1]+1\n            return lcp\n\n        def is_less_or_equal_to_with_same_length(num, lcp, i, j, l):\n            return lcp[i][j] >= l or num[i+lcp[i][j]] < num[j+lcp[i][j]]\n\n        lcp = find_longest_common_prefix(num)\n        dp = [[0]*len(num) for _ in xrange(len(num))]  # dp[i][l]: the count of numbers ending at num[i], where the length of the last number is l+1\n        dp[0][0] = int(num[0] != '0')\n        for i in xrange(1, len(num)):\n            dp[i][i] = dp[i-1][i-1]\n            if num[i] == '0':\n                continue\n            accu = 0\n            for l in xrange(len(num)-i+1):\n                ni = i+l-1\n                dp[ni][l-1] = accu  # accumulated count where the length of the second to last number ending at num[i-1] is shorter than the length of the last number ending at num[i+l-1]\n                if i-l < 0:\n                    continue\n                if num[i-l] != '0' and is_less_or_equal_to_with_same_length(num, lcp, i-l, i, l):\n                    dp[ni][l-1] = (dp[ni][l-1] + dp[i-1][l-1]) % MOD\n                accu = (accu + dp[i-1][l-1]) % MOD\n        return reduce(lambda total, x: (total+x)%MOD, dp[-1], 0)\n"
    },
    {
        "problem_name": "number-of-ways-to-split-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numWays(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        ones = s.count('1')\n        if ones % 3:\n            return 0\n        ones //= 3\n        if ones == 0:\n            return (len(s)-1)*(len(s)-2)//2 % MOD\n        count = left = right = 0\n        for c in s:\n            if c == '1':\n                count += 1\n            if count == ones:\n                left += 1\n            elif count == 2*ones:\n                right += 1\n        return left*right % MOD\n"
    },
    {
        "problem_name": "number-of-ways-to-split-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# prefix sum\nclass Solution(object):\n    def waysToSplitArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        total = sum(nums)\n        result = curr = 0\n        for i in xrange(len(nums)-1):\n            curr += nums[i]\n            result += int(curr >= total-curr)\n        return result\n"
    },
    {
        "problem_name": "number-of-ways-to-stay-in-the-same-place-after-some-steps",
        "solution": "# Time:  O(n^2), n is the number of steps\n# Space: O(n)\n    \nclass Solution(object):\n    def numWays(self, steps, arrLen):\n        \"\"\"\n        :type steps: int\n        :type arrLen: int\n        :rtype: int\n        \"\"\"\n        MOD = int(1e9+7)\n        l = min(1+steps//2, arrLen)\n        dp = [0]*(l+2)\n        dp[1] = 1\n        while steps > 0:\n            steps -= 1\n            new_dp = [0]*(l+2)\n            for i in xrange(1, l+1):\n                new_dp[i] = (dp[i] + dp[i-1] + dp[i+1]) % MOD\n            dp = new_dp\n        return dp[1]\n"
    },
    {
        "problem_name": "number-of-ways-to-wear-different-hats-to-each-other",
        "solution": "# Time:  O(h * 2^n)\n# Space: O(2^n)\n\nclass Solution(object):\n    def numberWays(self, hats):\n        \"\"\"\n        :type hats: List[List[int]]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        HAT_SIZE = 40\n        hat_to_people = [[] for _ in xrange(HAT_SIZE)]\n        for i in xrange(len(hats)):\n            for h in hats[i]:\n                hat_to_people[h-1].append(i)\n        dp = [0]*(1<<len(hats))\n        dp[0] = 1\n        for people in hat_to_people:\n            for mask in reversed(xrange(len(dp))):\n                for p in people:\n                    if mask & (1<<p):\n                        continue\n                    dp[mask | (1<<p)] += dp[mask]\n                    dp[mask | (1<<p)] %= MOD\n        return dp[-1]\n"
    },
    {
        "problem_name": "number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nimport collections\n\n\nclass Solution(object):\n    def numTriplets(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        def two_product(nums, i):\n            count = 0\n            lookup = collections.defaultdict(int)\n            for num in nums:\n                if i%num:\n                    continue\n                count += lookup[i//num]\n                lookup[num] += 1\n            return count\n        \n        result = 0\n        for num in nums1:\n            result += two_product(nums2, num**2)\n        for num in nums2:\n            result += two_product(nums1, num**2)\n        return result\n"
    },
    {
        "problem_name": "number-of-wonderful-substrings",
        "solution": "# Time:  O(n)\n# Space: O(2^10)\n\nclass Solution(object):\n    def wonderfulSubstrings(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        ALPHABET_SIZE = 10\n        count = [0]*(2**ALPHABET_SIZE)\n        count[0] = 1\n        result = curr = 0\n        for c in word:\n            curr ^= 1<<(ord(c)-ord('a'))\n            result += count[curr]\n            result += sum(count[curr^(1<<i)] for i in xrange(ALPHABET_SIZE))\n            count[curr] += 1\n        return result\n"
    },
    {
        "problem_name": "number-of-zero-filled-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers, combinatorics\nclass Solution(object):\n    def zeroFilledSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        prev = -1\n        for i in xrange(len(nums)):\n            if nums[i]:\n                prev = i\n                continue\n            result += i-prev\n        return result\n"
    },
    {
        "problem_name": "numbers-at-most-n-given-digit-set",
        "solution": "# Time:  O(logn)\n# Space: O(logn)\n\nclass Solution(object):\n    def atMostNGivenDigitSet(self, D, N):\n        \"\"\"\n        :type D: List[str]\n        :type N: int\n        :rtype: int\n        \"\"\"\n        str_N = str(N)\n        set_D = set(D)\n        result = sum(len(D)**i for i in xrange(1, len(str_N)))\n        i = 0\n        while i < len(str_N):\n            result += sum(c < str_N[i] for c in D) * (len(D)**(len(str_N)-i-1))\n            if str_N[i] not in set_D:\n                break\n            i += 1\n        return result + int(i == len(str_N))\n\n"
    },
    {
        "problem_name": "numbers-with-repeated-digits",
        "solution": "# Time:  O(logn)\n# Space: O(logn)\n\nclass Solution(object):\n    def numDupDigitsAtMostN(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        def P(m, n):\n            result = 1\n            for _ in xrange(n):\n                result *= m\n                m -= 1\n            return result\n\n        digits = map(int, str(N+1))\n        result = 0\n\n        # Given 321\n        #\n        # 1. count numbers without repeated digits:\n        # - X\n        # - XX\n        for i in xrange(1, len(digits)):\n            result += P(9, 1)*P(9, i-1)\n        \n        # 2. count numbers without repeated digits:\n        # - 1XX ~ 3XX\n        # - 30X ~ 32X\n        # - 320 ~ 321\n        prefix_set = set()\n        for i, x in enumerate(digits):\n            for y in xrange(1 if i == 0 else 0, x):\n                if y in prefix_set:\n                    continue\n                result += P(9-i, len(digits)-i-1)\n            if x in prefix_set:\n                break\n            prefix_set.add(x)\n        return N-result\n"
    },
    {
        "problem_name": "numbers-with-same-consecutive-differences",
        "solution": "# Time:  O(2^n)\n# Space: O(2^n)\n\nclass Solution(object):\n    def numsSameConsecDiff(self, N, K):\n        \"\"\"\n        :type N: int\n        :type K: int\n        :rtype: List[int]\n        \"\"\"\n        curr = range(10)\n        for i in xrange(N-1):\n            curr = [x*10 + y for x in curr for y in set([x%10 + K, x%10 - K]) \n                    if x and 0 <= y < 10]\n        return curr\n"
    },
    {
        "problem_name": "occurrences-after-bigram",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findOcurrences(self, text, first, second):\n        \"\"\"\n        :type text: str\n        :type first: str\n        :type second: str\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        first += ' '\n        second += ' '\n        third = []\n        i, j, k = 0, 0, 0\n        while k < len(text):\n            c = text[k]\n            k += 1\n            if i != len(first):\n                if c == first[i]:\n                    i += 1\n                else:\n                    i = 0\n                continue\n            if j != len(second):\n                if c == second[j]:\n                    j += 1\n                else:\n                    k -= j+1\n                    i, j = 0, 0\n                continue\n            if c != ' ':\n                third.append(c)\n                continue\n            k -= len(second) + len(third) + 1\n            i, j = 0, 0\n            result.append(\"\".join(third))\n            third = []\n        if third:\n            result.append(\"\".join(third))\n        return result\n"
    },
    {
        "problem_name": "odd-even-jump",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def oddEvenJumps(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        def findNext(idx):\n            result = [None]*len(idx)\n            stack = []\n            for i in idx:\n                while stack and stack[-1] < i:\n                    result[stack.pop()] = i\n                stack.append(i)\n            return result\n        \n        idx = sorted(range(len(A)), key = lambda i: A[i])\n        next_higher = findNext(idx)\n        idx.sort(key = lambda i: -A[i])\n        next_lower = findNext(idx)\n\n        odd, even = [False]*len(A), [False]*len(A)\n        odd[-1], even[-1] = True, True\n        for i in reversed(xrange(len(A)-1)):\n            if next_higher[i]:\n                odd[i] = even[next_higher[i]]\n            if next_lower[i]:\n                even[i] = odd[next_lower[i]]\n        return sum(odd)\n"
    },
    {
        "problem_name": "odd-even-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def oddEvenList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head:\n            odd_tail, cur = head, head.next\n            while cur and cur.next:\n                even_head = odd_tail.next\n                odd_tail.next = cur.next\n                odd_tail = odd_tail.next\n                cur.next = odd_tail.next\n                odd_tail.next = even_head\n                cur = cur.next\n        return head\n\n"
    },
    {
        "problem_name": "odd-string-difference",
        "solution": "# Time:  O(m * n), m is the number of words, n is the length of each word\n# Space: O(1)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def oddString(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        for i in xrange(len(words[0])-1):\n            lookup = collections.defaultdict(list)\n            for j, w in enumerate(words):\n                if len(lookup[ord(w[i+1])-ord(w[i])]) < 2:\n                    lookup[ord(w[i+1])-ord(w[i])].append(j)\n            if len(lookup) == 2:\n                return next(words[l[0]] for l in lookup.itervalues() if len(l) == 1)\n\n\n# Time:  O(m * n), m is the number of words, n is the length of each word\n# Space: O(n)\nimport collections\n\n\n# freq table\nclass Solution2(object):\n    def oddString(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        cnt = collections.Counter(tuple(ord(w[i+1])-ord(w[i]) for i in xrange(len(w)-1)) for w in words)\n        target = next(k for k, v in cnt.iteritems() if v == 1)\n        return next(w for w in words if tuple(ord(w[i+1])-ord(w[i]) for i in xrange(len(w)-1)) == target)\n"
    },
    {
        "problem_name": "one-edit-distance",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nclass Solution(object):\n    def isOneEditDistance(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        m, n = len(s), len(t)\n        if m > n:\n            return self.isOneEditDistance(t, s)\n        if n - m > 1:\n            return False\n\n        i, shift = 0, n - m\n        while i < m and s[i] == t[i]:\n            i += 1\n        if shift == 0:\n            i += 1\n        while i < m and s[i] == t[i + shift]:\n            i += 1\n\n        return i == m\n\n\n"
    },
    {
        "problem_name": "ones-and-zeroes",
        "solution": "# Time:  O(s * m * n), s is the size of the array.\n# Space: O(m * n)\n\nclass Solution(object):\n    def findMaxForm(self, strs, m, n):\n        \"\"\"\n        :type strs: List[str]\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]\n        for s in strs:\n            zero_count, one_count = 0, 0\n            for c in s:\n                if c == '0':\n                    zero_count += 1\n                elif c == '1':\n                    one_count += 1\n\n            for i in reversed(xrange(zero_count, m+1)):\n            \tfor j in reversed(xrange(one_count, n+1)):\n                    dp[i][j] = max(dp[i][j], dp[i-zero_count][j-one_count]+1)\n        return dp[m][n]\n\n"
    },
    {
        "problem_name": "online-election",
        "solution": "# Time:  ctor: O(n)\n#        q:    O(logn)\n# Space: O(n)\n\nimport collections\nimport itertools\nimport bisect\n\n\nclass TopVotedCandidate(object):\n\n    def __init__(self, persons, times):\n        \"\"\"\n        :type persons: List[int]\n        :type times: List[int]\n        \"\"\"\n        lead = -1\n        self.__lookup, count = [], collections.defaultdict(int)\n        for t, p in itertools.izip(times, persons):\n            count[p] += 1\n            if count[p] >= count[lead]:\n                lead = p\n                self.__lookup.append((t, lead))\n\n    def q(self, t):\n        \"\"\"\n        :type t: int\n        :rtype: int\n        \"\"\"\n        return self.__lookup[bisect.bisect(self.__lookup,\n                                           (t, float(\"inf\")))-1][1]\n\n\n\n"
    },
    {
        "problem_name": "online-majority-element-in-subarray",
        "solution": "# Time:  ctor:  O(n)\n#        query: O(klogn), k = log2(Q/ERROR_RATE)\n# Space: O(n)\n\nimport collections\nimport random\nimport bisect\n\n\nclass MajorityChecker(object):\n\n    def __init__(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        \"\"\"\n        Q, ERROR_RATE = 10000, 0.001\n        self.__K = int(Q/ERROR_RATE).bit_length()  # floor(log2(Q/ERROR_RATE))+1 = 24\n        self.__arr = arr\n        self.__inv_idx = collections.defaultdict(list)\n        for i, x in enumerate(self.__arr):\n            self.__inv_idx[x].append(i)\n\n    def query(self, left, right, threshold):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        def count(inv_idx, m, left, right):\n            return bisect.bisect_right(inv_idx[m], right) - \\\n                   bisect.bisect_left(inv_idx[m], left)\n\n        for _ in xrange(self.__K):\n            m = self.__arr[random.randint(left, right)]\n            if count(self.__inv_idx, m, left, right) >= threshold:\n                return m\n        return -1\n\n\n# Time:  ctor:  O(n)\n#        query: O(sqrt(n)*logn)\n# Space: O(n)\nimport collections\nimport bisect\n\n\nclass MajorityChecker2(object):\n\n    def __init__(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        \"\"\"\n        self.__arr = arr\n        self.__inv_idx = collections.defaultdict(list)\n        for i, x in enumerate(self.__arr):\n            self.__inv_idx[x].append(i)\n        self.__bound = int(round((len(arr)**0.5)))\n        self.__majorities = [i for i, group in self.__inv_idx.iteritems() if len(group) >= self.__bound]\n\n    def query(self, left, right, threshold):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        def count(inv_idx, m, left, right):\n            return bisect.bisect_right(inv_idx[m], right) - \\\n                   bisect.bisect_left(inv_idx[m], left)\n\n        def boyer_moore_majority_vote(nums, left, right):\n            m, cnt = nums[left], 1\n            for i in xrange(left+1, right+1):\n                if m == nums[i]:\n                    cnt += 1\n                else:\n                    cnt -= 1\n                    if cnt == 0:\n                        m = nums[i]\n                        cnt = 1\n            return m\n\n        if right-left+1 < self.__bound:\n            m = boyer_moore_majority_vote(self.__arr, left, right)\n            if count(self.__inv_idx, m, left, right) >= threshold:\n                return m\n        else:\n            for m in self.__majorities:\n                if count(self.__inv_idx, m, left, right) >= threshold:\n                    return m\n        return -1\n\n\n# Time:  ctor:  O(nlogn)\n#        query: O((logn)^2)\n# Space: O(n)\nimport functools\n\n\nclass SegmentTreeRecu(object):  # 0-based index\n    def __init__(self, nums, count):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        N = len(nums)\n        self.__original_length = N\n        self.__tree_length = 2**(N.bit_length() + (N&(N-1) != 0))-1\n        self.__tree = [-1 for _ in range(self.__tree_length)]\n        self.__count = count\n        self.__constructTree(nums, 0, self.__original_length-1, 0)\n\n    def query(self, i, j):\n        return self.__queryRange(i, j, 0, self.__original_length-1, 0)\n\n    def __constructTree(self, nums, left, right, idx):\n        if left > right:\n             return\n        if left == right:\n            self.__tree[idx] = nums[left]\n            return \n        mid = left + (right-left)//2\n        self.__constructTree(nums, left, mid, idx*2 + 1)\n        self.__constructTree(nums, mid+1, right, idx*2 + 2)\n        if self.__tree[idx*2 + 1] != -1 and \\\n           self.__count(self.__tree[idx*2 + 1], left, right)*2 > right-left+1:\n            self.__tree[idx] = self.__tree[idx*2 + 1] \n        elif self.__tree[idx*2 + 2] != -1 and \\\n             self.__count(self.__tree[idx*2 + 2], left, right)*2 > right-left+1:\n            self.__tree[idx] = self.__tree[idx*2 + 2] \n\n    def __queryRange(self, range_left, range_right, left, right, idx):\n        if left > right:\n            return (-1, -1)\n        if right < range_left or left > range_right:\n            return (-1, -1)\n        if range_left <= left and right <= range_right:\n            if self.__tree[idx] != -1:\n                c = self.__count(self.__tree[idx], range_left, range_right)\n                if c*2 > range_right-range_left+1:\n                    return (self.__tree[idx], c)\n        else:\n            mid = left + (right-left)//2\n            result = self.__queryRange(range_left, range_right, left, mid, idx*2 + 1)\n            if result[0] != -1:\n                return result\n            result = self.__queryRange(range_left, range_right, mid + 1, right, idx*2 + 2)\n            if result[0] != -1:\n                return result\n        return (-1, -1)\n\n\nclass MajorityChecker3(object):\n\n    def __init__(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        \"\"\"\n        def count(inv_idx, m, left, right):\n            return bisect.bisect_right(inv_idx[m], right) - \\\n                   bisect.bisect_left(inv_idx[m], left)\n\n        self.__arr = arr\n        self.__inv_idx = collections.defaultdict(list)\n        for i, x in enumerate(self.__arr):\n            self.__inv_idx[x].append(i)\n        self.__segment_tree = SegmentTreeRecu(arr, functools.partial(count, self.__inv_idx))\n\n    def query(self, left, right, threshold):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        result = self.__segment_tree.query(left, right)\n        if result[1] >= threshold:\n            return result[0]\n        return -1\n\n\n# Time:  ctor:  O(n)\n#        query: O(sqrt(n)*logn)\n# Space: O(n)\nimport collections\nimport bisect\n\n\nclass MajorityChecker4(object):\n\n    def __init__(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        \"\"\"\n        self.__arr = arr\n        self.__inv_idx = collections.defaultdict(list)\n        for i, x in enumerate(self.__arr):\n            self.__inv_idx[x].append(i)\n        self.__bucket_size = int(round((len(arr)**0.5)))\n        self.__bucket_majorities = []\n        for left in xrange(0, len(self.__arr), self.__bucket_size):\n            right = min(left+self.__bucket_size-1, len(self.__arr)-1)\n            self.__bucket_majorities.append(self.__boyer_moore_majority_vote(self.__arr, left, right))\n\n    def query(self, left, right, threshold):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        def count(inv_idx, m, left, right):\n            return bisect.bisect_right(inv_idx[m], right) - \\\n                   bisect.bisect_left(inv_idx[m], left)\n\n        l, r = left//self.__bucket_size, right//self.__bucket_size;\n        if l == r:\n            m = self.__boyer_moore_majority_vote(self.__arr, left, right)\n            if count(self.__inv_idx, m, left, right) >= threshold:\n                return m\n            return -1\n        else:\n            m = self.__boyer_moore_majority_vote(self.__arr, left, (l+1)*self.__bucket_size-1)\n            if count(self.__inv_idx, m, left, right) >= threshold:\n                return m\n            m = self.__boyer_moore_majority_vote(self.__arr, r*self.__bucket_size, right)\n            if count(self.__inv_idx, m, left, right) >= threshold:\n                return m;\n            for i in xrange(l+1, r):\n                if count(self.__inv_idx, self.__bucket_majorities[i], left, right) >= threshold:\n                    return self.__bucket_majorities[i]\n            return -1\n    \n    def __boyer_moore_majority_vote(self, nums, left, right):\n            m, cnt = nums[left], 1\n            for i in xrange(left+1, right+1):\n                if m == nums[i]:\n                    cnt += 1\n                else:\n                    cnt -= 1\n                    if cnt == 0:\n                        m = nums[i]\n                        cnt = 1\n            return m\n"
    },
    {
        "problem_name": "online-stock-span",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass StockSpanner(object):\n\n    def __init__(self):\n        self.__s = []\n\n    def next(self, price):\n        \"\"\"\n        :type price: int\n        :rtype: int\n        \"\"\"\n        result = 1\n        while self.__s and self.__s[-1][0] <= price:\n            result += self.__s.pop()[1]\n        self.__s.append([price, result])\n        return result\n\n\n\n"
    },
    {
        "problem_name": "open-the-lock",
        "solution": "# Time:  O(k * n^k + d), n is the number of alphabets,\n#                        k is the length of target,\n#                        d is the size of deadends\n# Space: O(k * n^k + d)\n\nclass Solution(object):\n    def openLock(self, deadends, target):\n        \"\"\"\n        :type deadends: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        dead = set(deadends)\n        q = [\"0000\"]\n        lookup = {\"0000\"}\n        depth = 0\n        while q:\n            next_q = []\n            for node in q:\n                if node == target: return depth\n                if node in dead: continue\n                for i in xrange(4):\n                    n = int(node[i])\n                    for d in (-1, 1):\n                        nn = (n+d) % 10\n                        neighbor = node[:i] + str(nn) + node[i+1:]\n                        if neighbor not in lookup:\n                            lookup.add(neighbor)\n                            next_q.append(neighbor)\n            q = next_q\n            depth += 1\n        return -1\n\n"
    },
    {
        "problem_name": "operations-on-tree",
        "solution": "# Time:  ctor:    O(n)\n#        lock:    O(1)\n#        unlock:  O(1)\n#        upgrade: O(n)\n# Space: O(n)\n\nclass LockingTree(object):\n\n    def __init__(self, parent):\n        \"\"\"\n        :type parent: List[int]\n        \"\"\"\n        self.__parent = parent\n        self.__children = [[] for _ in xrange(len(parent))]\n        for i, x in enumerate(parent):\n            if x != -1:\n                self.__children[x].append(i)\n        self.__locked = {}\n\n    def lock(self, num, user):\n        \"\"\"\n        :type num: int\n        :type user: int\n        :rtype: bool\n        \"\"\"\n        if num in self.__locked:\n            return False\n        self.__locked[num] = user\n        return True\n\n    def unlock(self, num, user):\n        \"\"\"\n        :type num: int\n        :type user: int\n        :rtype: bool\n        \"\"\"\n        if self.__locked.get(num) != user:\n            return False\n        del self.__locked[num]\n        return True\n\n    def upgrade(self, num, user):\n        \"\"\"\n        :type num: int\n        :type user: int\n        :rtype: bool\n        \"\"\"\n        node = num\n        while node != -1:\n            if node in self.__locked:\n                return False\n            node = self.__parent[node]\n        result = False\n        stk = [num]\n        while stk:\n            node = stk.pop()\n            if node in self.__locked:\n                del self.__locked[node]\n                result = True\n            for child in self.__children[node]:\n                stk.append(child)\n        if result:\n            self.__locked[num] = user\n        return result\n"
    },
    {
        "problem_name": "optimal-account-balancing",
        "solution": "# Time:  O(n * 2^n), n is the size of the debt.\n# Space: O(2^n)\n\nimport collections\n\n\nclass Solution(object):\n    def minTransfers(self, transactions):\n        \"\"\"\n        :type transactions: List[List[int]]\n        :rtype: int\n        \"\"\"\n        accounts = collections.defaultdict(int)\n        for src, dst, amount in transactions:\n            accounts[src] += amount\n            accounts[dst] -= amount\n\n        debts = [account for account in accounts.itervalues() if account]\n\n        dp = [0]*(2**len(debts))\n        sums = [0]*(2**len(debts))\n        for i in xrange(len(dp)):\n            bit = 1\n            for j in xrange(len(debts)):\n                if (i & bit) == 0:\n                    nxt = i | bit\n                    sums[nxt] = sums[i]+debts[j]\n                    if sums[nxt] == 0:\n                        dp[nxt] = max(dp[nxt], dp[i]+1)\n                    else:\n                        dp[nxt] = max(dp[nxt], dp[i])\n                bit <<= 1\n        return len(debts)-dp[-1]\n"
    },
    {
        "problem_name": "optimal-division",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def optimalDivision(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: str\n        \"\"\"\n        if len(nums) == 1:\n            return str(nums[0])\n        if len(nums) == 2:\n            return str(nums[0]) + \"/\" + str(nums[1])\n        result = [str(nums[0]) + \"/(\" + str(nums[1])]\n        for i in xrange(2, len(nums)):\n            result += \"/\" + str(nums[i])\n        result += \")\"\n        return \"\".join(result)\n\n"
    },
    {
        "problem_name": "optimal-partition-of-string",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table\nclass Solution(object):\n    def partitionString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, left = 1, 0\n        lookup = {}\n        for i, x in enumerate(s):\n            if x in lookup and lookup[x] >= left:\n                left = i\n                result += 1\n            lookup[x] = i\n        return result\n"
    },
    {
        "problem_name": "optimize-water-distribution-in-a-village",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[max(x_root, y_root)] = min(x_root, y_root)\n        self.count -= 1\n        return True\n\n\nclass Solution(object):\n    def minCostToSupplyWater(self, n, wells, pipes):\n        \"\"\"\n        :type n: int\n        :type wells: List[int]\n        :type pipes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        w = [[c, 0, i] for i, c in enumerate(wells, 1)]\n        p = [[c, i, j] for i, j, c in pipes]\n        result = 0\n        union_find = UnionFind(n+1)\n        for c, x, y in sorted(w+p):\n            if not union_find.union_set(x, y):\n                continue\n            result += c\n            if union_find.count == 1:\n                break\n        return result\n"
    },
    {
        "problem_name": "orderly-queue",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def orderlyQueue(self, S, K):\n        \"\"\"\n        :type S: str\n        :type K: int\n        :rtype: str\n        \"\"\"\n        if K == 1:\n            return min(S[i:] + S[:i] for i in xrange(len(S)))\n        return \"\".join(sorted(S))\n\n"
    },
    {
        "problem_name": "out-of-boundary-paths",
        "solution": "# Time:  O(N * m * n)\n# Space: O(m * n)\n\nclass Solution(object):\n    def findPaths(self, m, n, N, x, y):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type N: int\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        M = 1000000000 + 7\n        dp = [[[0 for _ in xrange(n)] for _ in xrange(m)] for _ in xrange(2)]\n        for moves in xrange(N):\n            for i in xrange(m):\n                for j in xrange(n):\n                    dp[(moves + 1) % 2][i][j] = (((1 if (i == 0) else dp[moves % 2][i - 1][j]) + \\\n                                                  (1 if (i == m - 1) else dp[moves % 2][i + 1][j])) % M + \\\n                                                 ((1 if (j == 0) else dp[moves % 2][i][j - 1]) + \\\n                                                  (1 if (j == n - 1) else dp[moves % 2][i][j + 1])) % M) % M\n        return dp[N % 2][x][y]\n\n"
    },
    {
        "problem_name": "output-contest-matches",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def findContestMatch(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        matches = map(str, range(1, n+1))\n        while len(matches)/2:\n            matches = [\"({},{})\".format(matches[i], matches[-i-1]) for i in xrange(len(matches)/2)]\n        return matches[0]\n\n\n"
    },
    {
        "problem_name": "pacific-atlantic-water-flow",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nclass Solution(object):\n    def pacificAtlantic(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        PACIFIC, ATLANTIC = 1, 2\n\n        def pacificAtlanticHelper(matrix, x, y, prev_height, prev_val, visited, res):\n            if (not 0 <= x < len(matrix)) or \\\n               (not 0 <= y < len(matrix[0])) or \\\n               matrix[x][y] < prev_height or \\\n               (visited[x][y] | prev_val) == visited[x][y]:\n                return\n\n            visited[x][y] |= prev_val\n            if visited[x][y] == (PACIFIC | ATLANTIC):\n                res.append((x, y))\n\n            for d in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                pacificAtlanticHelper(matrix, x + d[0], y + d[1], matrix[x][y], visited[x][y], visited, res)\n\n        if not matrix:\n            return []\n\n        res = []\n        m, n = len(matrix),len(matrix[0])\n        visited = [[0 for _ in xrange(n)] for _ in xrange(m)]\n\n        for i in xrange(m):\n            pacificAtlanticHelper(matrix, i, 0, float(\"-inf\"), PACIFIC, visited, res)\n            pacificAtlanticHelper(matrix, i, n - 1, float(\"-inf\"), ATLANTIC, visited, res)\n        for j in xrange(n):\n            pacificAtlanticHelper(matrix, 0, j, float(\"-inf\"), PACIFIC, visited, res)\n            pacificAtlanticHelper(matrix, m - 1, j, float(\"-inf\"), ATLANTIC, visited, res)\n\n        return res\n\n"
    },
    {
        "problem_name": "paint-fence",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        elif n == 1:\n            return k\n        ways = [0] * 3\n        ways[0] = k\n        ways[1] = (k - 1) * ways[0] + k\n        for i in xrange(2, n):\n            ways[i % 3] = (k - 1) * (ways[(i - 1) % 3] + ways[(i - 2) % 3])\n        return ways[(n - 1) % 3]\n\n# Time:  O(n)\n# Space: O(n)\n# DP solution.\nclass Solution2(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        elif n == 1:\n            return k\n        ways = [0] * n\n        ways[0] = k\n        ways[1] = (k - 1) * ways[0] + k\n        for i in xrange(2, n):\n            ways[i] = (k - 1) * (ways[i - 1] + ways[i - 2])\n        return ways[n - 1]\n\n"
    },
    {
        "problem_name": "paint-house-ii",
        "solution": "# Time:  O(n * k)\n# Space: O(k)\n\nclass Solution2(object):\n    def minCostII(self, costs):\n        \"\"\"\n        :type costs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        return min(reduce(self.combine, costs)) if costs else 0\n\n    def combine(self, tmp, house):\n        smallest, k, i = min(tmp), len(tmp), tmp.index(min(tmp))\n        tmp, tmp[i] = [smallest] * k, min(tmp[:i] + tmp[i+1:])\n        return map(sum, zip(tmp, house))\n\n\nclass Solution2(object):\n    def minCostII(self, costs):\n        \"\"\"\n        :type costs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not costs:\n            return 0\n\n        n = len(costs)\n        k = len(costs[0])\n        min_cost = [costs[0], [0] * k]\n        for i in xrange(1, n):\n            smallest, second_smallest = float(\"inf\"), float(\"inf\")\n            for j in xrange(k):\n                if min_cost[(i - 1) % 2][j] < smallest:\n                    smallest, second_smallest = min_cost[(i - 1) % 2][j], smallest\n                elif min_cost[(i - 1) % 2][j] < second_smallest:\n                    second_smallest = min_cost[(i - 1) % 2][j]\n            for j in xrange(k):\n                min_j = smallest if min_cost[(i - 1) % 2][j] != smallest else second_smallest\n                min_cost[i % 2][j] = costs[i][j] + min_j\n\n        return min(min_cost[(n - 1) % 2])\n\n"
    },
    {
        "problem_name": "paint-house-iii",
        "solution": "# Time:  O(m * t * n^2)\n# Space: O(t * n)\n\nclass Solution(object):\n    def minCost(self, houses, cost, m, n, target):\n        \"\"\"\n        :type houses: List[int]\n        :type cost: List[List[int]]\n        :type m: int\n        :type n: int\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # dp[i][j][k]: cost of covering i+1 houses with j+1 neighbor groups and the (k+1)th color\n        dp = [[[float(\"inf\") for _ in xrange(n)] for _ in xrange(target)] for _ in xrange(2)]\n        for i in xrange(m):\n            dp[i%2] = [[float(\"inf\") for _ in xrange(n)] for _ in xrange(target)]\n            for j in xrange(min(target, i+1)):\n                for k in xrange(n):\n                    if houses[i] and houses[i]-1 != k:\n                        continue\n                    same = dp[(i-1)%2][j][k] if i-1 >= 0 else 0\n                    diff = (min([dp[(i-1)%2][j-1][nk] for nk in xrange(n) if nk != k] or [float(\"inf\")]) if j-1 >= 0 else float(\"inf\")) if i-1 >= 0 else 0\n                    paint = cost[i][k] if not houses[i] else 0\n                    dp[i%2][j][k] = min(same, diff)+paint\n        result = min(dp[(m-1)%2][-1])\n        return result if result != float(\"inf\") else -1\n\n\n# Time:  O(m * t * n^2)\n# Space: O(t * n)\nclass Solution2(object):\n    def minCost(self, houses, cost, m, n, target):\n        \"\"\"\n        :type houses: List[int]\n        :type cost: List[List[int]]\n        :type m: int\n        :type n: int\n        :type target: int\n        :rtype: int\n        \"\"\"\n        dp = {(0, 0): 0}\n        for i, p in enumerate(houses):\n            new_dp = {}\n            for nk in (xrange(1, n+1) if not p else [p]):\n                for j, k in dp:\n                    nj = j + (k != nk)\n                    if nj > target:\n                        continue\n                    new_dp[nj, nk] = min(new_dp.get((nj, nk), float(\"inf\")), dp[j, k] + (cost[i][nk-1] if nk != p else 0))\n            dp = new_dp\n        return min([dp[j, k] for j, k in dp if j == target] or [-1])\n"
    },
    {
        "problem_name": "paint-house",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minCost(self, costs):\n        \"\"\"\n        :type costs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not costs:\n            return 0\n\n        min_cost = [costs[0], [0, 0, 0]]\n\n        n = len(costs)\n        for i in xrange(1, n):\n            min_cost[i % 2][0] = costs[i][0] + \\\n                                 min(min_cost[(i - 1) % 2][1], min_cost[(i - 1) % 2][2])\n            min_cost[i % 2][1] = costs[i][1] + \\\n                                 min(min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][2])\n            min_cost[i % 2][2] = costs[i][2] + \\\n                                 min(min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][1])\n\n        return min(min_cost[(n - 1) % 2])\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def minCost(self, costs):\n        \"\"\"\n        :type costs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not costs:\n            return 0\n\n        n = len(costs)\n        for i in xrange(1, n):\n            costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n            costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n            costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n\n        return min(costs[n - 1])\n\n"
    },
    {
        "problem_name": "painting-a-grid-with-three-different-colors",
        "solution": "# Time:  O(m * 2^m + 3^m + 2^(3 * m) * logn) = O(2^(3 * m) * logn)\n# Space: O(2^(2 * m))\n\nimport collections\nimport itertools\n\n\n# better complexity for small m, super large n\n# matrix exponentiation solution\nclass Solution(object):\n    def colorTheGrid(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def backtracking(mask1, mask2, basis, result):  # Time: O(2^m), Space: O(2^m)\n            if not basis:\n                result.append(mask2)\n                return\n            for i in xrange(3):\n                if (mask1 == -1 or mask1//basis%3 != i) and (mask2 == -1 or mask2//(basis*3)%3 != i):\n                    backtracking(mask1, mask2+i*basis if mask2 != -1 else i*basis, basis//3, result)\n\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A]\n \n        def matrix_expo(A, K):\n            result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def normalize(basis, mask):\n            norm = {}\n            result = 0\n            while basis:\n                x = mask//basis%3\n                if x not in norm:\n                    norm[x] = len(norm)\n                result += norm[x]*basis\n                basis //= 3\n            return result\n\n        if m > n:\n            m, n = n, m\n        basis = 3**(m-1)\n        masks = []\n        backtracking(-1, -1, basis, masks)  # Time: O(2^m), Space: O(2^m)\n        assert(len(masks) == 3 * 2**(m-1))\n        lookup = {mask:normalize(basis, mask) for mask in masks}  # Time: O(m * 2^m)\n        normalized_mask_cnt = collections.Counter(lookup[mask] for mask in masks)\n        assert(len(normalized_mask_cnt) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n        adj = collections.defaultdict(list)\n        for mask in normalized_mask_cnt.iterkeys():  # O(3^m) leaves which are all in depth m => Time: O(3^m), Space: O(3^m)\n            backtracking(mask, -1, basis, adj[mask])\n        normalized_adj = collections.defaultdict(lambda:collections.defaultdict(int))\n        for mask1, masks2 in adj.iteritems():\n            for mask2 in masks2:\n                normalized_adj[mask1][lookup[mask2]] = (normalized_adj[mask1][lookup[mask2]]+1)%MOD\n        # divided by 3 * 2 is since the first two colors in upper row are normalized to speed up performance,\n        # since first two colors in lower row which has at most 3 choices could be also normalized, lower bound is upper bound divided by at most 3\n        assert(2*3**m // 3 // 2 // 3 <= sum(len(v) for v in normalized_adj.itervalues()) <= 2*3**m // 3 // 2)\n        return reduce(lambda x,y: (x+y)%MOD,\n                      matrix_mult([normalized_mask_cnt.values()],\n                                   matrix_expo([[normalized_adj[mask1][mask2]\n                                                 for mask2 in normalized_mask_cnt.iterkeys()] \n                                                 for mask1 in normalized_mask_cnt.iterkeys()], n-1))[0],\n                      0)  # Time: O((2^m)^3 * logn), Space: O((2^m)^2)\n\n\n# Time:  O(n * 3^m)\n# Space: O(3^m)\nimport collections\n\n\n# better complexity for small m, large n\nclass Solution2(object):\n    def colorTheGrid(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def find_masks(m, basis):  # Time: 3 + 3*2 + 3*2*2 + ... + 3*2^(m-1) = 3 * (2^m - 1) = O(2^m), Space: O(2^m)\n            masks = [0]\n            for c in xrange(m):\n                new_masks = []\n                for mask in masks:\n                    choices = {0, 1, 2}\n                    if c > 0:\n                        choices.discard(mask//basis)  # get left grid\n                    for x in choices:\n                        new_masks.append((x*basis)+(mask//3))  # encoding mask\n                masks = new_masks\n            return masks\n\n        def find_adj(m, basis, dp):\n            # Time:  3*2^(m-1) * (1 + 2 + 2 * (3/2) + 2 * (3/2)^2 + ... + 2 * (3/2)^(m-2)) =\n            #        3*2^(m-1) * (1+2*((3/2)^(m-1)-1)/((3/2)-1)) =\n            #        3*2^(m-1) * (1+4*((3/2)^(m-1)-1)) =\n            #        3*2^(m-1) * (4*(3/2)^(m-1)-3) =\n            #        4*3^m-9*2^(m-1) =\n            #        O(3^m),\n            # Space: O(3^m)\n            adj = collections.defaultdict(list)\n            for mask in dp.iterkeys():  # O(2^m)\n                adj[mask].append(mask)\n            for c in xrange(m):\n                assert(sum(len(v) for v in adj.itervalues()) == (3**c * 2**(m-(c-1)) if c >= 1 else 3 * 2**(m-1)) // 3 // (2 if m >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n                new_adj = collections.defaultdict(list)\n                for mask1, mask2s in adj.iteritems():\n                    for mask in mask2s:\n                        choices = {0, 1, 2}\n                        choices.discard(mask%3)  # get up grid\n                        if c > 0:\n                            choices.discard(mask//basis)  # get left grid\n                        for x in choices:\n                            new_adj[mask1].append((x*basis)+(mask//3))  # encoding mask\n                adj = new_adj\n            assert(sum(3**c * 2**(m-(c-1)) if c >= 1 else 3 * 2**(m-1) for c in xrange(m)) == 4*3**m-9*2**(m-1))\n            return adj\n \n        def normalize(basis, mask):\n            norm = {}\n            result = 0\n            while basis:\n                x = mask//basis%3\n                if x not in norm:\n                    norm[x] = len(norm)\n                result += norm[x]*basis\n                basis //= 3\n            return result\n\n        if m > n:\n            m, n = n, m\n        basis = 3**(m-1)\n        masks = find_masks(m, basis)  # alternative of backtracking, Time: O(2^m), Space: O(2^m)\n        assert(len(masks) == 3 * 2**(m-1))\n        lookup = {mask:normalize(basis, mask) for mask in masks}  # Time: O(m * 2^m)\n        dp = collections.Counter(lookup[mask] for mask in masks)  # normalize colors to speed up performance\n        adj = find_adj(m, basis, dp)  # alternative of backtracking, Time: O(3^m), Space: O(3^m)\n        # proof:\n        #   'o' uses the same color with its bottom-left one, \n        #   'x' uses the remaining color different from its left one and bottom-left one,\n        #   k is the cnt of 'o', \n        #     [3, 1(o), 1(x), 1(o), ..., 1(o), 1(x)] => nCr(m-1, k) * 3 * 2 * 2^k for k in xrange(m) = 3 * 2 * (2+1)^(m-1) = 2*3^m combinations\n        #     [2,    2,    1,    2, ...,  2,      1]\n        # another proof:\n        #   given previous pair of colors, each pair of '?' has 3 choices of colors\n        #     [3, ?, ?, ..., ?] => 3 * 2 * 3^(m-1) = 2*3^m combinations\n        #         |  |       |\n        #         3  3       3\n        #         |  |       |\n        #     [2, ?, ?, ..., ?]\n        normalized_adj = collections.defaultdict(lambda:collections.defaultdict(int))\n        for mask1, mask2s in adj.iteritems():\n            for mask2 in mask2s:\n                normalized_adj[lookup[mask1]][lookup[mask2]] = (normalized_adj[lookup[mask1]][lookup[mask2]]+1)%MOD\n        # divided by 3 * 2 is since the first two colors in upper row are normalized to speed up performance,\n        # since first two colors in lower row which has at most 3 choices could be also normalized, lower bound is upper bound divided by at most 3\n        assert(2*3**m // 3 // 2 // 3 <= sum(len(v) for v in normalized_adj.itervalues()) <= 2*3**m // 3 // 2)\n        for _ in xrange(n-1):  # Time: O(n * 3^m), Space: O(2^m)\n            assert(len(dp) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n            new_dp = collections.Counter()\n            for mask, v in dp.iteritems():\n                for new_mask, cnt in normalized_adj[mask].iteritems():\n                    new_dp[lookup[new_mask]] = (new_dp[lookup[new_mask]] + v*cnt) % MOD\n            dp = new_dp\n        return reduce(lambda x,y: (x+y)%MOD, dp.itervalues(), 0)  # Time: O(2^m)\n\n\n# Time:  (m * n grids) * (O(3*3*2^(m-2)) possible states per grid) = O(n * m * 2^m)\n# Space: O(3*3*2^(m-2)) = O(2^m)\nimport collections\n\n\n# better complexity for large m, large n\nclass Solution3(object):\n    def colorTheGrid(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def normalize(basis, mask, lookup):  # compute and cache, at most O(3*2^(m-3)) time and space\n            if mask not in lookup[basis]:\n                norm = {}\n                result, b = 0, basis\n                while b:\n                    x = mask//b%3\n                    if x not in norm:\n                        norm[x] = len(norm)\n                    result += norm[x]*b\n                    b //= 3\n                lookup[basis][mask] = result\n            return lookup[basis][mask]\n\n        if m > n:\n            m, n = n, m\n        basis = b = 3**(m-1)\n        lookup = collections.defaultdict(dict)\n        dp = collections.Counter({0: 1})\n        for idx in xrange(m*n):\n            r, c = divmod(idx, m)\n            # sliding window with size m doesn't cross rows:\n            #   [3, 2, ..., 2] => 3*2^(m-1) combinations\n            assert(r != 0 or c != 0 or len(dp) == 1)\n            assert(r != 0 or c == 0 or len(dp) == 3*2**(c-1) // 3 // (2 if c >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n            assert(r == 0 or c != 0 or len(dp) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance\n            # sliding window with size m crosses rows:\n            #   [*, ..., *, *, 3, 2, ..., 2] => 3*3 * 2^(m-2) combinations\n            #   [2, ..., 2, 3, *, *, ..., *]\n            assert(r == 0 or c == 0 or len(dp) == (1 if m == 1 else 2 if m == 2 else 3*3 * 2**(m-2) // 3 // 2))  # divided by 3 * 2 for m >= 3 is since the first two colors of window are normalized to speed up performance\n            new_dp = collections.Counter()\n            for mask, v in dp.iteritems():\n                choices = {0, 1, 2}\n                if r > 0:\n                    choices.discard(mask%3)  # get up grid\n                if c > 0:\n                    choices.discard(mask//basis)  # get left grid\n                for x in choices:\n                    new_mask = normalize(basis//b, ((x*basis)+(mask//3))//b, lookup)*b  # encoding mask\n                    new_dp[new_mask] = (new_dp[new_mask]+v)%MOD\n            if b > 1:\n                b //= 3\n            dp = new_dp\n        return reduce(lambda x,y: (x+y)%MOD, dp.itervalues(), 0)  # Time: O(2^m)\n"
    },
    {
        "problem_name": "painting-the-walls",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport itertools\n\n\n# knapsack dp\nclass Solution(object):\n    def paintWalls(self, cost, time):\n        \"\"\"\n        :type cost: List[int]\n        :type time: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [float(\"inf\")]*(len(cost)+1)\n        dp[0] = 0\n        for c, t in itertools.izip(cost, time):\n            for j in reversed(xrange(1, len(cost)+1)):\n                dp[j] = min(dp[j], dp[max(j-(t+1), 0)]+c)\n        return dp[-1]\n"
    },
    {
        "problem_name": "pairs-of-songs-with-total-durations-divisible-by-60",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def numPairsDivisibleBy60(self, time):\n        \"\"\"\n        :type time: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        count = collections.Counter()\n        for t in time:\n            result += count[-t%60]\n            count[t%60] += 1\n        return result\n"
    },
    {
        "problem_name": "palindrome-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {ListNode} head\n    # @return {boolean}\n    def isPalindrome(self, head):\n        reverse, fast = None, head\n        # Reverse the first half part of the list.\n        while fast and fast.next:\n            fast = fast.next.next\n            head.next, reverse, head = reverse, head, head.next\n\n        # If the number of the nodes is odd,\n        # set the head of the tail list to the next of the median node.\n        tail = head.next if fast else head\n\n        # Compare the reversed first half list with the second half list.\n        # And restore the reversed first half list.\n        is_palindrome = True\n        while reverse:\n            is_palindrome = is_palindrome and reverse.val == tail.val\n            reverse.next, head, reverse = head, reverse, reverse.next\n            tail = tail.next\n\n        return is_palindrome\n\n"
    },
    {
        "problem_name": "palindrome-number",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    # @return a boolean\n    def isPalindrome(self, x):\n        if x < 0:\n            return False\n        copy, reverse = x, 0\n\n        while copy:\n            reverse *= 10\n            reverse += copy % 10\n            copy //= 10\n\n        return x == reverse\n\n"
    },
    {
        "problem_name": "palindrome-pairs",
        "solution": "# Time:  O(n * k^2), n is the number of the words, k is the max length of the words.\n# Space: O(n * k)\n\nimport collections\n\n\nclass Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        def is_palindrome(s, i, j):\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n \n        res = []\n        lookup = collections.defaultdict(dict)\n        for i, word in enumerate(words):\n            lookup[len(word)][word] = i\n\n        for i in xrange(len(words)):\n            for j in xrange(len(words[i]) + 1):\n                if j in lookup and is_palindrome(words[i], j, len(words[i])-1):\n                    suffix = words[i][:j][::-1]\n                    bucket = lookup[len(suffix)]\n                    if suffix in bucket and bucket[suffix] != i:\n                        res.append([i, bucket[suffix]])\n                if j > 0 and len(words[i])-j in lookup and is_palindrome(words[i], 0, j-1):\n                    prefix = words[i][j:][::-1]\n                    bucket = lookup[len(prefix)]\n                    if prefix in bucket and bucket[prefix] != i:\n                        res.append([bucket[prefix], i])\n        return res\n\n\n# Time:  O(n * k^2), n is the number of the words, k is the max length of the words.\n# Space: O(n * k^2)\n# Manacher solution.\nclass Solution_TLE(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        def manacher(s, P):\n            def preProcess(s):\n                if not s:\n                    return ['^', '$']\n                T = ['^']\n                for c in s:\n                    T +=  [\"#\", c]\n                T += ['#', '$']\n                return T\n\n            T = preProcess(s)\n            center, right = 0, 0\n            for i in xrange(1, len(T) - 1):\n                i_mirror = 2 * center - i\n                if right > i:\n                    P[i] = min(right - i, P[i_mirror])\n                else:\n                    P[i] = 0\n                while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\n                    P[i] += 1\n                if i + P[i] > right:\n                    center, right = i, i + P[i]\n\n        prefix, suffix = collections.defaultdict(list), collections.defaultdict(list)\n        for i, word in enumerate(words):\n            P = [0] * (2 * len(word) + 3)\n            manacher(word, P)\n            for j in xrange(len(P)):\n                if j - P[j] == 1:\n                    prefix[word[(j + P[j]) // 2:]].append(i)\n                if j + P[j] == len(P) - 2:\n                    suffix[word[:(j - P[j]) // 2]].append(i)\n        res = []\n        for i, word in enumerate(words):\n            for j in prefix[word[::-1]]:\n                if j != i:\n                    res.append([i, j])\n            for j in suffix[word[::-1]]:\n                if len(word) != len(words[j]):\n                    res.append([j, i])\n        return res\n\n\n# Time:  O(n * k^2), n is the number of the words, k is the max length of the words.\n# Space: O(n * k)\n# Trie solution.\nclass TrieNode(object):\n    def __init__(self):\n        self.word_idx = -1\n        self.leaves = {}\n\n    def insert(self, word, i):\n        cur = self\n        for c in word:\n            if not c in cur.leaves:\n                cur.leaves[c] = TrieNode()\n            cur = cur.leaves[c]\n        cur.word_idx = i\n\n    def find(self, s, idx, res):\n        cur = self\n        for i in reversed(xrange(len(s))):\n            if s[i] in cur.leaves:\n                cur = cur.leaves[s[i]]\n                if cur.word_idx not in (-1, idx) and \\\n                   self.is_palindrome(s, i - 1):\n                    res.append([cur.word_idx, idx])\n            else:\n                break\n\n    def is_palindrome(self, s, j):\n        i = 0\n        while i <= j:\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n\nclass Solution_MLE(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        trie = TrieNode()\n        for i in xrange(len(words)):\n            trie.insert(words[i], i)\n\n        for i in xrange(len(words)):\n            trie.find(words[i], i, res)\n\n        return res\n\n"
    },
    {
        "problem_name": "palindrome-partitioning-ii",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nclass Solution(object):\n    # @param s, a string\n    # @return an integer\n    def minCut(self, s):\n        lookup = [[False for j in xrange(len(s))] for i in xrange(len(s))]\n        mincut = [len(s) - 1 - i for i in xrange(len(s) + 1)]\n\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i, len(s)):\n                if s[i] == s[j]  and (j - i < 2 or lookup[i + 1][j - 1]):\n                    lookup[i][j] = True\n                    mincut[i] = min(mincut[i], mincut[j + 1] + 1)\n\n        return mincut[0]\n\n"
    },
    {
        "problem_name": "palindrome-partitioning-iii",
        "solution": "# Time:  O(k * n^2)\n# Space: O(n^2)\n\nclass Solution(object):\n    def palindromePartition(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # dp1[i][j]: minimum number of changes to make s[i, j] palindrome\n        dp1 = [[0]*len(s) for _ in xrange(len(s))]\n        for l in xrange(1, len(s)+1):\n            for i in xrange(len(s)-l+1):\n                j = i+l-1\n                if i == j-1:\n                    dp1[i][j] = 0 if s[i] == s[j] else 1\n                elif i != j:\n                    dp1[i][j] = dp1[i+1][j-1] if s[i] == s[j] else dp1[i+1][j-1]+1\n\n        # dp2[d][i]: minimum number of changes to divide s[0, i] into d palindromes\n        dp2 = [[float(\"inf\")]*len(s) for _ in xrange(2)]\n        dp2[1] = dp1[0][:]\n        for d in xrange(2, k+1):\n            dp2[d%2] = [float(\"inf\")]*len(s)\n            for i in xrange(d-1, len(s)):  \n                for j in xrange(d-2, i):\n                    dp2[d%2][i] = min(dp2[d%2][i], dp2[(d-1)%2][j]+dp1[j+1][i])\n        return dp2[k%2][len(s)-1]\n"
    },
    {
        "problem_name": "palindrome-partitioning-iv",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def checkPartitioning(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        def manacher(s):\n            s = '^#' + '#'.join(s) + '#$'\n            P = [0]*len(s)\n            C, R = 0, 0\n            for i in xrange(1, len(s)-1):\n                i_mirror = 2*C-i\n                if R > i:\n                    P[i] = min(R-i, P[i_mirror])\n                while s[i+1+P[i]] == s[i-1-P[i]]:\n                    P[i] += 1\n                if i+P[i] > R:\n                    C, R = i, i+P[i]\n            return P\n\n        P = manacher(s)\n        prefix, suffix = [], []\n        for i in xrange(2, len(P)-2):\n            if i-1-P[i] == 0:\n                prefix.append(i)\n            if i+1+P[i] == len(P)-1:\n                suffix.append(i)\n        for i in prefix:\n            for j in suffix:\n                left, right = i+1+P[i], j-1-P[j]\n                if left > right:\n                    continue\n                mid = left + (right-left)//2\n                if P[mid] >= mid-left:\n                    return True\n        return False\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\nclass Solution2(object):\n    def checkPartitioning(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"        \n        dp = [[False]*len(s) for _ in xrange(len(s))]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i, len(s)):\n                if s[i] == s[j] and (j-i < 2 or dp[i+1][j-1]):\n                    dp[i][j] = True\n        for i in xrange(1, len(s)-1):\n            if not dp[0][i-1]:\n                continue\n            for j in xrange(i+1, len(s)):\n                if not dp[j][-1]:\n                    continue\n                if dp[i][j-1]:\n                    return True\n        return False\n"
    },
    {
        "problem_name": "palindrome-partitioning",
        "solution": "# Time:  O(n^2 ~ 2^n)\n# Space: O(n^2)\n\nclass Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        is_palindrome = [[False] * len(s) for i in xrange(len(s))]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i, len(s)):\n                is_palindrome[i][j] = s[i] == s[j] and ((j - i < 2) or is_palindrome[i + 1][j - 1])\n\n        sub_partition = [[] for _ in xrange(len(s))]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i, len(s)):\n                if is_palindrome[i][j]:\n                    if j + 1 < len(s):\n                        for p in sub_partition[j + 1]:\n                            sub_partition[i].append([s[i:j + 1]] + p)\n                    else:\n                        sub_partition[i].append([s[i:j + 1]])\n\n        return sub_partition[0]\n\n\n# Time:  O(2^n)\n# Space: O(n)\n# recursive solution\nclass Solution2(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        result = []\n        self.partitionRecu(result, [], s, 0)\n        return result\n\n    def partitionRecu(self, result, cur, s, i):\n        if i == len(s):\n            result.append(list(cur))\n        else:\n            for j in xrange(i, len(s)):\n                if self.isPalindrome(s[i: j + 1]):\n                    cur.append(s[i: j + 1])\n                    self.partitionRecu(result, cur, s, j + 1)\n                    cur.pop()\n\n    def isPalindrome(self, s):\n        for i in xrange(len(s) / 2):\n            if s[i] != s[-(i + 1)]:\n                return False\n        return True\n\n"
    },
    {
        "problem_name": "palindrome-permutation-ii",
        "solution": "# Time:  O(n * n!)\n# Space: O(n)\n\nimport collections\nimport itertools\n\n\nclass Solution(object):\n    def generatePalindromes(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        cnt = collections.Counter(s)\n        mid = ''.join(k for k, v in cnt.iteritems() if v % 2)\n        chars = ''.join(k * (v / 2) for k, v in cnt.iteritems())\n        return self.permuteUnique(mid, chars) if len(mid) < 2 else []\n\n    def permuteUnique(self, mid, nums):\n        result = []\n        used = [False] * len(nums)\n        self.permuteUniqueRecu(mid, result, used, [], nums)\n        return result\n\n    def permuteUniqueRecu(self, mid, result, used, cur, nums):\n        if len(cur) == len(nums):\n            half_palindrome = ''.join(cur)\n            result.append(half_palindrome + mid + half_palindrome[::-1])\n            return\n        for i in xrange(len(nums)):\n            if not used[i] and not (i > 0 and nums[i-1] == nums[i] and used[i-1]):\n                used[i] = True\n                cur.append(nums[i])\n                self.permuteUniqueRecu(mid, result, used, cur, nums)\n                cur.pop()\n                used[i] = False\n\nclass Solution2(object):\n    def generatePalindromes(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        cnt = collections.Counter(s)\n        mid = tuple(k for k, v in cnt.iteritems() if v % 2)\n        chars = ''.join(k * (v / 2) for k, v in cnt.iteritems())\n        return [''.join(half_palindrome + mid + half_palindrome[::-1]) \\\n                for half_palindrome in set(itertools.permutations(chars))] if len(mid) < 2 else []\n\n"
    },
    {
        "problem_name": "palindrome-permutation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def canPermutePalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return sum(v % 2 for v in collections.Counter(s).values()) < 2\n\n"
    },
    {
        "problem_name": "palindrome-rearrangement-queries",
        "solution": "# Time:  O(26 + d * n + d * q)\n# Space: O(26 + d * n)\n\n# prefix sum, freq table\nclass Solution(object):\n    def canMakePalindromeQueries(self, s, queries):\n        \"\"\"\n        :type s: str\n        :type queries: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        def check(left1, right1, left2, right2):\n            def same(left, right):\n                return all(prefixs1[right+1][i]-prefixs1[left][i] == prefixs2[right+1][i]-prefixs2[left][i] for i in xrange(d))\n\n            min_left, max_left = min(left1, left2), max(left1, left2)\n            min_right, max_right = min(right1, right2), max(right1, right2)\n            if not (prefix[min_left]-prefix[0] == prefix[-1]-prefix[max_right+1] == 0):\n                return False\n            if min_right < max_left:  # non-overlapped\n                return prefix[max_left]-prefix[min_right+1] == 0 and same(min_left, min_right) and same(max_left, max_right)\n            # overlapped\n            if (left1 == min_left) == (right1 == max_right):  # inside another\n                return same(min_left, max_right)\n            # not inside another\n            p1, p2 = (prefixs1, prefixs2) if min_left == left1 else (prefixs2, prefixs1)\n            diff1 = [(p1[min_right+1][i]-p1[min_left][i])-(p2[max_left][i]-p2[min_left][i]) for i in xrange(d)]\n            diff2 = [(p2[max_right+1][i]-p2[max_left][i])-(p1[max_right+1][i]-p1[min_right+1][i]) for i in xrange(d)]\n            return diff1 == diff2 and all(x >= 0 for x in diff1)  # test case: s = \"aabbba\", queries = [[0,1,3,4]]\n\n        lookup = [-1]*26\n        d = 0\n        for x in s:\n            if lookup[ord(x)-ord('a')] != -1:\n                continue\n            lookup[ord(x)-ord('a')] = d\n            d += 1\n        prefix = [0]*(len(s)//2+1)\n        prefixs1 = [[0]*d for _ in xrange(len(s)//2+1)]\n        prefixs2 = [[0]*d for _ in xrange(len(s)//2+1)]\n        for i in xrange(len(s)//2):\n            x, y = lookup[ord(s[i])-ord('a')], lookup[ord(s[~i])-ord('a')]\n            prefix[i+1] = prefix[i]+int(x != y)\n            for j in xrange(d):\n                prefixs1[i+1][j] = prefixs1[i][j]+int(j == x)\n                prefixs2[i+1][j] = prefixs2[i][j]+int(j == y)\n        return [check(q[0], q[1], (len(s)-1)-q[3], (len(s)-1)-q[2]) for q in queries]\n\n\n# Time:  O(26 * n + 26 * q)\n# Space: O(26 * n)\n# prefix sum, freq table\nclass Solution2(object):\n    def canMakePalindromeQueries(self, s, queries):\n        \"\"\"\n        :type s: str\n        :type queries: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        def check(left1, right1, left2, right2):\n            def same(left, right):\n                return all(prefixs1[right+1][i]-prefixs1[left][i] == prefixs2[right+1][i]-prefixs2[left][i] for i in xrange(26))\n\n            min_left, max_left = min(left1, left2), max(left1, left2)\n            min_right, max_right = min(right1, right2), max(right1, right2)\n            if not (prefix[min_left]-prefix[0] == prefix[-1]-prefix[max_right+1] == 0):\n                return False\n            if min_right < max_left:  # non-overlapped\n                return prefix[max_left]-prefix[min_right+1] == 0 and same(min_left, min_right) and same(max_left, max_right)\n            # overlapped\n            if (left1 == min_left) == (right1 == max_right):  # inside another\n                return same(min_left, max_right)\n            # not inside another\n            p1, p2 = (prefixs1, prefixs2) if min_left == left1 else (prefixs2, prefixs1)\n            diff1 = [(p1[min_right+1][i]-p1[min_left][i])-(p2[max_left][i]-p2[min_left][i]) for i in xrange(26)]\n            diff2 = [(p2[max_right+1][i]-p2[max_left][i])-(p1[max_right+1][i]-p1[min_right+1][i]) for i in xrange(26)]\n            return diff1 == diff2 and all(x >= 0 for x in diff1)  # test case: s = \"aabbba\", queries = [[0,1,3,4]]\n\n        prefix = [0]*(len(s)//2+1)\n        prefixs1 = [[0]*26 for _ in xrange(len(s)//2+1)]\n        prefixs2 = [[0]*26 for _ in xrange(len(s)//2+1)]\n        for i in xrange(len(s)//2):\n            x, y = ord(s[i])-ord('a'), ord(s[~i])-ord('a')\n            prefix[i+1] = prefix[i]+int(x != y)\n            for j in xrange(26):\n                prefixs1[i+1][j] = prefixs1[i][j]+int(j == x)\n                prefixs2[i+1][j] = prefixs2[i][j]+int(j == y)\n        return [check(q[0], q[1], (len(s)-1)-q[3], (len(s)-1)-q[2]) for q in queries]\n"
    },
    {
        "problem_name": "palindrome-removal",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\nclass Solution(object):\n    def minimumMoves(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [[0 for _ in xrange(len(arr)+1)] for _ in xrange(len(arr)+1)]\n        for l in xrange(1, len(arr)+1):\n            for i in xrange(len(arr)-l+1):\n                j = i+l-1\n                if l == 1:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = 1+dp[i+1][j]\n                    if arr[i] == arr[i+1]:\n                        dp[i][j] = min(dp[i][j], 1+dp[i+2][j])\n                    for k in xrange(i+2, j+1):\n                        if arr[i] == arr[k]:\n                            dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k+1][j])\n        return dp[0][len(arr)-1]\n"
    },
    {
        "problem_name": "palindromic-substrings",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def countSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def manacher(s):\n            s = '^#' + '#'.join(s) + '#$'\n            P = [0] * len(s)\n            C, R = 0, 0\n            for i in xrange(1, len(s) - 1):\n                i_mirror = 2*C-i\n                if R > i:\n                    P[i] = min(R-i, P[i_mirror])\n                while s[i+1+P[i]] == s[i-1-P[i]]:\n                    P[i] += 1\n                if i+P[i] > R:\n                    C, R = i, i+P[i]\n            return P\n        return sum((max_len+1)//2 for max_len in manacher(s))\n\n"
    },
    {
        "problem_name": "pancake-sorting",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass BIT(object):  # 0-indexed.\n    def __init__(self, n):\n        self.__bit = [0]*(n+1)  # Extra one for dummy node.\n\n    def add(self, i, val):\n        i += 1  # Extra one for dummy node.\n        while i < len(self.__bit):\n            self.__bit[i] += val\n            i += (i & -i)\n\n    def query(self, i):\n        i += 1  # Extra one for dummy node.\n        ret = 0\n        while i > 0:\n            ret += self.__bit[i]\n            i -= (i & -i)\n        return ret\n\n# bit solution\nclass Solution(object):\n    def pancakeSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        bit = BIT(len(arr))\n        result = []\n        for i in xrange(len(arr)):\n            n = bit.query((arr[i]-1)-1)\n            bit.add(arr[i]-1, 1)\n            if n == i:  # already sorted\n                continue\n            if n == 0:                # (0..i-1)i\n                if i > 1:\n                    result.append(i)  # (i-1..0)i\n                result.append(i+1)    # i(0..i-1)\n            else:                     # (0..n-1)n(n+1..i-1)i\n                if n > 1:\n                    result.append(n)  # (n-1..0)n(n+1..i-1)i\n                result.append(i)      # (i-1..n+1)n(0..n-1)i\n                result.append(i+1)    # i(n-1..0)n(n+1..i-1)\n                result.append(n+1)    # (0..n-1)in(n+1..i-1)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# merge sort solution\nclass Solution2(object):\n    def pancakeSort(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def smallerMergeSort(idxs, start, end, counts):\n            if end - start <= 0:  # The size of range [start, end] less than 2 is always with count 0.\n                return 0\n\n            mid = start + (end - start) // 2\n            smallerMergeSort(idxs, start, mid, counts)\n            smallerMergeSort(idxs, mid + 1, end, counts)\n            r = start\n            tmp = []\n            for i in xrange(mid+1, end + 1):\n                # Merge the two sorted arrays into tmp.\n                while r <= mid and idxs[r][0] < idxs[i][0]:\n                    tmp.append(idxs[r])\n                    r += 1\n                if r <= mid:\n                    tmp.append(idxs[i])\n                counts[idxs[i][1]] += r - start\n            while r <= mid:\n                tmp.append(idxs[r])\n                r += 1\n            # Copy tmp back to idxs\n            idxs[start:start+len(tmp)] = tmp\n            \n        idxs = []\n        smaller_counts = [0]*len(arr)\n        for i, x in enumerate(arr):\n            idxs.append((x, i))\n        smallerMergeSort(idxs, 0, len(idxs)-1, smaller_counts)\n        result = []\n        for i, n in enumerate(smaller_counts):\n            if n == i:  # already sorted\n                continue\n            if n == 0:                # (0..i-1)i\n                if i > 1:\n                    result.append(i)  # (i-1..0)i\n                result.append(i+1)    # i(0..i-1)\n            else:                     # (0..n-1)n(n+1..i-1)i\n                if n > 1:\n                    result.append(n)  # (n-1..0)n(n+1..i-1)i\n                result.append(i)      # (i-1..n+1)n(0..n-1)i\n                result.append(i+1)    # i(n-1..0)n(n+1..i-1)\n                result.append(n+1)    # (0..n-1)in(n+1..i-1)\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(1)\nclass Solution3(object):\n    def pancakeSort(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def reverse(l, begin, end):\n            for i in xrange((end-begin) // 2):\n                l[begin+i], l[end-1-i] = l[end-1-i], l[begin+i]\n\n        result = []\n        for n in reversed(xrange(1, len(A)+1)):\n            i = A.index(n)\n            reverse(A, 0, i+1)\n            result.append(i+1)\n            reverse(A, 0, n)\n            result.append(n)\n        return result\n"
    },
    {
        "problem_name": "parallel-courses-ii",
        "solution": "# Time:  O((n * C(c, min(c, k))) * 2^n)\n# Space: O(2^n)\n\nimport itertools\n\n\nclass Solution(object):\n    def minNumberOfSemesters(self, n, dependencies, k):\n        \"\"\"\n        :type n: int\n        :type dependencies: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        reqs = [0]*n\n        for u, v in dependencies:\n            reqs[v-1] |= 1 << (u-1)\n        dp = [n]*(1<<n)\n        dp[0] = 0\n        for mask in xrange(1<<n):\n            candidates = []\n            for v in xrange(n):\n                if (mask&(1<<v)) == 0 and (mask&reqs[v]) == reqs[v]:\n                    candidates.append(v)\n            for choice in itertools.combinations(candidates, min(len(candidates), k)):\n                new_mask = mask\n                for v in choice:\n                    new_mask |= 1<<v\n                dp[new_mask] = min(dp[new_mask], dp[mask]+1)\n        return dp[-1]\n\n\n# Time:  O(nlogn + e), e is the number of edges in graph\n# Space: O(n + e)\nimport collections\nimport heapq\n\n# wrong greedy solution\n# since the priority of courses are hard to decide especially for those courses with zero indegrees are of the same outdegrees and depths\n# e.x.\n# 9\n# [[1,4],[1,5],[3,5],[3,6],[2,6],[2,7],[8,4],[8,5],[9,6],[9,7]]\n# 3\nclass Solution_WA(object):\n    def minNumberOfSemesters(self, n, dependencies, k):\n        \"\"\"\n        :type n: int\n        :type dependencies: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def dfs(graph, i, depths):\n            if depths[i] == -1:\n                depths[i] = max(dfs(graph, child, depths) for child in graph[i])+1 if i in graph else 1\n            return depths[i]\n            \n        degrees = [0]*n\n        graph = collections.defaultdict(list)\n        for u, v in dependencies:\n            graph[u-1].append(v-1)\n            degrees[v-1] += 1\n        depths = [-1]*n\n        for i in xrange(n):\n            dfs(graph, i, depths)\n        max_heap = []\n        for i in xrange(n):\n            if not degrees[i]:\n                heapq.heappush(max_heap, (-depths[i], i))\n        result = 0\n        while max_heap:\n            new_q = []\n            for _ in xrange(min(len(max_heap), k)):\n                _, node = heapq.heappop(max_heap)\n                if node not in graph:\n                    continue\n                for child in graph[node]:\n                    degrees[child] -= 1\n                    if not degrees[child]:\n                        new_q.append(child)\n            result += 1\n            for node in new_q:\n                heapq.heappush(max_heap, (-depths[node], node))\n        return result\n"
    },
    {
        "problem_name": "parallel-courses-iii",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|E|)\n\nclass Solution(object):\n    def minimumTime(self, n, relations, time):\n        \"\"\"\n        :type n: int\n        :type relations: List[List[int]]\n        :type time: List[int]\n        :rtype: int\n        \"\"\"\n        adj = [[] for _ in xrange(n)]\n        in_degree = [0]*n\n        for prev, nxt in relations:\n            adj[prev-1].append(nxt-1)\n            in_degree[nxt-1] += 1\n        q = [u for u in xrange(n) if not in_degree[u]]\n        dist = [time[u] if not in_degree[u] else 0 for u in xrange(n)] \n        while q:\n            new_q = []\n            for u in q:\n                for v in adj[u]:\n                    dist[v] = max(dist[v], dist[u]+time[v])\n                    in_degree[v] -= 1\n                    if not in_degree[v]:\n                        new_q.append(v)\n            q = new_q\n        return max(dist)\n"
    },
    {
        "problem_name": "parallel-courses",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|E|)\n\nimport collections\n\n\nclass Solution(object):\n    def minimumSemesters(self, N, relations):\n        \"\"\"\n        :type N: int\n        :type relations: List[List[int]]\n        :rtype: int\n        \"\"\"\n        g = collections.defaultdict(list)\n        in_degree = [0]*N\n        for x, y in relations:\n            g[x-1].append(y-1)\n            in_degree[y-1] += 1\n        q = collections.deque([(1, i) for i in xrange(N) if not in_degree[i]])\n\n        result = 0\n        count = N\n        while q:\n            level, u = q.popleft()\n            count -= 1\n            result = level\n            for v in g[u]:\n                in_degree[v] -= 1\n                if not in_degree[v]:\n                    q.append((level+1, v))\n        return result if count == 0 else -1\n"
    },
    {
        "problem_name": "parse-lisp-expression",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nclass Solution(object):\n    def evaluate(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: int\n        \"\"\"\n        def getval(lookup, x):\n            return lookup.get(x, x)\n\n        def evaluate(tokens, lookup):\n            if tokens[0] in ('add', 'mult'):\n                a, b = map(int, map(lambda x: getval(lookup, x), tokens[1:]))\n                return str(a+b if tokens[0] == 'add' else a*b)\n            for i in xrange(1, len(tokens)-1, 2):\n                if tokens[i+1]:\n                    lookup[tokens[i]] = getval(lookup, tokens[i+1])\n            return getval(lookup, tokens[-1])\n\n        tokens, lookup, stk = [''], {}, []\n        for c in expression:\n            if c == '(':\n                if tokens[0] == 'let':\n                    evaluate(tokens, lookup)\n                stk.append((tokens, dict(lookup)))\n                tokens =  ['']\n            elif c == ' ':\n                tokens.append('')\n            elif c == ')':\n                val = evaluate(tokens, lookup)\n                tokens, lookup = stk.pop()\n                tokens[-1] += val\n            else:\n                tokens[-1] += c\n        return int(tokens[0])\n\n"
    },
    {
        "problem_name": "parsing-a-boolean-expression",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def parseBoolExpr(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: bool\n        \"\"\"\n        def parse(expression, i):\n            if expression[i[0]] not in \"&|!\":\n                result = expression[i[0]] == 't'\n                i[0] += 1\n                return result\n            op = expression[i[0]]\n            i[0] += 2\n            stk = []\n            while expression[i[0]] != ')':\n                if expression[i[0]] == ',': \n                    i[0] += 1\n                    continue\n                stk.append(parse(expression, i))\n            i[0] += 1\n            if op == '&':\n                return all(stk)\n            if op == '|':\n                return any(stk)\n            return not stk[0]\n\n        return parse(expression, [0])\n"
    },
    {
        "problem_name": "partition-array-according-to-given-pivot",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# two pointers\nclass Solution(object):\n    def pivotArray(self, nums, pivot):\n        \"\"\"\n        :type nums: List[int]\n        :type pivot: int\n        :rtype: List[int]\n        \"\"\"\n        result = [pivot]*len(nums)\n        left, right = 0, len(nums)-sum(x > pivot for x in nums)\n        for x in nums:\n            if x < pivot:\n                result[left] = x\n                left += 1\n            elif x > pivot:\n                result[right] = x\n                right += 1\n        return result\n"
    },
    {
        "problem_name": "partition-array-for-maximum-sum",
        "solution": "# Time:  O(n * k)\n# Space: O(k)\n\nclass Solution(object):\n    def maxSumAfterPartitioning(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        W = K+1\n        dp = [0]*W\n        for i in xrange(len(A)):\n            curr_max = 0\n            # dp[i % W] = 0;  # no need in this problem\n            for k in xrange(1, min(K, i+1) + 1):\n                curr_max = max(curr_max, A[i-k+1])\n                dp[i % W] = max(dp[i % W], (dp[(i-k) % W] if i >= k else 0) + curr_max*k)\n        return dp[(len(A)-1) % W]\n"
    },
    {
        "problem_name": "partition-array-into-disjoint-intervals",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def partitionDisjoint(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        B = A[:]\n        for i in reversed(xrange(len(A)-1)):\n            B[i] = min(B[i], B[i+1])\n        p_max = 0\n        for i in xrange(1, len(A)):\n            p_max = max(p_max, A[i-1])\n            if p_max <= B[i]:\n                return i\n\n"
    },
    {
        "problem_name": "partition-array-into-three-parts-with-equal-sum",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def canThreePartsEqualSum(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: bool\n        \"\"\"\n        total = sum(A)\n        if total % 3 != 0:\n            return False\n        parts, curr = 0, 0\n        for x in A:\n            curr += x\n            if curr == total//3:\n                parts += 1\n                curr = 0\n        return parts >= 3\n"
    },
    {
        "problem_name": "partition-array-into-two-arrays-to-minimize-sum-difference",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(2^n)\n\nimport itertools\nimport bisect\n\n\nclass Solution(object):\n    def minimumDifference(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = nums[:len(nums)//2], nums[len(nums)//2:]\n        total1, total2 = sum(left), sum(right)\n        result = float(\"inf\")\n        for k in xrange(len(left)+1): \n            sums = sorted(2*sum(comb)-total1 for comb in itertools.combinations(left, k))\n            for comb in itertools.combinations(right, len(left)-k): \n                diff = 2*sum(comb)-total2\n                i = bisect.bisect_left(sums, -diff)\n                if i < len(sums):\n                    result = min(result, abs(sums[i]+diff))\n                if i > 0:\n                    result = min(result, abs(sums[i-1]+diff))\n        return result\n"
    },
    {
        "problem_name": "partition-array-such-that-maximum-difference-is-k",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, greedy\nclass Solution(object):\n    def partitionArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        result, prev = 1, 0\n        for i in xrange(len(nums)):\n            if nums[i]-nums[prev] <= k:\n                continue\n            prev = i\n            result += 1\n        return result\n"
    },
    {
        "problem_name": "partition-equal-subset-sum",
        "solution": "# Time:  O(n * s), s is the sum of nums\n# Space: O(s)\n\nclass Solution(object):\n    def canPartition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        s = sum(nums)\n        if s % 2:\n            return False\n\n        dp = [False] * (s/2 + 1)\n        dp[0] = True\n        for num in nums:\n            for i in reversed(xrange(1, len(dp))):\n                if num <= i:\n                    dp[i] = dp[i] or dp[i - num]\n        return dp[-1]\n\n"
    },
    {
        "problem_name": "partition-labels",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def partitionLabels(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[int]\n        \"\"\"\n        lookup = {c: i for i, c in enumerate(S)}\n        first, last = 0, 0\n        result = []\n        for i, c in enumerate(S):\n            last = max(last, lookup[c])\n            if i == last:\n                result.append(i-first+1)\n                first = i+1\n        return result\n\n"
    },
    {
        "problem_name": "partition-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    # @param head, a ListNode\n    # @param x, an integer\n    # @return a ListNode\n    def partition(self, head, x):\n        dummySmaller, dummyGreater = ListNode(-1), ListNode(-1)\n        smaller, greater = dummySmaller, dummyGreater\n\n        while head:\n            if head.val < x:\n                smaller.next = head\n                smaller = smaller.next\n            else:\n                greater.next = head\n                greater = greater.next\n            head = head.next\n\n        smaller.next = dummyGreater.next\n        greater.next = None\n\n        return dummySmaller.next\n\n"
    },
    {
        "problem_name": "partition-string-into-minimum-beautiful-substrings",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\n# dp\nclass Solution(object):\n    def minimumBeautifulSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        max_pow_5 = 1\n        while max_pow_5*5 <= (1<<len(s))-1:\n            max_pow_5 *= 5\n        dp = [float(\"inf\")]*(len(s)+1)\n        dp[0] = 0\n        for i in xrange(len(s)):\n            if s[i] == '0':\n                continue\n            curr = 0\n            for j in xrange(i, len(s)):\n                curr = curr*2+int(s[j])\n                if max_pow_5%curr == 0:\n                    dp[j+1] = min(dp[j+1], dp[(i-1)+1]+1)\n        return dp[-1] if dp[-1] != float(\"inf\") else -1\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# dp\nclass Solution2(object):\n    def minimumBeautifulSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        max_pow_5 = 1\n        while max_pow_5*5 <= (1<<len(s))-1:\n            max_pow_5 *= 5\n        dp = [float(\"inf\")]*(len(s)+1)\n        dp[0] = 0\n        for i in xrange(len(s)):\n            curr = 0\n            for j in reversed(xrange(i+1)):\n                curr += int(s[j])<<(i-j)\n                if s[j] == '1' and max_pow_5%curr == 0:\n                    dp[i+1] = min(dp[i+1], dp[(j-1)+1]+1)\n        return dp[-1] if dp[-1] != float(\"inf\") else -1\n"
    },
    {
        "problem_name": "partition-string-into-substrings-with-values-at-most-k",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def minimumPartition(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 1\n        curr = 0\n        for c in s:\n            if int(c) > k:\n                return -1\n            if curr*10+int(c) > k:\n                result += 1\n                curr = 0\n            curr = curr*10+int(c)\n        return result\n"
    },
    {
        "problem_name": "partition-to-k-equal-sum-subsets",
        "solution": "# Time:  O(n*2^n)\n# Space: O(2^n)\n\nclass Solution(object):\n    def canPartitionKSubsets(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        def dfs(nums, target, used, todo, lookup):\n            if lookup[used] is None:\n                targ = (todo-1)%target + 1\n                lookup[used] = any(dfs(nums, target, used | (1<<i), todo-num, lookup) \\\n                                   for i, num in enumerate(nums) \\\n                                   if ((used>>i) & 1) == 0 and num <= targ)\n            return lookup[used]\n\n        total = sum(nums)\n        if total%k or max(nums) > total//k:\n            return False\n        lookup = [None] * (1 << len(nums))\n        lookup[-1] = True\n        return dfs(nums, total//k, 0, total, lookup)\n\n\n# Time:  O(k^(n-k) * k!)\n# Space: O(n)\n# DFS solution with pruning.\nclass Solution2(object):\n    def canPartitionKSubsets(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        def dfs(nums, target, i, subset_sums):\n            if i == len(nums):\n                return True\n            for k in xrange(len(subset_sums)):\n                if subset_sums[k]+nums[i] > target:\n                    continue\n                subset_sums[k] += nums[i]\n                if dfs(nums, target, i+1, subset_sums):\n                    return True\n                subset_sums[k] -= nums[i]\n                if not subset_sums[k]: break\n            return False\n\n        total = sum(nums)\n        if total%k != 0 or max(nums) > total//k:\n            return False\n        nums.sort(reverse=True)\n        subset_sums = [0] * k\n        return dfs(nums, total//k, 0, subset_sums)\n\n"
    },
    {
        "problem_name": "partitioning-into-minimum-number-of-deci-binary-numbers",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minPartitions(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: int\n        \"\"\"\n        return int(max(n))\n"
    },
    {
        "problem_name": "pascals-triangle-ii",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    # @return a list of integers\n    def getRow(self, rowIndex):\n        result = [0] * (rowIndex + 1)\n        for i in xrange(rowIndex + 1):\n            old = result[0] = 1\n            for j in xrange(1, i + 1):\n                old, result[j] = result[j], old + result[j]\n        return result\n\n    def getRow2(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        row = [1]\n        for _ in range(rowIndex):\n            row = [x + y for x, y in zip([0] + row, row + [0])]\n        return row\n\n    def getRow3(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        if rowIndex == 0: return [1]\n        res = [1, 1]\n\n        def add(nums):\n            res = nums[:1]\n            for i, j in enumerate(nums):\n                if i < len(nums) - 1:\n                    res += [nums[i] + nums[i + 1]]\n            res += nums[:1]\n            return res\n\n        while res[1] < rowIndex:\n            res = add(res)\n        return res\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution2(object):\n    # @return a list of integers\n    def getRow(self, rowIndex):\n        result = [1]\n        for i in range(1, rowIndex + 1):\n            result = [1] + [result[j - 1] + result[j] for j in xrange(1, i)] + [1]\n        return result\n\n\n"
    },
    {
        "problem_name": "pascals-triangle",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    # @return a list of lists of integers\n    def generate(self, numRows):\n        result = []\n        for i in xrange(numRows):\n            result.append([])\n            for j in xrange(i + 1):\n                if j in (0, i):\n                    result[i].append(1)\n                else:\n                    result[i].append(result[i - 1][j - 1] + result[i - 1][j])\n        return result\n\n    def generate2(self, numRows):\n        if not numRows: return []\n        res = [[1]]\n        for i in range(1, numRows):\n            res += [map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1])]\n        return res[:numRows]\n\n    def generate3(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if numRows == 0: return []\n        if numRows == 1: return [[1]]\n        res = [[1], [1, 1]]\n\n        def add(nums):\n            res = nums[:1]\n            for i, j in enumerate(nums):\n                if i < len(nums) - 1:\n                    res += [nums[i] + nums[i + 1]]\n            res += nums[:1]\n            return res\n\n        while len(res) < numRows:\n            res.extend([add(res[-1])])\n        return res\n\n"
    },
    {
        "problem_name": "pass-the-pillow",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def passThePillow(self, n, time):\n        \"\"\"\n        :type n: int\n        :type time: int\n        :rtype: int\n        \"\"\"\n        return n-abs((n-1)-(time%(2*(n-1))))\n"
    },
    {
        "problem_name": "patching-array",
        "solution": "# Time:  O(s + logn), s is the number of elements in the array\n# Space: O(1)\n\nclass Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = reachable = 0\n        for x in nums:\n            if x > n:\n                break\n            while not reachable >= x-1:\n                result += 1\n                reachable += reachable+1\n            reachable += x\n        while not reachable >= n:\n            result += 1\n            reachable += reachable+1\n        return result\n\n\n# Time:  O(s + logn), s is the number of elements in the array\n# Space: O(1)\nclass Solution2(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result = reachable = 0\n        for x in nums:\n            while not reachable >= x-1:\n                result += 1\n                reachable += reachable+1\n                if reachable >= n:\n                    return result\n            reachable += x\n            if reachable >= n:\n                return result\n        while not reachable >= n:\n            result += 1\n            reachable += reachable+1\n        return result\n\n\n# Time:  O(s + logn), s is the number of elements in the array\n# Space: O(1)\nclass Solution3(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        patch, miss, i = 0, 1, 0\n        while miss <= n:\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss\n                patch += 1\n\n        return patch\n\n"
    },
    {
        "problem_name": "path-crossing",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def isPathCrossing(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: bool\n        \"\"\"\n        x = y = 0\n        lookup = {(0, 0)}\n        for c in path:\n            if c == 'E':\n                x += 1\n            elif c == 'W':\n                x -= 1\n            elif c == 'N':\n                y += 1\n            elif c == 'S':\n                y -= 1\n            if (x, y) in lookup:\n                return True\n            lookup.add((x, y))\n        return False\n"
    },
    {
        "problem_name": "path-in-zigzag-labelled-binary-tree",
        "solution": "# Time:  O(logn)\n# Space: O(logn)\n\nclass Solution(object):\n    def pathInZigZagTree(self, label):\n        \"\"\"\n        :type label: int\n        :rtype: List[int]\n        \"\"\"\n        count = 2**label.bit_length()\n        result = []\n        while label >= 1:\n            result.append(label)\n            label = ((count//2) + ((count-1)-label)) // 2\n            count //= 2\n        result.reverse()\n        return result\n"
    },
    {
        "problem_name": "path-sum-ii",
        "solution": "# Time:  O(n)\n# Space: O(h), h is height of binary tree\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @param sum, an integer\n    # @return a list of lists of integers\n    def pathSum(self, root, sum):\n        return self.pathSumRecu([], [], root, sum)\n\n\n    def pathSumRecu(self, result, cur, root, sum):\n        if root is None:\n            return result\n\n        if root.left is None and root.right is None and root.val == sum:\n            result.append(cur + [root.val])\n            return result\n\n        cur.append(root.val)\n        self.pathSumRecu(result, cur, root.left, sum - root.val)\n        self.pathSumRecu(result, cur,root.right, sum - root.val)\n        cur.pop()\n        return result\n\n"
    },
    {
        "problem_name": "path-sum-iii",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nimport collections\n\n\nclass Solution(object):\n    def pathSum(self, root, sum):\n        \"\"\"\n        :type root: TreeNode\n        :type sum: int\n        :rtype: int\n        \"\"\"\n        def pathSumHelper(root, curr, sum, lookup):\n            if root is None:\n                return 0\n            curr += root.val\n            result = lookup[curr-sum] if curr-sum in lookup else 0\n            lookup[curr] += 1\n            result += pathSumHelper(root.left, curr, sum, lookup) + \\\n                      pathSumHelper(root.right, curr, sum, lookup)\n            lookup[curr] -= 1\n            if lookup[curr] == 0:\n                del lookup[curr]\n            return result\n\n        lookup = collections.defaultdict(int)\n        lookup[0] = 1\n        return pathSumHelper(root, 0, sum, lookup)\n\n\n# Time:  O(n^2)\n# Space: O(h)\nclass Solution2(object):\n    def pathSum(self, root, sum):\n        \"\"\"\n        :type root: TreeNode\n        :type sum: int\n        :rtype: int\n        \"\"\"\n        def pathSumHelper(root, prev, sum):\n            if root is None:\n                return 0\n\n            curr = prev + root.val\n            return int(curr == sum) + \\\n                   pathSumHelper(root.left, curr, sum) + \\\n                   pathSumHelper(root.right, curr, sum)\n\n        if root is None:\n            return 0\n\n        return pathSumHelper(root, 0, sum) + \\\n               self.pathSum(root.left, sum) + \\\n               self.pathSum(root.right, sum)\n\n"
    },
    {
        "problem_name": "path-sum-iv",
        "solution": "# Time:  O(n)\n# Space: O(p), p is the number of paths\n\nimport collections\n\n\nclass Solution(object):\n    def pathSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        class Node(object):\n            def __init__(self, num):\n                self.level = num/100 - 1\n                self.i = (num%100)/10 - 1\n                self.val = num%10\n                self.leaf = True\n\n            def isParent(self, other):\n                return self.level == other.level-1 and \\\n                       self.i == other.i/2\n\n        if not nums:\n            return 0\n        result = 0\n        q = collections.deque()\n        dummy = Node(10)\n        parent = dummy\n        for num in nums:\n            child = Node(num)\n            while not parent.isParent(child):\n                result += parent.val if parent.leaf else 0\n                parent = q.popleft()\n            parent.leaf = False\n            child.val += parent.val\n            q.append(child)\n        while q:\n            result += q.pop().val\n        return result\n\n"
    },
    {
        "problem_name": "path-sum",
        "solution": "# Time:  O(n)\n# Space: O(h), h is height of binary tree\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @param sum, an integer\n    # @return a boolean\n    def hasPathSum(self, root, sum):\n        if root is None:\n            return False\n\n        if root.left is None and root.right is None and root.val == sum:\n            return True\n\n        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\n\n"
    },
    {
        "problem_name": "path-with-maximum-gold",
        "solution": "# Time:  O(m^2 * n^2)\n# Space: O(m * n)\n\nclass Solution(object):\n    def getMaximumGold(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def backtracking(grid, i, j):\n            result = 0\n            grid[i][j] *= -1\n            for dx, dy in directions:\n                ni, nj = i+dx, j+dy\n                if not (0 <= ni < len(grid) and\n                        0 <= nj < len(grid[0]) and\n                        grid[ni][nj] > 0):\n                    continue\n                result = max(result, backtracking(grid, ni, nj))\n            grid[i][j] *= -1\n            return grid[i][j] + result\n\n        result = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                if grid[i][j]:\n                    result = max(result, backtracking(grid, i, j))\n        return result\n"
    },
    {
        "problem_name": "path-with-maximum-minimum-value",
        "solution": "# Time:  O(m * n * log(m * n))\n# Space: O(m * n)\n\n# binary search + dfs solution\nclass Solution(object):\n    def maximumMinimumPath(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        def check(A, val, r, c, lookup):\n            if r == len(A)-1 and c == len(A[0])-1:\n                return True\n            lookup.add((r, c))\n            for d in directions:\n                nr, nc = r + d[0], c + d[1]\n                if 0 <= nr < len(A) and \\\n                   0 <= nc < len(A[0]) and \\\n                   (nr, nc) not in lookup and \\\n                   A[nr][nc] >= val and \\\n                   check(A, val, nr, nc, lookup):\n                    return True\n            return False\n        \n        vals, ceil = [], min(A[0][0], A[-1][-1])\n        for i in xrange(len(A)):\n            for j in xrange(len(A[0])):\n                if A[i][j] <= ceil:\n                    vals.append(A[i][j])\n        vals = list(set(vals))\n        vals.sort()\n        left, right = 0, len(vals)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(A, vals[mid], 0, 0, set()):\n                right = mid-1\n            else:\n                left = mid+1\n        return vals[right]\n\n\n# Time:  O(m * n * log(m * n))\n# Space: O(m * n)\nimport heapq\n\n\n# Dijkstra algorithm solution\nclass Solution2(object):\n    def maximumMinimumPath(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        max_heap = [(-A[0][0], 0, 0)]\n        lookup = set([(0, 0)])\n        while max_heap:\n            i, r, c = heapq.heappop(max_heap)\n            if r == len(A)-1 and c == len(A[0])-1:\n                return -i\n            for d in directions:\n                nr, nc = r+d[0], c+d[1]\n                if 0 <= nr < len(A) and \\\n                   0 <= nc < len(A[0]) and \\\n                   (nr, nc) not in lookup:\n                    heapq.heappush(max_heap, (-min(-i, A[nr][nc]), nr, nc))\n                    lookup.add((nr, nc))    \n        return -1\n"
    },
    {
        "problem_name": "path-with-maximum-probability",
        "solution": "# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,\n#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport collections\nimport itertools\nimport heapq\n\n\nclass Solution(object):\n    def maxProbability(self, n, edges, succProb, start, end):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type succProb: List[float]\n        :type start: int\n        :type end: int\n        :rtype: float\n        \"\"\"\n        adj = collections.defaultdict(list)\n        for (u, v), p in itertools.izip(edges, succProb):\n            adj[u].append((v, p))\n            adj[v].append((u, p))\n        max_heap = [(-1.0, start)]\n        result, lookup = collections.defaultdict(float), set()\n        result[start] = 1.0\n        while max_heap and len(lookup) != len(adj):\n            curr, u = heapq.heappop(max_heap)\n            if u in lookup:\n                continue\n            lookup.add(u)\n            for v, w in adj[u]:\n                if v in lookup:\n                    continue\n                if v in result and result[v] >= -curr*w:\n                    continue\n                result[v] = -curr*w\n                heapq.heappush(max_heap, (-result[v], v))\n        return result[end]\n"
    },
    {
        "problem_name": "path-with-minimum-effort",
        "solution": "# Time:  O(m * n * log(m * n))\n# Space: O(m * n)\n\nimport heapq\n\n\n# Dijkstra algorithm solution\nclass Solution(object):\n    def minimumEffortPath(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dst = (len(heights)-1, len(heights[0])-1)\n        dist = [[float(\"inf\")]*len(heights[0]) for _ in xrange(len(heights))]\n        dist[0][0] = 0;\n        min_heap = [(0, 0, 0)]\n        lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))]\n        while min_heap:\n            d, r, c = heapq.heappop(min_heap)\n            if lookup[r][c]:\n                continue\n            lookup[r][c] = True\n            if (r, c) == dst:\n                return d\n            for dr, dc in directions:\n                nr, nc = r+dr, c+dc\n                if not (0 <= nr < len(heights) and 0 <= nc < len(heights[0]) and not lookup[nr][nc]):\n                    continue\n                nd = max(d, abs(heights[nr][nc]-heights[r][c]))\n                if nd < dist[nr][nc]:\n                    dist[nr][nc] = nd\n                    heapq.heappush(min_heap, (nd, nr, nc))\n        return -1\n\n\n# Time:  O(m * n * log(m * n) + m * n * \u03b1(m * n)) = O(m * n * log(m * n))\n# Space: O(m * n)\nimport collections\n\n\nclass UnionFind(object):  # Time: O(n * \u03b1(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:  # union by rank\n            self.set[x_root] = y_root\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.set[y_root] = x_root\n        else:\n            self.set[y_root] = x_root\n            self.rank[x_root] += 1\n        return True\n\n\n# union find solution\nclass Solution2(object):\n    def minimumEffortPath(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def index(n, i, j):\n            return i*n + j\n    \n        diffs = []\n        for i in xrange(len(heights)):\n            for j in xrange(len(heights[0])):\n                if i > 0:\n                    diffs.append((abs(heights[i][j]-heights[i-1][j]), index(len(heights[0]), i-1, j), index(len(heights[0]), i, j)))\n                if j > 0:\n                    diffs.append((abs(heights[i][j]-heights[i][j-1]), index(len(heights[0]), i, j-1), index(len(heights[0]), i, j)))\n        diffs.sort()\n        union_find = UnionFind(len(heights)*len(heights[0]))\n        for d, i, j in diffs:\n            if union_find.union_set(i, j):\n                if union_find.find_set(index(len(heights[0]), 0, 0)) == \\\n                   union_find.find_set(index(len(heights[0]), len(heights)-1, len(heights[0])-1)):\n                    return d\n        return 0\n\n\n# Time:  O(m * n * logh)\n# Space: O(m * n)\n# bi-bfs solution\nclass Solution3(object):\n    def minimumEffortPath(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def check(heights, x):  # bi-bfs\n            lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))]\n            left, right = {(0, 0)}, {(len(heights)-1, len(heights[0])-1)}\n            while left:\n                for r, c in left:\n                    lookup[r][c] = True\n                new_left = set()\n                for r, c in left:\n                    if (r, c) in right: \n                        return True\n                    for dr, dc in directions:\n                        nr, nc = r+dr, c+dc\n                        if not (0 <= nr < len(heights) and\n                                0 <= nc < len(heights[0]) and\n                                abs(heights[nr][nc]-heights[r][c]) <= x and\n                                not lookup[nr][nc]):\n                            continue\n                        new_left.add((nr, nc))\n                left = new_left\n                if len(left) > len(right): \n                    left, right = right, left\n            return False            \n        \n\n        left, right = 0, 10**6\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(heights, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n\n\n# Time:  O(m * n * logh)\n# Space: O(m * n)\nimport collections\n\n\n# bfs solution\nclass Solution4(object):\n    def minimumEffortPath(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def check(heights, x):\n            lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))]\n            q = collections.deque([(0, 0)])\n            while q:\n                r, c = q.popleft()\n                if (r, c) == (len(heights)-1, len(heights[0])-1):\n                    return True\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(heights) and\n                                0 <= nc < len(heights[0]) and\n                                abs(heights[nr][nc]-heights[r][c]) <= x and\n                                not lookup[nr][nc]):\n                            continue\n                    lookup[nr][nc] = True\n                    q.append((nr, nc))\n            return False            \n        \n        left, right = 0, 10**6\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(heights, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n\n\n# Time:  O(m * n * logh)\n# Space: O(m * n)\n# dfs solution\nclass Solution5(object):\n    def minimumEffortPath(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def check(heights, x):\n            lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))]\n            stk = [(0, 0)]\n            while stk:\n                r, c = stk.pop()\n                if (r, c) == (len(heights)-1, len(heights[0])-1):\n                    return True\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(heights) and\n                                0 <= nc < len(heights[0]) and\n                                abs(heights[nr][nc]-heights[r][c]) <= x and\n                                not lookup[nr][nc]):\n                            continue\n                    lookup[nr][nc] = True\n                    stk.append((nr, nc))\n            return False            \n        \n        left, right = 0, 10**6\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(heights, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "paths-in-matrix-whose-sum-is-divisible-by-k",
        "solution": "# Time:  O(m * n * k)\n# Space: O(n * k)\n\n# dp\nclass Solution(object):\n    def numberOfPaths(self, grid, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        dp = [[0 for _ in xrange(k)] for _ in xrange(len(grid[0]))]\n        dp[0][0] = 1\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                dp[j] = [((dp[j-1][(l-grid[i][j])%k] if j-1 >= 0 else 0)+dp[j][(l-grid[i][j])%k])%MOD for l in xrange(k)]\n        return dp[-1][0]\n"
    },
    {
        "problem_name": "paths-in-maze-that-lead-to-same-room",
        "solution": "# Time:  O(|V|^3)\n# Space: O(|E|)\n\nclass Solution(object):\n    def numberOfPaths(self, n, corridors):\n        \"\"\"\n        :type n: int\n        :type corridors: List[List[int]]\n        :rtype: int\n        \"\"\"\n        adj = [set() for _ in xrange(n)]\n        for u, v in corridors:\n            adj[min(u, v)-1].add(max(u, v)-1)\n        return sum(k in adj[i] for i in xrange(n) for j in adj[i] for k in adj[j])\n"
    },
    {
        "problem_name": "peak-index-in-a-mountain-array",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def peakIndexInMountainArray(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(arr)-1\n        while left <= right:\n            mid = left + (right-left)//2\n            if arr[mid] > arr[mid+1]:\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n\n"
    },
    {
        "problem_name": "peeking-iterator",
        "solution": "# Time:  O(1) per peek(), next(), hasNext()\n# Space: O(1)\n\nclass PeekingIterator(object):\n    def __init__(self, iterator):\n        \"\"\"\n        Initialize your data structure here.\n        :type iterator: Iterator\n        \"\"\"\n        self.iterator = iterator\n        self.val_ = None\n        self.has_next_ = iterator.hasNext()\n        self.has_peeked_ = False\n\n\n    def peek(self):\n        \"\"\"\n        Returns the next element in the iteration without advancing the iterator.\n        :rtype: int\n        \"\"\"\n        if not self.has_peeked_:\n            self.has_peeked_ = True\n            self.val_ = self.iterator.next()\n        return self.val_\n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.val_ = self.peek()\n        self.has_peeked_ = False\n        self.has_next_ = self.iterator.hasNext()\n        return self.val_\n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return self.has_next_\n\n\n\n"
    },
    {
        "problem_name": "people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list",
        "solution": "# Time:  O(n * m * l + n^2 * m), n is favoriteCompanies.length\n#                              , m is the max of favoriteCompanies[i].length\n#                              , l is the max of favoriteCompanies[i][j].length\n# Space: O(n * m * l)\n\nclass Solution(object):\n    def peopleIndexes(self, favoriteCompanies):\n        \"\"\"\n        :type favoriteCompanies: List[List[str]]\n        :rtype: List[int]\n        \"\"\"\n        lookup, comps = {}, []\n        for cs in favoriteCompanies:\n            comps.append(set())\n            for c in cs:\n                if c not in lookup:\n                    lookup[c] = len(lookup)\n                comps[-1].add(lookup[c])\n        return [i for i, c1 in enumerate(comps)\n                if not any(i != j and len(c1) < len(c2) and c1 < c2\n                           for j, c2 in enumerate(comps))]\n    \n\n\n# Time:  O(n * m * l + n^2 * m * log*(n)), n is favoriteCompanies.length\n#                                        , m is the max of favoriteCompanies[i].length\n#                                        , l is the max of favoriteCompanies[i][j].length\n# Space: O(n * m * l)\nclass UnionFind(object):\n    def __init__(self, data):\n        self.data = [set(d) for d in data]\n        self.set = range(len(data))\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return\n        if len(self.data[x_root]) > len(self.data[y_root]) and \\\n           self.data[x_root] > self.data[y_root]:\n            self.set[y_root] = x_root\n        elif len(self.data[x_root]) < len(self.data[y_root]) and \\\n           self.data[x_root] < self.data[y_root]:\n            self.set[x_root] = y_root\n\n\nclass Solution2(object):\n    def peopleIndexes(self, favoriteCompanies):\n        \"\"\"\n        :type favoriteCompanies: List[List[str]]\n        :rtype: List[int]\n        \"\"\"\n        lookup, comps = {}, []\n        for cs in favoriteCompanies:\n            comps.append(set())\n            for c in cs:\n                if c not in lookup:\n                    lookup[c] = len(lookup)\n                comps[-1].add(lookup[c])\n        union_find = UnionFind(comps)\n        for i in xrange(len(comps)):\n            for j in xrange(len(comps)):\n                if j == i:\n                    continue\n                union_find.union_set(i, j)\n        return [x for i, x in enumerate(union_find.set) if x == i]\n"
    },
    {
        "problem_name": "percentage-of-letter-in-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def percentageLetter(self, s, letter):\n        \"\"\"\n        :type s: str\n        :type letter: str\n        :rtype: int\n        \"\"\"\n        return 100*s.count(letter)//len(s)\n"
    },
    {
        "problem_name": "perfect-number",
        "solution": "# Time:  O(sqrt(n))\n# Space: O(1)\n\nclass Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num <= 0:\n            return False\n\n        sqrt_num = int(num ** 0.5)\n        total = sum(i+num//i for i in xrange(1, sqrt_num+1) if num%i == 0)\n        if sqrt_num ** 2 == num:\n            total -= sqrt_num\n        return total - num == num\n\n"
    },
    {
        "problem_name": "perfect-rectangle",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nfrom collections import defaultdict\n\nclass Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        left = min(rec[0] for rec in rectangles)\n        bottom = min(rec[1] for rec in rectangles)\n        right = max(rec[2] for rec in rectangles)\n        top = max(rec[3] for rec in rectangles)\n\n        points = defaultdict(int)\n        for l, b, r, t in rectangles:\n            for p, q in zip(((l, b), (r, b), (l, t), (r, t)), (1, 2, 4, 8)):\n                if points[p] & q:\n                    return False\n                points[p] |= q\n\n        for px, py in points:\n            if left < px < right or bottom < py < top:\n                if points[(px, py)] not in (3, 5, 10, 12, 15):\n                    return False\n\n        return True\n\n"
    },
    {
        "problem_name": "perfect-squares",
        "solution": "# Time:  O(n * sqrt(n))\n# Space: O(n)\n\nclass Solution(object):\n    _num = [0]\n    def numSquares(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        num = self._num\n        while len(num) <= n:\n            num += min(num[-i*i] for i in xrange(1, int(len(num)**0.5+1))) + 1,\n        return num[n]\n\n"
    },
    {
        "problem_name": "perform-string-shifts",
        "solution": "# Time:  O(n + l)\n# Space: O(l)\n\nclass Solution(object):\n    def stringShift(self, s, shift):\n        \"\"\"\n        :type s: str\n        :type shift: List[List[int]]\n        :rtype: str\n        \"\"\"\n        left_shifts = 0\n        for direction, amount in shift:\n            if not direction:\n                left_shifts += amount\n            else:\n                left_shifts -= amount\n        left_shifts %= len(s)\n        return s[left_shifts:] + s[:left_shifts]\n"
    },
    {
        "problem_name": "permutation-difference-between-two-strings",
        "solution": "# Time:  O(n + 26)\n# Space: O(26)\n\n# hash table\nclass Solution(object):\n    def findPermutationDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        lookup = [-1]*26\n        for i, x in enumerate(s):\n            lookup[ord(x)-ord('a')] = i\n        return sum(abs(lookup[ord(x)-ord('a')]-i)for i, x in enumerate(t))\n"
    },
    {
        "problem_name": "permutation-in-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def checkInclusion(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        counts = collections.Counter(s1)\n        l = len(s1)\n        for i in xrange(len(s2)):\n            if counts[s2[i]] > 0:\n                l -= 1\n            counts[s2[i]] -= 1\n            if l == 0:\n                return True\n            start = i + 1 - len(s1)\n            if start >= 0:\n                counts[s2[start]] += 1\n                if counts[s2[start]] > 0:\n                    l += 1\n        return False\n\n"
    },
    {
        "problem_name": "permutation-sequence",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport math\n\n# Cantor ordering solution\nclass Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        seq, k, fact = \"\", k - 1, math.factorial(n - 1)\n        perm = [i for i in xrange(1, n + 1)]\n        for i in reversed(xrange(n)):\n            curr = perm[k / fact]\n            seq += str(curr)\n            perm.remove(curr)\n            if i > 0:\n                k %= fact\n                fact /= i\n        return seq\n\n\n"
    },
    {
        "problem_name": "permutations-ii",
        "solution": "# Time:  O(n * n!)\n# Space: O(n)\n\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = []\n        used = [False] * len(nums)\n        self.permuteUniqueRecu(result, used, [], nums)\n        return result\n\n    def permuteUniqueRecu(self, result, used, cur, nums):\n        if len(cur) == len(nums):\n            result.append(cur + [])\n            return\n        for i in xrange(len(nums)):\n            if used[i] or (i > 0 and nums[i-1] == nums[i] and not used[i-1]):\n                continue\n            used[i] = True\n            cur.append(nums[i])\n            self.permuteUniqueRecu(result, used, cur, nums)\n            cur.pop()\n            used[i] = False\n\nclass Solution2(object):\n    # @param num, a list of integer\n    # @return a list of lists of integers\n    def permuteUnique(self, nums):\n        solutions = [[]]\n\n        for num in nums:\n            next = []\n            for solution in solutions:\n                for i in xrange(len(solution) + 1):\n                    candidate = solution[:i] + [num] + solution[i:]\n                    if candidate not in next:\n                        next.append(candidate)\n\n            solutions = next\n\n        return solutions\n\n"
    },
    {
        "problem_name": "permutations",
        "solution": "# Time:  O(n * n!)\n# Space: O(n)\n\nclass Solution(object):\n    # @param num, a list of integer\n    # @return a list of lists of integers\n    def permute(self, num):\n        result = []\n        used = [False] * len(num)\n        self.permuteRecu(result, used, [], num)\n        return result\n\n    def permuteRecu(self, result, used, cur, num):\n        if len(cur) == len(num):\n            result.append(cur[:])\n            return\n        for i in xrange(len(num)):\n            if not used[i]:\n                used[i] = True\n                cur.append(num[i])\n                self.permuteRecu(result, used, cur, num)\n                cur.pop()\n                used[i] = False\n\n\n# Time:  O(n^2 * n!)\n# Space: O(n^2)\nclass Solution2(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        self.dfs(nums, [], res)\n        return res\n\n    def dfs(self, nums, path, res):\n        if not nums:\n            res.append(path)\n\n        for i in xrange(len(nums)):\n            # e.g., [1, 2, 3]: 3! = 6 cases\n            # idx -> nums, path\n            # 0 -> [2, 3], [1] -> 0: [3], [1, 2] -> [], [1, 2, 3]\n            #                  -> 1: [2], [1, 3] -> [], [1, 3, 2]\n            #\n            # 1 -> [1, 3], [2] -> 0: [3], [2, 1] -> [], [2, 1, 3]\n            #                  -> 1: [1], [2, 3] -> [], [2, 3, 1]\n            #\n            # 2 -> [1, 2], [3] -> 0: [2], [3, 1] -> [], [3, 1, 2]\n            #                  -> 1: [1], [3, 2] -> [], [3, 2, 1]\n            self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], res)\n"
    },
    {
        "problem_name": "pizza-with-3n-slices",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\n# [observation]\n# 1. we can never take two adjacent slices\n# 2. if we want some set of N / 3 non-adjacent slices, there is always a way to take\n#\n# [proof]\n# - for N = 3, it is obviously true.\n# - for N' = N + 3,\n#   - because it's impossible to have only one unwanted slices between all wanted slices.\n#     if it's true, there will be 3N'/2 unwanted slices rather than 2N' unwanted ones, -><-\n#   - so we can always find a sequence of two unwanted slices with one wanted slice\n#     to take firstly, then we can find a way to take the remaining N ones by induction, QED\n\n# better optimized space\nclass Solution(object):\n    def maxSizeSlices(self, slices):\n        \"\"\"\n        :type slices: List[int]\n        :rtype: int\n        \"\"\"\n        def maxSizeSlicesLinear(slices, start, end):\n            dp = [[0]*(len(slices)//3+1) for _ in xrange(2)]\n            for i in xrange(start, end):\n                for j in reversed(xrange(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1)):\n                    dp[i%2][j] = max(dp[(i-1)%2][j], dp[(i-2)%2][j-1] + slices[i])\n            return dp[(end-1)%2][len(slices)//3]\n        \n        return max(maxSizeSlicesLinear(slices, 0, len(slices)-1),\n                   maxSizeSlicesLinear(slices, 1, len(slices)))\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution2(object):\n    def maxSizeSlices(self, slices):\n        \"\"\"\n        :type slices: List[int]\n        :rtype: int\n        \"\"\"\n        def maxSizeSlicesLinear(slices, start, end):\n            dp = [[0]*(len(slices)//3+1) for _ in xrange(3)]\n            for i in xrange(start, end):\n                for j in xrange(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1):\n                    dp[i%3][j] = max(dp[(i-1)%3][j], dp[(i-2)%3][j-1] + slices[i])\n            return dp[(end-1)%3][len(slices)//3]\n        \n        return max(maxSizeSlicesLinear(slices, 0, len(slices)-1),\n                   maxSizeSlicesLinear(slices, 1, len(slices)))\n"
    },
    {
        "problem_name": "plates-between-candles",
        "solution": "# Time:  O(n + q)\n# Space: O(n)\n\nclass Solution(object):\n    def platesBetweenCandles(self, s, queries):\n        \"\"\"\n        :type s: str\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        left, prefix = [0]*len(s), {}\n        curr, cnt = -1, 0\n        for i in xrange(len(s)):\n            if s[i] == '|':\n                curr = i\n                cnt += 1\n                prefix[i] = cnt\n            left[i] = curr\n        right = [0]*len(s)\n        curr = len(s)\n        for i in reversed(xrange(len(s))):\n            if s[i] == '|':\n                curr = i\n            right[i] = curr\n        return [max((left[r]-right[l]+1) - (prefix[left[r]]-prefix[right[l]]+1), 0) for l, r in queries]\n"
    },
    {
        "problem_name": "play-with-chips",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minCostToMoveChips(self, chips):\n        \"\"\"\n        :type chips: List[int]\n        :rtype: int\n        \"\"\"\n        count = [0]*2\n        for p in chips:\n            count[p%2] += 1\n        return min(count)\n"
    },
    {
        "problem_name": "plus-one-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\n# Two pointers solution.\nclass Solution(object):\n    def plusOne(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        dummy = ListNode(0)\n        dummy.next = head\n\n        left, right = dummy, head\n        while right.next:\n            if right.val != 9:\n                left = right\n            right = right.next\n\n        if right.val != 9:\n            right.val += 1\n        else:\n            left.val += 1\n            right = left.next\n            while right:\n                right.val = 0\n                right = right.next\n\n        return dummy if dummy.val else dummy.next\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def plusOne(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        def reverseList(head):\n            dummy = ListNode(0)\n            curr = head\n            while curr:\n                dummy.next, curr.next, curr = curr, dummy.next, curr.next\n            return dummy.next\n\n        rev_head = reverseList(head)\n        curr, carry = rev_head, 1\n        while curr and carry:\n            curr.val += carry\n            carry = curr.val / 10\n            curr.val %= 10\n            if carry and curr.next is None:\n                curr.next = ListNode(0)\n            curr = curr.next\n\n        return reverseList(rev_head)\n\n"
    },
    {
        "problem_name": "plus-one",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in reversed(xrange(len(digits))):\n            if digits[i] == 9:\n                digits[i] = 0\n            else:\n                digits[i] += 1\n                return digits\n        digits[0] = 1\n        digits.append(0)\n        return digits\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = digits[::-1]\n        carry = 1\n        for i in xrange(len(result)):\n            result[i] += carry\n            carry, result[i] = divmod(result[i], 10)\n        if carry:\n            result.append(carry)\n        return result[::-1]\n\n\n"
    },
    {
        "problem_name": "points-that-intersect-with-cars",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, line sweep\nclass Solution(object):\n    def numberOfPoints(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        result = 0\n        curr = nums[0]\n        for i in xrange(1, len(nums)):\n            if nums[i][0] <= curr[1]:\n                curr[1] = max(curr[1], nums[i][1])\n            else:\n                result += curr[1]-curr[0]+1\n                curr = nums[i]\n        result += curr[1]-curr[0]+1\n        return result\n"
    },
    {
        "problem_name": "poor-pigs",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nimport math\n\n\nclass Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        return int(math.ceil(math.log(buckets) / math.log(minutesToTest / minutesToDie + 1)))\n\n"
    },
    {
        "problem_name": "populating-next-right-pointers-in-each-node-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return nothing\n    def connect(self, root):\n        head = root\n        pre = Node(0)\n        cur = pre\n        while root:\n            while root:\n                if root.left:\n                    cur.next = root.left\n                    cur = cur.next\n                if root.right:\n                    cur.next = root.right\n                    cur = cur.next\n                root = root.next\n            root, cur = pre.next, pre\n            cur.next = None\n        return head\n"
    },
    {
        "problem_name": "populating-next-right-pointers-in-each-node",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n        self.next = None\n\n    def __repr__(self):\n        if self is None:\n            return \"Nil\"\n        else:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return nothing\n    def connect(self, root):\n        head = root\n        while head:\n            cur = head\n            while cur and cur.left:\n                cur.left.next = cur.right\n                if cur.next:\n                    cur.right.next = cur.next.left\n                cur = cur.next\n            head = head.left\n\n# Time:  O(n)\n# Space: O(logn)\n# recusion\nclass Solution2(object):\n    # @param root, a tree node\n    # @return nothing\n    def connect(self, root):\n        if root is None:\n            return\n        if root.left:\n            root.left.next = root.right\n        if root.right and root.next:\n            root.right.next = root.next.left\n        self.connect(root.left)\n        self.connect(root.right)\n\n"
    },
    {
        "problem_name": "positions-of-large-groups",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n\nclass Solution(object):\n    def largeGroupPositions(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i = 0\n        for j in xrange(len(S)):\n            if j == len(S)-1 or S[j] != S[j+1]:\n                if j-i+1 >= 3:\n                    result.append([i, j])\n                i = j+1\n        return result\n\n"
    },
    {
        "problem_name": "possible-bipartition",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|V| + |E|)\n\nimport collections\n\n\nclass Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        \"\"\"\n        :type N: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        adj = [[] for _ in xrange(N)]\n        for u, v in dislikes:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n\n        color = [0]*N\n        color[0] = 1\n        q = collections.deque([0])\n        while q:\n            cur = q.popleft()\n            for nei in adj[cur]:\n                if color[nei] == color[cur]:\n                    return False\n                elif color[nei] == -color[cur]:\n                    continue\n                color[nei] = -color[cur]\n                q.append(nei)\n        return True\n \n\n"
    },
    {
        "problem_name": "pour-water-between-buckets-to-make-water-levels-equal",
        "solution": "# Time:  O(nlogr)\n# Space: O(1)\n\n# binary search\nclass Solution(object):\n    def equalizeWater(self, buckets, loss):\n        \"\"\"\n        :type buckets: List[int]\n        :type loss: int\n        :rtype: float\n        \"\"\"\n        def check(buckets, rate, x):\n            return sum(b-x for b in buckets if b-x > 0)*rate >= sum(x-b for b in buckets if x-b > 0)\n\n        EPS = 1e-5\n        rate = (100-loss)/100.0\n        left, right = float(min(buckets)), float(sum(buckets))/len(buckets)\n        while right-left > EPS:\n            mid = left + (right-left)/2\n            if not check(buckets, rate, mid):\n                right = mid\n            else:\n                left = mid\n        return left\n"
    },
    {
        "problem_name": "pour-water",
        "solution": "# Time:  O(v * n)\n# Space: O(1)\n\nclass Solution(object):\n    def pourWater(self, heights, V, K):\n        \"\"\"\n        :type heights: List[int]\n        :type V: int\n        :type K: int\n        :rtype: List[int]\n        \"\"\"\n        for _ in xrange(V):\n            best = K\n            for d in (-1, 1):\n                i = K\n                while 0 <= i+d < len(heights) and \\\n                      heights[i+d] <= heights[i]:\n                    if heights[i+d] < heights[i]: best = i+d\n                    i += d\n                if best != K:\n                    break\n            heights[best] += 1\n        return heights\n\n"
    },
    {
        "problem_name": "power-of-four",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def isPowerOfFour(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        return num > 0 and (num & (num - 1)) == 0 and \\\n               ((num & 0b01010101010101010101010101010101) == num)\n\n\n# Time:  O(1)\n# Space: O(1)\nclass Solution2(object):\n    def isPowerOfFour(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        while num and not (num & 0b11):\n            num >>= 2\n        return (num == 1)\n\n\nclass Solution3(object):\n    def isPowerOfFour(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        num = bin(num)\n        return True if num[2:].startswith('1') and len(num[2:]) == num.count('0') and num.count('0') % 2 and '-' not in num else False\n\n"
    },
    {
        "problem_name": "power-of-heroes",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, combinatorics, dp\nclass Solution(object):\n    def sumOfPower(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        nums.sort()\n        result = dp = 0\n        for x in nums:\n            result = (result+(x**2)*(dp+x))%MOD\n            dp = (dp+(dp+x))%MOD\n        return result\n"
    },
    {
        "problem_name": "power-of-three",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nimport math\n\n\nclass Solution(object):\n    def __init__(self):\n        self.__max_log3 = int(math.log(0x7fffffff) / math.log(3))\n        self.__max_pow3 = 3 ** self.__max_log3\n\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n > 0 and self.__max_pow3 % n == 0\n\n\nclass Solution2(object):\n    def isPowerOfThree(self, n):\n        return n > 0 and (math.log10(n)/math.log10(3)).is_integer()\n\n"
    },
    {
        "problem_name": "power-of-two",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {integer} n\n    # @return {boolean}\n    def isPowerOfTwo(self, n):\n        return n > 0 and (n & (n - 1)) == 0\n\n\nclass Solution2(object):\n    # @param {integer} n\n    # @return {boolean}\n    def isPowerOfTwo(self, n):\n        return n > 0 and (n & ~-n) == 0\n\n"
    },
    {
        "problem_name": "powerful-integers",
        "solution": "# Time:  O((logn)^2), n is the bound\n# Space: O(r), r is the size of the result\n\nimport math\n\n\nclass Solution(object):\n    def powerfulIntegers(self, x, y, bound):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :type bound: int\n        :rtype: List[int]\n        \"\"\"\n        result = set()\n        log_x = int(math.floor(math.log(bound) / math.log(x)))+1 if x != 1 else 1\n        log_y = int(math.floor(math.log(bound) / math.log(y)))+1 if y != 1 else 1\n        pow_x = 1\n        for i in xrange(log_x):\n            pow_y = 1\n            for j in xrange(log_y):\n                val = pow_x + pow_y\n                if val <= bound:\n                    result.add(val)\n                pow_y *= y\n            pow_x *= x\n        return list(result)\n"
    },
    {
        "problem_name": "powx-n",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        result = 1\n        abs_n = abs(n)\n        while abs_n:\n            if abs_n & 1:\n                result *= x\n            abs_n >>= 1\n            x *= x\n\n        return 1 / result if n < 0 else result\n\n\n# Time:  O(logn)\n# Space: O(logn)\n# Recursive solution.\nclass Solution2(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        if n < 0 and n != -n:\n            return 1.0 / self.myPow(x, -n)\n        if n == 0:\n            return 1\n        v = self.myPow(x, n / 2)\n        if n % 2 == 0:\n            return v * v\n        else:\n            return v * v * x\n\n\n"
    },
    {
        "problem_name": "predict-the-winner",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def PredictTheWinner(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) % 2 == 0 or len(nums) == 1:\n            return True\n\n        dp = [0] * len(nums)\n        for i in reversed(xrange(len(nums))):\n            dp[i] = nums[i]\n            for j in xrange(i+1, len(nums)):\n                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1])\n\n        return dp[-1] >= 0\n\n\n"
    },
    {
        "problem_name": "prefix-and-suffix-search",
        "solution": "# Time:  ctor:   O(w * l^2), w is the number of words, l is the word length on average\n#        search: O(p + s)  , p is the length of the prefix, s is the length of the suffix,\n# Space: O(t), t is the number of trie nodes\n\nimport collections\n\n\nclass WordFilter(object):\n\n    def __init__(self, words):\n        \"\"\"\n        :type words: List[str]\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        self.__trie = _trie()\n\n        for weight, word in enumerate(words):\n            word += '#'\n            for i in xrange(len(word)):\n                cur = self.__trie\n                cur[\"_weight\"] = weight\n                for j in xrange(i, 2*len(word)-1):\n                    cur = cur[word[j%len(word)]]\n                    cur[\"_weight\"] = weight\n\n    def f(self, prefix, suffix):\n        \"\"\"\n        :type prefix: str\n        :type suffix: str\n        :rtype: int\n        \"\"\"\n        cur = self.__trie\n        for letter in suffix + '#' + prefix:\n            if letter not in cur:\n                return -1\n            cur = cur[letter]\n        return cur[\"_weight\"]\n\n\n# Time:  ctor:   O(w * l), w is the number of words, l is the word length on average\n#        search: O(p + s + max(m, n)), p is the length of the prefix, s is the length of the suffix,\n#                                      m is the number of the prefix match, n is the number of the suffix match\n# Space: O(w * l)\nclass Trie(object):\n\n    def __init__(self):\n        _trie = lambda: collections.defaultdict(_trie)\n        self.__trie = _trie()\n\n    def insert(self, word, i):\n        def add_word(cur, i):\n            if \"_words\" not in cur:\n                cur[\"_words\"] = []\n            cur[\"_words\"].append(i)\n\n        cur = self.__trie\n        add_word(cur, i)\n        for c in word:\n            cur = cur[c]\n            add_word(cur, i)\n\n    def find(self, word):\n        cur = self.__trie\n        for c in word:\n            if c not in cur:\n                return []\n            cur = cur[c]\n        return cur[\"_words\"]\n\n\nclass WordFilter2(object):\n\n    def __init__(self, words):\n        \"\"\"\n        :type words: List[str]\n        \"\"\"\n        self.__prefix_trie = Trie()\n        self.__suffix_trie = Trie()\n        for i in reversed(xrange(len(words))):\n            self.__prefix_trie.insert(words[i], i)\n            self.__suffix_trie.insert(words[i][::-1], i)\n\n    def f(self, prefix, suffix):\n        \"\"\"\n        :type prefix: str\n        :type suffix: str\n        :rtype: int\n        \"\"\"\n        prefix_match = self.__prefix_trie.find(prefix)\n        suffix_match = self.__suffix_trie.find(suffix[::-1])\n        i, j = 0, 0\n        while i != len(prefix_match) and j != len(suffix_match):\n            if prefix_match[i] == suffix_match[j]:\n                return prefix_match[i]\n            elif prefix_match[i] > suffix_match[j]:\n                i += 1\n            else:\n                j += 1\n        return -1\n\n\n\n"
    },
    {
        "problem_name": "preimage-size-of-factorial-zeroes-function",
        "solution": "# Time:  O((logn)^2)\n# Space: O(1)\n\nclass Solution(object):\n    def preimageSizeFZF(self, K):\n        \"\"\"\n        :type K: int\n        :rtype: int\n        \"\"\"\n        def count_of_factorial_primes(n, p):\n            cnt = 0\n            while n > 0:\n                cnt += n//p\n                n //= p\n            return cnt\n\n        p = 5\n        left, right = 0, p*K\n        while left <= right:\n            mid = left + (right-left)//2\n            if count_of_factorial_primes(mid, p) >= K:\n                right = mid-1\n            else:\n                left = mid+1\n        return p if count_of_factorial_primes(left, p) == K else 0\n\n"
    },
    {
        "problem_name": "previous-permutation-with-one-swap",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def prevPermOpt1(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for left in reversed(xrange(len(A)-1)):\n            if A[left] > A[left+1]:\n                break\n        else:\n            return A\n        right = len(A)-1\n        while A[left] <= A[right]:\n            right -= 1\n        while A[right-1] == A[right]:\n            right -= 1\n        A[left], A[right] = A[right], A[left]\n        return A\n"
    },
    {
        "problem_name": "prime-arrangements",
        "solution": "# Time:  O(n/2 + n/3 + ... + n/p) = O(nlog(logn)), see https://mathoverflow.net/questions/4596/on-the-series-1-2-1-3-1-5-1-7-1-11\n# Space: O(n)\n\nclass Solution(object):\n    def numPrimeArrangements(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def count_primes(n):\n            if n <= 1:\n                return 0\n            is_prime = [True]*((n+1)//2)\n            cnt = len(is_prime)\n            for i in xrange(3, n+1, 2):\n                if i*i > n:\n                    break\n                if not is_prime[i//2]:\n                    continue\n                for j in xrange(i*i, n+1, 2*i):\n                    if not is_prime[j//2]:\n                        continue\n                    cnt -= 1\n                    is_prime[j//2] = False\n            return cnt\n        \n        def factorial(n):\n            result = 1\n            for i in xrange(2, n+1):\n                result = (result*i)%MOD\n            return result\n\n        MOD = 10**9+7\n        cnt = count_primes(n)\n        return factorial(cnt) * factorial(n-cnt) % MOD\n"
    },
    {
        "problem_name": "prime-in-diagonal",
        "solution": "# Time:  precompute: O(MAX_N)\n#        runtime: O(n)\n# Space: O(MAX_N)\n\n# number theory\ndef linear_sieve_of_eratosthenes(n):\n    primes = []\n    spf = [-1]*(n+1)  # the smallest prime factor\n    for i in xrange(2, n+1):\n        if spf[i] == -1:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if i*p > n or p > spf[i]:\n                break\n            spf[i*p] = p\n    return primes  # len(primes) = O(n/(logn-1)), reference: https://math.stackexchange.com/questions/264544/how-to-find-number-of-prime-numbers-up-to-to-n\n\n\nMAX_N = 4*10**6\nPRIMES = linear_sieve_of_eratosthenes(MAX_N)\nPRIMES_SET = set(PRIMES)\nclass Solution(object):\n    def diagonalPrime(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(len(nums)):\n            if nums[i][i] in PRIMES_SET:\n                result = max(result, nums[i][i])\n            if nums[i][~i] in PRIMES_SET:\n                result = max(result, nums[i][~i])\n        return result\n"
    },
    {
        "problem_name": "prime-number-of-set-bits-in-binary-representation",
        "solution": "# Time:  O(log(R - L)) = O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def countPrimeSetBits(self, L, R):\n        \"\"\"\n        :type L: int\n        :type R: int\n        :rtype: int\n        \"\"\"\n        def bitCount(n):\n            result = 0\n            while n:\n                n &= n-1\n                result += 1\n            return result\n\n        primes = {2, 3, 5, 7, 11, 13, 17, 19}\n        return sum(bitCount(i) in primes\n                   for i in xrange(L, R+1))\n\n"
    },
    {
        "problem_name": "prime-pairs-with-target-sum",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# number theory\nclass Solution(object):\n    def findPrimePairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def linear_sieve_of_eratosthenes(n):\n            primes = []\n            spf = [-1]*(n+1)  # the smallest prime factor\n            for i in xrange(2, n+1):\n                if spf[i] == -1:\n                    spf[i] = i\n                    primes.append(i)\n                for p in primes:\n                    if i*p > n or p > spf[i]:\n                        break\n                    spf[i*p] = p\n            return spf  # len(primes) = O(n/(logn-1)), reference: https://math.stackexchange.com/questions/264544/how-to-find-number-of-prime-numbers-up-to-to-n\n\n        spf = linear_sieve_of_eratosthenes(n)\n        return [[i, n-i] for i in xrange(2, n//2+1) if spf[i] == i and spf[n-i] == n-i]\n"
    },
    {
        "problem_name": "prime-palindrome",
        "solution": "# Time:  O(n^(1/2) * (logn + n^(1/2)))\n# Space: O(logn)\n\n\nclass Solution(object):\n    def primePalindrome(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        def is_prime(n):\n            if n < 2 or n % 2 == 0:\n                return n == 2\n            return all(n % d for d in xrange(3, int(n**.5) + 1, 2))\n\n        if 8 <= N <= 11:\n            return 11\n        for i in xrange(10**(len(str(N))//2), 10**5):\n            j = int(str(i) + str(i)[-2::-1])\n            if j >= N and is_prime(j):\n                return j\n\n"
    },
    {
        "problem_name": "prime-subtraction-operation",
        "solution": "# Time:  O(p + nlogp)\n# Space: O(p)\n\nimport bisect\n\n\n# number theory, greedy, binary search\ndef linear_sieve_of_eratosthenes(n):\n    primes = []\n    spf = [-1]*(n+1)  # the smallest prime factor\n    for i in xrange(2, n+1):\n        if spf[i] == -1:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if i*p > n or p > spf[i]:\n                break\n            spf[i*p] = p\n    return primes  # len(primes) = O(n/(logn-1)), reference: https://math.stackexchange.com/questions/264544/how-to-find-number-of-prime-numbers-up-to-to-n\n\n\nMAX_N = 10**3\nPRIMES = linear_sieve_of_eratosthenes(MAX_N-1)  \nclass Solution(object):\n    def primeSubOperation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for i in xrange(len(nums)):\n            j = bisect.bisect_left(PRIMES, nums[i]-nums[i-1] if i-1 >= 0 else nums[i])\n            if j-1 >= 0:\n                nums[i] -= PRIMES[j-1]\n            if i-1 >= 0 and nums[i-1] >=nums[i]:\n                return False\n        return True\n"
    },
    {
        "problem_name": "print-binary-tree",
        "solution": "# Time:  O(h * 2^h)\n# Space: O(h * 2^h)\n\nclass Solution(object):\n    def printTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[str]]\n        \"\"\"\n        def getWidth(root):\n            if not root:\n                return 0\n            return 2 * max(getWidth(root.left), getWidth(root.right)) + 1\n\n        def getHeight(root):\n            if not root:\n                return 0\n            return max(getHeight(root.left), getHeight(root.right)) + 1\n\n        def preorderTraversal(root, level, left, right, result):\n            if not root:\n                return\n            mid = left + (right-left)/2\n            result[level][mid] = str(root.val)\n            preorderTraversal(root.left, level+1, left, mid-1, result)\n            preorderTraversal(root.right, level+1, mid+1, right, result)\n\n        h, w = getHeight(root), getWidth(root)\n        result = [[\"\"] * w for _ in xrange(h)]\n        preorderTraversal(root, 0, 0, w-1, result)\n        return result\n\n"
    },
    {
        "problem_name": "print-foobar-alternately",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport threading\n\n\nclass FooBar(object):\n    def __init__(self, n):\n        self.__n = n\n        self.__curr = False\n        self.__cv = threading.Condition()\n\n    def foo(self, printFoo):\n        \"\"\"\n        :type printFoo: method\n        :rtype: void\n        \"\"\"\n        for i in xrange(self.__n):\n            with self.__cv:\n                while self.__curr != False:\n                    self.__cv.wait()\n                self.__curr = not self.__curr\n                # printFoo() outputs \"foo\". Do not change or remove this line.\n                printFoo()\n                self.__cv.notify()\n\n    def bar(self, printBar):\n        \"\"\"\n        :type printBar: method\n        :rtype: void\n        \"\"\"\n        for i in xrange(self.__n):\n            with self.__cv:\n                while self.__curr != True:\n                        self.__cv.wait()\n                self.__curr = not self.__curr\n                # printBar() outputs \"bar\". Do not change or remove this line.\n                printBar()\n                self.__cv.notify()\n"
    },
    {
        "problem_name": "print-immutable-linked-list-in-reverse",
        "solution": "# Time:  O(n)\n# Space: O(sqrt(n))\n\nimport math\n\n\nclass Solution(object):\n    def printLinkedListInReverse(self, head):\n        \"\"\"\n        :type head: ImmutableListNode\n        :rtype: None\n        \"\"\"\n        def print_nodes(head, count):\n            nodes = []\n            while head and len(nodes) != count:\n                nodes.append(head)\n                head = head.getNext()\n            for node in reversed(nodes):\n                node.printValue()\n                   \n        count = 0\n        curr = head\n        while curr:\n            curr = curr.getNext()\n            count += 1\n        bucket_count = int(math.ceil(count**0.5))\n        \n        buckets = []\n        count = 0\n        curr = head\n        while curr:\n            if count % bucket_count == 0:\n                buckets.append(curr)\n            curr = curr.getNext()\n            count += 1\n        for node in reversed(buckets):\n            print_nodes(node, bucket_count)\n            \n        \n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def printLinkedListInReverse(self, head):\n        \"\"\"\n        :type head: ImmutableListNode\n        :rtype: None\n        \"\"\"\n        nodes = []\n        while head:\n            nodes.append(head)\n            head = head.getNext()\n        for node in reversed(nodes):\n            node.printValue()\n\n\n# Time:  O(n^2)\n# Space: O(1)\nclass Solution3(object):\n    def printLinkedListInReverse(self, head):\n        \"\"\"\n        :type head: ImmutableListNode\n        :rtype: None\n        \"\"\"\n        tail = None\n        while head != tail:\n            curr = head\n            while curr.getNext() != tail:\n                curr = curr.getNext()\n            curr.printValue()\n            tail = curr\n"
    },
    {
        "problem_name": "print-in-order",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport threading\n\n\nclass Foo(object):\n    def __init__(self):\n        self.__cv = threading.Condition()\n        self.__has_first = False\n        self.__has_second = False\n\n    def first(self, printFirst):\n        \"\"\"\n        :type printFirst: method\n        :rtype: void\n        \"\"\"\n        with self.__cv:\n            # printFirst() outputs \"first\". Do not change or remove this line.\n            printFirst()            \n            self.__has_first = True\n            self.__cv.notifyAll()\n\n    def second(self, printSecond):\n        \"\"\"\n        :type printSecond: method\n        :rtype: void\n        \"\"\"\n        with self.__cv:\n            while not self.__has_first:\n                self.__cv.wait()\n            # printSecond() outputs \"second\". Do not change or remove this line.\n            printSecond()\n            self.__has_second = True\n            self.__cv.notifyAll()\n              \n    def third(self, printThird):\n        \"\"\"\n        :type printThird: method\n        :rtype: void\n        \"\"\"\n        with self.__cv:\n            while not self.__has_second:\n                self.__cv.wait()\n            # printThird() outputs \"third\". Do not change or remove this line.\n            printThird()\n            self.__cv.notifyAll()\n        \n"
    },
    {
        "problem_name": "print-words-vertically",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport itertools\n\n\nclass Solution(object):\n    def printVertically(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        return [\"\".join(c).rstrip() for c in itertools.izip_longest(*s.split(), fillvalue=' ')]\n"
    },
    {
        "problem_name": "print-zero-even-odd",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport threading\n\n\nclass ZeroEvenOdd(object):\n    def __init__(self, n):\n        self.__n = n\n        self.__curr = 0\n        self.__cv = threading.Condition()\n        \n\t# printNumber(x) outputs \"x\", where x is an integer.\n    def zero(self, printNumber):\n        \"\"\"\n        :type printNumber: method\n        :rtype: void\n        \"\"\"\n        for i in xrange(self.__n):\n            with self.__cv:\n                while self.__curr % 2 != 0:\n                    self.__cv.wait()\n                self.__curr += 1\n                printNumber(0)\n                self.__cv.notifyAll()\n        \n    def even(self, printNumber):\n        \"\"\"\n        :type printNumber: method\n        :rtype: void\n        \"\"\"\n        for i in xrange(2, self.__n+1, 2):\n            with self.__cv:\n                while self.__curr % 4 != 3:\n                    self.__cv.wait()\n                self.__curr += 1\n                printNumber(i)\n                self.__cv.notifyAll()\n        \n    def odd(self, printNumber):\n        \"\"\"\n        :type printNumber: method\n        :rtype: void\n        \"\"\"\n        for i in xrange(1, self.__n+1, 2):\n            with self.__cv:\n                while self.__curr % 4 != 1:\n                    self.__cv.wait()\n                self.__curr += 1\n                printNumber(i)\n                self.__cv.notifyAll()\n"
    },
    {
        "problem_name": "prison-cells-after-n-days",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def prisonAfterNDays(self, cells, N):\n        \"\"\"\n        :type cells: List[int]\n        :type N: int\n        :rtype: List[int]\n        \"\"\"\n        N -= max(N-1, 0) // 14 * 14  # 14 is got from Solution2\n        for i in xrange(N):\n            cells = [0] + [cells[i-1] ^ cells[i+1] ^ 1 for i in xrange(1, 7)] + [0]\n        return cells\n\n\n# Time:  O(1)\n# Space: O(1)\nclass Solution2(object):\n    def prisonAfterNDays(self, cells, N):\n        \"\"\"\n        :type cells: List[int]\n        :type N: int\n        :rtype: List[int]\n        \"\"\"\n        cells = tuple(cells)\n        lookup = {}\n        while N:\n            lookup[cells] = N\n            N -= 1\n            cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in xrange(1, 7)] + [0])\n            if cells in lookup:\n                assert(lookup[cells] - N in (1, 7, 14))\n                N %= lookup[cells] - N\n                break\n\n        while N:\n            N -= 1\n            cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in xrange(1, 7)] + [0])\n        return list(cells)\n"
    },
    {
        "problem_name": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "solution": "# Time:  O(k^3 * n^2)\n# Space: O(k^2 * n)\n\nimport collections\n\n\nclass Solution(object):\n    def getProbability(self, balls):\n        \"\"\"\n        :type balls: List[int]\n        :rtype: float\n        \"\"\"\n        def nCrs(n):  # Time: O(n), Space: O(1)\n            c = 1\n            for k in xrange(n+1):\n                yield c\n                c *= n-(k+1)+1\n                c //= k+1\n        \n        def nCr(n, r):  # Time: O(n), Space: O(1)\n            if n-r < r:\n                return nCr(n, n-r)\n            c = 1\n            for k in xrange(1, r+1):\n                c *= n-k+1\n                c //= k\n            return c\n        \n        dp = collections.defaultdict(int)\n        dp[0, 0] = 1  # dp[i, j] is the number of ways with number difference i and color difference j\n        for n in balls:  # O(k) times\n            new_dp = collections.defaultdict(int)\n            for (ndiff, cdiff), count in dp.iteritems():  # O(k^2 * n) times\n                for k, new_count in enumerate(nCrs(n)):  # O(n) times\n                    new_ndiff = ndiff+(k-(n-k))\n                    new_cdiff = cdiff-1 if k == 0 else (cdiff+1 if k == n else cdiff)\n                    new_dp[new_ndiff, new_cdiff] += count*new_count\n            dp = new_dp\n        total = sum(balls)\n        return float(dp[0, 0])/nCr(total, total//2)\n"
    },
    {
        "problem_name": "process-restricted-friend-requests",
        "solution": "# Time:  O(n * (alpha(n) + r)) = O(n * r)\n# Space: O(n)\n\nclass UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)\n    def __init__(self, n):\n        self.set = range(n)\n        self.rank = [0]*n\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x, y = self.find_set(x), self.find_set(y)\n        if x == y:\n            return False\n        if self.rank[x] > self.rank[y]:  # union by rank\n            x, y = y, x\n        self.set[x] = self.set[y]\n        if self.rank[x] == self.rank[y]:\n            self.rank[y] += 1\n        return True\n\n\nclass Solution(object):\n    def friendRequests(self, n, restrictions, requests):\n        \"\"\"\n        :type n: int\n        :type restrictions: List[List[int]]\n        :type requests: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        result = []\n        uf = UnionFind(n)\n        for u, v in requests:\n            pu, pv = uf.find_set(u), uf.find_set(v)\n            ok = True\n            for x, y in restrictions:\n                px, py = uf.find_set(x), uf.find_set(y)\n                if {px, py} == {pu, pv}:\n                    ok = False\n                    break\n            result.append(ok)\n            if ok:\n                uf.union_set(u, v) \n        return result\n"
    },
    {
        "problem_name": "process-tasks-using-servers",
        "solution": "# Time:  O(n + mlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def assignTasks(self, servers, tasks):\n        \"\"\"\n        :type servers: List[int]\n        :type tasks: List[int]\n        :rtype: List[int]\n        \"\"\"\n        idle = [(servers[i], i) for i in xrange(len(servers))]\n        working = []\n        heapq.heapify(idle)\n        result = []\n        t = 0\n        for i in xrange(len(tasks)):\n            t = max(t, i) if idle else working[0][0]\n            while working and working[0][0] <= t:\n                _, w, idx = heapq.heappop(working)\n                heapq.heappush(idle, (w, idx))\n            w, idx = heapq.heappop(idle)\n            heapq.heappush(working, (t+tasks[i], w, idx))\n            result.append(idx)\n        return result\n"
    },
    {
        "problem_name": "product-of-array-except-self",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def productExceptSelf(self, nums):\n        if not nums:\n            return []\n\n        left_product = [1 for _ in xrange(len(nums))]\n        for i in xrange(1, len(nums)):\n            left_product[i] = left_product[i - 1] * nums[i - 1]\n\n        right_product = 1\n        for i in xrange(len(nums) - 2, -1, -1):\n            right_product *= nums[i + 1]\n            left_product[i] = left_product[i] * right_product\n\n        return left_product\n\n"
    },
    {
        "problem_name": "product-of-the-last-k-numbers",
        "solution": "# Time:  ctor: O(1)\n#        add : O(1)\n#        get : O(1)\n# Space: O(n)\n\nclass ProductOfNumbers(object):\n\n    def __init__(self):\n        self.__accu = [1]\n\n    def add(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: None\n        \"\"\"\n        if not num:\n            self.__accu = [1]\n            return\n        self.__accu.append(self.__accu[-1]*num)             \n\n    def getProduct(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(self.__accu) <= k:\n            return 0\n        return self.__accu[-1] // self.__accu[-1-k]\n"
    },
    {
        "problem_name": "product-of-two-run-length-encoded-arrays",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nclass Solution(object):\n    def findRLEArray(self, encoded1, encoded2):\n        \"\"\"\n        :type encoded1: List[List[int]]\n        :type encoded2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i = j = remain1 = remain2 = 0\n        while (remain1 or i < len(encoded1)) and (remain2 or j < len(encoded2)):\n            if not remain1:\n                remain1 = encoded1[i][1]\n                i += 1\n            if not remain2:\n                remain2 = encoded2[j][1]\n                j += 1\n            cnt = min(remain1, remain2)\n            remain1 -= cnt\n            remain2 -= cnt\n            if result and result[-1][0] == encoded1[i-1][0]*encoded2[j-1][0]:\n                result[-1][1] += cnt\n            else:\n                result.append([encoded1[i-1][0]*encoded2[j-1][0], cnt])\n        return result\n"
    },
    {
        "problem_name": "profitable-schemes",
        "solution": "# Time:  O(n * p * g)\n# Space: O(p * g)\n\nimport itertools\n\n\nclass Solution(object):\n    def profitableSchemes(self, G, P, group, profit):\n        \"\"\"\n        :type G: int\n        :type P: int\n        :type group: List[int]\n        :type profit: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [[0 for _ in xrange(G+1)] for _ in xrange(P+1)]\n        dp[0][0] = 1\n        for p, g in itertools.izip(profit, group):\n            for i in reversed(xrange(P+1)):\n                for j in reversed(xrange(G-g+1)):\n                    dp[min(i+p, P)][j+g] += dp[i][j]\n        return sum(dp[P]) % (10**9 + 7)\n\n"
    },
    {
        "problem_name": "projection-area-of-3d-shapes",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def projectionArea(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(len(grid)):\n            max_row, max_col = 0, 0\n            for j in xrange(len(grid)):\n                if grid[i][j]:\n                    result += 1\n                max_row = max(max_row, grid[i][j])\n                max_col = max(max_col, grid[j][i])\n            result += max_row + max_col\n        return result\n\n"
    },
    {
        "problem_name": "pseudo-palindromic-paths-in-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def pseudoPalindromicPaths (self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = [(root, 0)]\n        while stk:\n            node, count = stk.pop()\n            if not node:\n                continue\n            count ^= 1 << (node.val-1)\n            result += int(node.left == node.right and count&(count-1) == 0)\n            stk.append((node.right, count))\n            stk.append((node.left, count))\n        return result\n    \n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def pseudoPalindromicPaths (self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node, count):\n            if not root:\n                return 0\n            count ^= 1 << (node.val-1)\n            return int(node.left == node.right and count&(count-1) == 0) + \\\n                   dfs(node.left, count) + dfs(node.right, count)\n        return dfs(root, 0)\n"
    },
    {
        "problem_name": "push-dominoes",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n\nclass Solution(object):\n    def pushDominoes(self, dominoes):\n        \"\"\"\n        :type dominoes: str\n        :rtype: str\n        \"\"\"\n        force = [0]*len(dominoes)\n\n        f = 0\n        for i in xrange(len(dominoes)):\n            if dominoes[i] == 'R':\n                f = len(dominoes)\n            elif dominoes[i] == 'L':\n                f = 0\n            else:\n                f = max(f-1, 0)\n            force[i] += f\n\n        f = 0\n        for i in reversed(xrange(len(dominoes))):\n            if dominoes[i] == 'L':\n                f = len(dominoes)\n            elif dominoes[i] == 'R':\n                f = 0\n            else:\n                f = max(f-1, 0)\n            force[i] -= f\n\n        return \"\".join('.' if f == 0 else 'R' if f > 0 else 'L'\n                       for f in force)\n\n"
    },
    {
        "problem_name": "put-boxes-into-the-warehouse-i",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def maxBoxesInWarehouse(self, boxes, warehouse):\n        \"\"\"\n        :type boxes: List[int]\n        :type warehouse: List[int]\n        :rtype: int\n        \"\"\"\n        boxes.sort(reverse=True)\n        result = 0\n        for h in boxes:\n            if h > warehouse[result]:\n                continue\n            result += 1\n            if result == len(warehouse):\n                break\n        return result\n\n\n# Time:  O(nlogn + m)\n# Space: O(1)\nclass Solution2(object):\n    def maxBoxesInWarehouse(self, boxes, warehouse):\n        \"\"\"\n        :type boxes: List[int]\n        :type warehouse: List[int]\n        :rtype: int\n        \"\"\"\n        boxes.sort()\n        for i in xrange(1, len(warehouse)):\n            warehouse[i] = min(warehouse[i], warehouse[i-1])\n        result, curr = 0, 0\n        for h in reversed(warehouse):\n            if boxes[curr] > h:\n                continue\n            result += 1\n            curr += 1\n            if curr == len(boxes):\n                break\n        return result\n"
    },
    {
        "problem_name": "put-boxes-into-the-warehouse-ii",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def maxBoxesInWarehouse(self, boxes, warehouse):\n        \"\"\"\n        :type boxes: List[int]\n        :type warehouse: List[int]\n        :rtype: int\n        \"\"\"\n        boxes.sort(reverse=True)\n        left, right = 0, len(warehouse)-1\n        for h in boxes:\n            if h <= warehouse[left]:\n                left += 1\n            elif h <= warehouse[right]:\n                right -= 1\n            if left > right:\n                break\n        return left + (len(warehouse)-1-right)\n"
    },
    {
        "problem_name": "put-marbles-in-bags",
        "solution": "# Time:  O(n) on average\n# Space: O(1)\n\nimport random\n\n\n# greedy, quick select\nclass Solution(object):\n    def putMarbles(self, weights, k):\n        \"\"\"\n        :type weights: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            right = len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        for i in xrange(len(weights)-1):\n            weights[i] += weights[i+1]\n        weights.pop()\n        result = 0\n        nth_element(weights, (k-1)-1, compare=lambda a, b: a > b)\n        result += sum(weights[i] for i in xrange(k-1))\n        nth_element(weights, (k-1)-1)\n        result -= sum(weights[i] for i in xrange(k-1))\n        return result\n"
    },
    {
        "problem_name": "pyramid-transition-matrix",
        "solution": "# Time:  O((a^(b+1)-a)/(a-1)) = O(a^b) , a is the size of allowed,\n#                                        b is the length of bottom\n# Space: O((a^(b+1)-a)/(a-1)) = O(a^b)\n\nclass Solution(object):\n    def pyramidTransition(self, bottom, allowed):\n        \"\"\"\n        :type bottom: str\n        :type allowed: List[str]\n        :rtype: bool\n        \"\"\"\n        def pyramidTransitionHelper(bottom, edges, lookup):\n            def dfs(bottom, edges, new_bottom, idx, lookup):\n                if idx == len(bottom)-1:\n                    return pyramidTransitionHelper(\"\".join(new_bottom), edges, lookup)\n                for i in edges[ord(bottom[idx])-ord('A')][ord(bottom[idx+1])-ord('A')]:\n                    new_bottom[idx] = chr(i+ord('A'))\n                    if dfs(bottom, edges, new_bottom, idx+1, lookup):\n                        return True\n                return False\n\n            if len(bottom) == 1:\n                return True\n            if bottom in lookup:\n                return False\n            lookup.add(bottom)\n            for i in xrange(len(bottom)-1):\n                if not edges[ord(bottom[i])-ord('A')][ord(bottom[i+1])-ord('A')]:\n                    return False\n            new_bottom = ['A']*(len(bottom)-1)\n            return dfs(bottom, edges, new_bottom, 0, lookup)\n\n        edges = [[[] for _ in xrange(7)] for _ in xrange(7)]\n        for s in allowed:\n            edges[ord(s[0])-ord('A')][ord(s[1])-ord('A')].append(ord(s[2])-ord('A'))\n        return pyramidTransitionHelper(bottom, edges, set())\n\n"
    },
    {
        "problem_name": "queens-that-can-attack-the-king",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def queensAttacktheKing(self, queens, king):\n        \"\"\"\n        :type queens: List[List[int]]\n        :type king: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        dirctions = [(-1, 0), (0, 1), (1, 0), (0, -1),\n                     (-1, 1), (1, 1), (1, -1), (-1, -1)]\n        result = []\n        lookup = {(i, j) for i, j in queens}\n        for dx, dy in dirctions:\n            for i in xrange(1, 8):\n                x, y = king[0] + dx*i, king[1] + dy*i\n                if (x, y) in lookup:\n                    result.append([x, y])\n                    break\n        return result\n"
    },
    {
        "problem_name": "queries-on-a-permutation-with-key",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass BIT(object):  # Fenwick Tree, 1-indexed\n    def __init__(self, n):\n        self.__bit = [0] * n\n\n    def add(self, i, val):\n        while i < len(self.__bit):\n            self.__bit[i] += val\n            i += (i & -i)\n\n    def sum(self, i):\n        result = 0\n        while i > 0:\n            result += self.__bit[i]\n            i -= (i & -i)\n        return result\n\n\nclass Solution(object):\n    def processQueries(self, queries, m):\n        \"\"\"\n        :type queries: List[int]\n        :type m: int\n        :rtype: List[int]\n        \"\"\"\n        bit = BIT(2*m+1)\n        lookup = {}\n        for i in xrange(1, m+1):\n            bit.add(m+i, 1)\n            lookup[i] = m+i\n        result, curr = [], m\n        for q in queries:\n            i = lookup.pop(q)\n            result.append(bit.sum(i-1))\n            bit.add(i, -1)\n            lookup[q] = curr\n            bit.add(curr, 1)\n            curr -= 1\n        return result\n"
    },
    {
        "problem_name": "queries-on-number-of-points-inside-a-circle",
        "solution": "# Time:  O(q * n)\n# Space: O(1)\n\nclass Solution(object):\n    def countPoints(self, points, queries):\n        \"\"\"\n        :type points: List[List[int]]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i, j, r in queries:\n            result.append(0)\n            for x, y in points:\n                if (x-i)**2+(y-j)**2 <= r**2:\n                    result[-1] += 1\n        return result\n"
    },
    {
        "problem_name": "query-kth-smallest-trimmed-number",
        "solution": "# Time:  O(q + n * t)\n# Space: O(t + n + q)\n\n# radix sort\nclass Solution(object):\n    def smallestTrimmedNumbers(self, nums, queries):\n        \"\"\"\n        :type nums: List[str]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        max_t = max(t for _, t in queries)\n        lookup = [[] for _ in xrange(max_t+1)]\n        for i, (k, t) in enumerate(queries):\n            lookup[t].append((k, i))\n        result = [0]*len(queries)\n        idxs = range(len(nums))\n        for l in xrange(1, max_t+1):\n            cnt = [0]*10\n            for i in idxs:\n                d = int(nums[i][-l])\n                cnt[d] += 1\n            for d in xrange(9):\n                cnt[d+1] += cnt[d]\n            new_idxs = [0]*len(nums)\n            for i in reversed(idxs):\n                d = int(nums[i][-l])\n                cnt[d] -= 1\n                new_idxs[cnt[d]] = i\n            idxs = new_idxs\n            for k, i in lookup[l]:\n                result[i] = idxs[k-1]\n        return result\n\n            \n# Time:  O(q * n * t) on average\n# Space: O(n + q)\nimport random\n\n\n# quick select\nclass Solution2(object):\n    def smallestTrimmedNumbers(self, nums, queries):\n        \"\"\"\n        :type nums: List[str]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        def compare(a, b):\n            for i in xrange(len(nums[a])-t, len(nums[a])):\n                if nums[a][i] < nums[b][i]:\n                    return True\n                if nums[a][i] > nums[b][i]:\n                    return False\n            return cmp(a, b) < 0\n\n        result = []\n        idxs = range(len(nums))\n        for k, t in queries:\n            nth_element(idxs, k-1, compare=compare)\n            result.append(idxs[k-1])\n        return result\n\n\n# Time:  O(q + nlogn * t)\n# Space: O(t + n + q)\n# sort\nclass Solution3(object):\n    def smallestTrimmedNumbers(self, nums, queries):\n        \"\"\"\n        :type nums: List[str]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def compare(a, b):\n            for i in xrange(len(nums[a])-t, len(nums[a])):\n                if nums[a][i] < nums[b][i]:\n                    return -1\n                if nums[a][i] > nums[b][i]:\n                    return 1\n            return cmp(a, b)\n\n        max_t = max(t for _, t in queries)\n        lookup = [[] for _ in xrange(max_t+1)]\n        for i, (k, t) in enumerate(queries):\n            lookup[t].append((k, i))\n        result = [0]*len(queries)\n        idxs = range(len(nums))\n        for t in xrange(1, max_t+1):\n            if not lookup[t]:\n                continue\n            idxs.sort(cmp=compare)\n            for k, i in lookup[t]:\n                result[i] = idxs[k-1]\n        return result\n"
    },
    {
        "problem_name": "queue-reconstruction-by-height",
        "solution": "# Time:  O(n * sqrt(n))\n# Space: O(n)\n\nclass Solution(object):\n    def reconstructQueue(self, people):\n        \"\"\"\n        :type people: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        people.sort(key=lambda h_k: (-h_k[0], h_k[1]))\n\n        blocks = [[]]\n        for p in people:\n            index = p[1]\n\n            for i, block in enumerate(blocks):\n                if index <= len(block):\n                    break\n                index -= len(block)\n            block.insert(index, p)\n\n            if len(block) * len(block) > len(people):\n                blocks.insert(i+1, block[len(block)/2:])\n                del block[len(block)/2:]\n\n        return [p for block in blocks for p in block]\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution2(object):\n    def reconstructQueue(self, people):\n        \"\"\"\n        :type people: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        people.sort(key=lambda h_k1: (-h_k1[0], h_k1[1]))\n        result = []\n        for p in people:\n            result.insert(p[1], p)\n        return result\n\n"
    },
    {
        "problem_name": "rabbits-in-forest",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def numRabbits(self, answers):\n        \"\"\"\n        :type answers: List[int]\n        :rtype: int\n        \"\"\"\n        count = collections.Counter(answers)\n        return sum((((k+1)+v-1)//(k+1))*(k+1) for k, v in count.iteritems())\n\n"
    },
    {
        "problem_name": "race-car",
        "solution": "# Time : O(nlogn), n is the value of the target\n# Space: O(n)\n\n\nclass Solution(object):\n    def racecar(self, target):\n        dp = [0] * (target+1)\n        for i in xrange(1, target+1):\n            # 2^(k-1) <= i < 2^k\n            k = i.bit_length()\n\n            # case 1. drive exactly i at best\n            #         seq(i) = A^k\n            if i == 2**k-1:\n                dp[i] = k\n                continue\n\n            # case 2. drive cross i at 2^k-1, and turn back to i\n            #         seq(i) = A^k -> R -> seq(2^k-1 - i)\n            dp[i] = k+1 + dp[2**k-1 - i]\n\n            # case 3. drive less then 2^k-1, and turn back some distance,\n            #         and turn back again to make the direction is the same\n            #         seq(i) = shortest(seq(i), A^(k-1) -> R -> A^j -> R ->\n            #                                   seq(i - (2^(k-1)-1) + (2^j-1)),\n            #                  where 0 <= j < k-1)\n            #         => dp[i] = min(dp[i], (k-1) + 1 + j + 1 +\n            #                               dp[i - (2**(k-1)-1) + (2**j-1)])\n            for j in xrange(k-1):\n                dp[i] = min(dp[i], k+j+1 + dp[i - 2**(k-1) + 2**j])\n\n        return dp[-1]\n\n"
    },
    {
        "problem_name": "random-flip-matrix",
        "solution": "# Time:  ctor:  O(1)\n#        flip:  O(1)\n#        reset: O(min(f, r * c))\n# Space: O(min(f, r * c))\n\nimport random\n\n\nclass Solution(object):\n\n    def __init__(self, n_rows, n_cols):\n        \"\"\"\n        :type n_rows: int\n        :type n_cols: int\n        \"\"\"\n        self.__n_rows = n_rows\n        self.__n_cols = n_cols\n        self.__n = n_rows*n_cols\n        self.__lookup = {}\n        \n\n    def flip(self):\n        \"\"\"\n        :rtype: List[int]\n        \"\"\"\n        self.__n -= 1\n        target = random.randint(0, self.__n)\n        x = self.__lookup.get(target, target)\n        self.__lookup[target] = self.__lookup.get(self.__n, self.__n)\n        return divmod(x, self.__n_cols)\n        \n\n    def reset(self):\n        \"\"\"\n        :rtype: void\n        \"\"\"\n        self.__n = self.__n_rows*self.__n_cols\n        self.__lookup = {}\n        \n\n\n"
    },
    {
        "problem_name": "random-pick-index",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nfrom random import randint\n\nclass Solution(object):\n\n    def __init__(self, nums):\n        \"\"\"\n\n        :type nums: List[int]\n        :type numsSize: int\n        \"\"\"\n        self.__nums = nums\n\n    def pick(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: int\n        \"\"\"\n        reservoir = -1\n        n = 0\n        for i in xrange(len(self.__nums)):\n            if self.__nums[i] != target:\n                continue\n            reservoir = i if randint(1, n+1) == 1 else reservoir\n            n += 1\n        return reservoir\n\n\n\n"
    },
    {
        "problem_name": "random-pick-with-blacklist",
        "solution": "# Time:  ctor: O(b)\n#        pick: O(1)\n# Space: O(b)\n\nimport random\n\n\nclass Solution(object):\n    \n    def __init__(self, N, blacklist):\n        \"\"\"\n        :type N: int\n        :type blacklist: List[int]\n        \"\"\"\n        self.__n = N-len(blacklist)\n        self.__lookup = {}\n        white = iter(set(range(self.__n, N))-set(blacklist))\n        for black in blacklist:\n            if black < self.__n:\n                self.__lookup[black] = next(white)\n        \n        \n    def pick(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        index = random.randint(0, self.__n-1)\n        return self.__lookup[index] if index in self.__lookup else index\n\n\n# Time:  ctor: O(blogb)\n#        pick: O(logb)\n# Space: O(b)\nimport random\n\nclass Solution2(object):\n    \n    def __init__(self, N, blacklist):\n        \"\"\"\n        :type N: int\n        :type blacklist: List[int]\n        \"\"\"\n        self.__n = N-len(blacklist)\n        blacklist.sort()\n        self.__blacklist = blacklist\n        \n    def pick(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        index = random.randint(0, self.__n-1)\n        left, right = 0, len(self.__blacklist)-1\n        while left <= right:\n            mid = left+(right-left)//2\n            if index+mid < self.__blacklist[mid]:\n                right = mid-1\n            else:\n                left = mid+1\n        return index+left\n\n\n\n"
    },
    {
        "problem_name": "random-pick-with-weight",
        "solution": "# Time:  ctor: O(n)\n#        pickIndex: O(logn)\n# Space: O(n)\n\nimport random\nimport bisect\n\n\nclass Solution(object):\n\n    def __init__(self, w):\n        \"\"\"\n        :type w: List[int]\n        \"\"\"\n        self.__prefix_sum = list(w)\n        for i in xrange(1, len(w)):\n            self.__prefix_sum[i] += self.__prefix_sum[i-1]\n\n    def pickIndex(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        target = random.randint(0, self.__prefix_sum[-1]-1)\n        return bisect.bisect_right(self.__prefix_sum, target)\n\n\n\n"
    },
    {
        "problem_name": "random-point-in-non-overlapping-rectangles",
        "solution": "# Time:  ctor: O(n)\n#        pick: O(logn)\n# Space: O(n)\n\nimport random\nimport bisect\n\n\nclass Solution(object):\n\n    def __init__(self, rects):\n        \"\"\"\n        :type rects: List[List[int]]\n        \"\"\"\n        self.__rects = list(rects)\n        self.__prefix_sum = map(lambda x : (x[2]-x[0]+1)*(x[3]-x[1]+1), rects)\n        for i in xrange(1, len(self.__prefix_sum)):\n            self.__prefix_sum[i] += self.__prefix_sum[i-1]\n\n    def pick(self):\n        \"\"\"\n        :rtype: List[int]\n        \"\"\"\n        target = random.randint(0, self.__prefix_sum[-1]-1)\n        left = bisect.bisect_right(self.__prefix_sum, target)\n        rect = self.__rects[left]\n        width, height = rect[2]-rect[0]+1, rect[3]-rect[1]+1\n        base = self.__prefix_sum[left]-width*height\n        return [rect[0]+(target-base)%width, rect[1]+(target-base)//width]\n\n\n\n"
    },
    {
        "problem_name": "range-addition-ii",
        "solution": "# Time:  O(p), p is the number of ops\n# Space: O(1)\n\nclass Solution(object):\n    def maxCount(self, m, n, ops):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type ops: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for op in ops:\n            m = min(m, op[0])\n            n = min(n, op[1])\n        return m*n\n\n"
    },
    {
        "problem_name": "range-addition",
        "solution": "# Time:  O(k + n)\n# Space: O(1)\n\nclass Solution(object):\n    def getModifiedArray(self, length, updates):\n        \"\"\"\n        :type length: int\n        :type updates: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * length\n        for update in updates:\n            result[update[0]] += update[2]\n            if update[1]+1 < length:\n                result[update[1]+1] -= update[2]\n\n        for i in xrange(1, length):\n            result[i] += result[i-1]\n\n        return result\n\n"
    },
    {
        "problem_name": "range-frequency-queries",
        "solution": "# Time:  ctor:  O(n)\n#        query: O(logn)\n# Space: O(n)\n\nimport collections\nimport bisect\n\n\nclass RangeFreqQuery(object):\n\n    def __init__(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        \"\"\"\n        self.__idxs = collections.defaultdict(list)\n        for i, x in enumerate(arr):\n            self.__idxs[x].append(i)\n\n    def query(self, left, right, value):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :type value: int\n        :rtype: int\n        \"\"\"\n        return bisect.bisect_right(self.__idxs[value], right) - \\\n               bisect.bisect_left(self.__idxs[value], left)\n"
    },
    {
        "problem_name": "range-module",
        "solution": "# Time:  addRange:    O(n)\n#        removeRange: O(n)\n#        queryRange:  O(logn)\n# Space: O(n)\n\nimport bisect\n\n\nclass RangeModule(object):\n\n    def __init__(self):\n        self.__intervals = []\n\n    def addRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: void\n        \"\"\"\n        tmp = []\n        i = 0\n        for interval in self.__intervals:\n            if right < interval[0]:\n                tmp.append((left, right))\n                break\n            elif interval[1] < left:\n                tmp.append(interval)\n            else:\n                left = min(left, interval[0])\n                right = max(right, interval[1])\n            i += 1\n        if i == len(self.__intervals):\n            tmp.append((left, right))\n        while i < len(self.__intervals):\n            tmp.append(self.__intervals[i])\n            i += 1\n        self.__intervals = tmp\n\n    def queryRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: bool\n        \"\"\"\n        i = bisect.bisect_left(self.__intervals, (left, float(\"inf\")))\n        if i: i -= 1\n        return bool(self.__intervals) and \\\n               self.__intervals[i][0] <= left and \\\n               right <= self.__intervals[i][1]\n\n    def removeRange(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: void\n        \"\"\"\n        tmp = []\n        for interval in self.__intervals:\n            if interval[1] <= left or interval[0] >= right:\n                tmp.append(interval)\n            else:\n                if interval[0] < left:\n                    tmp.append((interval[0], left))\n                if right < interval[1]:\n                    tmp.append((right, interval[1]))\n        self.__intervals = tmp\n\n\n\n"
    },
    {
        "problem_name": "range-product-queries-of-powers",
        "solution": "# Time:  O(logn + qlogr), r = MOD\n# Space: O(logn)\n\n# prefix sum\nclass Solution(object):\n    def productQueries(self, n, queries):\n        \"\"\"\n        :type n: int\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        MOD = 10**9+7\n        prefix = [0]\n        i = 0\n        while (1<<i) <= n:\n            if n&(1<<i):\n                prefix.append(prefix[-1]+i)\n            i += 1\n        return [pow(2, prefix[r+1]-prefix[l], MOD) for l, r in queries]\n"
    },
    {
        "problem_name": "range-sum-of-bst",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def rangeSumBST(self, root, L, R):\n        \"\"\"\n        :type root: TreeNode\n        :type L: int\n        :type R: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        s = [root]\n        while s:\n            node = s.pop()\n            if node:\n                if L <= node.val <= R:\n                    result += node.val\n                if L < node.val:\n                    s.append(node.left)\n                if node.val < R:\n                    s.append(node.right)\n        return result\n"
    },
    {
        "problem_name": "range-sum-of-sorted-subarray-sums",
        "solution": "# Time:  O(nlog(sum(nums)))\n# Space: O(n)\n\n# binary search + sliding window solution\nclass Solution(object):\n    def rangeSum(self, nums, n, left, right):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :type left: int\n        :type right: int\n        :rtype: int\n        \"\"\"\n        def countUntil(nums, target):\n            result, curr, left = 0, 0, 0\n            for right in xrange(len(nums)):\n                curr += nums[right]\n                while curr > target:\n                    curr -= nums[left]\n                    left += 1\n                result += right-left+1\n            return result\n        \n        def sumUntil(nums, prefix, target):\n            result, curr, total, left = 0, 0, 0, 0\n            for right in xrange(len(nums)):\n                curr += nums[right]\n                total += nums[right]*(right-left+1)\n                while curr > target:\n                    curr -= nums[left]\n                    total -= prefix[right+1]-prefix[(left-1)+1]\n                    left += 1\n                result += total\n            return result\n            \n        def sumLessOrEqualTo(prefix, nums, left, right, count):\n            while left <= right:\n                mid = left + (right-left)//2\n                if countUntil(nums, mid)-count >= 0:\n                    right = mid-1\n                else:\n                    left = mid+1\n            return sumUntil(nums, prefix, left)-left*(countUntil(nums, left)-count)\n    \n        MOD = 10**9+7\n        prefix = [0]*(len(nums)+1)\n        for i in xrange(len(nums)):\n            prefix[i+1] = prefix[i]+nums[i]\n        m, M = min(nums), sum(nums)\n        return (sumLessOrEqualTo(prefix, nums, m, M, right) -\n                sumLessOrEqualTo(prefix, nums, m, M, left-1))%MOD\n    \n\n    \n# Time:  O(rlogr), worst: O(n^2 * logn)\n# Space: O(n)\nimport heapq\n\n\n# heap solution\nclass Solution2(object):\n    def rangeSum(self, nums, n, left, right):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :type left: int\n        :type right: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        min_heap = [];\n        for i, num in enumerate(nums, 1):\n            heapq.heappush(min_heap, (num, i))\n        result = 0\n        for i in xrange(1, right+1):\n            total, j = heapq.heappop(min_heap)\n            if i >= left:\n                result = (result+total)%MOD\n            if j+1 <= n:\n                heapq.heappush(min_heap, (total+nums[j], j+1))\n        return result\n"
    },
    {
        "problem_name": "range-sum-query-2d-immutable",
        "solution": "# Time:  ctor:   O(m * n),\n#        lookup: O(1)\n# Space: O(m * n)\n\nclass NumMatrix(object):\n    def __init__(self, matrix):\n        \"\"\"\n        initialize your data structure here.\n        :type matrix: List[List[int]]\n        \"\"\"\n        if not matrix:\n            return\n\n        m, n = len(matrix), len(matrix[0])\n        self.__sums = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]\n        for i in xrange(1, m+1):\n            for j in xrange(1, n+1):\n                self.__sums[i][j] = self.__sums[i][j-1] + self.__sums[i-1][j] - \\\n                                    self.__sums[i-1][j-1] + matrix[i-1][j-1]\n\n    def sumRegion(self, row1, col1, row2, col2):\n        \"\"\"\n        sum of elements matrix[(row1,col1)..(row2,col2)], inclusive.\n        :type row1: int\n        :type col1: int\n        :type row2: int\n        :type col2: int\n        :rtype: int\n        \"\"\"\n        return self.__sums[row2+1][col2+1] - self.__sums[row2+1][col1] - \\\n               self.__sums[row1][col2+1] + self.__sums[row1][col1]\n\n\n\n"
    },
    {
        "problem_name": "range-sum-query-2d-mutable",
        "solution": "# Time:  ctor:   O(m * n)\n#        update: O(logm * logn)\n#        query:  O(logm * logn)\n# Space: O(m * n)\n\nclass NumMatrix(object):\n    def __init__(self, matrix):\n        \"\"\"\n        initialize your data structure here.\n        :type matrix: List[List[int]]\n        \"\"\"\n        if not matrix:\n            return\n        self.__matrix = matrix\n        self.__bit = [[0] * (len(self.__matrix[0]) + 1) \\\n                      for _ in xrange(len(self.__matrix) + 1)]\n        for i in xrange(1, len(self.__bit)):\n            for j in xrange(1, len(self.__bit[0])):\n                self.__bit[i][j] = matrix[i-1][j-1] + self.__bit[i-1][j] + \\\n                                   self.__bit[i][j-1] - self.__bit[i-1][j-1]\n        for i in reversed(xrange(1, len(self.__bit))):\n            for j in reversed(xrange(1, len(self.__bit[0]))):\n                last_i, last_j = i - (i & -i), j - (j & -j)\n                self.__bit[i][j] = self.__bit[i][j] - self.__bit[i][last_j] - \\\n                                   self.__bit[last_i][j] + self.__bit[last_i][last_j]\n\n    def update(self, row, col, val):\n        \"\"\"\n        update the element at matrix[row,col] to val.\n        :type row: int\n        :type col: int\n        :type val: int\n        :rtype: void\n        \"\"\"\n        if val - self.__matrix[row][col]:\n            self.__add(row, col, val - self.__matrix[row][col])\n            self.__matrix[row][col] = val\n\n    def sumRegion(self, row1, col1, row2, col2):\n        \"\"\"\n        sum of elements matrix[(row1,col1)..(row2,col2)], inclusive.\n        :type row1: int\n        :type col1: int\n        :type row2: int\n        :type col2: int\n        :rtype: int\n        \"\"\"\n        return self.__sum(row2, col2) - self.__sum(row2, col1 - 1) - \\\n               self.__sum(row1 - 1, col2) + self.__sum(row1 - 1, col1 - 1)\n\n    def __sum(self, row, col):\n        row += 1\n        col += 1\n        ret = 0\n        i = row\n        while i > 0:\n            j = col\n            while j > 0:\n                ret += self.__bit[i][j]\n                j -= (j & -j)\n            i -= (i & -i)\n        return ret\n\n    def __add(self, row, col, val):\n        row += 1\n        col += 1\n        i = row\n        while i <= len(self.__matrix):\n            j = col\n            while j <= len(self.__matrix[0]):\n                self.__bit[i][j] += val\n                j += (j & -j)\n            i += (i & -i)\n\n\n\n"
    },
    {
        "problem_name": "range-sum-query-immutable",
        "solution": "# Time:  ctor:   O(n),\n#        lookup: O(1)\n# Space: O(n)\n\nclass NumArray(object):\n    def __init__(self, nums):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        self.accu = [0]\n        for num in nums:\n            self.accu.append(self.accu[-1] + num),\n\n    def sumRange(self, i, j):\n        \"\"\"\n        sum of elements nums[i..j], inclusive.\n        :type i: int\n        :type j: int\n        :rtype: int\n        \"\"\"\n        return self.accu[j + 1] - self.accu[i]\n\n\n\n"
    },
    {
        "problem_name": "range-sum-query-mutable",
        "solution": "# Time:  ctor:   O(n),\n#        update: O(logn),\n#        query:  O(logn)\n# Space: O(n)\n\nclass NumArray(object):\n    def __init__(self, nums):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        if not nums:\n            return\n        self.__nums = nums\n        self.__bit = [0] * (len(self.__nums) + 1)\n        for i in xrange(1, len(self.__bit)):\n            self.__bit[i] = nums[i-1] + self.__bit[i-1]\n\n        for i in reversed(xrange(1, len(self.__bit))):\n            last_i = i - (i & -i)\n            self.__bit[i] -= self.__bit[last_i]\n\n    def update(self, i, val):\n        \"\"\"\n        :type i: int\n        :type val: int\n        :rtype: int\n        \"\"\"\n        if val - self.__nums[i]:\n            self.__add(i, val - self.__nums[i])\n            self.__nums[i] = val\n\n    def sumRange(self, i, j):\n        \"\"\"\n        sum of elements nums[i..j], inclusive.\n        :type i: int\n        :type j: int\n        :rtype: int\n        \"\"\"\n        return self.__sum(j) - self.__sum(i-1)\n\n    def __sum(self, i):\n        i += 1\n        ret = 0\n        while i > 0:\n            ret += self.__bit[i]\n            i -= (i & -i)\n        return ret\n\n    def __add(self, i, val):\n        i += 1\n        while i <= len(self.__nums):\n            self.__bit[i] += val\n            i += (i & -i)\n\n\n# Time:  ctor:   O(n),\n#        update: O(logn),\n#        query:  O(logn)\n# Space: O(n)\n# Segment Tree solution.\nclass NumArray2(object):\n    def __init__(self, nums,\n                 query_fn=lambda x, y: x+y,\n                 update_fn=lambda x, y: y,\n                 default_val=0):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        N = len(nums)\n        self.__original_length = N\n        self.__tree_length = 2**(N.bit_length() + (N&(N-1) != 0))-1\n        self.__query_fn = query_fn\n        self.__update_fn = update_fn\n        self.__default_val = default_val\n        self.__tree = [default_val for _ in range(self.__tree_length)]\n        self.__lazy = [None for _ in range(self.__tree_length)]\n        self.__constructTree(nums, 0, self.__original_length-1, 0)\n\n    def update(self, i, val):\n        self.__updateTree(val, i, i, 0, self.__original_length-1, 0)\n\n    def sumRange(self, i, j):\n        return self.__queryRange(i, j, 0, self.__original_length-1, 0)\n\n    def __constructTree(self, nums, left, right, idx):\n        if left > right:\n             return\n        if left == right:\n            self.__tree[idx] = self.__update_fn(self.__tree[idx], nums[left])\n            return \n        mid = left + (right-left)//2\n        self.__constructTree(nums, left, mid, idx*2 + 1)\n        self.__constructTree(nums, mid+1, right, idx*2 + 2)\n        self.__tree[idx] = self.__query_fn(self.__tree[idx*2 + 1], self.__tree[idx*2 + 2])\n\n    def __apply(self, left, right, idx, val):\n        self.__tree[idx] = self.__update_fn(self.__tree[idx], val)\n        if left != right:\n            self.__lazy[idx*2 + 1] = self.__update_fn(self.__lazy[idx*2 + 1], val)\n            self.__lazy[idx*2 + 2] = self.__update_fn(self.__lazy[idx*2 + 2], val)\n\n    def __updateTree(self, val, range_left, range_right, left, right, idx):\n        if left > right:\n            return\n        if self.__lazy[idx] is not None:\n            self.__apply(left, right, idx, self.__lazy[idx])\n            self.__lazy[idx] = None\n        if range_left > right or range_right < left:\n            return\n        if range_left <= left and right <= range_right:\n            self.__apply(left, right, idx, val)\n            return\n        mid = left + (right-left)//2\n        self.__updateTree(val, range_left, range_right, left, mid, idx*2 + 1)\n        self.__updateTree(val, range_left, range_right, mid+1, right, idx*2 + 2)\n        self.__tree[idx] = self.__query_fn(self.__tree[idx*2 + 1],\n                                           self.__tree[idx*2 + 2])\n\n    def __queryRange(self, range_left, range_right, left, right, idx):\n        if left > right:\n            return self.__default_val\n        if self.__lazy[idx] is not None:\n            self.__apply(left, right, idx, self.__lazy[idx])\n            self.__lazy[idx] = None\n        if right < range_left or left > range_right:\n            return self.__default_val\n        if range_left <= left and right <= range_right:\n            return self.__tree[idx]\n        mid = left + (right-left)//2\n        return self.__query_fn(self.__queryRange(range_left, range_right, left, mid, idx*2 + 1), \n                               self.__queryRange(range_left, range_right, mid + 1, right, idx*2 + 2))\n"
    },
    {
        "problem_name": "rank-teams-by-votes",
        "solution": "# Time:  O(m * (n + mlogm)), n is the number of votes\n#                          , m is the length of vote\n# Space: O(m^2)\n\nclass Solution(object):\n    def rankTeams(self, votes):\n        \"\"\"\n        :type votes: List[str]\n        :rtype: str\n        \"\"\"\n        count = {v: [0]*len(votes[0]) + [v] for v in votes[0]}\n        for vote in votes:\n            for i, v in enumerate(vote):\n                count[v][i] -= 1\n        return \"\".join(sorted(votes[0], key=count.__getitem__))\n"
    },
    {
        "problem_name": "rank-transform-of-a-matrix",
        "solution": "# Time:  O(m * n * log(m * n) + m * n * \u03b1(m * n)) = O(m * n * log(m * n))\n# Space: O(m * n)\n\nimport collections\n\n\nclass UnionFind(object):  # Time: O(n * \u03b1(n)), Space: O(n)\n    def __init__(self, n, cb):\n        self.set = range(n)\n        self.rank = [0]*n\n        self.cb = cb\n\n    def find_set(self, x):\n        stk = []\n        while self.set[x] != x:  # path compression\n            stk.append(x)\n            x = self.set[x]\n        while stk:\n            self.set[stk.pop()] = x\n        return x\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:  # union by rank\n            self.set[x_root] = y_root\n            self.cb(y_root, x_root, y_root)\n        elif self.rank[x_root] > self.rank[y_root]:\n            self.set[y_root] = x_root\n            self.cb(x_root, x_root, y_root)\n        else:\n            self.set[y_root] = x_root\n            self.rank[x_root] += 1\n            self.cb(x_root, x_root, y_root)\n        return True\n\n\nclass Solution(object):\n    def matrixRankTransform(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        def cb(x, y, z):\n            new_rank[x] = max(new_rank[y], new_rank[z])\n\n        lookup = collections.defaultdict(list)\n        for i in xrange(len(matrix)):\n            for j in xrange(len(matrix[0])):\n                lookup[matrix[i][j]].append([i, j])\n        rank = [0]*(len(matrix)+len(matrix[0]))\n        for x in sorted(lookup):\n            new_rank = rank[:]\n            union_find = UnionFind(len(matrix)+len(matrix[0]), cb)\n            for i, j in lookup[x]:\n                union_find.union_set(i, j+len(matrix))\n            for i, j in lookup[x]:\n                matrix[i][j] = rank[i] = rank[j+len(matrix)] = new_rank[union_find.find_set(i)]+1\n        return matrix\n"
    },
    {
        "problem_name": "rank-transform-of-an-array",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def arrayRankTransform(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return map({x: i+1 for i, x in enumerate(sorted(set(arr)))}.get, arr)\n"
    },
    {
        "problem_name": "ransom-note",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def canConstruct(self, ransomNote, magazine):\n        \"\"\"\n        :type ransomNote: str\n        :type magazine: str\n        :rtype: bool\n        \"\"\"\n        counts = [0] * 26\n        letters = 0\n\n        for c in ransomNote:\n            if counts[ord(c) - ord('a')] == 0:\n                letters += 1\n            counts[ord(c) - ord('a')] += 1\n\n        for c in magazine:\n            counts[ord(c) - ord('a')] -= 1\n            if counts[ord(c) - ord('a')] == 0:\n                letters -= 1\n                if letters == 0:\n                    break\n\n        return letters == 0\n\n# Time:  O(n)\n# Space: O(1)\nimport collections\n\nclass Solution2(object):\n    def canConstruct(self, ransomNote, magazine):\n        \"\"\"\n        :type ransomNote: str\n        :type magazine: str\n        :rtype: bool\n        \"\"\"\n        return not collections.Counter(ransomNote) - collections.Counter(magazine)\n\n"
    },
    {
        "problem_name": "reach-a-number",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nimport math\n\n\nclass Solution(object):\n    def reachNumber(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: int\n        \"\"\"\n        target = abs(target)\n        k = int(math.ceil((-1+math.sqrt(1+8*target))/2))\n        target -= k*(k+1)/2\n        return k if target%2 == 0 else k+1+k%2\n\n\n# Time:  O(sqrt(n))\n# Space: O(1)\nclass Solution2(object):\n    def reachNumber(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: int\n        \"\"\"\n        target = abs(target)\n        k = 0\n        while target > 0:\n            k += 1\n            target -= k\n        return k if target%2 == 0 else k+1+k%2\n\n"
    },
    {
        "problem_name": "reachable-nodes-in-subdivided-graph",
        "solution": "# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),\n#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)\n# Space: O(|E| + |V|) = O(|E|)\n\nimport collections\nimport heapq\n\nclass Solution(object):\n    def reachableNodes(self, edges, M, N):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type M: int\n        :type N: int\n        :rtype: int\n        \"\"\"\n        adj = [[] for _ in xrange(N)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n\n        min_heap = [(0, 0)]\n        best = collections.defaultdict(lambda: float(\"inf\"))\n        best[0] = 0\n        count = collections.defaultdict(lambda: collections.defaultdict(int))\n        result = 0\n        while min_heap:\n            curr_total, u = heapq.heappop(min_heap)  # O(|V|*log|V|) in total\n            if best[u] < curr_total:\n                continue\n            result += 1\n            for v, w in adj[u]:\n                count[u][v] = min(w, M-curr_total)\n                next_total = curr_total+w+1\n                if next_total <= M and next_total < best[v]:\n                    best[v] = next_total\n                    heapq.heappush(min_heap, (next_total, v))  # binary heap O(|E|*log|V|) in total\n                                                               # Fibonacci heap O(|E|) in total\n        for u, v, w in edges:\n            result += min(w, count[u][v]+count[v][u])\n        return result\n\n"
    },
    {
        "problem_name": "reachable-nodes-with-restrictions",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# bfs\nclass Solution(object):\n    def reachableNodes(self, n, edges, restricted):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type restricted: List[int]\n        :rtype: int\n        \"\"\"\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        result = 0\n        lookup = [False]*n\n        for x in restricted:\n            lookup[x] = True\n        q = [0]\n        lookup[0] = True\n        while q:\n            new_q = []\n            for u in q:\n                result += 1\n                for v in adj[u]:\n                    if lookup[v]:\n                        continue\n                    lookup[v] = True\n                    new_q.append(v)\n            q = new_q\n        return result\n"
    },
    {
        "problem_name": "reaching-points",
        "solution": "# Time:  O(log(max(m, n)))\n# Space: O(1)\n\nclass Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        while tx >= sx and ty >= sy:\n            if tx < ty:\n                sx, sy = sy, sx\n                tx, ty = ty, tx\n            if ty > sy:\n                tx %= ty\n            else:\n                return (tx - sx) % ty == 0\n\n        return False\n\n"
    },
    {
        "problem_name": "read-n-characters-given-read4-ii-call-multiple-times",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\ndef read4(buf):\n    global file_content\n    i = 0\n    while i < len(file_content) and i < 4:\n        buf[i] = file_content[i]\n        i += 1\n\n    if len(file_content) > 4:\n        file_content = file_content[4:]\n    else:\n        file_content = \"\"\n    return i\n\n# The read4 API is already defined for you.\n# @param buf, a list of characters\n# @return an integer\n# def read4(buf):\n\nclass Solution(object):\n    def __init__(self):\n        self.__buf4 = [''] * 4\n        self.__i4 = 0\n        self.__n4 = 0\n\n    def read(self, buf, n):\n        \"\"\"\n        :type buf: Destination buffer (List[str])\n        :type n: Maximum number of characters to read (int)\n        :rtype: The number of characters read (int)\n        \"\"\"\n        i = 0\n        while i < n:\n            if self.__i4 < self.__n4:  # Any characters in buf4.\n                buf[i] = self.__buf4[self.__i4]\n                i += 1\n                self.__i4 += 1\n            else:\n                self.__n4 = read4(self.__buf4)  # Read more characters.\n                if self.__n4:\n                    self.__i4 = 0\n                else:  # Buffer has been empty.\n                    break\n\n        return i\n\n"
    },
    {
        "problem_name": "read-n-characters-given-read4",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\ndef read4(buf):\n    global file_content\n    i = 0\n    while i < len(file_content) and i < 4:\n        buf[i] = file_content[i]\n        i += 1\n\n    if len(file_content) > 4:\n        file_content = file_content[4:]\n    else:\n        file_content = \"\"\n    return i\n\nclass Solution(object):\n    def read(self, buf, n):\n        \"\"\"\n        :type buf: Destination buffer (List[str])\n        :type n: Maximum number of characters to read (int)\n        :rtype: The number of characters read (int)\n        \"\"\"\n        read_bytes = 0\n        buffer = [''] * 4\n        for i in xrange((n+4-1)//4):\n            size = min(read4(buffer), n-read_bytes)\n            buf[read_bytes:read_bytes+size] = buffer[:size]\n            read_bytes += size\n        return read_bytes\n"
    },
    {
        "problem_name": "rearrange-array-elements-by-sign",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers\nclass Solution(object):\n    def rearrangeArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        pos, neg = 0, 1\n        result = [0]*len(nums)\n        for x in nums:\n            if x > 0:\n                result[pos] = x\n                pos += 2\n            else:\n                result[neg] = x\n                neg += 2\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\n# generator\nclass Solution2(object):\n    def rearrangeArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def pos():\n            for x in nums:\n                if x > 0:\n                    yield x\n        \n        def neg():\n            for x in nums:\n                if x < 0:\n                    yield x\n        \n        gen_pos = pos()\n        gen_neg = neg()\n        return [next(gen_pos) if i%2 == 0 else next(gen_neg)  for i in xrange(len(nums))]\n\n\n# Time:  O(n)\n# Space: O(n)\n# array, implementation\nclass Solution3(object):\n    def rearrangeArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        pos, neg = [], []\n        for i in reversed(xrange(len(nums))):\n            if nums[i] > 0:\n                pos.append(nums[i])\n            else:\n                neg.append(nums[i])\n        result = []\n        for i in xrange(len(nums)):\n            if i%2 == 0:\n                result.append(pos.pop())\n            else:\n                result.append(neg.pop())\n        return result\n"
    },
    {
        "problem_name": "rearrange-array-to-maximize-prefix-score",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# sort, greedy\nclass Solution(object):\n    def maxScore(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort(reverse=True)\n        curr = 0\n        for i, x in enumerate(nums):\n            curr += x\n            if curr <= 0:\n                return i\n        return len(nums)\n"
    },
    {
        "problem_name": "rearrange-characters-to-make-target-string",
        "solution": "# Time:  O(n + m)\n# Space: O(1)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def rearrangeCharacters(self, s, target):\n        \"\"\"\n        :type s: str\n        :type target: str\n        :rtype: int\n        \"\"\"\n        cnt1 = collections.Counter(s)\n        cnt2 = collections.Counter(target)\n        return min(cnt1[k]//v for k, v in cnt2.iteritems())\n"
    },
    {
        "problem_name": "rearrange-spaces-between-words",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# inplace solution\nclass Solution(object):\n    def reorderSpaces(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: str\n        \"\"\"\n        text = list(text)\n        # count the spaces and words\n        space_count, word_count = 0, 0\n        for i, c in enumerate(text):\n            if c == ' ':\n                space_count += 1\n            elif i == 0 or text[i-1] == ' ':\n                word_count += 1\n\n        # rearrange all the spaces to the right\n        left, i = 0, 0\n        while i < len(text):\n            has_word = False\n            while i < len(text) and text[i] != ' ':\n                text[left], text[i] = text[i], text[left]\n                left += 1\n                i += 1\n                has_word = True\n            if has_word:\n                left += 1  # keep one space\n            i += 1\n\n        # rearrange all the spaces to the left\n        equal_count = space_count//(word_count-1) if word_count-1 > 0 else 0\n        extra_count = space_count%(word_count-1) if word_count-1 > 0 else space_count\n        right, i = len(text)-1-extra_count, len(text)-1\n        while i >= 0:\n            has_word = False\n            while i >= 0 and text[i] != ' ':\n                text[right], text[i] = text[i], text[right]\n                right -= 1\n                i -= 1\n                has_word = True\n            if has_word:\n                right -= equal_count  # keep equal_count spaces\n            i -= 1\n        return \"\".join(text)\n"
    },
    {
        "problem_name": "rearrange-string-k-distance-apart",
        "solution": "# Time:  O(n)\n# Space: O(c)\n\nimport collections\nimport itertools\n\n\nclass Solution(object):\n    def rearrangeString(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        if not k:\n            return s\n        cnts = collections.Counter(s)\n        bucket_cnt = max(cnts.itervalues())\n        if not ((bucket_cnt-1)*k+sum(x == bucket_cnt for x in cnts.itervalues()) <= len(s)):\n            return \"\"\n        result = [0]*len(s)\n        i = (len(s)-1)%k\n        for c in itertools.chain((c for c, v in cnts.iteritems() if v == bucket_cnt), (c for c, v in cnts.iteritems() if v != bucket_cnt)):\n            for _ in xrange(cnts[c]):\n                result[i] = c\n                i += k\n                if i >= len(result):\n                    i = (i-1)%k\n        return \"\".join(result)\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\nimport itertools\n\n\n# reference: https://codeforces.com/blog/entry/110184 1774B - Coloring\nclass Solution2(object):\n    def rearrangeString(self, s, k):\n        \"\"\"\n        :type str: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        if not k:\n            return s\n        cnts = collections.Counter(s)\n        bucket_cnt = (len(s)+k-1)//k\n        if not (max(cnts.itervalues()) <= bucket_cnt and cnts.values().count(bucket_cnt) <= (len(s)-1)%k+1):\n            return \"\"\n        result = [0]*len(s)\n        i = 0\n        for c in itertools.chain((c for c, v in cnts.iteritems() if v == bucket_cnt),\n                                 (c for c, v in cnts.iteritems() if v <= bucket_cnt-2),\n                                 (c for c, v in cnts.iteritems() if v == bucket_cnt-1)):\n            for _ in xrange(cnts[c]):\n                result[i] = c\n                i += k\n                if i >= len(result):\n                    i = i%k+1\n        return \"\".join(result)\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\nimport itertools\n\n\nclass Solution3(object):\n    def rearrangeString(self, s, k):\n        \"\"\"\n        :type str: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        cnts = collections.Counter(s)\n        bucket_cnt = max(cnts.itervalues())\n        buckets = [[] for _ in xrange(bucket_cnt)]\n        i = 0\n        for c in itertools.chain((c for c, v in cnts.iteritems() if v == bucket_cnt),\n                                 (c for c, v in cnts.iteritems() if v == bucket_cnt-1),\n                                 (c for c, v in cnts.iteritems() if v <= bucket_cnt-2)):\n            for _ in xrange(cnts[c]):\n                buckets[i].append(c)\n                i = (i+1) % max(cnts[c], bucket_cnt-1)\n        if any(len(buckets[i]) < k for i in xrange(len(buckets)-1)):\n            return \"\"\n        return \"\".join(map(lambda x : \"\".join(x), buckets))\n\n\n# Time:  O(nlogc), c is the count of unique characters.\n# Space: O(c)\nfrom collections import Counter\nfrom heapq import heappush, heappop\nclass Solution4(object):\n    def rearrangeString(self, s, k):\n        \"\"\"\n        :type str: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        if k <= 1:\n            return s\n\n        cnts = Counter(s)\n        heap = []\n        for c, cnt in cnts.iteritems():\n            heappush(heap, [-cnt, c])\n\n        result = []\n        while heap:\n            used_cnt_chars = []\n            for _ in xrange(min(k, len(s) - len(result))):\n                if not heap:\n                    return \"\"\n                cnt_char = heappop(heap)\n                result.append(cnt_char[1])\n                cnt_char[0] += 1\n                if cnt_char[0] < 0:\n                    used_cnt_chars.append(cnt_char)\n            for cnt_char in used_cnt_chars:\n                heappush(heap, cnt_char)\n\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "rearrange-words-in-a-sentence",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def arrangeWords(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: str\n        \"\"\"\n        result = text.split()\n        result[0] = result[0].lower()\n        result.sort(key=len) \n        result[0] = result[0].title()\n        return \" \".join(result)\n"
    },
    {
        "problem_name": "rearranging-fruits",
        "solution": "# Time:  O(n) on average\n# Space: O(n)\n\nimport random\nimport collections\n\n\n# freq table, greedy, quick select\nclass Solution(object):\n    def minCost(self, basket1, basket2):\n        \"\"\"\n        :type basket1: List[int]\n        :type basket2: List[int]\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, left=0, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n            \n            right = len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n    \n        cnt = collections.Counter()\n        for x in basket1:\n            cnt[x] += 1\n        for x in basket2:\n            cnt[x] -= 1\n        mn = min(cnt.iterkeys())\n        swaps = []\n        for k, v in cnt.iteritems():\n            if v%2:\n                return -1\n            swaps.extend(k for _ in xrange(abs(v)//2))\n        nth_element(swaps, len(swaps)//2)\n        return sum(min(swaps[i], mn*2) for i in xrange(len(swaps)//2))\n"
    },
    {
        "problem_name": "reconstruct-a-2-row-binary-matrix",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def reconstructMatrix(self, upper, lower, colsum):\n        \"\"\"\n        :type upper: int\n        :type lower: int\n        :type colsum: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        upper_matrix, lower_matrix = [0]*len(colsum), [0]*len(colsum)\n        for i in xrange(len(colsum)):\n            upper_matrix[i] = int(upper > 0 and colsum[i] != 0)\n            lower_matrix[i] = colsum[i]-upper_matrix[i]\n            upper -= upper_matrix[i]\n            lower -= lower_matrix[i]\n        return [upper_matrix, lower_matrix] if upper == lower == 0 else []\n"
    },
    {
        "problem_name": "reconstruct-itinerary",
        "solution": "# Time:  O(|V| + |E|log|V|)\n# Space: O(|V| + |E|)\n\n# Hierholzer Algorithm\nimport collections\n\n\nclass Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        for ticket in tickets:\n            adj[ticket[0]].append(ticket[1])\n        for x in adj.itervalues():\n            x.sort(reverse=True)\n        origin = \"JFK\"\n        result = []\n        stk = [origin]\n        while stk:\n            while adj[stk[-1]]: \n                stk.append(adj[stk[-1]].pop())\n            result.append(stk.pop())\n        result.reverse()\n        return result\n\n\n# Time:  O(t! / (n1! * n2! * ... nk!)), t is the total number of tickets,\n#                                       ni is the number of the ticket which from is city i,\n#                                       k is the total number of cities.\n# Space: O(t)\nimport collections\n\n\nclass Solution2(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        def route_helper(origin, ticket_cnt, graph, ans):\n            if ticket_cnt == 0:\n                return True\n\n            for i, (dest, valid)  in enumerate(graph[origin]):\n                if valid:\n                    graph[origin][i][1] = False\n                    ans.append(dest)\n                    if route_helper(dest, ticket_cnt - 1, graph, ans):\n                        return ans\n                    ans.pop()\n                    graph[origin][i][1] = True\n            return False\n\n        graph = collections.defaultdict(list)\n        for ticket in tickets:\n            graph[ticket[0]].append([ticket[1], True])\n        for k in graph.keys():\n            graph[k].sort()\n\n        origin = \"JFK\"\n        ans = [origin]\n        route_helper(origin, len(tickets), graph, ans)\n        return ans\n\n"
    },
    {
        "problem_name": "reconstruct-original-digits-from-english",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nfrom collections import Counter\n\nclass Solution(object):\n    def originalDigits(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # The count of each char in each number string.\n        cnts = [Counter(_) for _ in [\"zero\", \"one\", \"two\", \"three\", \\\n                                     \"four\", \"five\", \"six\", \"seven\", \\\n                                     \"eight\", \"nine\"]]\n\n        # The order for greedy method.\n        order = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]\n\n        # The unique char in the order.\n        unique_chars = ['z', 'o', 'w', 't', 'u', \\\n                        'f', 'x', 's', 'g', 'n']\n\n        cnt = Counter(list(s))\n        res = []\n        for i in order:\n            while cnt[unique_chars[i]] > 0:\n                cnt -= cnts[i]\n                res.append(i)\n        res.sort()\n\n        return \"\".join(map(str, res))\n\n"
    },
    {
        "problem_name": "recover-a-tree-from-preorder-traversal",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n# iterative stack solution\nclass Solution(object):\n    def recoverFromPreorder(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: TreeNode\n        \"\"\"\n        i = 0\n        stack = []\n        while i < len(S):\n            level = 0\n            while i < len(S) and S[i] == '-':\n                level += 1\n                i += 1\n            while len(stack) > level:\n                stack.pop()\n            val = []\n            while i < len(S) and S[i] != '-':\n                val.append(S[i])\n                i += 1\n            node = TreeNode(int(\"\".join(val)))\n            if stack:\n                if stack[-1].left is None:\n                    stack[-1].left = node\n                else:\n                    stack[-1].right = node\n            stack.append(node)\n        return stack[0]\n\n\n# Time:  O(n)\n# Space: O(h)\n# recursive solution\nclass Solution2(object):\n    def recoverFromPreorder(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: TreeNode\n        \"\"\"\n        def recoverFromPreorderHelper(S, level, i):\n            j = i[0]\n            while j < len(S) and S[j] == '-':\n                j += 1 \n            if level != j - i[0]:\n                return None\n            i[0] = j\n            while j < len(S) and S[j] != '-':\n                j += 1\n            node = TreeNode(int(S[i[0]:j]))\n            i[0] = j\n            node.left = recoverFromPreorderHelper(S, level+1, i)\n            node.right = recoverFromPreorderHelper(S, level+1, i)\n            return node\n\n        return recoverFromPreorderHelper(S, 0, [0])\n"
    },
    {
        "problem_name": "recover-binary-search-tree",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        if self:\n            serial = []\n            queue = [self]\n\n            while queue:\n                cur = queue[0]\n\n                if cur:\n                    serial.append(cur.val)\n                    queue.append(cur.left)\n                    queue.append(cur.right)\n                else:\n                    serial.append(\"#\")\n\n                queue = queue[1:]\n\n            while serial[-1] == \"#\":\n                serial.pop()\n\n            return repr(serial)\n\n        else:\n            return None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return a tree node\n    def recoverTree(self, root):\n        return self.MorrisTraversal(root)\n\n    def MorrisTraversal(self, root):\n        if root is None:\n            return\n        broken = [None, None]\n        pre, cur = None, root\n\n        while cur:\n            if cur.left is None:\n                self.detectBroken(broken, pre, cur)\n                pre = cur\n                cur = cur.right\n            else:\n                node = cur.left\n                while node.right and node.right != cur:\n                    node = node.right\n\n                if node.right is None:\n                    node.right =cur\n                    cur = cur.left\n                else:\n                    self.detectBroken(broken, pre, cur)\n                    node.right = None\n                    pre = cur\n                    cur = cur.right\n\n        broken[0].val, broken[1].val = broken[1].val, broken[0].val\n\n        return root\n\n    def detectBroken(self, broken, pre, cur):\n        if pre and pre.val > cur.val:\n            if broken[0] is None:\n                broken[0] = pre\n            broken[1] = cur\n\n"
    },
    {
        "problem_name": "recover-the-original-array",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def recoverArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def check(k, cnt, result):\n            for x in nums:\n                if cnt[x] == 0:\n                    continue\n                if cnt[x+2*k] == 0:\n                    return False\n                cnt[x] -= 1\n                cnt[x+2*k] -= 1\n                result.append(x+k)\n            return True\n            \n        nums.sort()\n        cnt = collections.Counter(nums)\n        for i in xrange(1, len(nums)//2+1):\n            k = nums[i]-nums[0]\n            if k == 0 or k%2:\n                continue\n            k //= 2\n            result = []\n            if check(k, collections.Counter(cnt), result):\n                return result\n        return []\n"
    },
    {
        "problem_name": "rectangle-area-ii",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass SegmentTreeNode(object):\n    def __init__(self, start, end):\n        self.start, self.end = start, end\n        self.total = self.count = 0\n        self._left = self._right = None\n\n    def mid(self):\n        return (self.start+self.end) // 2\n\n    def left(self):\n        self._left = self._left or SegmentTreeNode(self.start, self.mid())\n        return self._left\n\n    def right(self):\n        self._right = self._right or SegmentTreeNode(self.mid(), self.end)\n        return self._right\n\n    def update(self, X, i, j, val):\n        if i >= j:\n            return 0\n        if self.start == i and self.end == j:\n            self.count += val\n        else:\n            self.left().update(X, i, min(self.mid(), j), val)\n            self.right().update(X, max(self.mid(), i), j, val)\n        if self.count > 0:\n            self.total = X[self.end]-X[self.start]\n        else:\n            self.total = self.left().total + self.right().total\n        return self.total\n\n\nclass Solution(object):\n    def rectangleArea(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: int\n        \"\"\"\n        OPEN, CLOSE = 1, -1\n        events = []\n        X = set()\n        for x1, y1, x2, y2 in rectangles:\n            events.append((y1, OPEN, x1, x2))\n            events.append((y2, CLOSE, x1, x2))\n            X.add(x1)\n            X.add(x2)\n        events.sort()\n        X = sorted(X)\n        Xi = {x: i for i, x in enumerate(X)}\n\n        st = SegmentTreeNode(0, len(X)-1)\n        result = 0\n        cur_x_sum = 0\n        cur_y = events[0][0]\n        for y, typ, x1, x2 in events:\n            result += cur_x_sum * (y-cur_y)\n            cur_x_sum = st.update(X, Xi[x1], Xi[x2], typ)\n            cur_y = y\n        return result % (10**9+7)\n\n"
    },
    {
        "problem_name": "rectangle-area",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {integer} A\n    # @param {integer} B\n    # @param {integer} C\n    # @param {integer} D\n    # @param {integer} E\n    # @param {integer} F\n    # @param {integer} G\n    # @param {integer} H\n    # @return {integer}\n    def computeArea(self, A, B, C, D, E, F, G, H):\n        return (D - B) * (C - A) + \\\n               (G - E) * (H - F) - \\\n               max(0, (min(C, G) - max(A, E))) * \\\n               max(0, (min(D, H) - max(B, F)))\n\n"
    },
    {
        "problem_name": "rectangle-overlap",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def isRectangleOverlap(self, rec1, rec2):\n        \"\"\"\n        :type rec1: List[int]\n        :type rec2: List[int]\n        :rtype: bool\n        \"\"\"\n        def intersect(p_left, p_right, q_left, q_right):\n            return max(p_left, q_left) < min(p_right, q_right)\n\n        return (intersect(rec1[0], rec1[2], rec2[0], rec2[2]) and\n                intersect(rec1[1], rec1[3], rec2[1], rec2[3]))\n\n"
    },
    {
        "problem_name": "redistribute-characters-to-make-all-strings-equal",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def makeEqual(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: bool\n        \"\"\"\n        cnt = collections.defaultdict(int)\n        for w in words:\n            for c in w:\n                cnt[c] += 1\n        return all(v%len(words) == 0 for v in cnt.itervalues())\n"
    },
    {
        "problem_name": "reduce-array-size-to-the-half",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n        \nclass Solution(object):\n    def minSetSize(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        counting_sort = [0]*len(arr)\n        count = collections.Counter(arr)\n        for c in count.itervalues():\n            counting_sort[c-1] += 1\n        result, total = 0, 0\n        for c in reversed(xrange(len(arr))):\n            if not counting_sort[c]:\n                continue\n            count = min(counting_sort[c],\n                        ((len(arr)+1)//2 - total - 1)//(c+1) + 1)\n            result += count\n            total += count*(c+1)\n            if total >= (len(arr)+1)//2:\n                break\n        return result\n"
    },
    {
        "problem_name": "reducing-dishes",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def maxSatisfaction(self, satisfaction):\n        \"\"\"\n        :type satisfaction: List[int]\n        :rtype: int\n        \"\"\"\n        satisfaction.sort(reverse=True)\n        result, curr = 0, 0\n        for x in satisfaction:\n            curr += x\n            if curr <= 0:\n                break\n            result += curr\n        return result\n"
    },
    {
        "problem_name": "reduction-operations-to-make-the-array-elements-equal",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def reductionOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        result = curr = 0\n        for i in xrange(1, len(nums)): \n            if nums[i-1] < nums[i]:\n                curr += 1\n            result += curr\n        return result\n"
    },
    {
        "problem_name": "redundant-connection-ii",
        "solution": "# Time:  O(nlog*n) ~= O(n), n is the length of the positions\n# Space: O(n)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\n\nclass Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        cand1, cand2 = [], []\n        parent = {}\n        for edge in edges:\n            if edge[1] not in parent:\n                parent[edge[1]] = edge[0]\n            else:\n                cand1 = [parent[edge[1]], edge[1]]\n                cand2 = edge\n\n        union_find = UnionFind(len(edges)+1)\n        for edge in edges:\n            if edge == cand2:\n                continue\n            if not union_find.union_set(*edge):\n                return cand1 if cand2 else edge\n        return cand2\n\n"
    },
    {
        "problem_name": "redundant-connection",
        "solution": "# Time:  O(nlog*n) ~= O(n), n is the length of the positions\n# Space: O(n)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\n\nclass Solution(object):\n    def findRedundantConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        union_find = UnionFind(len(edges)+1)\n        for edge in edges:\n            if not union_find.union_set(*edge):\n                return edge\n        return []\n"
    },
    {
        "problem_name": "reformat-date",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def reformatDate(self, date):\n        \"\"\"\n        :type date: str\n        :rtype: str\n        \"\"\"\n        lookup = {\"Jan\":1, \"Feb\":2, \"Mar\":3, \"Apr\":4,\n                  \"May\":5, \"Jun\":6, \"Jul\":7, \"Aug\":8,\n                  \"Sep\":9, \"Oct\":10, \"Nov\":11, \"Dec\":12}\n        return \"{:04d}-{:02d}-{:02d}\".format(int(date[-4:]), lookup[date[-8:-5]], int(date[:date.index(' ')-2]))\n"
    },
    {
        "problem_name": "reformat-phone-number",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# inplace solution\nclass Solution(object):\n    def reformatNumber(self, number):\n        \"\"\"\n        :type number: str\n        :rtype: str\n        \"\"\"\n        number = list(number)\n        src_len = 0\n        for c in number:  # remove non-digit characters\n            if c.isdigit():\n                number[src_len] = c\n                src_len += 1\n        dst_len = src_len + (src_len-1)//3\n        if dst_len > len(number):  # resize the buffer to expected final size\n            number.extend([0]*(dst_len-len(number)))\n        while dst_len < len(number):\n            number.pop()\n        curr = dst_len-1\n        for l, i in enumerate(reversed(xrange(src_len)), (3-src_len%3)%3):\n            if l and l%3 == 0:  # group by 3 digits\n                number[curr] = '-'\n                curr -= 1\n            number[curr] = number[i]\n            curr -= 1\n        if dst_len >= 3 and number[dst_len-2] == '-':  # adjust for the 4 digits case\n            number[dst_len-3], number[dst_len-2] = number[dst_len-2], number[dst_len-3]            \n        return \"\".join(number)\n"
    },
    {
        "problem_name": "reformat-the-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def reformat(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def char_gen(start, end, count):\n            for c in xrange(ord(start), ord(end)+1):\n                c = chr(c)\n                for i in xrange(count[c]):\n                    yield c\n            yield ''\n    \n        count = collections.defaultdict(int)\n        alpha_cnt = 0\n        for c in s:\n            count[c] += 1\n            if c.isalpha():\n                alpha_cnt += 1\n        if abs(len(s)-2*alpha_cnt) > 1:\n            return \"\"\n\n        result = []\n        it1, it2 = char_gen('a', 'z', count), char_gen('0', '9', count)\n        if alpha_cnt < len(s)-alpha_cnt:\n            it1, it2 = it2, it1\n        while len(result) < len(s):\n            result.append(next(it1))\n            result.append(next(it2))\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "regions-cut-by-slashes",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n       if self.set[x] != x:\n           self.set[x] = self.find_set(self.set[x])  # path compression.\n       return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root != y_root:\n            self.set[min(x_root, y_root)] = max(x_root, y_root)\n            self.count -= 1\n\n\nclass Solution(object):\n    def regionsBySlashes(self, grid):\n        \"\"\"\n        :type grid: List[str]\n        :rtype: int\n        \"\"\"\n        def index(n, i, j, k):\n            return (i*n + j)*4 + k\n    \n        union_find = UnionFind(len(grid)**2 * 4)\n        N, E, S, W = range(4)\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid)):\n                if i:\n                    union_find.union_set(index(len(grid), i-1, j, S),\n                                         index(len(grid),i, j, N))\n                if j:\n                    union_find.union_set(index(len(grid), i, j-1, E),\n                                         index(len(grid), i, j, W))\n                if grid[i][j] != \"/\":\n                    union_find.union_set(index(len(grid), i, j, N),\n                                         index(len(grid), i, j, E))\n                    union_find.union_set(index(len(grid), i, j, S),\n                                         index(len(grid), i, j, W))\n                if grid[i][j] != \"\\\\\":\n                    union_find.union_set(index(len(grid), i, j, W),\n                                         index(len(grid), i, j, N))\n                    union_find.union_set(index(len(grid), i, j, E),\n                                         index(len(grid), i, j, S))\n        return union_find.count\n"
    },
    {
        "problem_name": "regular-expression-matching",
        "solution": "# Time:  O(m * n)\n# Space: O(n)\n\nclass Solution(object):\n    # @return a boolean\n    def isMatch(self, s, p):\n        k = 3\n        result = [[False for j in xrange(len(p) + 1)] for i in xrange(k)]\n\n        result[0][0] = True\n        for i in xrange(2, len(p) + 1):\n            if p[i-1] == '*':\n                result[0][i] = result[0][i-2]\n\n        for i in xrange(1,len(s) + 1):\n            if i > 1:\n                result[0][0] = False\n            for j in xrange(1, len(p) + 1):\n                if p[j-1] != '*':\n                    result[i % k][j] = result[(i-1) % k][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.')\n                else:\n                    result[i % k][j] = result[i % k][j-2] or (result[(i-1) % k][j] and (s[i-1] == p[j-2] or p[j-2] == '.'))\n\n        return result[len(s) % k][len(p)]\n\n# dp\n# Time:  O(m * n)\n# Space: O(m * n)\nclass Solution2(object):\n    # @return a boolean\n    def isMatch(self, s, p):\n        result = [[False for j in xrange(len(p) + 1)] for i in xrange(len(s) + 1)]\n\n        result[0][0] = True\n        for i in xrange(2, len(p) + 1):\n            if p[i-1] == '*':\n                result[0][i] = result[0][i-2]\n\n        for i in xrange(1,len(s) + 1):\n            for j in xrange(1, len(p) + 1):\n                if p[j-1] != '*':\n                    result[i][j] = result[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.')\n                else:\n                    result[i][j] = result[i][j-2] or (result[i-1][j] and (s[i-1] == p[j-2] or p[j-2] == '.'))\n\n        return result[len(s)][len(p)]\n\n# iteration\nclass Solution3(object):\n    # @return a boolean\n    def isMatch(self, s, p):\n        p_ptr, s_ptr, last_s_ptr, last_p_ptr = 0, 0, -1, -1\n        last_ptr = []\n        while s_ptr < len(s):\n            if p_ptr < len(p) and (p_ptr == len(p) - 1 or p[p_ptr + 1] != '*') and \\\n            (s_ptr < len(s) and (p[p_ptr] == s[s_ptr] or p[p_ptr] == '.')):\n                    s_ptr += 1\n                    p_ptr += 1\n            elif p_ptr < len(p) - 1 and (p_ptr != len(p) - 1 and p[p_ptr + 1] == '*'):\n                p_ptr += 2\n                last_ptr.append([s_ptr, p_ptr])\n            elif  last_ptr:\n                [last_s_ptr, last_p_ptr] = last_ptr.pop()\n                while last_ptr and p[last_p_ptr - 2] != s[last_s_ptr] and p[last_p_ptr - 2] != '.':\n                    [last_s_ptr, last_p_ptr] = last_ptr.pop()\n\n                if p[last_p_ptr - 2] == s[last_s_ptr] or p[last_p_ptr - 2] == '.':\n                    last_s_ptr += 1\n                    s_ptr = last_s_ptr\n                    p_ptr = last_p_ptr\n                    last_ptr.append([s_ptr, p_ptr])\n                else:\n                    return False\n            else:\n                return False\n\n        while p_ptr < len(p) - 1 and p[p_ptr] == '.' and p[p_ptr + 1] == '*':\n            p_ptr += 2\n\n        return p_ptr == len(p)\n\n# recursive\nclass Solution4(object):\n    # @return a boolean\n    def isMatch(self, s, p):\n        if not p:\n            return not s\n\n        if len(p) == 1 or p[1] != '*':\n            if len(s) > 0 and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p[1:])\n            else:\n                return False\n        else:\n            while len(s) > 0 and (p[0] == s[0] or p[0] == '.'):\n                if self.isMatch(s, p[2:]):\n                    return True\n                s = s[1:]\n            return self.isMatch(s, p[2:])\n\n"
    },
    {
        "problem_name": "relative-ranks",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def findRelativeRanks(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        sorted_nums = sorted(nums)[::-1]\n        ranks = [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"] + map(str, range(4, len(nums) + 1))\n        return map(dict(zip(sorted_nums, ranks)).get, nums)\n\n"
    },
    {
        "problem_name": "relative-sort-array",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def relativeSortArray(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        lookup = {v: i for i, v in enumerate(arr2)}\n        return sorted(arr1, key=lambda i: lookup.get(i, len(arr2)+i))\n"
    },
    {
        "problem_name": "relocate-marbles",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport itertools\n\n\n# hash table, sort\nclass Solution(object):\n    def relocateMarbles(self, nums, moveFrom, moveTo):\n        \"\"\"\n        :type nums: List[int]\n        :type moveFrom: List[int]\n        :type moveTo: List[int]\n        :rtype: List[int]\n        \"\"\"\n        lookup = set(nums)\n        for a, b in itertools.izip(moveFrom, moveTo):\n            lookup.remove(a)\n            lookup.add(b)\n        return sorted(lookup)\n"
    },
    {
        "problem_name": "remove-9",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def newInteger(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        result, base = 0, 1\n        while n > 0:\n            result += (n%9) * base\n            n /= 9\n            base *= 10\n        return result\n\n"
    },
    {
        "problem_name": "remove-adjacent-almost-equal-characters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def removeAlmostEqualCharacters(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(len(word)-1):\n            if (i+1)+result >= len(word):\n                break\n            if abs(ord(word[(i+1)+result])-ord(word[i+result])) <= 1:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "remove-all-adjacent-duplicates-in-string-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def removeDuplicates(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        stk = [['^', 0]]\n        for c in s:\n            if stk[-1][0] == c:\n                stk[-1][1] += 1\n                if stk[-1][1] == k:\n                    stk.pop()\n            else:\n                stk.append([c, 1])\n        return \"\".join(c*k for c, k in stk)\n"
    },
    {
        "problem_name": "remove-all-adjacent-duplicates-in-string",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def removeDuplicates(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        result = []\n        for c in S:\n            if result and result[-1] == c:\n                result.pop()\n            else:\n                result.append(c)\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "remove-all-occurrences-of-a-substring",
        "solution": "# Time:  O(n + m)\n# Space: O(n + m)\n\n# kmp solution\nclass Solution(object):\n    def removeOccurrences(self, s, part):\n        \"\"\"\n        :type s: str\n        :type part: str\n        :rtype: str\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j != -1 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n        \n        prefix = getPrefix(part)\n        result, lookup = [], []\n        i = -1\n        for c in s:\n            while i != -1 and part[i+1] != c:\n                i = prefix[i]\n            if part[i+1] == c:\n                i += 1\n            result.append(c)\n            lookup.append(i)\n            if i == len(part)-1:\n                result[len(result)-len(part):] = []\n                lookup[len(lookup)-len(part):] = []\n                i = lookup[-1] if lookup else -1\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "remove-all-ones-with-row-and-column-flips-ii",
        "solution": "# Time:  O(m * n * 2^(m * n))\n# Space: O(2^(m * n))\n\n# dp, bitmasks\nclass Solution(object):\n    def removeOnes(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        rows = [0]*len(grid)\n        mask, bit = 0, 1\n        for _ in xrange(len(grid[0])):\n            mask += bit\n            bit <<= 1\n        for i in xrange(len(grid)):\n            rows[i] = mask\n            mask <<= len(grid[0])\n\n        cols = [0]*len(grid[0])\n        mask, bit = 0, 1\n        for _ in xrange(len(grid)):\n            mask += bit\n            bit <<= len(grid[0])\n        for j in xrange(len(grid[0])):\n            cols[j] = mask\n            mask <<= 1\n\n        full_mask = (1<<(len(grid)*len(grid[0])))-1\n        masks = [[full_mask for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))]\n        target, bit = 0, 1\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                target += bit*grid[i][j]\n                masks[i][j] -= (rows[i]+cols[j]-bit)\n                bit <<= 1\n\n        dp = [float(\"inf\") for _ in xrange(target+1)]\n        dp[0] = 0\n        for mask in xrange(1, target+1):\n            for i in xrange(len(grid)):\n                for j in xrange(len(grid[0])):\n                    if grid[i][j]:\n                        dp[mask] = min(dp[mask], dp[mask&masks[i][j]]+1)\n        return dp[target]\n"
    },
    {
        "problem_name": "remove-all-ones-with-row-and-column-flips",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def removeOnes(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        return all(grid[i] == grid[0] or all(grid[i][j] != grid[0][j] for j in xrange(len(grid[0]))) for i in xrange(1, len(grid)))\n"
    },
    {
        "problem_name": "remove-boxes",
        "solution": "# Time:  O(n^3) ~ O(n^4)\n# Space: O(n^3)\n\nclass Solution(object):\n    def removeBoxes(self, boxes):\n        \"\"\"\n        :type boxes: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(boxes, l, r, k, lookup):\n            if l > r: return 0\n            if lookup[l][r][k]: return lookup[l][r][k]\n\n            ll, kk = l, k\n            while l < r and boxes[l+1] == boxes[l]:\n                l += 1\n                k += 1\n            result = dfs(boxes, l+1, r, 0, lookup) + (k+1) ** 2\n            for i in xrange(l+1, r+1):\n                if boxes[i] == boxes[l]:\n                    result = max(result, dfs(boxes, l+1, i-1, 0, lookup) + dfs(boxes, i, r, k+1, lookup))\n            lookup[ll][r][kk] = result\n            return result\n\n        lookup = [[[0]*len(boxes) for _ in xrange(len(boxes)) ] for _ in xrange(len(boxes)) ]\n        return dfs(boxes, 0, len(boxes)-1, 0, lookup)\n\n"
    },
    {
        "problem_name": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def winnerOfGame(self, colors):\n        \"\"\"\n        :type colors: str\n        :rtype: bool\n        \"\"\"\n        cnt1 = cnt2 = 0\n        for i in xrange(1, len(colors)-1):\n            if not (colors[i-1] == colors[i] == colors[i+1]):\n                continue\n            if colors[i] == 'A':\n                cnt1 += 1\n            else:\n                cnt2 += 1\n        return cnt1 > cnt2\n"
    },
    {
        "problem_name": "remove-comments",
        "solution": "# Time:  O(n), n is the length of the source\n# Space: O(k), k is the max length of a line\n\nclass Solution(object):\n    def removeComments(self, source):\n        \"\"\"\n        :type source: List[str]\n        :rtype: List[str]\n        \"\"\"\n        in_block = False\n        result, newline = [], []\n        for line in source:\n            i = 0\n            while i < len(line):\n                if not in_block and i+1 < len(line) and line[i:i+2] == '/*':\n                    in_block = True\n                    i += 1\n                elif in_block and i+1 < len(line) and line[i:i+2] == '*/':\n                    in_block = False\n                    i += 1\n                elif not in_block and i+1 < len(line) and line[i:i+2] == '//':\n                    break\n                elif not in_block:\n                    newline.append(line[i])\n                i += 1\n            if newline and not in_block:\n                result.append(\"\".join(newline))\n                newline = []\n        return result\n\n"
    },
    {
        "problem_name": "remove-covered-intervals",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def removeCoveredIntervals(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        intervals.sort(key=lambda x: [x[0], -x[1]])\n        result, max_right = 0, 0\n        for left, right in intervals:\n            result += int(right > max_right)\n            max_right = max(max_right, right)\n        return result\n"
    },
    {
        "problem_name": "remove-digit-from-number-to-maximize-result",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def removeDigit(self, number, digit):\n        \"\"\"\n        :type number: str\n        :type digit: str\n        :rtype: str\n        \"\"\"\n        i = next((i for i in xrange(len(number)-1) if digit == number[i] < number[i+1]), len(number)-1)\n        if i+1 == len(number):\n            i = next((i for i in reversed(xrange(len(number))) if digit == number[i]))\n        return number[:i]+number[i+1:]\n"
    },
    {
        "problem_name": "remove-duplicate-letters",
        "solution": "# Time:  O(n)\n# Space: O(k), k is size of the alphabet\n\nfrom collections import Counter\n\n\nclass Solution(object):\n    def removeDuplicateLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        remaining = Counter(s)\n\n        in_stack, stk = set(), []\n        for c in s:\n            if c not in in_stack:\n                while stk and stk[-1] > c and remaining[stk[-1]]:\n                    in_stack.remove(stk.pop())\n                stk += c\n                in_stack.add(c)\n            remaining[c] -= 1\n        return \"\".join(stk)\n"
    },
    {
        "problem_name": "remove-duplicates-from-an-unsorted-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution(object):\n    def deleteDuplicatesUnsorted(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        count = collections.defaultdict(int)\n        curr = head\n        while curr:\n            count[curr.val] += 1\n            curr = curr.next\n        curr = dummy = ListNode(0, head)\n        while curr.next:\n            if count[curr.next.val] == 1:\n                curr = curr.next\n            else:\n                curr.next = curr.next.next\n        return dummy.next\n"
    },
    {
        "problem_name": "remove-duplicates-from-sorted-array-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param a list of integers\n    # @return an integer\n    def removeDuplicates(self, A):\n        if not A:\n            return 0\n\n        last, i, same = 0, 1, False\n        while i < len(A):\n            if A[last] != A[i] or not same:\n                same = A[last] == A[i]\n                last += 1\n                A[last] = A[i]\n            i += 1\n\n        return last + 1\n\n"
    },
    {
        "problem_name": "remove-duplicates-from-sorted-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param a list of integers\n    # @return an integer\n    def removeDuplicates(self, A):\n        if not A:\n            return 0\n\n        last = 0\n        for i in xrange(len(A)):\n            if A[last] != A[i]:\n                last += 1\n                A[last] = A[i]\n        return last + 1\n\n"
    },
    {
        "problem_name": "remove-duplicates-from-sorted-list-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self is None:\n            return \"Nil\"\n        else:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        pre, cur = dummy, head\n        while cur:\n            if cur.next and cur.next.val == cur.val:\n                val = cur.val\n                while cur and cur.val == val:\n                    cur = cur.next\n                pre.next = cur\n            else:\n                pre.next = cur\n                pre = cur\n                cur = cur.next\n        return dummy.next\n\n"
    },
    {
        "problem_name": "remove-duplicates-from-sorted-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        cur = head\n        while cur:\n            runner = cur.next\n            while runner and runner.val == cur.val:\n                runner = runner.next\n            cur.next = runner\n            cur = runner\n        return head\n\n    def deleteDuplicates2(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head: return head\n        if head.next:\n            if head.val == head.next.val:\n                head = self.deleteDuplicates2(head.next)\n            else:\n                head.next = self.deleteDuplicates2(head.next)\n        return head\n\n\n"
    },
    {
        "problem_name": "remove-element",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param    A       a list of integers\n    # @param    elem    an integer, value need to be removed\n    # @return an integer\n    def removeElement(self, A, elem):\n        i, last = 0, len(A) - 1\n        while i <= last:\n            if A[i] == elem:\n                A[i], A[last] = A[last], A[i]\n                last -= 1\n            else:\n                i += 1\n        return last + 1\n\n"
    },
    {
        "problem_name": "remove-interval",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def removeInterval(self, intervals, toBeRemoved):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type toBeRemoved: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        A, B = toBeRemoved\n        return [[x, y] for a, b in intervals\n                for x, y in ((a, min(A, b)), (max(a, B), b))\n                if x < y]\n"
    },
    {
        "problem_name": "remove-invalid-parentheses",
        "solution": "# Time:  O(C(n, c)), try out all possible substrings with the minimum c deletion.\n# Space: O(c), the depth is at most c, and it costs n at each depth\n\nclass Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        # Calculate the minimum left and right parantheses to remove\n        def findMinRemove(s):\n            left_removed, right_removed = 0, 0\n            for c in s:\n                if c == '(':\n                    left_removed += 1\n                elif c == ')':\n                    if not left_removed:\n                        right_removed += 1\n                    else:\n                        left_removed -= 1\n            return (left_removed, right_removed)\n\n        # Check whether s is valid or not.\n        def isValid(s):\n            sum = 0\n            for c in s:\n                if c == '(':\n                    sum += 1\n                elif c == ')':\n                    sum -= 1\n                if sum < 0:\n                    return False\n            return sum == 0\n\n        def removeInvalidParenthesesHelper(start, left_removed, right_removed):\n            if left_removed == 0 and right_removed == 0:\n                tmp = \"\"\n                for i, c in enumerate(s):\n                    if i not in removed:\n                        tmp += c\n                if isValid(tmp):\n                    res.append(tmp)\n                return\n\n            for i in xrange(start, len(s)):\n                if right_removed == 0 and left_removed > 0 and s[i] == '(':\n                    if i == start or s[i] != s[i - 1]:  # Skip duplicated.\n                        removed[i] = True\n                        removeInvalidParenthesesHelper(i + 1, left_removed - 1, right_removed)\n                        del removed[i]\n                elif right_removed > 0 and s[i] == ')':\n                    if i == start or s[i] != s[i - 1]:  # Skip duplicated.\n                        removed[i] = True\n                        removeInvalidParenthesesHelper(i + 1, left_removed, right_removed - 1)\n                        del removed[i]\n\n        res, removed = [], {}\n        (left_removed, right_removed) = findMinRemove(s)\n        removeInvalidParenthesesHelper(0, left_removed, right_removed)\n        return res\n\n"
    },
    {
        "problem_name": "remove-k-digits",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def removeKdigits(self, num, k):\n        \"\"\"\n        :type num: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        result = []\n        for d in num:\n            while k and result and result[-1] > d:\n                result.pop()\n                k -= 1\n            result.append(d)\n        return ''.join(result).lstrip('0')[:-k or None] or '0'\n\n"
    },
    {
        "problem_name": "remove-letter-to-equalize-frequency",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\n# freq table, edge cases\nclass Solution(object):\n    def equalFrequency(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        cnt = collections.Counter(collections.Counter(word).itervalues())\n        if len(cnt) > 2:\n            return False\n        if len(cnt) == 1:\n            a = cnt.keys()[0]\n            return a == 1 or cnt[a] == 1\n        a, b = cnt.keys()\n        if a > b:\n            a, b = b, a\n        return (a == 1 and cnt[a] == 1) or (a+1 == b and cnt[b] == 1)\n\n\n# Time:  O(26 * n)\n# Space: O(1)\nimport collections\n\n\n# brute force, freq table\nclass Solution2(object):\n    def equalFrequency(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        cnt = collections.Counter(collections.Counter(word))\n        for c in word:\n            cnt[c] -= 1\n            if len(collections.Counter(c for c in cnt.itervalues() if c)) == 1:\n                return True\n            cnt[c] += 1\n        return False\n"
    },
    {
        "problem_name": "remove-linked-list-elements",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    # @param {ListNode} head\n    # @param {integer} val\n    # @return {ListNode}\n    def removeElements(self, head, val):\n        dummy = ListNode(float(\"-inf\"))\n        dummy.next = head\n        prev, curr = dummy, dummy.next\n\n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n\n            curr = curr.next\n\n        return dummy.next\n\n\n\n"
    },
    {
        "problem_name": "remove-max-number-of-edges-to-keep-graph-fully-traversable",
        "solution": "# Time:  O(n + m * \u03b1(n)) ~= O(n + m)\n# Space: O(n)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[max(x_root, y_root)] = min(x_root, y_root)\n        self.count -= 1\n        return True\n\n\nclass Solution(object):\n    def maxNumEdgesToRemove(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result = 0\n        union_find_a, union_find_b = UnionFind(n), UnionFind(n)\n        for t, i, j in edges:\n            if t != 3:\n                continue\n            a = union_find_a.union_set(i-1, j-1)\n            b = union_find_b.union_set(i-1, j-1)\n            if not a and not b:\n                result += 1\n        for t, i, j in edges:\n            if t == 1:\n                if not union_find_a.union_set(i-1, j-1):\n                    result += 1\n            elif t == 2:\n                if not union_find_b.union_set(i-1, j-1):\n                    result += 1\n        return result if union_find_a.count == union_find_b.count == 1 else -1\n"
    },
    {
        "problem_name": "remove-nodes-from-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        pass\n\n\n# mono stack\nclass Solution(object):\n    def removeNodes(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        stk = []\n        while head:\n            while stk and stk[-1].val < head.val:\n                stk.pop()\n            if stk:\n                stk[-1].next = head\n            stk.append(head)\n            head = head.next\n        return stk[0]\n"
    },
    {
        "problem_name": "remove-nth-node-from-end-of-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self is None:\n            return \"Nil\"\n        else:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    # @return a ListNode\n    def removeNthFromEnd(self, head, n):\n        dummy = ListNode(-1)\n        dummy.next = head\n        slow, fast = dummy, dummy\n\n        for i in xrange(n):\n            fast = fast.next\n\n        while fast.next:\n            slow, fast = slow.next, fast.next\n\n        slow.next = slow.next.next\n\n        return dummy.next\n\n"
    },
    {
        "problem_name": "remove-one-element-to-make-the-array-strictly-increasing",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def canBeIncreasing(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        deleted = False\n        for i in xrange(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                continue\n            if deleted:\n                return False\n            deleted = True\n            if i >= 2 and nums[i-2] > nums[i]:  # delete nums[i] or nums[i-1]\n                nums[i] = nums[i-1]\n        return True\n"
    },
    {
        "problem_name": "remove-outermost-parentheses",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def removeOuterParentheses(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        deep = 1\n        result, cnt = [], 0\n        for c in S:\n            if c == '(' and cnt >= deep:\n                result.append(c)\n            if c == ')' and cnt > deep:\n                result.append(c)\n            cnt += 1 if c == '(' else -1\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "remove-palindromic-subsequences",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def removePalindromeSub(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def is_palindrome(s):\n            for i in xrange(len(s)//2):\n                if s[i] != s[-1-i]:\n                    return False\n            return True\n        \n        return 2 - is_palindrome(s) - (s == \"\")\n"
    },
    {
        "problem_name": "remove-stones-to-minimize-the-total",
        "solution": "# Time:  O(n + klogn)\n# Space: O(1)\n\nimport heapq\n\n\nclass Solution(object):\n    def minStoneSum(self, piles, k):\n        \"\"\"\n        :type piles: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for i, x in enumerate(piles):\n            piles[i] = -x\n        heapq.heapify(piles)\n        for i in xrange(k):\n            heapq.heappush(piles, heapq.heappop(piles)//2)\n        return -sum(piles)\n"
    },
    {
        "problem_name": "remove-sub-folders-from-the-filesystem",
        "solution": "# Time:  O(n), n is the total sum of the lengths of folder names\n# Space: O(t), t is the number of nodes in trie\n\nimport collections\nimport itertools\n\n\nclass Solution(object):\n    def removeSubfolders(self, folder):\n        \"\"\"\n        :type folder: List[str]\n        :rtype: List[str]\n        \"\"\"\n        def dfs(curr, path, result):\n            if \"_end\" in curr:\n                result.append(\"/\" + \"/\".join(path))\n                return\n            for c in curr:\n                if c == \"_end\":\n                    continue\n                path.append(c)\n                dfs(curr[c], path, result)\n                path.pop()\n\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        for f in folder:\n            f_list = f.split(\"/\")\n            reduce(dict.__getitem__,\n                   itertools.islice(f_list, 1, len(f_list)),\n                   trie).setdefault(\"_end\")\n        result = []\n        dfs(trie, [], result)\n        return result\n  \n"
    },
    {
        "problem_name": "remove-trailing-zeros-from-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def removeTrailingZeros(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        return num[:next(i for i in reversed(xrange(len(num))) if num[i] != '0')+1]\n"
    },
    {
        "problem_name": "remove-vowels-from-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def removeVowels(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        lookup = set(\"aeiou\")\n        return \"\".join(c for c in S if c not in lookup)\n"
    },
    {
        "problem_name": "remove-zero-sum-consecutive-nodes-from-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution(object):\n    def removeZeroSumSublists(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        curr = dummy = ListNode(0)\n        dummy.next = head\n        prefix = 0\n        lookup = collections.OrderedDict()\n        while curr:\n            prefix += curr.val\n            node = lookup.get(prefix, curr)\n            while prefix in lookup:\n                lookup.popitem()\n            lookup[prefix] = node\n            node.next = curr.next\n            curr = curr.next\n        return dummy.next\n"
    },
    {
        "problem_name": "removing-minimum-and-maximum-from-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minimumDeletions(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        i, j = nums.index(min(nums)), nums.index(max(nums))\n        if i > j:\n            i, j = j, i\n        return min((i+1)+(len(nums)-j), j+1, len(nums)-i)\n"
    },
    {
        "problem_name": "removing-minimum-number-of-magic-beans",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def minimumRemoval(self, beans):\n        \"\"\"\n        :type beans: List[int]\n        :rtype: int\n        \"\"\"\n        beans.sort()\n        return sum(beans) - max(x*(len(beans)-i)for i, x in enumerate(beans))\n"
    },
    {
        "problem_name": "removing-stars-from-a-string",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# stack\nclass Solution(object):\n    def removeStars(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        result = []\n        for c in s:\n            if c == '*':\n                result.pop()\n            else:\n                result.append(c)\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "reorder-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    # @param head, a ListNode\n    # @return nothing\n    def reorderList(self, head):\n        if head == None or head.next == None:\n            return head\n\n        fast, slow, prev = head, head, None\n        while fast != None and fast.next != None:\n            fast, slow, prev = fast.next.next, slow.next, slow\n        current, prev.next, prev = slow, None, None\n\n        while current != None:\n            current.next, prev, current = prev, current, current.next\n\n        l1, l2 = head, prev\n        dummy = ListNode(0)\n        current = dummy\n\n        while l1 != None and l2 != None:\n            current.next, current, l1 = l1, l1, l1.next\n            current.next, current, l2 = l2, l2, l2.next\n\n        return dummy.next\n\n"
    },
    {
        "problem_name": "reorder-log-files",
        "solution": "# Time:  O(nlogn * l), n is the length of files, l is the average length of strings\n# Space: O(l)\n\nclass Solution(object):\n    def reorderLogFiles(self, logs):\n        \"\"\"\n        :type logs: List[str]\n        :rtype: List[str]\n        \"\"\"\n        def f(log):\n            i, content = log.split(\" \", 1)\n            return (0, content, i) if content[0].isalpha() else (1,)\n\n        logs.sort(key=f)\n        return logs\n"
    },
    {
        "problem_name": "reorder-routes-to-make-all-paths-lead-to-the-city-zero",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def minReorder(self, n, connections):\n        \"\"\"\n        :type n: int\n        :type connections: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup, graph = set(), collections.defaultdict(list)\n        for u, v in connections:\n            lookup.add(u*n+v)\n            graph[v].append(u)\n            graph[u].append(v) \n        result = 0\n        stk = [(-1, 0)]\n        while stk:\n            parent, u = stk.pop()\n            result += (parent*n+u in lookup)\n            for v in reversed(graph[u]):\n                if v == parent:\n                    continue\n                stk.append((u, v))\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\nimport collections\n\n\nclass Solution2(object):\n    def minReorder(self, n, connections):\n        \"\"\"\n        :type n: int\n        :type connections: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def dfs(n, lookup, graph, parent, u):\n            result = (parent*n+u in lookup)\n            for v in graph[u]:\n                if v == parent:\n                    continue\n                result += dfs(n, lookup, graph, u, v)  \n            return result\n\n        lookup, graph = set(), collections.defaultdict(list)\n        for u, v in connections:\n            lookup.add(u*n+v)\n            graph[v].append(u)\n            graph[u].append(v) \n        return dfs(n, lookup, graph, -1, 0)\n"
    },
    {
        "problem_name": "reordered-power-of-2",
        "solution": "# Time:  O((logn)^2) = O(1) due to n is a 32-bit number\n# Space: O(logn) = O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def reorderedPowerOf2(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: bool\n        \"\"\"\n        count = collections.Counter(str(N))\n        return any(count == collections.Counter(str(1 << i))\n                   for i in xrange(31))\n\n"
    },
    {
        "problem_name": "reorganize-string",
        "solution": "# Time:  O(nloga) = O(n), a is the size of alphabet\n# Space: O(a) = O(1)\n\nimport collections\nimport heapq\n\n\nclass Solution(object):\n    def reorganizeString(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        counts = collections.Counter(S)\n        if any(v > (len(S)+1)/2 for k, v in counts.iteritems()):\n            return \"\"\n\n        result = []\n        max_heap = []\n        for k, v in counts.iteritems():\n            heapq.heappush(max_heap, (-v, k))\n        while len(max_heap) > 1:\n            count1, c1 = heapq.heappop(max_heap)\n            count2, c2 = heapq.heappop(max_heap)\n            if not result or c1 != result[-1]:\n                result.extend([c1, c2])\n                if count1+1: heapq.heappush(max_heap, (count1+1, c1))\n                if count2+1: heapq.heappush(max_heap, (count2+1, c2))\n        return \"\".join(result) + (max_heap[0][1] if max_heap else '')\n\n"
    },
    {
        "problem_name": "repeated-dna-sequences",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\nclass Solution(object):\n    def findRepeatedDnaSequences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        dict, rolling_hash, res = {}, 0, []\n\n        for i in xrange(len(s)):\n            rolling_hash = ((rolling_hash << 3) & 0x3fffffff) | (ord(s[i]) & 7)\n            if rolling_hash not in dict:\n                dict[rolling_hash] = True\n            elif dict[rolling_hash]:\n                res.append(s[i - 9: i + 1])\n                dict[rolling_hash] = False\n        return res\n\n    def findRepeatedDnaSequences2(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        l, r = [], []\n        if len(s) < 10: return []\n        for i in range(len(s) - 9):\n            l.extend([s[i:i + 10]])\n        return [k for k, v in collections.Counter(l).items() if v > 1]\n\n\n"
    },
    {
        "problem_name": "repeated-string-match",
        "solution": "# Time:  O(n + m)\n# Space: O(1)\n\nclass Solution(object):\n    def repeatedStringMatch(self, A, B):\n        \"\"\"\n        :type A: str\n        :type B: str\n        :rtype: int\n        \"\"\"\n        def check(index):\n            return all(A[(i+index) % len(A)] == c\n                       for i, c in enumerate(B))\n\n        M, p = 10**9+7, 113\n        p_inv = pow(p, M-2, M)\n        q = (len(B)+len(A)-1) // len(A)\n\n        b_hash, power = 0, 1\n        for c in B:\n            b_hash += power * ord(c)\n            b_hash %= M\n            power = (power*p) % M\n\n        a_hash, power = 0, 1\n        for i in xrange(len(B)):\n            a_hash += power * ord(A[i%len(A)])\n            a_hash %= M\n            power = (power*p) % M\n\n        if a_hash == b_hash and check(0): return q\n\n        power = (power*p_inv) % M\n        for i in xrange(len(B), (q+1)*len(A)):\n            a_hash = (a_hash-ord(A[(i-len(B))%len(A)])) * p_inv\n            a_hash += power * ord(A[i%len(A)])\n            a_hash %= M\n            if a_hash == b_hash and check(i-len(B)+1):\n                return q if i < q*len(A) else q+1\n\n        return -1\n\n"
    },
    {
        "problem_name": "repeated-substring-pattern",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def repeatedSubstringPattern(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: bool\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1] * len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j > -1 and pattern[j + 1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j + 1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        prefix = getPrefix(str)\n        return prefix[-1] != -1 and \\\n               (prefix[-1] + 1) % (len(str) - prefix[-1] - 1) == 0\n\n    def repeatedSubstringPattern2(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: bool\n        \"\"\"\n        if not str:\n            return False\n\n        ss = (str + str)[1:-1]\n        return ss.find(str) != -1\n\n"
    },
    {
        "problem_name": "replace-all-digits-with-characters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def replaceDigits(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        return \"\".join(chr(ord(s[i-1])+int(s[i])) if i%2 else s[i] for i in xrange(len(s)))\n"
    },
    {
        "problem_name": "replace-all-s-to-avoid-consecutive-repeating-characters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def modifyString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        s = list(s)\n        for i in xrange(len(s)):\n            if s[i] != '?':\n                continue\n            for c in ('a', 'b', 'c'):\n                if (i == 0 or s[i-1] != c) and (i == len(s)-1 or c != s[i+1]):\n                    break\n            s[i] = c\n        return \"\".join(s)\n"
    },
    {
        "problem_name": "replace-elements-in-an-array",
        "solution": "# Time:  O(n + m)\n# Space: O(n)\n\n# hash table, optimized from solution2\nclass Solution(object):\n    def arrayChange(self, nums, operations):\n        \"\"\"\n        :type nums: List[int]\n        :type operations: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        lookup = {x:i for i, x in enumerate(nums)}\n        for x, y in operations:\n            lookup[y] = lookup.pop(x)\n        for x, i in lookup.iteritems():\n            nums[i] = x\n        return nums\n\n\n# Time:  O(n + m)\n# Space: O(n)\n# hash table\nclass Solution2(object):\n    def arrayChange(self, nums, operations):\n        \"\"\"\n        :type nums: List[int]\n        :type operations: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        lookup = {x:i for i, x in enumerate(nums)}\n        for x, y in operations:\n            nums[lookup[x]] = y\n            lookup[y] = lookup.pop(x)\n        return nums\n"
    },
    {
        "problem_name": "replace-elements-with-greatest-element-on-right-side",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def replaceElements(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        curr_max = -1\n        for i in reversed(xrange(len(arr))):\n            arr[i], curr_max = curr_max, max(curr_max, arr[i])\n        return arr\n"
    },
    {
        "problem_name": "replace-non-coprime-numbers-in-array",
        "solution": "# Time:  O(nlogm), m is the max of nums\n# Space: O(1)\n\n# math, stack\nclass Solution(object):\n    def replaceNonCoprimes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def gcd(a, b):  # Time: O(log(min(a, b)))\n            while b:\n                a, b = b, a%b\n            return a\n\n        result = []\n        for x in nums:\n            while True:\n                g = gcd(result[-1] if result else 1, x)\n                if g == 1:\n                    break\n                x *= result.pop()//g\n            result.append(x)\n        return result\n"
    },
    {
        "problem_name": "replace-question-marks-in-string-to-minimize-its-value",
        "solution": "# Time:  O(n + 26 * log(26))\n# Space: O(26)\n\n# greedy, counting sort, prefix sum\nclass Solution(object):\n    def minimizeStringValue(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def counting_sort(cnt):\n            for i in xrange(len(cnt)):\n                for _ in xrange(cnt[i]):\n                    yield i\n        \n        def fill(cnt):\n            result = [0]*26\n            a = [(x, i) for i, x in enumerate(cnt)]\n            a.sort()\n            total = s.count('?')\n            curr = 0\n            for i in xrange(len(a)-1):\n                if curr+(a[i+1][0]-a[i][0])*(i+1) > total:\n                    break\n                curr += (a[i+1][0]-a[i][0])*(i+1)\n            else:\n                i = len(a)-1\n            q, r = divmod(total-curr, i+1)\n            for j in xrange(i+1):\n                result[a[j][1]] = (a[i][0]-a[j][0])+q\n            cnt2 = [0]*26\n            for j in xrange(i+1):\n                cnt2[a[j][1]] += 1\n            it = counting_sort(cnt2)\n            for _ in xrange(r):\n                result[next(it)] += 1\n            return result\n    \n        cnt = [0]*26\n        for x in s:\n            if x == '?':\n                continue\n            cnt[ord(x)-ord('a')] += 1\n        it = counting_sort(fill(cnt))\n        result = list(s)\n        for i in xrange(len(result)):\n            if result[i] != '?':\n                continue\n            result[i] = chr(ord('a')+next(it))\n        return \"\".join(result)\n\n\n# Time:  O(n + n * log(26))\n# Space: O(26)\nimport heapq\n\n\n# greedy, counting sort, heap\nclass Solution2(object):\n    def minimizeStringValue(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def counting_sort(cnt):\n            for i in xrange(len(cnt)):\n                for _ in xrange(cnt[i]):\n                    yield i\n\n        cnt = [0]*26\n        for x in s:\n            if x == '?':\n                continue\n            cnt[ord(x)-ord('a')] += 1\n        min_heap = [(x, i) for i, x in enumerate(cnt)]\n        heapq.heapify(min_heap)\n        cnt2 = [0]*26\n        for _ in xrange(s.count('?')):\n            c, i = heapq.heappop(min_heap)\n            heapq.heappush(min_heap, (c+1, i))\n            cnt2[i] += 1\n        it = counting_sort(cnt2)\n        result = list(s)\n        for i in xrange(len(result)):\n            if result[i] != '?':\n                continue\n            result[i] = chr(ord('a')+next(it))\n        return \"\".join(result)\n\n\n# Time:  O(n + n * 26)\n# Space: O(26)\n# greedy, counting sort\nclass Solution3(object):\n    def minimizeStringValue(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def counting_sort(cnt):\n            for i in xrange(len(cnt)):\n                for _ in xrange(cnt[i]):\n                    yield i\n    \n        cnt = [0]*26\n        for x in s:\n            if x == '?':\n                continue\n            cnt[ord(x)-ord('a')] += 1\n        cnt2 = [0]*26\n        for _ in xrange(s.count('?')):\n            i = min(xrange(len(cnt)), key=lambda x: cnt[x]+cnt2[x])\n            cnt2[i] += 1\n        it = counting_sort(cnt2)\n        result = list(s)\n        for i in xrange(len(result)):\n            if result[i] != '?':\n                continue\n            result[i] = chr(ord('a')+next(it))\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "replace-the-substring-for-balanced-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def balancedString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        count = collections.Counter(s)\n        result = len(s) \n        left = 0\n        for right in xrange(len(s)):\n            count[s[right]] -= 1\n            while left < len(s) and \\\n                  all(v <= len(s)//4 for v in count.itervalues()):\n                result = min(result, right-left+1)\n                count[s[left]] += 1\n                left += 1\n        return result\n"
    },
    {
        "problem_name": "replace-words",
        "solution": "# Time:  O(n)\n# Space: O(t), t is the number of nodes in trie\n\nimport collections\n\n\nclass Solution(object):\n    def replaceWords(self, dictionary, sentence):\n        \"\"\"\n        :type dictionary: List[str]\n        :type sentence: str\n        :rtype: str\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        for word in dictionary:\n            reduce(dict.__getitem__, word, trie).setdefault(\"_end\")\n\n        def replace(word):\n            curr = trie\n            for i, c in enumerate(word):\n                if c not in curr:\n                    break\n                curr = curr[c]\n                if \"_end\" in curr:\n                    return word[:i+1]\n            return word\n\n        return \" \".join(map(replace, sentence.split()))\n\n"
    },
    {
        "problem_name": "reshape-the-matrix",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nclass Solution(object):\n    def matrixReshape(self, nums, r, c):\n        \"\"\"\n        :type nums: List[List[int]]\n        :type r: int\n        :type c: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums or \\\n           r*c != len(nums) * len(nums[0]):\n            return nums\n\n        result = [[0 for _ in xrange(c)] for _ in xrange(r)]\n        count = 0\n        for i in xrange(len(nums)):\n            for j in xrange(len(nums[0])):\n                result[count/c][count%c] = nums[i][j]\n                count += 1\n        return result\n\n"
    },
    {
        "problem_name": "restore-ip-addresses",
        "solution": "# Time:  O(n^m) = O(3^4)\n# Space: O(n * m) = O(3 * 4)\n\nclass Solution(object):\n    # @param s, a string\n    # @return a list of strings\n    def restoreIpAddresses(self, s):\n        result = []\n        self.restoreIpAddressesRecur(result, s, 0, \"\", 0)\n        return result\n\n    def restoreIpAddressesRecur(self, result, s, start, current, dots):\n        # pruning to improve performance\n        if (4 - dots) * 3 < len(s) - start or (4 - dots) > len(s) - start:\n            return\n\n        if start == len(s) and dots == 4:\n            result.append(current[:-1])\n        else:\n            for i in xrange(start, start + 3):\n                if len(s) > i and self.isValid(s[start:i + 1]):\n                    current += s[start:i + 1] + '.'\n                    self.restoreIpAddressesRecur(result, s, i + 1, current, dots + 1)\n                    current = current[:-(i - start + 2)]\n\n    def isValid(self, s):\n        if len(s) == 0 or (s[0] == '0' and s != \"0\"):\n            return False\n        return int(s) < 256\n\n"
    },
    {
        "problem_name": "restore-the-array-from-adjacent-pairs",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def restoreArray(self, adjacentPairs):\n        \"\"\"\n        :type adjacentPairs: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        for u, v in adjacentPairs: \n            adj[u].append(v)\n            adj[v].append(u)\n        result = next([x, adj[x][0]] for x in adj if len(adj[x]) == 1)\n        while len(result) != len(adjacentPairs)+1:\n            result.append(adj[result[-1]][adj[result[-1]][0] == result[-2]])\n        return result\n"
    },
    {
        "problem_name": "restore-the-array",
        "solution": "# Time:  O(nlogk)\n# Space: O(logk)\n\nclass Solution(object):\n    def numberOfArrays(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        klen = len(str(k))\n        dp = [0]*(klen+1)\n        dp[len(s)%len(dp)] = 1\n        for i in reversed(xrange(len(s))):\n            dp[i%len(dp)] = 0\n            if s[i] == '0':\n                continue\n            curr = 0\n            for j in xrange(i, min(i+klen, len(s))):\n                curr = 10*curr + int(s[j])\n                if curr > k:\n                    break\n                dp[i%len(dp)] = (dp[i%len(dp)] + dp[(j+1)%len(dp)])%MOD\n        return dp[0]\n"
    },
    {
        "problem_name": "reveal-cards-in-increasing-order",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def deckRevealedIncreasing(self, deck):\n        \"\"\"\n        :type deck: List[int]\n        :rtype: List[int]\n        \"\"\"\n        d = collections.deque()\n        deck.sort(reverse=True)\n        for i in deck:\n            if d:\n                d.appendleft(d.pop())\n            d.appendleft(i)\n        return list(d)\n"
    },
    {
        "problem_name": "reverse-bits",
        "solution": "# Time : O(32)\n# Space: O(1)\n\nclass Solution(object):\n    # @param n, an integer\n    # @return an integer\n    def reverseBits(self, n):\n        n = (n >> 16) | (n << 16)\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8)\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4)\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2)\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1)\n        return n\n\n\n# Time : O(logn) = O(32)\n# Space: O(1)\nclass Solution2(object):\n    # @param n, an integer\n    # @return an integer\n    def reverseBits(self, n):\n        result = 0\n        for i in xrange(32):\n            result <<= 1\n            result |= n & 1\n            n >>= 1\n        return result\n\n"
    },
    {
        "problem_name": "reverse-integer",
        "solution": "# Time:  O(logn) = O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            return -self.reverse(-x)\n\n        result = 0\n        while x:\n            result = result * 10 + x % 10\n            x //= 10\n        return result if result <= 0x7fffffff else 0  # Handle overflow.\n\n    def reverse2(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            x = int(str(x)[::-1][-1] + str(x)[::-1][:-1])\n        else:\n            x = int(str(x)[::-1])\n        x = 0 if abs(x) > 0x7FFFFFFF else x\n        return x\n\n    def reverse3(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        s = cmp(x, 0)\n        r = int(repr(s * x)[::-1])\n        return s * r * (r < 2 ** 31)\n\n\n"
    },
    {
        "problem_name": "reverse-linked-list-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\nclass Solution(object):\n    # @param head, a ListNode\n    # @param m, an integer\n    # @param n, an integer\n    # @return a ListNode\n    def reverseBetween(self, head, m, n):\n        diff, dummy, cur = n - m + 1, ListNode(-1), head\n        dummy.next = head\n\n        last_unswapped = dummy\n        while cur and m > 1:\n            cur, last_unswapped, m = cur.next, cur, m - 1\n\n        prev, first_swapped = last_unswapped,  cur\n        while cur and diff > 0:\n            cur.next, prev, cur, diff = prev, cur, cur.next, diff - 1\n\n        last_unswapped.next, first_swapped.next = prev, cur\n\n        return dummy.next\n\n"
    },
    {
        "problem_name": "reverse-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\n# Iterative solution.\nclass Solution(object):\n    # @param {ListNode} head\n    # @return {ListNode}\n    def reverseList(self, head):\n        dummy = ListNode(float(\"-inf\"))\n        while head:\n            dummy.next, head.next, head = head, dummy.next, head.next\n        return dummy.next\n\n# Time:  O(n)\n# Space: O(n)\n# Recursive solution.\nclass Solution2(object):\n    # @param {ListNode} head\n    # @return {ListNode}\n    def reverseList(self, head):\n        [begin, end] = self.reverseListRecu(head)\n        return begin\n\n    def reverseListRecu(self, head):\n        if not head:\n            return [None, None]\n\n        [begin, end] = self.reverseListRecu(head.next)\n\n        if end:\n            end.next = head\n            head.next = None\n            return [begin, head]\n        else:\n            return [head, head]\n\n"
    },
    {
        "problem_name": "reverse-nodes-in-even-length-groups",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution(object):\n    def reverseEvenLengthGroups(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        prev, l = head, 2\n        while prev.next:\n            curr, cnt = prev, 0\n            for _ in xrange(l):\n                if not curr.next:\n                    break\n                cnt += 1\n                curr = curr.next\n            l += 1\n            if cnt%2:\n                prev = curr\n                continue\n            curr, last = prev.next, None\n            for _ in xrange(cnt):\n                curr.next, curr, last = last, curr.next, curr\n            prev.next.next, prev.next, prev = curr, last, prev.next\n        return head\n"
    },
    {
        "problem_name": "reverse-nodes-in-k-group",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    # @param head, a ListNode\n    # @param k, an integer\n    # @return a ListNode\n    def reverseKGroup(self, head, k):\n        dummy = ListNode(-1)\n        dummy.next = head\n\n        cur, cur_dummy = head, dummy\n        length = 0\n\n        while cur:\n            next_cur = cur.next\n            length = (length + 1) % k\n\n            if length == 0:\n                next_dummy = cur_dummy.next\n                self.reverse(cur_dummy, cur.next)\n                cur_dummy = next_dummy\n\n            cur = next_cur\n\n        return dummy.next\n\n    def reverse(self, begin, end):\n            first = begin.next\n            cur = first.next\n\n            while cur != end:\n                first.next = cur.next\n                cur.next = begin.next\n                begin.next = cur\n                cur = first.next\n\n"
    },
    {
        "problem_name": "reverse-odd-levels-of-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\n# bfs\nclass Solution(object):\n    def reverseOddLevels(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        q = [root]\n        parity = 0\n        while q:\n            if parity:\n                left, right = 0, len(q)-1\n                while left < right:\n                    q[left].val, q[right].val = q[right].val, q[left].val\n                    left += 1\n                    right -= 1\n            if not q[0].left:\n                break\n            new_q = []\n            for node in q:\n                new_q.append(node.left)\n                new_q.append(node.right)\n            q = new_q       \n            parity ^= 1\n        return root\n"
    },
    {
        "problem_name": "reverse-only-letters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def reverseOnlyLetters(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        def getNext(S):\n            for i in reversed(xrange(len(S))):\n                if S[i].isalpha():\n                    yield S[i]\n\n        result = []\n        letter = getNext(S)\n        for i in xrange(len(S)):\n            if S[i].isalpha():\n                result.append(letter.next())\n            else:\n                result.append(S[i])\n        return \"\".join(result)\n\n"
    },
    {
        "problem_name": "reverse-pairs",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def merge(nums, start, mid, end):\n            r = mid + 1\n            tmp = []\n            for i in xrange(start, mid + 1):\n                while r <= end and nums[i] > nums[r]:\n                    tmp.append(nums[r])\n                    r += 1\n                tmp.append(nums[i])\n            nums[start:start+len(tmp)] = tmp\n\n        def countAndMergeSort(nums, start, end):\n            if end - start <= 0:\n                return 0\n\n            mid = start + (end - start) / 2\n            count = countAndMergeSort(nums, start, mid) + countAndMergeSort(nums, mid + 1, end)\n            r = mid + 1\n            for i in xrange(start, mid + 1):\n                while r <= end and nums[i] > nums[r] * 2:\n                    r += 1\n                count += r - (mid + 1)\n            merge(nums, start, mid, end)\n            return count\n\n        return countAndMergeSort(nums, 0, len(nums) - 1)\n\n"
    },
    {
        "problem_name": "reverse-prefix-of-word",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def reversePrefix(self, word, ch):\n        \"\"\"\n        :type word: str\n        :type ch: str\n        :rtype: str\n        \"\"\"\n        i = word.find(ch)\n        return word[:i+1][::-1]+word[i+1:]\n"
    },
    {
        "problem_name": "reverse-string-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def reverseStr(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        s = list(s)\n        for i in xrange(0, len(s), 2*k):\n            s[i:i+k] = reversed(s[i:i+k])\n        return \"\".join(s)\n\n"
    },
    {
        "problem_name": "reverse-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        i, j = 0, len(s) - 1\n        while i < j:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n"
    },
    {
        "problem_name": "reverse-subarray-to-maximize-array-value",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxValueAfterReverse(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result, add, max_pair, min_pair = 0, 0, float(\"-inf\"), float(\"inf\")\n        for i in xrange(1, len(nums)):\n            result += abs(nums[i-1]-nums[i])\n            add = max(add,\n                      abs(nums[0]-nums[i]) - abs(nums[i-1]-nums[i]),\n                      abs(nums[-1]-nums[i-1]) - abs(nums[i-1]-nums[i]))\n            min_pair = min(min_pair, max(nums[i-1], nums[i]))\n            max_pair = max(max_pair, min(nums[i-1], nums[i]))\n        return result + max(add, (max_pair-min_pair)*2)\n"
    },
    {
        "problem_name": "reverse-substrings-between-each-pair-of-parentheses",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def reverseParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stk, lookup = [], {}\n        for i, c in enumerate(s):\n            if c == '(':\n                stk.append(i)\n            elif c == ')':\n                j = stk.pop()\n                lookup[i], lookup[j] = j, i\n        result = []\n        i, d = 0, 1\n        while i < len(s):\n            if i in lookup:\n                i = lookup[i]\n                d *= -1\n            else:\n                result.append(s[i])\n            i += d\n        return \"\".join(result)\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution2(object):\n    def reverseParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stk = [[]]\n        for c in s:\n            if c == '(':\n                stk.append([])\n            elif c == ')':\n                end = stk.pop()\n                end.reverse()\n                stk[-1].extend(end)\n            else:\n                stk[-1].append(c)\n        return \"\".join(stk.pop())\n"
    },
    {
        "problem_name": "reverse-vowels-of-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        vowels = \"aeiou\"\n        string = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            if string[i].lower() not in vowels:\n                i += 1\n            elif string[j].lower() not in vowels:\n                j -= 1\n            else:\n                string[i], string[j] = string[j], string[i]\n                i += 1\n                j -= 1\n        return \"\".join(string)\n\n"
    },
    {
        "problem_name": "reverse-words-in-a-string-ii",
        "solution": "# Time: O(n)\n# Space:O(1)\n\nclass Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: a list of 1 length strings (List[str])\n        :rtype: nothing\n        \"\"\"\n        def reverse(s, begin, end):\n            for i in xrange((end - begin) / 2):\n                s[begin + i], s[end - 1 - i] = s[end - 1 - i], s[begin + i]\n\n        reverse(s, 0, len(s))\n        i = 0\n        for j in xrange(len(s) + 1):\n            if j == len(s) or s[j] == ' ':\n                reverse(s, i, j)\n                i = j + 1\n\n\n"
    },
    {
        "problem_name": "reverse-words-in-a-string-iii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def reverse(s, begin, end):\n            for i in xrange((end - begin) // 2):\n                s[begin + i], s[end - 1 - i] = s[end - 1 - i], s[begin + i]\n\n        s, i = list(s), 0\n        for j in xrange(len(s) + 1):\n            if j == len(s) or s[j] == ' ':\n                reverse(s, i, j)\n                i = j + 1\n        return \"\".join(s)\n\n\nclass Solution2(object):\n    def reverseWords(self, s):\n        reversed_words = [word[::-1] for word in s.split(' ')]\n        return ' '.join(reversed_words)\n\n"
    },
    {
        "problem_name": "reverse-words-in-a-string",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    # @param s, a string\n    # @return a string\n    def reverseWords(self, s):\n        return ' '.join(reversed(s.split()))\n\n"
    },
    {
        "problem_name": "reward-top-k-students",
        "solution": "# Time:  O(pf * l + nf * l + n * l + klogk)\n# Space: O(pf * l + nf * l + n)\n\nimport random\nimport itertools\n\n\n# quick select, partial sort\nclass Solution(object):\n    def topStudents(self, positive_feedback, negative_feedback, report, student_id, k):\n        \"\"\"\n        :type positive_feedback: List[str]\n        :type negative_feedback: List[str]\n        :type report: List[str]\n        :type student_id: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        pos, neg = set(positive_feedback), set(negative_feedback)\n        arr = []\n        for i, r in itertools.izip(student_id, report):\n            score = sum(3 if w in pos else -1 if w in neg else 0 for w in r.split())\n            arr.append((-score, i))\n        nth_element(arr, k-1)\n        return [i for _, i in sorted(arr[:k])]\n"
    },
    {
        "problem_name": "richest-customer-wealth",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def maximumWealth(self, accounts):\n        \"\"\"\n        :type accounts: List[List[int]]\n        :rtype: int\n        \"\"\"\n        return max(itertools.imap(sum, accounts))\n"
    },
    {
        "problem_name": "right-triangles",
        "solution": "# Time:  O(n * m)\n# Space: O(min(n, m))\n\n# combinatorics\nclass Solution(object):\n    def numberOfRightTriangles(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def get(i, j):\n            return grid[i][j] if n < m else grid[j][i]\n\n        n, m = len(grid), len(grid[0])\n        result = 0\n        cnt1 = [sum(get(i, j) for j in xrange(max(n, m))) for i in xrange(min(n, m))]\n        for j in xrange(max(n, m)):\n            cnt2 = sum(get(i, j) for i in xrange(min(n, m)))\n            result += sum((cnt1[i]-1)*(cnt2-1) for i in xrange(min(n, m)) if get(i, j))\n        return result\n\n\n# Time:  O(n * m)\n# Space: O(n + m)\n# combinatorics\nclass Solution2(object):\n    def numberOfRightTriangles(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n, m = len(grid), len(grid[0])\n        cnt1 = [sum(grid[i][j] for j in xrange(m)) for i in xrange(n)]\n        cnt2 = [sum(grid[i][j] for i in xrange(n)) for j in xrange(m)]\n        return sum((cnt1[i]-1)*(cnt2[j]-1) for i in xrange(n) for j in xrange(m) if grid[i][j])\n\n\n# Time:  O(n * m)\n# Space: O(min(n, m))\n# freq table\nclass Solution3(object):\n    def numberOfRightTriangles(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def get(i, j):\n            return grid[i][j] if n < m else grid[j][i]\n\n        def count(direction):\n            result = 0\n            cnt = [0]*min(n, m)\n            for j in direction(xrange(max(n, m))):\n                c = sum(get(i, j) for i in xrange(len(cnt)))\n                for i in xrange(len(cnt)):\n                    if get(i, j) == 0:\n                        continue\n                    result += cnt[i]\n                    cnt[i] += c-1\n            return result\n        \n        n, m = len(grid), len(grid[0])\n        return count(lambda x: x)+count(reversed)\n"
    },
    {
        "problem_name": "rings-and-rods",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def countPoints(self, rings):\n        \"\"\"\n        :type rings: str\n        :rtype: int\n        \"\"\"\n        bits = {'R':0b001, 'G':0b010, 'B':0b100}\n        rods = collections.defaultdict(int)\n        for i in xrange(0, len(rings), 2):\n            rods[int(rings[i+1])] |= bits[rings[i]]\n        return sum(x == 0b111 for x in rods.itervalues())\n"
    },
    {
        "problem_name": "rle-iterator",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass RLEIterator(object):\n\n    def __init__(self, A):\n        \"\"\"\n        :type A: List[int]\n        \"\"\"\n        self.__A = A\n        self.__i = 0\n        self.__cnt = 0\n\n    def next(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        while self.__i < len(self.__A):\n            if  n > self.__A[self.__i] - self.__cnt:\n                n -= self.__A[self.__i] - self.__cnt\n                self.__cnt = 0\n                self.__i += 2\n            else:\n                self.__cnt += n\n                return self.__A[self.__i+1]\n        return -1\n\n\n\n"
    },
    {
        "problem_name": "robot-bounded-in-circle",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isRobotBounded(self, instructions):\n        \"\"\"\n        :type instructions: str\n        :rtype: bool\n        \"\"\"\n        directions = [[ 1, 0], [0, -1], [-1, 0], [0, 1]]\n        x, y, i = 0, 0, 0\n        for instruction in instructions:\n            if instruction == 'R':\n                i = (i+1) % 4;\n            elif instruction == 'L':\n                i = (i-1) % 4;\n            else:\n                x += directions[i][0]\n                y += directions[i][1]\n        return (x == 0 and y == 0) or i > 0\n"
    },
    {
        "problem_name": "robot-collisions",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# sort, simulation, stack\nclass Solution(object):\n    def survivedRobotsHealths(self, positions, healths, directions):\n        \"\"\"\n        :type positions: List[int]\n        :type healths: List[int]\n        :type directions: str\n        :rtype: List[int]\n        \"\"\"\n        stk = []\n        for i in sorted(xrange(len(positions)), key=lambda x:positions[x]):\n            if directions[i] == 'R':\n                stk.append(i)\n                continue\n            while stk:\n                if healths[stk[-1]] == healths[i]:\n                    healths[stk.pop()] = healths[i] = 0\n                    break\n                if healths[stk[-1]] > healths[i]:\n                    healths[i] = 0\n                    healths[stk[-1]] -= 1\n                    break                \n                healths[stk.pop()] = 0\n                healths[i] -= 1\n        return [x for x in healths if x]\n"
    },
    {
        "problem_name": "robot-return-to-origin",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def judgeCircle(self, moves):\n        \"\"\"\n        :type moves: str\n        :rtype: bool\n        \"\"\"\n        count = collections.Counter(moves)\n        return count['L'] == count['R'] and count['U'] == count['D']\n\n \n# Time:  O(n)\n# Space: O(1)\nclass Solution(object):\n    def judgeCircle(self, moves):\n        \"\"\"\n        :type moves: str\n        :rtype: bool\n        \"\"\"\n        v, h = 0, 0\n        for move in moves:\n            if move == 'U':\n                v += 1\n            elif move == 'D':\n                v -= 1\n            elif move == 'R':\n                h += 1\n            elif move == 'L':\n                h -= 1\n        return v == 0 and h == 0\n"
    },
    {
        "problem_name": "robot-room-cleaner",
        "solution": "# Time:  O(n), n is the number of cells\n# Space: O(n)\n\nclass Solution(object):\n    def cleanRoom(self, robot):\n        \"\"\"\n        :type robot: Robot\n        :rtype: None\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def goBack(robot):\n            robot.turnLeft()\n            robot.turnLeft()\n            robot.move()\n            robot.turnRight()\n            robot.turnRight()\n\n        def dfs(pos, robot, d, lookup):\n            robot.clean()\n            for _ in directions:\n                new_pos = (pos[0]+directions[d][0],\n                           pos[1]+directions[d][1])\n                if new_pos not in lookup:\n                    lookup.add(new_pos)\n                    if robot.move():\n                        dfs(new_pos, robot, d, lookup)\n                        goBack(robot)\n                robot.turnRight()\n                d = (d+1) % len(directions)\n        \n        dfs((0, 0), robot, 0, set())\n"
    },
    {
        "problem_name": "roman-to-integer",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @return an integer\n    def romanToInt(self, s):\n        numeral_map = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\":100, \"D\": 500, \"M\": 1000}\n        decimal = 0\n        for i in xrange(len(s)):\n            if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]:\n                decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]]\n            else:\n                decimal += numeral_map[s[i]]\n        return decimal\n\n"
    },
    {
        "problem_name": "root-equals-sum-of-children",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        pass\n\n\n# tree\nclass Solution(object):\n    def checkTree(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        return root.val == root.left.val+root.right.val\n"
    },
    {
        "problem_name": "rotate-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def rotate(self, nums, k):\n        def reverse(nums, start, end):\n            while start < end:\n                nums[start], nums[end - 1] = nums[end - 1], nums[start]\n                start += 1\n                end -= 1\n\n        k %= len(nums)\n        reverse(nums, 0, len(nums))\n        reverse(nums, 0, k)\n        reverse(nums, k, len(nums))\n\n\n# Time:  O(n)\n# Space: O(1)\nfrom fractions import gcd\n\n\nclass Solution2(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def rotate(self, nums, k):\n        def apply_cycle_permutation(k, offset, cycle_len, nums):\n            tmp = nums[offset]\n            for i in xrange(1, cycle_len):\n                nums[(offset + i * k) % len(nums)], tmp = tmp, nums[(offset + i * k) % len(nums)]\n            nums[offset] = tmp\n\n        k %= len(nums)\n        num_cycles = gcd(len(nums), k)\n        cycle_len = len(nums) / num_cycles\n        for i in xrange(num_cycles):\n            apply_cycle_permutation(k, i, cycle_len, nums)\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution3(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def rotate(self, nums, k):\n        count = 0\n        start = 0\n        while count < len(nums):\n            curr = start\n            prev = nums[curr]\n            while True:\n                idx = (curr + k) % len(nums)\n                nums[idx], prev = prev, nums[idx]\n                curr = idx\n                count += 1\n                if start == curr:\n                    break\n            start += 1\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution4(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def rotate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums[:] = nums[len(nums) - k:] + nums[:len(nums) - k]\n        \n\n# Time:  O(k * n)\n# Space: O(1)\nclass Solution5(object):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    def rotate(self, nums, k):\n        while k > 0:\n            nums.insert(0, nums.pop())\n            k -= 1\n\n \n"
    },
    {
        "problem_name": "rotate-function",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxRotateFunction(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        s = sum(A)\n        fi = 0\n        for i in xrange(len(A)):\n            fi += i * A[i]\n\n        result = fi\n        for i in xrange(1, len(A)+1):\n            fi += s - len(A) * A[-i]\n            result = max(result, fi)\n        return result\n\n"
    },
    {
        "problem_name": "rotate-image",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        n = len(matrix)\n\n        # anti-diagonal mirror\n        for i in xrange(n):\n            for j in xrange(n - i):\n                matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j]\n\n        # horizontal mirror\n        for i in xrange(n / 2):\n            for j in xrange(n):\n                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n\n        return matrix\n\n# Time:  O(n^2)\n# Space: O(n^2)\nclass Solution2(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of lists of integers\n    def rotate(self, matrix):\n        return [list(reversed(x)) for x in zip(*matrix)]\n\n"
    },
    {
        "problem_name": "rotate-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        n, cur = 1, head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        cur.next = head\n\n        cur, tail = head, cur\n        for _ in xrange(n - k % n):\n            tail = cur\n            cur = cur.next\n        tail.next = None\n\n        return cur\n\n\n"
    },
    {
        "problem_name": "rotate-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def rotateString(self, A, B):\n        \"\"\"\n        :type A: str\n        :type B: str\n        :rtype: bool\n        \"\"\"\n        def check(index):\n            return all(A[(i+index) % len(A)] == c\n                       for i, c in enumerate(B))\n\n        if len(A) != len(B):\n            return False\n\n        M, p = 10**9+7, 113\n        p_inv = pow(p, M-2, M)\n\n        b_hash, power = 0, 1\n        for c in B:\n            b_hash += power * ord(c)\n            b_hash %= M\n            power = (power*p) % M\n\n        a_hash, power = 0, 1\n        for i in xrange(len(B)):\n            a_hash += power * ord(A[i%len(A)])\n            a_hash %= M\n            power = (power*p) % M\n\n        if a_hash == b_hash and check(0): return True\n\n        power = (power*p_inv) % M\n        for i in xrange(len(B), 2*len(A)):\n            a_hash = (a_hash-ord(A[(i-len(B))%len(A)])) * p_inv\n            a_hash += power * ord(A[i%len(A)])\n            a_hash %= M\n            if a_hash == b_hash and check(i-len(B)+1):\n                return True\n\n        return False\n\n\n# Time:  O(n)\n# Space: O(n)\n# KMP algorithm\nclass Solution2(object):\n    def rotateString(self, A, B):\n        \"\"\"\n        :type A: str\n        :type B: str\n        :rtype: bool\n        \"\"\"\n        def strStr(haystack, needle):\n            def KMP(text, pattern):\n                prefix = getPrefix(pattern)\n                j = -1\n                for i in xrange(len(text)):\n                    while j > -1 and pattern[j + 1] != text[i]:\n                        j = prefix[j]\n                    if pattern[j + 1] == text[i]:\n                        j += 1\n                    if j == len(pattern) - 1:\n                        return i - j\n                return -1\n\n            def getPrefix(pattern):\n                prefix = [-1] * len(pattern)\n                j = -1\n                for i in xrange(1, len(pattern)):\n                    while j > -1 and pattern[j + 1] != pattern[i]:\n                        j = prefix[j]\n                    if pattern[j + 1] == pattern[i]:\n                        j += 1\n                    prefix[i] = j\n                return prefix\n\n            if not needle:\n                return 0\n            return KMP(haystack, needle)\n\n        if len(A) != len(B):\n            return False\n        return strStr(A*2, B) != -1\n\n\n# Time:  O(n^2)\n# Space: O(n)\nclass Solution3(object):\n    def rotateString(self, A, B):\n        \"\"\"\n        :type A: str\n        :type B: str\n        :rtype: bool\n        \"\"\"\n        return len(A) == len(B) and B in A*2\n\n"
    },
    {
        "problem_name": "rotated-digits",
        "solution": "# Time:  O(logn)\n# Space: O(logn)\n\nclass Solution(object):\n    def rotatedDigits(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        A = map(int, str(N))\n        invalid, diff = set([3, 4, 7]), set([2, 5, 6, 9])\n        def dp(A, i, is_prefix_equal, is_good, lookup):\n            if i == len(A): return int(is_good)\n            if (i, is_prefix_equal, is_good) not in lookup:\n                result = 0\n                for d in xrange(A[i]+1 if is_prefix_equal else 10):\n                    if d in invalid: continue\n                    result += dp(A, i+1,\n                                 is_prefix_equal and d == A[i],\n                                 is_good or d in diff,\n                                 lookup)\n                lookup[i, is_prefix_equal, is_good] = result\n            return lookup[i, is_prefix_equal, is_good]\n\n        lookup = {}\n        return dp(A, 0, True, False, lookup)\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def rotatedDigits(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        INVALID, SAME, DIFF = 0, 1, 2\n        same, diff = [0, 1, 8], [2, 5, 6, 9]\n        dp = [0] * (N+1)\n        dp[0] = SAME\n        for i in xrange(N//10+1):\n            if dp[i] != INVALID:\n                for j in same:\n                    if i*10+j <= N:\n                        dp[i*10+j] = max(SAME, dp[i])\n                for j in diff:\n                    if i*10+j <= N:\n                        dp[i*10+j] = DIFF\n        return dp.count(DIFF)\n\n\n# Time:  O(nlogn) = O(n), because O(logn) = O(32) by this input\n# Space: O(logn) = O(1)\nclass Solution3(object):\n    def rotatedDigits(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        invalid, diff = set(['3', '4', '7']), set(['2', '5', '6', '9'])\n        result = 0\n        for i in xrange(N+1):\n            lookup = set(list(str(i)))\n            if invalid & lookup:\n                continue\n            if diff & lookup:\n                result += 1\n        return result\n\n\n"
    },
    {
        "problem_name": "rotating-the-box",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def rotateTheBox(self, box):\n        \"\"\"\n        :type box: List[List[str]]\n        :rtype: List[List[str]]\n        \"\"\"\n        result = [['.']*len(box) for _ in xrange(len(box[0]))]\n        for i in xrange(len(box)):\n            k = len(box[0])-1\n            for j in reversed(xrange(len(box[0]))):\n                if box[i][j] == '.':\n                    continue\n                if box[i][j] == '*':\n                    k = j\n                result[k][-1-i] = box[i][j]\n                k -= 1\n        return result\n"
    },
    {
        "problem_name": "rotting-oranges",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nimport collections\n\n\nclass Solution(object):\n    def orangesRotting(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        count = 0\n        q = collections.deque()\n        for r, row in enumerate(grid):\n            for c, val in enumerate(row):\n                if val == 2:\n                    q.append((r, c, 0))\n                elif val == 1:\n                    count += 1\n\n        result = 0\n        while q:\n            r, c, result = q.popleft()\n            for d in directions:\n                nr, nc = r+d[0], c+d[1]\n                if not (0 <= nr < len(grid) and \\\n                        0 <= nc < len(grid[r])):\n                    continue\n                if grid[nr][nc] == 1:\n                    count -= 1\n                    grid[nr][nc] = 2\n                    q.append((nr, nc, result+1))\n        return result if count == 0 else -1\n"
    },
    {
        "problem_name": "row-with-maximum-ones",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def rowAndMaximumOnes(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        return max(([i, mat[i].count(1)] for i in xrange(len(mat))), key=lambda x: x[1])\n"
    },
    {
        "problem_name": "running-sum-of-1d-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def runningSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in xrange(len(nums)-1):\n            nums[i+1] += nums[i]\n        return nums\n"
    },
    {
        "problem_name": "russian-doll-envelopes",
        "solution": "# Time:  O(nlogn + nlogk) = O(nlogn), k is the length of the result.\n# Space: O(1)\n\nclass Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def insert(target):\n            left, right = 0, len(result) - 1\n            while left <= right:\n                mid = left + (right - left) / 2\n                if result[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            if left == len(result):\n                result.append(target)\n            else:\n                result[left] = target\n\n        result = []\n\n        envelopes.sort(lambda x, y: y[1] - x[1] if x[0] == y[0] else \\\n                                    x[0] - y[0])\n        for envelope in envelopes:\n            insert(envelope[1])\n\n        return len(result)\n\n"
    },
    {
        "problem_name": "same-tree",
        "solution": "# Time:  O(n)\n# Space: O(h), h is height of binary tree\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param p, a tree node\n    # @param q, a tree node\n    # @return a boolean\n    def isSameTree(self, p, q):\n        if p is None and q is None:\n            return True\n\n        if p is not None and q is not None:\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n        return False\n\n"
    },
    {
        "problem_name": "satisfiability-of-equality-equations",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\n\nclass Solution(object):\n    def equationsPossible(self, equations):\n        \"\"\"\n        :type equations: List[str]\n        :rtype: bool\n        \"\"\"\n        union_find = UnionFind(26)\n        for eqn in equations:\n            x = ord(eqn[0]) - ord('a')\n            y = ord(eqn[3]) - ord('a')\n            if eqn[1] == '=':\n                union_find.union_set(x, y)\n        for eqn in equations:\n            x = ord(eqn[0]) - ord('a')\n            y = ord(eqn[3]) - ord('a')\n            if eqn[1] == '!':\n                if union_find.find_set(x) == union_find.find_set(y):\n                    return False\n        return True\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def equationsPossible(self, equations):\n        \"\"\"\n        :type equations: List[str]\n        :rtype: bool\n        \"\"\"\n        graph = [[] for _ in xrange(26)]\n\n        for eqn in equations:\n            x = ord(eqn[0]) - ord('a')\n            y = ord(eqn[3]) - ord('a')\n            if eqn[1] == '!':\n                if x == y:\n                    return False\n            else:\n                graph[x].append(y)\n                graph[y].append(x)\n\n        color = [None]*26\n        c = 0\n        for i in xrange(26):\n            if color[i] is not None:\n                continue\n            c += 1\n            stack = [i]\n            while stack:\n                node = stack.pop()\n                for nei in graph[node]:\n                    if color[nei] is not None:\n                        continue\n                    color[nei] = c\n                    stack.append(nei)\n\n        for eqn in equations:\n            if eqn[1] != '!':\n                continue\n            x = ord(eqn[0]) - ord('a')\n            y = ord(eqn[3]) - ord('a')\n            if color[x] is not None and \\\n               color[x] == color[y]:\n                return False\n        return True\n"
    },
    {
        "problem_name": "score-after-flipping-matrix",
        "solution": "# Time:  O(r * c)\n# Space: O(1)\n\n\nclass Solution(object):\n    def matrixScore(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        R, C = len(A), len(A[0])\n        result = 0\n        for c in xrange(C):\n            col = 0\n            for r in xrange(R):\n                col += A[r][c] ^ A[r][0]\n            result += max(col, R-col) * 2**(C-1-c)\n        return result\n\n"
    },
    {
        "problem_name": "score-of-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def scoreOfString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return sum(abs(ord(s[i+1])-ord(s[i])) for i in xrange(len(s)-1))\n"
    },
    {
        "problem_name": "score-of-parentheses",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n\nclass Solution(object):\n    def scoreOfParentheses(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        result, depth = 0, 0\n        for i in xrange(len(S)):\n            if S[i] == '(':\n                depth += 1\n            else:\n                depth -= 1\n                if S[i-1] == '(':\n                    result += 2**depth\n        return result\n\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def scoreOfParentheses(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        stack = [0]\n        for c in S:\n            if c == '(':\n                stack.append(0)\n            else:\n                last = stack.pop()\n                stack[-1] += max(1, 2*last)\n        return stack[0]\n\n"
    },
    {
        "problem_name": "scramble-string",
        "solution": "# Time:  O(n^4)\n# Space: O(n^3)\n\nclass Solution(object):\n    # @return a boolean\n    def isScramble(self, s1, s2):\n        if not s1 or not s2 or len(s1) != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        result = [[[False for j in xrange(len(s2))] for i in xrange(len(s1))] for n in xrange(len(s1) + 1)]\n        for i in xrange(len(s1)):\n            for j in xrange(len(s2)):\n                if s1[i] == s2[j]:\n                    result[1][i][j] = True\n\n        for n in xrange(2, len(s1) + 1):\n            for i in xrange(len(s1) - n + 1):\n                for j in xrange(len(s2) - n + 1):\n                    for k in xrange(1, n):\n                        if result[k][i][j] and result[n - k][i + k][j + k] or\\\n                           result[k][i][j + n - k] and result[n - k][i + k][j]:\n                            result[n][i][j] = True\n                            break\n\n        return result[n][0][0]\n\n"
    },
    {
        "problem_name": "search-a-2d-matrix-ii",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {integer[][]} matrix\n    # @param {integer} target\n    # @return {boolean}\n    def searchMatrix(self, matrix, target):\n        m = len(matrix)\n        if m == 0:\n            return False\n\n        n = len(matrix[0])\n        if n == 0:\n            return False\n\n        i, j = 0, n - 1\n        while i < m and j >= 0:\n            if matrix[i][j] == target:\n                return True\n            elif matrix[i][j] > target:\n                j -= 1\n            else:\n                i += 1\n\n        return False\n\n"
    },
    {
        "problem_name": "search-a-2d-matrix",
        "solution": "# Time:  O(logm + logn)\n# Space: O(1)\n\nclass Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not matrix:\n            return False\n\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n\n        while left < right:\n            mid = left + (right - left) / 2\n            if matrix[mid / n][mid % n] >= target:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left < m * n and matrix[left / n][left % n] == target\n\n\n"
    },
    {
        "problem_name": "search-in-a-binary-search-tree",
        "solution": "# Time:  O(h)\n# Space: O(1)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def searchBST(self, root, val):\n        \"\"\"\n        :type root: TreeNode\n        :type val: int\n        :rtype: TreeNode\n        \"\"\"\n        while root and val != root.val:\n            if val < root.val:\n                root = root.left\n            else:\n                root = root.right\n        return root\n\n"
    },
    {
        "problem_name": "search-in-a-sorted-array-of-unknown-size",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def search(self, reader, target):\n        \"\"\"\n        :type reader: ArrayReader\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, 19999\n        while left <= right:\n            mid = left + (right-left)//2\n            response = reader.get(mid)\n            if response > target:\n                right = mid-1\n            elif response < target:\n                left = mid+1\n            else:\n                return mid\n        return -1\n\n"
    },
    {
        "problem_name": "search-in-rotated-sorted-array-ii",
        "solution": "# Time:  O(logn) ~ O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] == target:\n                return True\n            elif nums[mid] == nums[left]:\n                left += 1\n            elif (nums[mid] > nums[left] and nums[left] <= target < nums[mid]) or \\\n                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return False\n\n\n"
    },
    {
        "problem_name": "search-in-rotated-sorted-array",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) / 2\n\n            if nums[mid] == target:\n                return mid\n            elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or \\\n                 (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])):\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return -1\n\n\n"
    },
    {
        "problem_name": "search-insert-position",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if nums[mid] >= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left\n\n\n"
    },
    {
        "problem_name": "search-suggestions-system",
        "solution": "# Time:  ctor: O(n * l), n is the number of products\n#                      , l is the average length of product name\n#        suggest: O(l^2)\n# Space: O(t), t is the number of nodes in trie\n\nimport collections\n\n\nclass TrieNode(object):\n\n    def __init__(self):\n        self.__TOP_COUNT = 3\n        self.leaves = collections.defaultdict(TrieNode)\n        self.infos = []\n\n    def insert(self, words, i):\n        curr = self\n        for c in words[i]:\n            curr = curr.leaves[c]\n            curr.add_info(words, i)\n\n    def add_info(self, words, i):\n        self.infos.append(i)\n        self.infos.sort(key=lambda x: words[x])\n        if len(self.infos) > self.__TOP_COUNT:\n            self.infos.pop()\n\n\nclass Solution(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        trie = TrieNode()\n        for i in xrange(len(products)):\n            trie.insert(products, i)\n        result = [[] for _ in xrange(len(searchWord))]\n        for i, c in enumerate(searchWord):\n            if c not in trie.leaves:\n                break\n            trie = trie.leaves[c]\n            result[i] = map(lambda x: products[x], trie.infos)\n        return result\n\n\n# Time:  ctor: O(n * l * log(n * l)), n is the number of products\n#                                   , l is the average length of product name\n#        suggest: O(l^2)\n# Space: O(t), t is the number of nodes in trie\nclass TrieNode2(object):\n\n    def __init__(self):\n        self.__TOP_COUNT = 3\n        self.leaves = collections.defaultdict(TrieNode2)\n        self.infos = []\n\n    def insert(self, words, i):\n        curr = self\n        for c in words[i]:\n            curr = curr.leaves[c]\n            curr.add_info(i)\n\n    def add_info(self, i):\n        if len(self.infos) == self.__TOP_COUNT:\n            return\n        self.infos.append(i)\n\n\nclass Solution2(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        products.sort()\n        trie = TrieNode2()\n        for i in xrange(len(products)):\n            trie.insert(products, i)\n        result = [[] for _ in xrange(len(searchWord))]\n        for i, c in enumerate(searchWord):\n            if c not in trie.leaves:\n                break\n            trie = trie.leaves[c]\n            result[i] = map(lambda x: products[x], trie.infos)\n        return result\n\n\n# Time:  ctor: O(n * l * log(n * l)), n is the number of products\n#                                   , l is the average length of product name\n#        suggest: O(l^2 * n)\n# Space: O(n * l)\nimport bisect\n\n\nclass Solution3(object):\n    def suggestedProducts(self, products, searchWord):\n        \"\"\"\n        :type products: List[str]\n        :type searchWord: str\n        :rtype: List[List[str]]\n        \"\"\"\n        products.sort()  # Time: O(n * l * log(n * l))\n        result = []\n        prefix = \"\"\n        for i, c in enumerate(searchWord):  # Time: O(l)\n            prefix += c\n            start = bisect.bisect_left(products, prefix)  # Time: O(log(n * l))\n            new_products = []\n            for j in xrange(start, len(products)):  # Time: O(n * l)\n                if not (i < len(products[j]) and products[j][i] == c):\n                    break\n                new_products.append(products[j])\n            products = new_products\n            result.append(products[:3])\n        return result\n"
    },
    {
        "problem_name": "seat-reservation-manager",
        "solution": "# Time:  ctor:      O(n)\n#        reserve:   O(logn)\n#        unreserve: O(logn)\n# Space: O(n)\n\nimport heapq\n\n\nclass SeatManager(object):\n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.__min_heap = range(1, n+1)\n        # heapq.heapify(self.__min_heap)  # no need for sorted list\n\n    def reserve(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return heapq.heappop(self.__min_heap)\n\n    def unreserve(self, seatNumber):\n        \"\"\"\n        :type seatNumber: int\n        :rtype: None\n        \"\"\"\n        heapq.heappush(self.__min_heap, seatNumber)\n"
    },
    {
        "problem_name": "second-largest-digit-in-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def secondHighest(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        first = second = -1\n        for c in s:\n            if not c.isdigit():\n                continue\n            d = int(c)\n            if d > first:\n                first, second = d, first\n            elif first > d > second:\n                second = d\n        return second\n"
    },
    {
        "problem_name": "second-minimum-node-in-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nimport heapq\n\n\nclass Solution(object):\n    def findSecondMinimumValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def findSecondMinimumValueHelper(root, max_heap, lookup):\n            if not root:\n                return\n            if root.val not in lookup:\n                heapq.heappush(max_heap, -root.val)\n                lookup.add(root.val)\n                if len(max_heap) > 2:\n                    lookup.remove(-heapq.heappop(max_heap))\n            findSecondMinimumValueHelper(root.left, max_heap, lookup)\n            findSecondMinimumValueHelper(root.right, max_heap, lookup)\n\n        max_heap, lookup = [], set()\n        findSecondMinimumValueHelper(root, max_heap, lookup)\n        if len(max_heap) < 2:\n            return -1\n        return -max_heap[0]\n\n"
    },
    {
        "problem_name": "second-minimum-time-to-reach-destination",
        "solution": "# Time:  O(|V| + |E|) = O(|E|) since graph is connected, O(|E|) >= O(|V|) \n# Space: O(|V| + |E|) = O(|E|)\n\nclass Solution(object):\n    def secondMinimum(self, n, edges, time, change):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type time: int\n        :type change: int\n        :rtype: int\n        \"\"\"\n        # Template:\n        # https://github.com/kamyu104/LeetCode-Solutions/blob/master/Python/find-if-path-exists-in-graph.py\n        def bi_bfs(adj, start, target):\n            left, right = {start}, {target}\n            lookup = set()\n            result = steps = 0\n            while left and (not result or result+2 > steps):  # modified\n                for u in left:\n                    lookup.add(u)\n                new_left = set()\n                for u in left: \n                    if u in right:\n                        if not result:  # modified\n                            result = steps\n                        elif result < steps:  # modifeid\n                            return result+1\n                    for v in adj[u]:\n                        if v in lookup:\n                            continue\n                        new_left.add(v)\n                left = new_left\n                steps += 1\n                if len(left) > len(right): \n                    left, right = right, left\n            return result+2  # modified\n\n        def calc_time(time, change, dist):\n            result = 0\n            for _ in xrange(dist):\n                if result//change%2:\n                    result = (result//change+1)*change\n                result += time\n            return result\n\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        return calc_time(time, change, bi_bfs(adj, 0, n-1))\n\n\n# Time:  O(|V| + |E|) = O(|E|) since graph is connected, O(|E|) >= O(|V|) \n# Space: O(|V| + |E|) = O(|E|)\nclass Solution2(object):\n    def secondMinimum(self, n, edges, time, change):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type time: int\n        :type change: int\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        def bfs(adj, start):\n            q = [start]\n            dist = [INF]*len(adj)\n            dist[start] = 0\n            while q:\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if dist[v] != INF:\n                            continue\n                        dist[v] = dist[u]+1\n                        new_q.append(v)\n                q = new_q\n            return dist\n\n        def calc_time(time, change, dist):\n            result = 0\n            for _ in xrange(dist):\n                if result//change%2:\n                    result = (result//change+1)*change\n                result += time\n            return result\n\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        dist_to_end, dist_to_start = bfs(adj, 0), bfs(adj, n-1)\n\n        dist = dist_to_end[n-1]+2  # always exists\n        for i in xrange(n):  # case of detour\n            if dist_to_end[i]+dist_to_start[i] == dist_to_end[n-1]:\n                continue\n            dist = min(dist, dist_to_end[i]+dist_to_start[i])  # find second min\n            if dist == dist_to_end[n-1]+1:\n                break\n        return calc_time(time, change, dist)\n"
    },
    {
        "problem_name": "self-crossing",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isSelfCrossing(self, x):\n        \"\"\"\n        :type x: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(x) >= 5 and x[3] == x[1] and x[4] + x[0] >= x[2]:\n            # Crossing in a loop:\n            #     2\n            # 3 \u250c\u2500\u2500\u2500\u2500\u2510\n            #   \u2514\u2500\u2550\u2550>\u25181\n            #   4  0  (overlapped)\n            return True\n\n        for i in xrange(3, len(x)):\n            if x[i] >= x[i - 2] and x[i - 3] >= x[i - 1]:\n                # Case 1:\n                #    i-2\n                # i-1\u250c\u2500\u2510\n                #    \u2514\u2500\u253c\u2500>i\n                #     i-3\n                return True\n            elif i >= 5 and x[i - 4] <= x[i - 2] and x[i] + x[i - 4] >= x[i - 2] and \\\n                            x[i - 1] <= x[i - 3] and x[i - 5] + x[i - 1] >= x[i - 3]:\n                # Case 2:\n                #    i-4\n                #    \u250c\u2500\u2500\u2510\n                #    \u2502i<\u253c\u2500\u2510\n                # i-3\u2502 i-5\u2502i-1\n                #    \u2514\u2500\u2500\u2500\u2500\u2518\n                #      i-2\n                return True\n        return False\n\n"
    },
    {
        "problem_name": "self-dividing-numbers",
        "solution": "# Time:  O(nlogr) = O(n)\n# Space: O(logr) = O(1)\n\nclass Solution(object):\n    def selfDividingNumbers(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: List[int]\n        \"\"\"\n        def isDividingNumber(num):\n            n = num\n            while n > 0:\n                n, r = divmod(n, 10)\n                if r == 0 or (num%r) != 0:\n                    return False\n            return True\n        \n        return [num for num in xrange(left, right+1) if isDividingNumber(num)]\n\n\n# Time:  O(nlogr) = O(n)\n# Space: O(logr) = O(1)\nimport itertools\n\n\nclass Solution2(object):\n    def selfDividingNumbers(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: List[int]\n        \"\"\"\n        return [num for num in xrange(left, right+1) \\\n                if not any(itertools.imap(lambda x: int(x) == 0 or num%int(x) != 0, str(num)))]\n"
    },
    {
        "problem_name": "sell-diminishing-valued-colored-balls",
        "solution": "# Time:  O(nlogm), m is the max of inventory, n is the size of inventory\n# Space: O(1)\n\nclass Solution(object):\n    def maxProfit(self, inventory, orders):\n        \"\"\"\n        :type inventory: List[int]\n        :type orders: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def check(inventory, orders, x):\n            return count(inventory, x) > orders\n        \n        def count(inventory, x):\n            return sum(count-x+1 for count in inventory if count >= x)\n\n        left, right = 1, max(inventory)\n        while left <= right:\n            mid = left + (right-left)//2\n            if not check(inventory, orders, mid):\n                right = mid-1\n            else:\n                left = mid+1\n        # assert(orders-count(inventory, left) >= 0)\n        return (sum((left+cnt)*(cnt-left+1)//2 for cnt in inventory if cnt >= left) +\n                (left-1)*(orders-count(inventory, left)))% MOD\n"
    },
    {
        "problem_name": "selling-pieces-of-wood",
        "solution": "# Time:  O(m * n * (m + n))\n# Space: O(m * n)\n\n# dp\nclass Solution(object):\n    def sellingWood(self, m, n, prices):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type prices: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = [[0]*(n+1) for i in xrange(m+1)]\n        for h, w, p in prices:\n            dp[h][w] = p\n        for i in xrange(1, m+1):\n            for j in xrange(1, n+1):\n                for k in xrange(1, i//2+1):\n                    dp[i][j] = max(dp[i][j], dp[k][j]+dp[i-k][j])\n                for k in xrange(1, j//2+1):\n                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[i][j-k])\n        return dp[m][n]\n"
    },
    {
        "problem_name": "semi-ordered-permutation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def semiOrderedPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        i, j = nums.index(1), nums.index(len(nums))\n        return i+((len(nums)-1)-j)-int(i > j)\n"
    },
    {
        "problem_name": "sender-with-largest-word-count",
        "solution": "# Time:  O(n * l)\n# Space: O(n)\n\nimport collections\nimport itertools\n\n\n# freq table\nclass Solution(object):\n    def largestWordCount(self, messages, senders):\n        \"\"\"\n        :type messages: List[str]\n        :type senders: List[str]\n        :rtype: str\n        \"\"\"\n        cnt = collections.Counter()\n        for m, s in itertools.izip(messages, senders):\n            cnt[s] += m.count(' ')+1\n        return max((k for k in cnt.iterkeys()), key=lambda x: (cnt[x], x))\n"
    },
    {
        "problem_name": "sentence-screen-fitting",
        "solution": "# Time:  O(r + n * c)\n# Space: O(n)\n\nclass Solution(object):\n    def wordsTyping(self, sentence, rows, cols):\n        \"\"\"\n        :type sentence: List[str]\n        :type rows: int\n        :type cols: int\n        :rtype: int\n        \"\"\"\n        def words_fit(sentence, start, cols):\n            if len(sentence[start]) > cols:\n                return 0\n\n            s, count = len(sentence[start]), 1\n            i = (start + 1) % len(sentence)\n            while s + 1 + len(sentence[i]) <= cols:\n                s += 1 + len(sentence[i])\n                count += 1\n                i = (i + 1) % len(sentence)\n            return count\n\n        wc = [0] * len(sentence)\n        for i in xrange(len(sentence)):\n            wc[i] = words_fit(sentence, i, cols)\n\n        words, start = 0, 0\n        for i in xrange(rows):\n            words += wc[start]\n            start = (start + wc[start]) % len(sentence)\n        return words / len(sentence)\n\n"
    },
    {
        "problem_name": "sentence-similarity-ii",
        "solution": "# Time:  O(n + p)\n# Space: O(p)\n\nimport itertools\n\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\n\nclass Solution(object):\n    def areSentencesSimilarTwo(self, words1, words2, pairs):\n        \"\"\"\n        :type words1: List[str]\n        :type words2: List[str]\n        :type pairs: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        if len(words1) != len(words2): return False\n\n        lookup = {}\n        union_find = UnionFind(2 * len(pairs))\n        for pair in pairs:\n            for p in pair:\n                if p not in lookup:\n                    lookup[p] = len(lookup)\n            union_find.union_set(lookup[pair[0]], lookup[pair[1]])\n\n        return all(w1 == w2 or\n                   w1 in lookup and w2 in lookup and\n                   union_find.find_set(lookup[w1]) == union_find.find_set(lookup[w2])\n                   for w1, w2 in itertools.izip(words1, words2))\n\n"
    },
    {
        "problem_name": "sentence-similarity-iii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def areSentencesSimilar(self, sentence1, sentence2):\n        \"\"\"\n        :type sentence1: str\n        :type sentence2: str\n        :rtype: bool\n        \"\"\"\n        if len(sentence1) > len(sentence2):\n            sentence1, sentence2 = sentence2, sentence1\n        count = 0\n        for idx in (lambda x:x, lambda x:-1-x):\n            for i in xrange(len(sentence1)+1):\n                c1 = sentence1[idx(i)] if i != len(sentence1) else ' '\n                c2 = sentence2[idx(i)] if i != len(sentence2) else ' '\n                if c1 != c2:\n                    break\n                if c1 == ' ':\n                    count += 1\n        return count >= sentence1.count(' ')+1\n"
    },
    {
        "problem_name": "sentence-similarity",
        "solution": "# Time:  O(n + p)\n# Space: O(p)\n\nimport itertools\n\n\nclass Solution(object):\n    def areSentencesSimilar(self, words1, words2, pairs):\n        \"\"\"\n        :type words1: List[str]\n        :type words2: List[str]\n        :type pairs: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        if len(words1) != len(words2): return False\n        lookup = set(map(tuple, pairs))\n        return all(w1 == w2 or (w1, w2) in lookup or (w2, w1) in lookup \\\n                   for w1, w2 in itertools.izip(words1, words2))\n\n"
    },
    {
        "problem_name": "separate-black-and-white-balls",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# two pointers\nclass Solution(object):\n    def minimumSteps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = left = 0\n        for right in xrange(len(s)):\n            if s[right] != '0':\n                continue\n            result += right-left\n            left += 1\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\n# two pointers\nclass Solution2(object):\n    def minimumSteps(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        left, right = 0, len(s)-1\n        while left < right:\n            if left < len(s) and s[left] != '1':\n                left += 1\n                continue\n            if right >= 0 and s[right] != '0':\n                right -= 1\n                continue\n            result += right-left\n            left += 1\n            right -= 1\n        return result\n"
    },
    {
        "problem_name": "separate-the-digits-in-an-array",
        "solution": "# Time:  O(n * logr)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def separateDigits(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for x in reversed(nums):\n            while x:\n                result.append(x%10)\n                x //= 10\n        result.reverse()\n        return result\n\n\n# Time:  O(n * logr)\n# Space: O(logr), r = max(nums)\n# array\nclass Solution2(object):\n    def separateDigits(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [int(c) for x in nums for c in str(x)]\n"
    },
    {
        "problem_name": "sequence-reconstruction",
        "solution": "# Time:  O(n * s), n is the size of org, s is the size of seqs\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def sequenceReconstruction(self, org, seqs):\n        \"\"\"\n        :type org: List[int]\n        :type seqs: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not seqs:\n            return False\n        pos = [0] * (len(org) + 1)\n        for i in xrange(len(org)):\n            pos[org[i]] = i\n\n        is_matched = [False] * (len(org) + 1)\n        cnt_to_match = len(org) - 1\n        for seq in seqs:\n            for i in xrange(len(seq)):\n                if not 0 < seq[i] <= len(org):\n                    return False\n                if i == 0:\n                    continue\n                if pos[seq[i-1]] >= pos[seq[i]]:\n                    return False\n                if is_matched[seq[i-1]] == False and pos[seq[i-1]] + 1 == pos[seq[i]]:\n                    is_matched[seq[i-1]] = True\n                    cnt_to_match -= 1\n\n        return cnt_to_match == 0\n\n\n# Time:  O(|V| + |E|)\n# Space: O(|E|)\nclass Solution2(object):\n    def sequenceReconstruction(self, org, seqs):\n        \"\"\"\n        :type org: List[int]\n        :type seqs: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        graph = collections.defaultdict(set)\n        indegree = collections.defaultdict(int)\n        integer_set = set()\n        for seq in seqs:\n            for i in seq:\n                integer_set.add(i)\n            if len(seq) == 1:\n                if seq[0] not in indegree:\n                    indegree[seq[0]] = 0\n                continue\n            for i in xrange(len(seq)-1):\n                if seq[i] not in indegree:\n                    indegree[seq[i]] = 0\n                if seq[i+1] not in graph[seq[i]]:\n                    graph[seq[i]].add(seq[i+1])\n                    indegree[seq[i+1]] += 1\n\n        cnt_of_zero_indegree = 0\n        res = []\n        q = []\n        for i in indegree:\n            if indegree[i] == 0:\n                cnt_of_zero_indegree += 1\n                if cnt_of_zero_indegree > 1:\n                    return False\n                q.append(i)\n\n        while q:\n            i = q.pop()\n            res.append(i)\n            cnt_of_zero_indegree = 0\n            for j in graph[i]:\n                indegree[j] -= 1\n                if indegree[j] == 0:\n                    cnt_of_zero_indegree += 1\n                    if cnt_of_zero_indegree > 1:\n                        return False\n                    q.append(j)\n        return res == org and len(org) == len(integer_set)\n\n"
    },
    {
        "problem_name": "sequential-digits",
        "solution": "# Time:  O((8 + 1) * 8 / 2) = O(1)\n# Space: O(8) = O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def sequentialDigits(self, low, high):\n        \"\"\"\n        :type low: int\n        :type high: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        q = collections.deque(range(1, 9))\n        while q:\n            num = q.popleft()\n            if num > high:\n                continue\n            if low <= num:\n                result.append(num)\n            if num%10+1 < 10:\n                q.append(num*10+num%10+1)\n        return result\n"
    },
    {
        "problem_name": "sequentially-ordinal-rank-tracker",
        "solution": "# Time:  add: O(logn)\n#        get: O(logn)\n# Space: O(n)\n\nfrom sortedcontainers import SortedList\n\n\nclass SORTracker(object):\n\n    def __init__(self):\n        self.__sl = SortedList()\n        self.__i = 0\n\n    def add(self, name, score):\n        \"\"\"\n        :type name: str\n        :type score: int\n        :rtype: None\n        \"\"\"\n        self.__sl.add((-score, name))\n        \n    def get(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        self.__i += 1\n        return self.__sl[self.__i-1][1]\n"
    },
    {
        "problem_name": "serialize-and-deserialize-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Codec(object):\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def serializeHelper(node):\n            if not node:\n                vals.append('#')\n                return\n            vals.append(str(node.val))\n            serializeHelper(node.left)\n            serializeHelper(node.right)\n        vals = []\n        serializeHelper(root)\n        return ' '.join(vals)\n\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def deserializeHelper():\n            val = next(vals)\n            if val == '#':\n                return None\n            node = TreeNode(int(val))\n            node.left = deserializeHelper()\n            node.right = deserializeHelper()\n            return node\n        def isplit(source, sep):\n            sepsize = len(sep)\n            start = 0\n            while True:\n                idx = source.find(sep, start)\n                if idx == -1:\n                    yield source[start:]\n                    return\n                yield source[start:idx]\n                start = idx + sepsize\n        vals = iter(isplit(data, ' '))\n        return deserializeHelper()\n\n\n# time: O(n)\n# space: O(n)\n\nclass Codec2(object):\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def gen_preorder(node):\n            if not node:\n                yield '#'\n            else:\n                yield str(node.val)\n                for n in gen_preorder(node.left):\n                    yield n\n                for n in gen_preorder(node.right):\n                    yield n\n                \n        return ' '.join(gen_preorder(root))\n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def builder(chunk_iter):\n            val = next(chunk_iter)\n            if val == '#':\n                return None\n            node = TreeNode(int(val))\n            node.left = builder(chunk_iter)\n            node.right = builder(chunk_iter)\n            return node\n        \n        # https://stackoverflow.com/a/42373311/568901\n        chunk_iter = iter(data.split())\n        return builder(chunk_iter)\n"
    },
    {
        "problem_name": "serialize-and-deserialize-bst",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nimport collections\n\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Codec(object):\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def serializeHelper(node, vals):\n            if node:\n                vals.append(node.val)\n                serializeHelper(node.left, vals)\n                serializeHelper(node.right, vals)\n\n        vals = []\n        serializeHelper(root, vals)\n\n        return ' '.join(map(str, vals))\n\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def deserializeHelper(minVal, maxVal, vals):\n            if not vals:\n                return None\n\n            if minVal < vals[0] < maxVal:\n                val = vals.popleft()\n                node = TreeNode(val)\n                node.left = deserializeHelper(minVal, val, vals)\n                node.right = deserializeHelper(val, maxVal, vals)\n                return node\n            else:\n                return None\n\n        vals = collections.deque([int(val) for val in data.split()])\n\n        return deserializeHelper(float('-inf'), float('inf'), vals)\n\n\n\n"
    },
    {
        "problem_name": "serialize-and-deserialize-n-ary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\n\nclass Codec(object):\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: Node\n        :rtype: str\n        \"\"\"\n        def dfs(node, vals):\n            if not node:\n                return\n            vals.append(str(node.val))\n            for child in node.children:\n                dfs(child, vals)\n            vals.append(\"#\")\n        \n        vals = []\n        dfs(root, vals)\n        return \" \".join(vals)\n\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: Node\n        \"\"\"\n        def isplit(source, sep):\n            sepsize = len(sep)\n            start = 0\n            while True:\n                idx = source.find(sep, start)\n                if idx == -1:\n                    yield source[start:]\n                    return\n                yield source[start:idx]\n                start = idx + sepsize\n                \n        def dfs(vals):\n            val = next(vals)\n            if val == \"#\":\n                return None\n            root = Node(int(val), [])\n            child = dfs(vals)\n            while child:\n                root.children.append(child)\n                child = dfs(vals)\n            return root\n\n        if not data:\n            return None\n    \n        return dfs(iter(isplit(data, ' ')))\n        \n\n\n"
    },
    {
        "problem_name": "set-intersection-size-at-least-two",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        intervals.sort(key = lambda s_e: (s_e[0], -s_e[1]))\n        cnts = [2] * len(intervals)\n        result = 0\n        while intervals:\n            (start, _), cnt = intervals.pop(), cnts.pop()\n            for s in xrange(start, start+cnt):\n                for i in xrange(len(intervals)):\n                    if cnts[i] and s <= intervals[i][1]:\n                        cnts[i] -= 1\n            result += cnt\n        return result\n\n"
    },
    {
        "problem_name": "set-matrix-zeroes",
        "solution": "from functools import reduce\n# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param matrix, a list of lists of integers\n    # RETURN NOTHING, MODIFY matrix IN PLACE.\n    def setZeroes(self, matrix):\n        first_col = reduce(lambda acc, i: acc or matrix[i][0] == 0, xrange(len(matrix)), False)\n        first_row = reduce(lambda acc, j: acc or matrix[0][j] == 0, xrange(len(matrix[0])), False)\n\n        for i in xrange(1, len(matrix)):\n            for j in xrange(1, len(matrix[0])):\n                if matrix[i][j] == 0:\n                    matrix[i][0], matrix[0][j] = 0, 0\n\n        for i in xrange(1, len(matrix)):\n            for j in xrange(1, len(matrix[0])):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n\n        if first_col:\n            for i in xrange(len(matrix)):\n                matrix[i][0] = 0\n\n        if first_row:\n            for j in xrange(len(matrix[0])):\n                matrix[0][j] = 0\n\n"
    },
    {
        "problem_name": "set-mismatch",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findErrorNums(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        x_xor_y = 0\n        for i in xrange(len(nums)):\n            x_xor_y ^= nums[i] ^ (i+1)\n        bit = x_xor_y & ~(x_xor_y-1)\n        result = [0] * 2\n        for i, num in enumerate(nums):\n            result[bool(num & bit)] ^= num\n            result[bool((i+1) & bit)] ^= i+1\n        if result[0] not in nums:\n            result[0], result[1] = result[1], result[0]\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def findErrorNums(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0] * 2\n        for i in nums:\n            if nums[abs(i)-1] < 0:\n                result[0] = abs(i)\n            else:\n                nums[abs(i)-1] *= -1\n        for i in xrange(len(nums)):\n            if nums[i] > 0:\n                result[1] = i+1\n            else:\n                nums[i] *= -1\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution3(object):\n    def findErrorNums(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        N = len(nums)\n        x_minus_y = sum(nums) - N*(N+1)//2\n        x_plus_y = (sum(x*x for x in nums) - N*(N+1)*(2*N+1)/6) // x_minus_y\n        return (x_plus_y+x_minus_y) // 2, (x_plus_y-x_minus_y) // 2\n\n"
    },
    {
        "problem_name": "shift-2d-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def shiftGrid(self, grid, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def rotate(grids, k):\n            def reverse(grid, start, end):\n                while start < end:\n                    start_r, start_c = divmod(start, len(grid[0]))\n                    end_r, end_c = divmod(end-1, len(grid[0]))\n                    grid[start_r][start_c], grid[end_r][end_c] = grid[end_r][end_c], grid[start_r][start_c]\n                    start += 1\n                    end -= 1\n\n            k %= len(grid)*len(grid[0])\n            reverse(grid, 0, len(grid)*len(grid[0]))\n            reverse(grid, 0, k)\n            reverse(grid, k, len(grid)*len(grid[0]))\n\n        rotate(grid, k)\n        return grid\n"
    },
    {
        "problem_name": "shifting-letters-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# line sweep\nclass Solution(object):\n    def shiftingLetters(self, s, shifts):\n        \"\"\"\n        :type s: str\n        :type shifts: List[List[int]]\n        :rtype: str\n        \"\"\"\n        events = [0]*(len(s)+1)\n        for b, e, d in shifts:\n            events[b] += 1 if d else -1\n            events[e+1] -= 1 if d else -1\n        result = []\n        curr = 0\n        for i in xrange(len(s)):\n            curr += events[i]\n            result.append(chr(ord('a')+(ord(s[i])-ord('a')+curr)%26))\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "shifting-letters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def shiftingLetters(self, S, shifts):\n        \"\"\"\n        :type S: str\n        :type shifts: List[int]\n        :rtype: str\n        \"\"\"\n        result = []\n        times = sum(shifts) % 26\n        for i, c in enumerate(S):\n            index = ord(c) - ord('a')\n            result.append(chr(ord('a') + (index+times) % 26))\n            times = (times-shifts[i]) % 26\n        return \"\".join(result)\n\n"
    },
    {
        "problem_name": "shopping-offers",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(n)\n\nclass Solution(object):\n    def shoppingOffers(self, price, special, needs):\n        \"\"\"\n        :type price: List[int]\n        :type special: List[List[int]]\n        :type needs: List[int]\n        :rtype: int\n        \"\"\"\n        def shoppingOffersHelper(price, special, needs, i):\n            if i == len(special):\n                return sum(map(lambda x, y: x*y, price, needs))\n            result = shoppingOffersHelper(price, special, needs, i+1)\n            for j in xrange(len(needs)):\n                needs[j] -= special[i][j]\n            if all(need >= 0 for need in needs):\n                result = min(result, special[i][-1] + shoppingOffersHelper(price, special, needs, i))\n            for j in xrange(len(needs)):\n                needs[j] += special[i][j]\n            return result\n\n        return shoppingOffersHelper(price, special, needs, 0)\n\n"
    },
    {
        "problem_name": "short-encoding-of-words",
        "solution": "# Time:  O(n), n is the total sum of the lengths of words\n# Space: O(t), t is the number of nodes in trie\n\nimport collections\nimport functools\n\n\nclass Solution(object):\n    def minimumLengthEncoding(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        words = list(set(words))\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n\n        nodes = [functools.reduce(dict.__getitem__, word[::-1], trie)\n                 for word in words]\n\n        return sum(len(word) + 1\n                   for i, word in enumerate(words)\n                   if len(nodes[i]) == 0)\n\n"
    },
    {
        "problem_name": "shortest-and-lexicographically-smallest-beautiful-string",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\n# two pointers, sliding window\nclass Solution(object):\n    def shortestBeautifulSubstring(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        def check(r1, r2):\n            if r1[1]-r1[0]+1 > r2[1]-r2[0]+1:\n                return False\n            if r1[1]-r1[0]+1 < r2[1]-r2[0]+1:\n                return True\n            for i, j in itertools.izip(xrange(r1[0], r1[1]+1), xrange(r2[0], r2[1]+1)):\n                if s[i] != s[j]:\n                    return s[i] < s[j]\n            return False\n    \n        result = []\n        left = curr = 0\n        for right in xrange(len(s)):\n            curr += s[right] == '1'\n            while curr == k+1:\n                curr -= s[left] == '1'\n                left += 1\n            while left < len(s) and s[left] == '0':\n                left += 1\n            if curr == k:\n                if not result or check([left, right], result):\n                    result = [left, right]\n        return s[result[0]:result[1]+1] if result else \"\"\n"
    },
    {
        "problem_name": "shortest-bridge",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nimport collections\n\n\nclass Solution(object):\n    def shortestBridge(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def get_islands(A):\n            islands = []\n            done = set()\n            for r, row in enumerate(A):\n                for c, val in enumerate(row):\n                    if val == 0 or (r, c) in done:\n                        continue\n                    s = [(r, c)]\n                    lookup = set(s)\n                    while s:\n                        node = s.pop()\n                        for d in directions:\n                            nei = node[0]+d[0], node[1]+d[1]\n                            if not (0 <= nei[0] < len(A) and 0 <= nei[1] < len(A[0])) or \\\n                               nei in lookup or A[nei[0]][nei[1]] == 0:\n                                continue\n                            s.append(nei)\n                            lookup.add(nei)\n                    done |= lookup\n                    islands.append(lookup)\n                    if len(islands) == 2:\n                        break\n            return islands\n\n        lookup, target = get_islands(A)\n        q = collections.deque([(node, 0) for node in lookup])\n        while q:\n            node, dis = q.popleft()\n            if node in target:\n                return dis-1\n            for d in directions:\n                nei = node[0]+d[0], node[1]+d[1]\n                if not (0 <= nei[0] < len(A) and 0 <= nei[1] < len(A[0])) or \\\n                   nei in lookup:\n                    continue\n                q.append((nei, dis+1))\n                lookup.add(nei)\n"
    },
    {
        "problem_name": "shortest-common-supersequence",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nclass Solution(object):\n    def shortestCommonSupersequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: str\n        \"\"\"\n        dp = [[0 for _ in xrange(len(str2)+1)] for _ in xrange(2)]\n        bt = [[None for _ in xrange(len(str2)+1)] for _ in xrange(len(str1)+1)]\n        for i, c in enumerate(str1):\n            bt[i+1][0] = (i, 0, c)\n        for j, c in enumerate(str2):\n            bt[0][j+1] = (0, j, c)\n        for i in xrange(len(str1)):\n            for j in xrange(len(str2)):\n                if dp[i % 2][j+1] > dp[(i+1) % 2][j]:\n                    dp[(i+1) % 2][j+1] = dp[i % 2][j+1]\n                    bt[i+1][j+1] = (i, j+1, str1[i])\n                else:\n                    dp[(i+1) % 2][j+1] = dp[(i+1) % 2][j]\n                    bt[i+1][j+1] = (i+1, j, str2[j])\n                if str1[i] != str2[j]:\n                    continue\n                if dp[i % 2][j]+1 > dp[(i+1) % 2][j+1]:\n                    dp[(i+1) % 2][j+1] = dp[i % 2][j]+1\n                    bt[i+1][j+1] = (i, j, str1[i])\n        \n        i, j = len(str1), len(str2)\n        result = []\n        while i != 0 or j != 0:\n            i, j, c = bt[i][j]\n            result.append(c)\n        result.reverse()\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "shortest-completing-word",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def shortestCompletingWord(self, licensePlate, words):\n        \"\"\"\n        :type licensePlate: str\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        def contains(counter1, w2):\n            c2 = collections.Counter(w2.lower())\n            c2.subtract(counter1)\n            return all(map(lambda x: x >= 0, c2.values()))\n\n        result = None\n        counter = collections.Counter(c.lower() for c in licensePlate if c.isalpha())\n        for word in words:\n            if (result is None or (len(word) < len(result))) and \\\n               contains(counter, word):\n                result = word\n        return result\n\n"
    },
    {
        "problem_name": "shortest-cycle-in-a-graph",
        "solution": "# Time:  O(n^2)\n# Space: O(n + e)\n\n# bfs\nclass Solution(object):\n    def findShortestCycle(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        def bfs(u):\n            result = INF\n            dist = [float(\"inf\")]*len(adj)\n            dist[u] = 0\n            q = [u]\n            while q:\n                new_q = []\n                for u in q:\n                    for v in adj[u]:\n                        if dist[v] != INF:\n                            assert(abs(dist[v]-dist[u]) <= 1)\n                            if dist[v] != dist[u]-1:\n                                result = min(result, 1+dist[u]+dist[v])  # d = dist[u]+1 >= 2, check if any cycle of length 2*d-1 or 2*d exists\n                            continue\n                        dist[v] = dist[u]+1\n                        new_q.append(v)\n                if result != INF:  # a cycle of length 2*d-1 or 2*d was found, early return\n                    break\n                q = new_q\n            return result\n\n        adj = [[] for _ in xrange(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        result = min(bfs(u) for u in xrange(n))\n        return result if result != INF else -1\n"
    },
    {
        "problem_name": "shortest-distance-from-all-buildings",
        "solution": "# Time:  O(k * m * n), k is the number of the buildings\n# Space: O(m * n)\n\nclass Solution(object):\n    def shortestDistance(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def bfs(grid, dists, cnts, x, y):\n            dist, m, n = 0, len(grid), len(grid[0])\n            visited = [[False for _ in xrange(n)] for _ in xrange(m)]\n\n            pre_level = [(x, y)]\n            visited[x][y] = True\n            while pre_level:\n                dist += 1\n                cur_level = []\n                for i, j in pre_level:\n                    for dir in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        I, J = i+dir[0], j+dir[1]\n                        if 0 <= I < m and 0 <= J < n and grid[I][J] == 0 and not visited[I][J]:\n                            cnts[I][J] += 1\n                            dists[I][J] += dist\n                            cur_level.append((I, J))\n                            visited[I][J] = True\n\n                pre_level = cur_level\n\n\n        m, n, cnt = len(grid),  len(grid[0]), 0\n        dists = [[0 for _ in xrange(n)] for _ in xrange(m)]\n        cnts = [[0 for _ in xrange(n)] for _ in xrange(m)]\n        for i in xrange(m):\n            for j in xrange(n):\n                if grid[i][j] == 1:\n                    cnt += 1\n                    bfs(grid, dists, cnts, i, j)\n\n        shortest = float(\"inf\")\n        for i in xrange(m):\n            for j in xrange(n):\n                if dists[i][j] < shortest and cnts[i][j] == cnt:\n                    shortest = dists[i][j]\n\n        return shortest if shortest != float(\"inf\") else -1\n\n"
    },
    {
        "problem_name": "shortest-distance-to-a-character",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def shortestToChar(self, S, C):\n        \"\"\"\n        :type S: str\n        :type C: str\n        :rtype: List[int]\n        \"\"\"\n        result = [len(S)] * len(S)\n        prev = -len(S)\n        for i in itertools.chain(xrange(len(S)),\n                                 reversed(xrange(len(S)))):\n            if S[i] == C:\n                prev = i\n            result[i] = min(result[i], abs(i-prev))\n        return result\n\n"
    },
    {
        "problem_name": "shortest-distance-to-target-color",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def shortestDistanceColor(self, colors, queries):\n        \"\"\"\n        :type colors: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        dp = [[-1 for _ in xrange(len(colors))] for _ in xrange(3)]\n        dp[colors[0]-1][0] = 0\n        for i in xrange(1, len(colors)):\n            for color in xrange(3):\n                dp[color][i] = dp[color][i-1]\n            dp[colors[i]-1][i] = i\n\n        dp[colors[len(colors)-1]-1][len(colors)-1] = len(colors)-1\n        for i in reversed(xrange(len(colors)-1)):\n            for color in xrange(3):\n                if dp[color][i+1] == -1:\n                    continue\n                if dp[color][i] == -1 or \\\n                   abs(dp[color][i+1]-i) < abs(dp[color][i]-i):\n                    dp[color][i] = dp[color][i+1]\n            dp[colors[i]-1][i] = i\n         \n        return [abs(dp[color-1][i]-i) if dp[color-1][i] != -1 else -1 \\\n                    for i, color in queries]\n"
    },
    {
        "problem_name": "shortest-distance-to-target-string-in-a-circular-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def closetTarget(self, words, target, startIndex):\n        \"\"\"\n        :type words: List[str]\n        :type target: str\n        :type startIndex: int\n        :rtype: int\n        \"\"\"\n        INF = float(\"inf\")\n        result = INF\n        for i, w in enumerate(words):\n            if w == target:\n                result = min(result, (i-startIndex)%len(words), (startIndex-i)%len(words))\n        return result if result != INF else -1\n"
    },
    {
        "problem_name": "shortest-impossible-sequence-of-rolls",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\n# constructive algorithms\nclass Solution(object):\n    def shortestSequence(self, rolls, k):\n        \"\"\"\n        :type rolls: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        l = 0\n        lookup = set()\n        for x in rolls:\n            lookup.add(x)\n            if len(lookup) != k:\n                continue\n            lookup.clear()\n            l += 1\n        return l+1\n"
    },
    {
        "problem_name": "shortest-palindrome",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# optimized from Solution2\nclass Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1] * len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j > -1 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        if not s:\n            return s\n\n        A = s + '#' + s[::-1]\n        return s[getPrefix(A)[-1]+1:][::-1] + s\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1] * len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j > -1 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        if not s:\n            return s\n\n        A = s + s[::-1]\n        prefix = getPrefix(A)\n        i = prefix[-1]\n        while i >= len(s):\n            i = prefix[i]\n        return s[i+1:][::-1] + s\n\n\n# Time:  O(n)\n# Space: O(n)\n# Manacher's Algorithm\nclass Solution3(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def preProcess(s):\n            if not s:\n                return ['^', '$']\n            string = ['^']\n            for c in s:\n                string +=  ['#', c]\n            string += ['#', '$']\n            return string\n\n        string = preProcess(s)\n        palindrome = [0] * len(string)\n        center, right = 0, 0\n        for i in xrange(1, len(string) - 1):\n            i_mirror = 2 * center - i\n            if right > i:\n                palindrome[i] = min(right - i, palindrome[i_mirror])\n            else:\n                palindrome[i] = 0\n\n            while string[i + 1 + palindrome[i]] == string[i - 1 - palindrome[i]]:\n                palindrome[i] += 1\n\n            if i + palindrome[i] > right:\n                center, right = i, i + palindrome[i]\n\n        max_len = 0\n        for i in xrange(1, len(string) - 1):\n            if i - palindrome[i] == 1:\n                max_len = palindrome[i]\n        return s[len(s)-1:max_len-1:-1] + s\n\n"
    },
    {
        "problem_name": "shortest-path-in-a-grid-with-obstacles-elimination",
        "solution": "# Time:  O(m * n * k)\n# Space: O(m * n)\n\n# A* Search Algorithm without heap\nclass Solution(object):\n    def shortestPath(self, grid, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        def dot(a, b):\n            return a[0]*b[0]+a[1]*b[1]\n\n        def g(a, b):\n            return abs(a[0]-b[0])+abs(a[1]-b[1])\n        \n        def a_star(grid, b, t, k):\n            f, dh = g(b, t), 2\n            closer, detour = [(b, k)], []\n            lookup = {}\n            while closer or detour:\n                if not closer:\n                    f += dh\n                    closer, detour = detour, closer\n                b, k = closer.pop()\n                if b == t:\n                    return f\n                if b in lookup and lookup[b] >= k:\n                    continue\n                lookup[b] = k\n                for dx, dy in directions:\n                    nb = (b[0]+dx, b[1]+dy)\n                    if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and\n                            (grid[nb[0]][nb[1]] == 0 or k > 0) and\n                            (nb not in lookup or lookup[nb] < k)):\n                        continue\n                    (closer if dot((dx, dy), (t[0]-b[0], t[1]-b[1])) > 0 else detour).append((nb, k-int(grid[nb[0]][nb[1]] == 1)))\n            return -1\n\n        return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1), k)\n"
    },
    {
        "problem_name": "shortest-path-in-a-hidden-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nclass GridMaster(object):\n    def canMove(self, direction):\n        pass\n\n    def move(self, direction):\n        pass\n\n    def isTarget(self):\n        pass\n\n\nimport collections\n\n\nclass Solution(object):\n    def findShortestPath(self, master):\n        \"\"\"\n        :type master: GridMaster\n        :rtype: int\n        \"\"\"\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}\n\n        def dfs(pos, target, master, lookup, adj):\n            if target[0] is None and master.isTarget():\n                target[0] = pos\n            lookup.add(pos)\n            for d, (di, dj) in directions.iteritems():\n                if not master.canMove(d):\n                    continue\n                nei = (pos[0]+di, pos[1]+dj)\n                adj[pos].add(nei)\n                adj[nei].add(pos)\n                if nei in lookup:\n                    continue\n                master.move(d)\n                dfs(nei, target, master, lookup, adj)\n                master.move(rollback[d])\n                        \n        def bi_bfs(adj, start, target):\n            left, right = {start}, {target}\n            lookup = set()\n            steps = 0\n            while left:\n                for pos in left:\n                    lookup.add(pos)\n                new_left = set()\n                for pos in left:\n                    if pos in right: \n                        return steps\n                    for nei in adj[pos]:\n                        if nei in lookup:\n                            continue\n                        new_left.add(nei)\n                left = new_left\n                steps += 1\n                if len(left) > len(right): \n                    left, right = right, left\n            return -1         \n        \n        start = (0, 0)\n        target = [None]\n        adj = collections.defaultdict(set)\n        dfs(start, target, master, set(), adj)\n        if not target[0]:\n            return -1\n        return bi_bfs(adj, start, target[0])\n\n\n# Time:  O(m * n)\n# Space: O(m * n)\nclass Solution2(object):\n    def findShortestPath(self, master):\n        \"\"\"\n        :type master: GridMaster\n        :rtype: int\n        \"\"\"\n        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}\n\n        def dfs(pos, target, master, lookup, adj):\n            if target[0] is None and master.isTarget():\n                target[0] = pos\n            lookup.add(pos)\n            for d, (di, dj) in directions.iteritems():\n                if not master.canMove(d):\n                    continue\n                nei = (pos[0]+di, pos[1]+dj)\n                adj[pos].add(nei)\n                adj[nei].add(pos)\n                if nei in lookup:\n                    continue\n                master.move(d)\n                dfs(nei, target, master, lookup, adj)\n                master.move(rollback[d])\n                        \n        def bfs(adj, start, target):\n            q = [start]\n            lookup = set(q)\n            steps = 0\n            while q:\n                new_q = []\n                for pos in q:\n                    if pos == target:\n                        return steps\n                    for nei in adj[pos]:\n                        if nei in lookup:\n                            continue\n                        lookup.add(nei)\n                        new_q.append(nei)\n                q = new_q\n                steps += 1\n            return -1  \n        \n        start = (0, 0)\n        target = [None]\n        adj = collections.defaultdict(set)\n        dfs(start, target, master, set(), adj)\n        if not target[0]:\n            return -1\n        return bfs(adj, start, target[0])\n"
    },
    {
        "problem_name": "shortest-path-in-binary-matrix",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def shortestPathBinaryMatrix(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(-1, -1), (-1, 0), (-1, 1), \\\n                      ( 0, -1), ( 0, 1), \\\n                      ( 1, -1), ( 1, 0), ( 1, 1)]\n        result = 0\n        q = collections.deque([(0, 0)])\n        while q:\n            result += 1\n            next_depth = collections.deque()\n            while q:\n                i, j = q.popleft()\n                if 0 <= i < len(grid) and \\\n                   0 <= j < len(grid[0]) and \\\n                    not grid[i][j]:\n                    grid[i][j] = 1\n                    if i == len(grid)-1 and j == len(grid)-1:\n                        return result\n                    for d in directions:\n                        next_depth.append((i+d[0], j+d[1]))\n            q = next_depth\n        return -1\n"
    },
    {
        "problem_name": "shortest-path-to-get-all-keys",
        "solution": "# Time:  O(k*r*c + |E|log|V|) = O(k*r*c + (k*|V|)*log|V|)\n#                             = O(k*r*c + (k*(k*2^k))*log(k*2^k))\n#                             = O(k*r*c + (k*(k*2^k))*(logk + k*log2))\n#                             = O(k*r*c + (k*(k*2^k))*k)\n#                             = O(k*r*c + k^3*2^k)\n# Space: O(|V|) = O(k*2^k)\n\nimport collections\nimport heapq\n\n\nclass Solution(object):\n    def shortestPathAllKeys(self, grid):\n        \"\"\"\n        :type grid: List[str]\n        :rtype: int\n        \"\"\"\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\n        def bfs(grid, source, locations):\n            r, c = locations[source]\n            lookup = [[False]*(len(grid[0])) for _ in xrange(len(grid))]\n            lookup[r][c] = True\n            q = collections.deque([(r, c, 0)])\n            dist = {}\n            while q:\n                r, c, d = q.popleft()\n                if source != grid[r][c] != '.':\n                    dist[grid[r][c]] = d\n                    continue\n                for direction in directions:\n                    cr, cc = r+direction[0], c+direction[1]\n                    if not ((0 <= cr < len(grid)) and\n                            (0 <= cc < len(grid[cr]))):\n                        continue\n                    if grid[cr][cc] != '#' and not lookup[cr][cc]:\n                        lookup[cr][cc] = True\n                        q.append((cr, cc, d+1))\n            return dist\n\n        locations = {place: (r, c)\n                     for r, row in enumerate(grid)\n                     for c, place in enumerate(row)\n                     if place not in '.#'}\n        dists = {place: bfs(grid, place, locations) for place in locations}\n\n        # Dijkstra's algorithm\n        min_heap = [(0, '@', 0)]\n        best = collections.defaultdict(lambda: collections.defaultdict(\n                                                   lambda: float(\"inf\")))\n        best['@'][0] = 0\n        target_state = 2**sum(place.islower() for place in locations)-1\n        while min_heap:\n            cur_d, place, state = heapq.heappop(min_heap)\n            if best[place][state] < cur_d:\n                continue\n            if state == target_state:\n                return cur_d\n            for dest, d in dists[place].iteritems():\n                next_state = state\n                if dest.islower():\n                    next_state |= (1 << (ord(dest)-ord('a')))\n                elif dest.isupper():\n                    if not (state & (1 << (ord(dest)-ord('A')))):\n                        continue\n                if cur_d+d < best[dest][next_state]:\n                    best[dest][next_state] = cur_d+d\n                    heapq.heappush(min_heap, (cur_d+d, dest, next_state))\n        return -1\n\n"
    },
    {
        "problem_name": "shortest-path-to-get-food",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nclass Solution(object):\n    def getFood(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        q = []\n        for r in xrange(len(grid)):\n            for c in xrange(len(grid[0])):\n                if grid[r][c] == '*':\n                    q.append((r, c))\n                    break\n        \n        result = 0\n        while q:\n            result += 1\n            new_q = []\n            for r, c in q:\n                for dr, dc in directions:\n                    nr, nc = r+dr, c+dc\n                    if not (0 <= nr < len(grid) and\n                            0 <= nc < len(grid[0]) and\n                            grid[nr][nc] != 'X'):\n                        continue\n                    if grid[nr][nc] == '#':\n                        return result\n                    grid[nr][nc] = 'X'\n                    new_q.append((nr, nc))\n            q = new_q \n        return -1\n"
    },
    {
        "problem_name": "shortest-path-visiting-all-nodes",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(n * 2^n)\n\nimport collections\n\n\nclass Solution(object):\n    def shortestPathLength(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = [[float(\"inf\")]*(len(graph))\n              for _ in xrange(1 << len(graph))]\n        q = collections.deque()\n        for i in xrange(len(graph)):\n            dp[1 << i][i] = 0\n            q.append((1 << i, i))\n        while q:\n            state, node = q.popleft()\n            steps = dp[state][node]\n            for nei in graph[node]:\n                new_state = state | (1 << nei)\n                if dp[new_state][nei] == float(\"inf\"):\n                    dp[new_state][nei] = steps+1\n                    q.append((new_state, nei))\n        return min(dp[-1])\n\n"
    },
    {
        "problem_name": "shortest-path-with-alternating-colors",
        "solution": "# Time:  O(n + e), e is the number of red and blue edges\n# Space: O(n + e)\n\nimport collections\n\n\nclass Solution(object):\n    def shortestAlternatingPaths(self, n, red_edges, blue_edges):\n        \"\"\"\n        :type n: int\n        :type red_edges: List[List[int]]\n        :type blue_edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        neighbors = [[set() for _ in xrange(2)] for _ in xrange(n)]\n        for i, j in red_edges:\n            neighbors[i][0].add(j)\n        for i, j in blue_edges:\n            neighbors[i][1].add(j)\n        INF = max(2*n-3, 0)+1\n        dist = [[INF, INF] for i in xrange(n)]\n        dist[0] = [0, 0]\n        q = collections.deque([(0, 0), (0, 1)])\n        while q:\n            i, c = q.popleft()\n            for j in neighbors[i][c]:\n                if dist[j][c] != INF:\n                    continue\n                dist[j][c] = dist[i][1^c]+1\n                q.append((j, 1^c))\n        return [x if x != INF else -1 for x in map(min, dist)]\n"
    },
    {
        "problem_name": "shortest-string-that-contains-three-strings",
        "solution": "# Time:  O(l)\n# Space: O(l)\n\n# brute force, longest prefix suffix, kmp algorithm\nclass Solution(object):\n    def minimumString(self, a, b, c):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :type c: str\n        :rtype: str\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j != -1 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        def KMP(text, pattern):\n            prefix = getPrefix(pattern)\n            j = -1\n            for i in xrange(len(text)):\n                while j != -1 and pattern[j+1] != text[i]:\n                    j = prefix[j]\n                if pattern[j+1] == text[i]:\n                    j += 1\n                if j+1 == len(pattern):\n                    return i-j\n            return -1\n    \n        def merge(a, b):\n            if KMP(b, a) != -1:\n                return b\n            prefix = getPrefix(b+'#'+a)            \n            l = prefix[-1]+1  # longest prefix suffix length\n            return a+b[l:]\n\n        result = [merge(a, merge(b, c)), merge(a, merge(c, b)),\n                  merge(b, merge(a, c)), merge(b, merge(c, a)),\n                  merge(c, merge(a, b)), merge(c, merge(b, a))]\n        return min(result, key=lambda x: (len(x), x))\n\n\n# Time:  O(l^2)\n# Space: O(l)\n# brute force\nclass Solution2(object):\n    def minimumString(self, a, b, c):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :type c: str\n        :rtype: str\n        \"\"\"\n        def merge(a, b):\n            if a in b:\n                return b\n            l = next((l for l in reversed(xrange(1, min(len(a), len(b)))) if a[-l:] == b[:l]), 0)\n            return a+b[l:]\n\n        result = [merge(a, merge(b, c)), merge(a, merge(c, b)),\n                  merge(b, merge(a, c)), merge(b, merge(c, a)),\n                  merge(c, merge(a, b)), merge(c, merge(b, a))]\n        return min(result, key=lambda x: (len(x), x))\n"
    },
    {
        "problem_name": "shortest-subarray-to-be-removed-to-make-array-sorted",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findLengthOfShortestSubarray(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        j = -1\n        for j in reversed(xrange(1, len(arr))):\n            if arr[j-1] > arr[j]:\n                break\n        else:\n            return 0\n        result = j\n        for i in xrange(j):\n            if i and arr[i] < arr[i-1]:\n                break\n            while j < len(arr) and arr[i] > arr[j]:\n                j += 1\n            result = min(result, (j-i+1)-2)\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def findLengthOfShortestSubarray(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(1, len(arr)):\n            if arr[i-1] <= arr[i]:\n                continue\n            j = len(arr)-1\n            while j > i and (j == len(arr)-1 or arr[j] <= arr[j+1]) and arr[i-1] <= arr[j]:\n                j -= 1\n            result = j-i+1\n            break\n        for j in reversed(xrange(len(arr)-1)):\n            if arr[j] <= arr[j+1]:\n                continue\n            i = 0\n            while i < j and (i == 0 or arr[i-1] <= arr[i]) and arr[i] <= arr[j+1]:\n                i += 1\n            result = min(result, j-i+1)\n            break\n        return result\n"
    },
    {
        "problem_name": "shortest-subarray-with-or-at-least-k-i",
        "solution": "# Time:  O(nlogr) = O(n * 30)\n# Space: O(logr) = O(30)\n\n# freq table, two pointers\nclass Solution(object):\n    def minimumSubarrayLength(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def update(x, d, curr):\n            for i in xrange(len(cnt)):\n                if x < (1<<i):\n                    break\n                if not (x&(1<<i)):\n                    continue\n                if cnt[i] == 0:\n                    curr ^= 1<<i\n                cnt[i] += d\n                if cnt[i] == 0:\n                    curr ^= 1<<i\n            return curr\n\n        total = reduce(lambda x, y: x|y, nums)\n        if total < k:\n            return -1\n        cnt = [0]*total.bit_length()\n        result = len(nums)\n        left = curr = 0\n        for right in xrange(len(nums)):\n            curr = update(nums[right], +1, curr)\n            while left <= right and curr >= k:\n                result = min(result, right-left+1)\n                curr = update(nums[left], -1, curr)\n                left += 1\n        return result \n\n\n# Time:  O(n^2)\n# Space: O(1)\n# brute force\nclass Solution2(object):\n    def minimumSubarrayLength(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = float(\"inf\")\n        for left in xrange(len(nums)):\n            curr = 0\n            for right in xrange(left, len(nums)):\n                curr |= nums[right]\n                if curr < k:\n                    continue\n                result = min(result, right-left+1)\n                break\n        return result if result != float(\"inf\") else -1\n    \n"
    },
    {
        "problem_name": "shortest-subarray-with-or-at-least-k-ii",
        "solution": "# Time:  O(nlogr) = O(n * 30)\n# Space: O(logr) = O(30)\n\n# freq table, two pointers\nclass Solution(object):\n    def minimumSubarrayLength(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def update(x, d, curr):\n            for i in xrange(len(cnt)):\n                if x < (1<<i):\n                    break\n                if not (x&(1<<i)):\n                    continue\n                if cnt[i] == 0:\n                    curr ^= 1<<i\n                cnt[i] += d\n                if cnt[i] == 0:\n                    curr ^= 1<<i\n            return curr\n\n        total = reduce(lambda x, y: x|y, nums)\n        if total < k:\n            return -1\n        cnt = [0]*total.bit_length()\n        result = len(nums)\n        left = curr = 0\n        for right in xrange(len(nums)):\n            curr = update(nums[right], +1, curr)\n            while left <= right and curr >= k:\n                result = min(result, right-left+1)\n                curr = update(nums[left], -1, curr)\n                left += 1\n        return result \n"
    },
    {
        "problem_name": "shortest-subarray-with-sum-at-least-k",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def shortestSubarray(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        accumulated_sum = [0]*(len(A)+1)\n        for i in xrange(len(A)):\n            accumulated_sum[i+1] = accumulated_sum[i]+A[i]\n\n        result = float(\"inf\")\n        mono_increasing_q = collections.deque()\n        for i, curr in enumerate(accumulated_sum):\n            while mono_increasing_q and curr <= \\\n                    accumulated_sum[mono_increasing_q[-1]]:\n                mono_increasing_q.pop()\n            while mono_increasing_q and \\\n                    curr-accumulated_sum[mono_increasing_q[0]] >= K:\n                result = min(result, i-mono_increasing_q.popleft())\n            mono_increasing_q.append(i)\n        return result if result != float(\"inf\") else -1\n\n"
    },
    {
        "problem_name": "shortest-uncommon-substring-in-an-array",
        "solution": "# Time:  O(n * l^2)\n# Space: O(t)\n\n# trie\nclass Solution(object):\n    def shortestSubstrings(self, arr):\n        \"\"\"\n        :type arr: List[str]\n        :rtype: List[str]\n        \"\"\"\n        class Trie(object):\n            def __init__(self):\n                self.__nodes = []\n                self.__cnts = []\n                self.__new_node()\n            \n            def __new_node(self):\n                self.__nodes.append([-1]*26)\n                self.__cnts.append(0)\n                return len(self.__nodes)-1\n\n            def add(self, s, d):\n                for i in xrange(len(s)):\n                    curr = 0\n                    for j in xrange(i, len(s)):\n                        x = ord(s[j])-ord('a')\n                        if self.__nodes[curr][x] == -1:\n                            self.__nodes[curr][x] = self.__new_node()\n                        curr = self.__nodes[curr][x]\n                        self.__cnts[curr] += d\n    \n            def query(self, s):\n                result = (float(\"inf\"), \"\")\n                for i in xrange(len(s)):\n                    curr = 0\n                    for j in xrange(i, len(s)):\n                        curr = self.__nodes[curr][ord(s[j])-ord('a')]\n                        if self.__cnts[curr] == 0:\n                            result = min(result, (j-i+1, s[i:j+1]))\n                            break\n                return result[1]\n    \n        trie = Trie()\n        for x in arr:\n            trie.add(x, +1)\n        result = []\n        for x in arr:\n            trie.add(x, -1)\n            result.append(trie.query(x))\n            trie.add(x, +1)\n        return result\n"
    },
    {
        "problem_name": "shortest-unsorted-continuous-subarray",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findUnsortedSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        left, right = -1, -2\n        min_from_right, max_from_left = nums[-1], nums[0]\n        for i in xrange(1, n):\n            max_from_left = max(max_from_left, nums[i])\n            min_from_right = min(min_from_right, nums[n-1-i])\n            if nums[i] < max_from_left: right = i\n            if nums[n-1-i] > min_from_right: left = n-1-i\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nclass Solution2(object):\n    def findUnsortedSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        a = sorted(nums) #sort the list\n        left, right = 0, len(nums) -1 #define left and right pointer\n        while (nums[left] == a[left] or nums[right] == a[right]):\n            if right - left <= 1:\n                return 0\n            if nums[left] == a[left]:\n                left += 1\n            if nums[right] == a[right]:\n                right -= 1\n        return right - left + 1\n\n"
    },
    {
        "problem_name": "shortest-way-to-form-string",
        "solution": "# Time:  O(m + n), m is the length of source\n#                , n is the length of target\n# Space: O(m)\n\n# greedy solution\nclass Solution(object):\n    def shortestWay(self, source, target):\n        \"\"\"\n        :type source: str\n        :type target: str\n        :rtype: int\n        \"\"\"\n        lookup = [[None for _ in xrange(26)] for _ in xrange(len(source)+1)]\n        find_char_next_pos = [None]*26\n        for i in reversed(xrange(len(source))):\n            find_char_next_pos[ord(source[i])-ord('a')] = i+1\n            lookup[i] = list(find_char_next_pos)\n\n        result, start = 1, 0\n        for c in target:\n            start = lookup[start][ord(c)-ord('a')]\n            if start != None:\n                continue\n            result += 1\n            start = lookup[0][ord(c)-ord('a')]\n            if start == None:\n                return -1\n        return result\n"
    },
    {
        "problem_name": "shortest-word-distance-ii",
        "solution": "# Time:  init: O(n), lookup: O(a + b), a, b is occurences of word1, word2\n# Space: O(n)\n\nimport collections\n\n\nclass WordDistance(object):\n    # initialize your data structure here.\n    # @param {string[]} words\n    def __init__(self, words):\n        self.wordIndex = collections.defaultdict(list)\n        for i in xrange(len(words)):\n            self.wordIndex[words[i]].append(i)\n\n    # @param {string} word1\n    # @param {string} word2\n    # @return {integer}\n    # Adds a word into the data structure.\n    def shortest(self, word1, word2):\n        indexes1 = self.wordIndex[word1]\n        indexes2 = self.wordIndex[word2]\n\n        i, j, dist = 0, 0, float(\"inf\")\n        while i < len(indexes1) and j < len(indexes2):\n            dist = min(dist, abs(indexes1[i] - indexes2[j]))\n            if indexes1[i] < indexes2[j]:\n                i += 1\n            else:\n                j += 1\n\n        return dist\n\n"
    },
    {
        "problem_name": "shortest-word-distance-iii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {string[]} words\n    # @param {string} word1\n    # @param {string} word2\n    # @return {integer}\n    def shortestWordDistance(self, words, word1, word2):\n        dist = float(\"inf\")\n        is_same = (word1 == word2)\n        i, index1, index2 = 0, None, None\n        while i < len(words):\n            if words[i] == word1:\n                if is_same and index1 is not None:\n                    dist = min(dist, abs(index1 - i))\n                index1 = i\n            elif words[i] == word2:\n                index2 = i\n\n            if index1 is not None and index2 is not None:\n                dist = min(dist, abs(index1 - index2))\n            i += 1\n\n        return dist\n\n"
    },
    {
        "problem_name": "shortest-word-distance",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {string[]} words\n    # @param {string} word1\n    # @param {string} word2\n    # @return {integer}\n    def shortestDistance(self, words, word1, word2):\n        dist = float(\"inf\")\n        i, index1, index2 = 0, None, None\n        while i < len(words):\n            if words[i] == word1:\n                index1 = i\n            elif words[i] == word2:\n                index2 = i\n\n            if index1 is not None and index2 is not None:\n                dist = min(dist, abs(index1 - index2))\n            i += 1\n\n        return dist\n\n"
    },
    {
        "problem_name": "shuffle-an-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport random\n\n\nclass Solution(object):\n\n    def __init__(self, nums):\n        \"\"\"\n\n        :type nums: List[int]\n        :type size: int\n        \"\"\"\n        self.__nums = nums\n\n\n    def reset(self):\n        \"\"\"\n        Resets the array to its original configuration and return it.\n        :rtype: List[int]\n        \"\"\"\n        return self.__nums\n\n\n    def shuffle(self):\n        \"\"\"\n        Returns a random shuffling of the array.\n        :rtype: List[int]\n        \"\"\"\n        nums = list(self.__nums)\n        for i in xrange(len(nums)):\n            j = random.randint(i, len(nums)-1)\n            nums[i], nums[j] = nums[j], nums[i]\n        return nums\n\n\n\n"
    },
    {
        "problem_name": "shuffle-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# in-place solution\nclass Solution(object):\n    def restoreString(self, s, indices):\n        \"\"\"\n        :type s: str\n        :type indices: List[int]\n        :rtype: str\n        \"\"\"\n        result = list(s)\n        for i, c in enumerate(result):\n            if indices[i] == i:\n                continue\n            move, j = c, indices[i]\n            while j != i:\n                result[j], move = move, result[j]\n                indices[j], j = j, indices[j]\n            result[i] = move\n        return \"\".join(result)\n\n\n# Time:  O(n)\n# Space: O(1)\nimport itertools\n\n\nclass Solution2(object):\n    def restoreString(self, s, indices):\n        \"\"\"\n        :type s: str\n        :type indices: List[int]\n        :rtype: str\n        \"\"\"\n        result = ['']*len(s)\n        for i, c in itertools.izip(indices, s):\n            result[i] = c\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "shuffle-the-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def shuffle(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        def index(i):\n            return 2*i if i < n else 2*(i-n)+1\n    \n        for i in xrange(len(nums)):\n            j = i\n            while nums[i] >= 0:\n                j = index(j)\n                nums[i], nums[j] = nums[j], ~nums[i]  # processed\n        for i in xrange(len(nums)):\n            nums[i] = ~nums[i]\n        return nums\n"
    },
    {
        "problem_name": "sign-of-the-product-of-an-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def arraySign(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        flag = 0\n        for x in nums:\n            if not x:\n                return 0\n            if x < 0:\n                flag ^= 1\n        return -1 if flag else 1\n"
    },
    {
        "problem_name": "similar-rgb-color",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def similarRGB(self, color):\n        \"\"\"\n        :type color: str\n        :rtype: str\n        \"\"\"\n        def rounding(color):\n            q, r = divmod(int(color, 16), 17)\n            if r > 8: q += 1\n            return '{:02x}'.format(17*q)\n\n        return '#' + \\\n                rounding(color[1:3]) + \\\n                rounding(color[3:5]) + \\\n                rounding(color[5:7])\n\n"
    },
    {
        "problem_name": "similar-string-groups",
        "solution": "# Time:  O(n^2 * l) ~ O(n * l^4)\n# Space: O(n) ~ O(n * l^3)\n\nimport collections\nimport itertools\n\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.__size = n\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        self.__size -= 1\n        return True\n\n    def size(self):\n        return self.__size\n\n\nclass Solution(object):\n    def numSimilarGroups(self, A):\n        def isSimilar(a, b):\n            diff = 0\n            for x, y in itertools.izip(a, b):\n                if x != y:\n                    diff += 1\n                    if diff > 2:\n                        return False\n            return diff == 2\n\n        N, L = len(A), len(A[0])\n        union_find = UnionFind(N)\n        if N < L*L:\n            for (i1, word1), (i2, word2) in \\\n                    itertools.combinations(enumerate(A), 2):\n                if isSimilar(word1, word2):\n                    union_find.union_set(i1, i2)\n        else:\n            buckets = collections.defaultdict(list)\n            lookup = set()\n            for i in xrange(len(A)):\n                word = list(A[i])\n                if A[i] not in lookup:\n                    buckets[A[i]].append(i)\n                    lookup.add(A[i])\n                for j1, j2 in itertools.combinations(xrange(L), 2):\n                    word[j1], word[j2] = word[j2], word[j1]\n                    buckets[\"\".join(word)].append(i)\n                    word[j1], word[j2] = word[j2], word[j1]\n            for word in A:  # Time:  O(n * l^4)\n                for i1, i2 in itertools.combinations(buckets[word], 2):\n                    union_find.union_set(i1, i2)\n        return union_find.size()\n\n"
    },
    {
        "problem_name": "simple-bank-system",
        "solution": "# Time:  ctor:     O(1)\n#        transer:  O(1)\n#        deposit:  O(1)\n#        withdraw: O(1)\n# Space: O(1)\n\nclass Bank(object):\n\n    def __init__(self, balance):\n        \"\"\"\n        :type balance: List[int]\n        \"\"\"\n        self.__balance = balance\n\n    def transfer(self, account1, account2, money):\n        \"\"\"\n        :type account1: int\n        :type account2: int\n        :type money: int\n        :rtype: bool\n        \"\"\"\n        if 1 <= account2 <= len(self.__balance) and self.withdraw(account1, money):\n            return self.deposit(account2, money)\n        return False\n\n    def deposit(self, account, money):\n        \"\"\"\n        :type account: int\n        :type money: int\n        :rtype: bool\n        \"\"\"\n        if 1 <= account <= len(self.__balance):\n            self.__balance[account-1] += money\n            return True\n        return False\n\n    def withdraw(self, account, money):\n        \"\"\"\n        :type account: int\n        :type money: int\n        :rtype: bool\n        \"\"\"\n        if 1 <= account <= len(self.__balance) and self.__balance[account-1] >= money:\n            self.__balance[account-1] -= money\n            return True\n        return False\n"
    },
    {
        "problem_name": "simplified-fractions",
        "solution": "# Time:  O(n^2 * logn)\n# Space: O(n^2)\n\nimport fractions\n\nclass Solution(object):\n    def simplifiedFractions(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        lookup = set()\n        for b in xrange(1, n+1):\n            for a in xrange(1, b):\n                g = fractions.gcd(a, b)\n                lookup.add((a//g, b//g))\n        return map(lambda x: \"{}/{}\".format(*x), lookup)\n"
    },
    {
        "problem_name": "simplify-path",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    # @param path, a string\n    # @return a string\n    def simplifyPath(self, path):\n        stack, tokens = [], path.split(\"/\")\n        for token in tokens:\n            if token == \"..\" and stack:\n                stack.pop()\n            elif token != \"..\" and token != \".\" and token:\n                stack.append(token)\n        return \"/\" + \"/\".join(stack)\n\n"
    },
    {
        "problem_name": "single-element-in-a-sorted-array",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def singleNonDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)-1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if not (mid%2 == 0 and mid+1 < len(nums) and \\\n                    nums[mid] == nums[mid+1]) and \\\n               not (mid%2 == 1 and nums[mid] == nums[mid-1]):\n                right = mid-1\n            else:\n                left = mid+1\n        return nums[left]\n\n"
    },
    {
        "problem_name": "single-number-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    # @param A, a list of integer\n    # @return an integer\n    def singleNumber(self, A):\n        one, two = 0, 0\n        for x in A:\n            one, two = (~x & one) | (x & ~one & ~two), (~x & two) | (x & one)\n        return one\n\n\nclass Solution2(object):\n    # @param A, a list of integer\n    # @return an integer\n    def singleNumber(self, A):\n        one, two, carry = 0, 0, 0\n        for x in A:\n            two |= one & x\n            one ^= x\n            carry = one & two\n            one &= ~carry\n            two &= ~carry\n        return one\n\n\nclass Solution3(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return (collections.Counter(list(set(nums)) * 3) - collections.Counter(nums)).keys()[0]\n\n\nclass Solution4(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return (sum(set(nums)) * 3 - sum(nums)) / 2\n\n\n#  every element appears 4 times except for one with 2 times\nclass SolutionEX(object):\n    # @param A, a list of integer\n    # @return an integer\n    # [1, 1, 1, 1, 2, 2, 2, 2, 3, 3]\n    def singleNumber(self, A):\n        one, two, three = 0, 0, 0\n        for x in A:\n            one, two, three = (~x & one) | (x & ~one & ~two & ~three), (~x & two) | (x & one), (~x & three) | (x & two)\n        return two\n\n"
    },
    {
        "problem_name": "single-number-iii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport operator\nimport collections\n\n\nclass Solution(object):\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def singleNumber(self, nums):\n        x_xor_y = reduce(operator.xor, nums)\n        bit =  x_xor_y & -x_xor_y\n        result = [0, 0]\n        for i in nums:\n            result[bool(i & bit)] ^= i\n        return result\n\n\nclass Solution2(object):\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def singleNumber(self, nums):\n        x_xor_y = 0\n        for i in nums:\n            x_xor_y ^= i\n\n        bit = x_xor_y & ~(x_xor_y - 1)\n\n        x = 0\n        for i in nums:\n            if i & bit:\n                x ^= i\n\n        return [x, x ^ x_xor_y]\n\n\nclass Solution3(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return [x[0] for x in sorted(collections.Counter(nums).items(), key=lambda i: i[1], reverse=False)[:2]]\n\n"
    },
    {
        "problem_name": "single-number",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport operator\nfrom functools import reduce\n\n\nclass Solution(object):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    def singleNumber(self, A):\n        return reduce(operator.xor, A)\n\n"
    },
    {
        "problem_name": "single-row-keyboard",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def calculateTime(self, keyboard, word):\n        \"\"\"\n        :type keyboard: str\n        :type word: str\n        :rtype: int\n        \"\"\"\n        lookup = {c:i for i, c in enumerate(keyboard)}\n        result, prev = 0, 0\n        for c in word:\n            result += abs(lookup[c]-prev)\n            prev = lookup[c]\n        return result\n"
    },
    {
        "problem_name": "single-threaded-cpu",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def getOrder(self, tasks):\n        \"\"\"\n        :type tasks: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        idx = range(len(tasks))\n        idx.sort(key=lambda x: tasks[x][0])\n        result, min_heap = [], []\n        i, time = 0, tasks[idx[0]][0]\n        while i < len(idx) or min_heap:\n            while i < len(idx) and tasks[idx[i]][0] <= time:\n                heapq.heappush(min_heap, (tasks[idx[i]][1], idx[i]))\n                i += 1\n            if not min_heap:\n                time = tasks[idx[i]][0]\n                continue\n            t, j = heapq.heappop(min_heap)\n            time += t\n            result.append(j)\n        return result\n"
    },
    {
        "problem_name": "sliding-puzzle",
        "solution": "# Time:  O((m * n) * (m * n)!)\n# Space: O((m * n) * (m * n)!)\n\nimport heapq\nimport itertools\n\n\n# A* Search Algorithm\nclass Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def dot(p1, p2):\n            return p1[0]*p2[0]+p1[1]*p2[1]\n\n        def heuristic_estimate(board, R, C, expected):\n            result = 0\n            for i in xrange(R):\n                for j in xrange(C):\n                    val = board[C*i + j]\n                    if val == 0: continue\n                    r, c = expected[val]\n                    result += abs(r-i) + abs(c-j)\n            return result\n\n        R, C = len(board), len(board[0])\n        begin = tuple(itertools.chain(*board))\n        end = tuple(range(1, R*C) + [0])\n        expected = {(C*i+j+1) % (R*C) : (i, j)\n                    for i in xrange(R) for j in xrange(C)}\n\n        min_steps = heuristic_estimate(begin, R, C, expected)\n        closer, detour = [(begin.index(0), begin)], []\n        lookup = set()\n        while True:\n            if not closer:\n                if not detour:\n                    return -1\n                min_steps += 2\n                closer, detour = detour, closer\n            zero, board = closer.pop()\n            if board == end:\n                return min_steps\n            if board not in lookup:\n                lookup.add(board)\n                r, c = divmod(zero, C)\n                for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                    i, j = r+direction[0], c+direction[1]\n                    if 0 <= i < R and 0 <= j < C:\n                        new_zero = i*C+j\n                        tmp = list(board)\n                        tmp[zero], tmp[new_zero] = tmp[new_zero], tmp[zero]\n                        new_board = tuple(tmp)\n                        r2, c2 = expected[board[new_zero]]\n                        r1, c1 = divmod(zero, C)\n                        r0, c0 = divmod(new_zero, C)\n                        is_closer = dot((r1-r0, c1-c0), (r2-r0, c2-c0)) > 0\n                        (closer if is_closer else detour).append((new_zero, new_board))\n        return min_steps\n\n\n# Time:  O((m * n) * (m * n)! * log((m * n)!))\n# Space: O((m * n) * (m * n)!)\n# A* Search Algorithm\nclass Solution2(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def heuristic_estimate(board, R, C, expected):\n            result = 0\n            for i in xrange(R):\n                for j in xrange(C):\n                    val = board[C*i + j]\n                    if val == 0: continue\n                    r, c = expected[val]\n                    result += abs(r-i) + abs(c-j)\n            return result\n\n        R, C = len(board), len(board[0])\n        begin = tuple(itertools.chain(*board))\n        end = tuple(range(1, R*C) + [0])\n        end_wrong = tuple(range(1, R*C-2) + [R*C-1, R*C-2, 0])\n        expected = {(C*i+j+1) % (R*C) : (i, j)\n                    for i in xrange(R) for j in xrange(C)}\n\n        min_heap = [(0, 0, begin.index(0), begin)]\n        lookup = {begin: 0}\n        while min_heap:\n            f, g, zero, board = heapq.heappop(min_heap)\n            if board == end: return g\n            if board == end_wrong: return -1\n            if f > lookup[board]: continue\n\n            r, c = divmod(zero, C)\n            for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                i, j = r+direction[0], c+direction[1]\n                if 0 <= i < R and 0 <= j < C:\n                    new_zero = C*i+j\n                    tmp = list(board)\n                    tmp[zero], tmp[new_zero] = tmp[new_zero], tmp[zero]\n                    new_board = tuple(tmp)\n                    f = g+1+heuristic_estimate(new_board, R, C, expected)\n                    if f < lookup.get(new_board, float(\"inf\")):\n                        lookup[new_board] = f\n                        heapq.heappush(min_heap, (f, g+1, new_zero, new_board))\n        return -1\n\n"
    },
    {
        "problem_name": "sliding-subarray-beauty",
        "solution": "# Time:  O(nlogk)\n# Space: O(k)\n\nfrom sortedcontainers import SortedList\n\n\n# sorted list, two pointers\nclass Solution(object):\n    def getSubarrayBeauty(self, nums, k, x):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type x: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        sl = SortedList()\n        for i, v in enumerate(nums): \n            if i-k >= 0:\n                sl.remove(nums[i-k])\n            sl.add(v)\n            if i-k+1 >= 0:\n                result.append(min(sl[x-1], 0))\n        return result \n"
    },
    {
        "problem_name": "sliding-window-maximum",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\nfrom collections import deque\n\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result, dq = [], deque()\n        for i in xrange(len(nums)):\n            if dq and i-dq[0] == k:\n                dq.popleft()\n            while dq and nums[dq[-1]] <= nums[i]:\n                dq.pop()\n            dq.append(i)\n            if i >= k-1:\n                result.append(nums[dq[0]])\n        return result\n"
    },
    {
        "problem_name": "sliding-window-median",
        "solution": "# Time:  O(nlogk)\n# Space: O(k)\n\nfrom sortedcontainers import SortedList\n\n\nclass Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        sl = SortedList(float(nums[i])for i in xrange(k))\n        result = [(sl[k//2]+sl[k//2-(1-k%2)])/2]\n        for i in xrange(k, len(nums)):\n            sl.add(float(nums[i]))\n            sl.remove(nums[i-k])\n            result.append((sl[k//2]+sl[k//2-(1-k%2)])/2)\n        return result\n\n\n# Time:  O(nlogk)\n# Space: O(k)\nimport collections\nimport heapq\n\n\nclass Solution2(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        def lazy_delete(heap, to_remove, sign):\n            while heap and sign*heap[0] in to_remove:\n                to_remove[sign*heap[0]] -= 1\n                if not to_remove[sign*heap[0]]:\n                    del to_remove[sign*heap[0]]\n                heapq.heappop(heap)\n\n        def full_delete(heap, to_remove, sign):  # Time: O(k), Space: O(k)\n            result = []\n            for x in heap:\n                if sign*x not in to_remove:\n                    result.append(x)\n                    continue\n                to_remove[sign*x] -= 1\n                if not to_remove[sign*x]:\n                    del to_remove[sign*x]\n            heap[:] = result\n            heapify(heap)\n\n        min_heap, max_heap = [], []\n        for i in xrange(k):\n            if i%2 == 0:\n                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))\n            else:\n                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]\n        to_remove = collections.defaultdict(int)\n        for i in xrange(k, len(nums)):\n            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n            if nums[i-k] > -max_heap[0]:\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            to_remove[nums[i-k]] += 1\n            lazy_delete(max_heap, to_remove, -1)\n            lazy_delete(min_heap, to_remove, 1)\n            if len(min_heap)+len(max_heap) > 2*k:\n                full_delete(max_heap, to_remove, -1)\n                full_delete(min_heap, to_remove, 1)\n            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)\n        return result\n\n\n# Time:  O(nlogn) due to lazy delete\n# Space: O(n)\nimport collections\nimport heapq\n\n\nclass Solution3(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        def lazy_delete(heap, to_remove, sign):\n            while heap and sign*heap[0] in to_remove:\n                to_remove[sign*heap[0]] -= 1\n                if not to_remove[sign*heap[0]]:\n                    del to_remove[sign*heap[0]]\n                heapq.heappop(heap)\n\n        min_heap, max_heap = [], []\n        for i in xrange(k):\n            if i%2 == 0:\n                heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i]))\n            else:\n                heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n        result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0]\n        to_remove = collections.defaultdict(int)\n        for i in xrange(k, len(nums)):\n            heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i]))\n            if nums[i-k] > -max_heap[0]:\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            to_remove[nums[i-k]] += 1\n            lazy_delete(max_heap, to_remove, -1)\n            lazy_delete(min_heap, to_remove, 1)\n            result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0)\n        return result\n"
    },
    {
        "problem_name": "slowest-key",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def slowestKey(self, releaseTimes, keysPressed):\n        \"\"\"\n        :type releaseTimes: List[int]\n        :type keysPressed: str\n        :rtype: str\n        \"\"\"\n        result, lookup = 'a', collections.Counter()\n        for i, c in enumerate(keysPressed):\n            lookup[c] = max(lookup[c], releaseTimes[i]-(releaseTimes[i-1] if i > 0 else 0))\n            if lookup[c] > lookup[result] or lookup[c] == lookup[result] and c > result:\n                result = c\n        return result\n"
    },
    {
        "problem_name": "smallest-common-region",
        "solution": "# Time:  O(m * n)\n# Space: O(n)\n\nclass Solution(object):\n    def findSmallestRegion(self, regions, region1, region2):\n        \"\"\"\n        :type regions: List[List[str]]\n        :type region1: str\n        :type region2: str\n        :rtype: str\n        \"\"\"\n        parents = {region[i] : region[0]\n                   for region in regions\n                   for i in xrange(1, len(region))}\n        lookup = {region1}\n        while region1 in parents:\n            region1 = parents[region1]\n            lookup.add(region1)\n        while region2 not in lookup:\n            region2 = parents[region2]\n        return region2\n"
    },
    {
        "problem_name": "smallest-even-multiple",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math, bit manipulation\nclass Solution(object):\n    def smallestEvenMultiple(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return n<<(n&1)\n"
    },
    {
        "problem_name": "smallest-good-base",
        "solution": "# Time:  O(logn * log(logn))\n# Space: O(1)\n\nimport math\n\n\nclass Solution(object):\n    def smallestGoodBase(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        num = int(n)\n        max_len = int(math.log(num,2))\n        for l in xrange(max_len, 1, -1):\n            b = int(num ** (l**-1))\n            if (b**(l+1)-1) // (b-1) == num:\n                return str(b)\n        return str(num-1)\n\n"
    },
    {
        "problem_name": "smallest-greater-multiple-made-of-two-digits",
        "solution": "# Time:  sum(O(l * 2^l) for l in range(1, 11)) = O(20 * 2^10) = O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def findInteger(self, k, digit1, digit2):\n        \"\"\"\n        :type k: int\n        :type digit1: int\n        :type digit2: int\n        :rtype: int\n        \"\"\"\n        MAX_NUM_OF_DIGITS = 10\n        INT_MAX = 2**31-1\n\n        if digit1 < digit2:\n            digit1, digit2 = digit2, digit1\n        total = 2\n        for l in xrange(1, MAX_NUM_OF_DIGITS+1):\n            for mask in xrange(total):\n                curr, bit = 0, total>>1\n                while bit:\n                    curr = curr*10 + (digit1 if mask&bit else digit2)\n                    bit >>= 1\n                if k < curr <= INT_MAX and curr%k == 0:\n                    return curr\n            total <<= 1\n        return -1\n"
    },
    {
        "problem_name": "smallest-index-with-equal-value",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def smallestEqual(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return next((i for i, x in enumerate(nums) if i%10 == x), -1)\n"
    },
    {
        "problem_name": "smallest-integer-divisible-by-k",
        "solution": "# Time:  O(k)\n# Space: O(1)\n\nclass Solution(object):\n    def smallestRepunitDivByK(self, K):\n        \"\"\"\n        :type K: int\n        :rtype: int\n        \"\"\"\n        # by observation, K % 2 = 0 or K % 5 = 0, it is impossible\n        if K % 2 == 0 or K % 5 == 0:\n            return -1\n\n        # let f(N) is a N-length integer only containing digit 1\n        # if there is no N in range (1..K) s.t. f(N) % K = 0\n        # => there must be K remainders of f(N) % K in range (1..K-1) excluding 0\n        # => due to pigeonhole principle, there must be at least 2 same remainders\n        # => there must be some x, y in range (1..K) and x > y s.t. f(x) % K = f(y) % K\n        # => (f(x) - f(y)) % K = 0\n        # => (f(x-y) * 10^y) % K = 0\n        # => due to (x-y) in range (1..K)\n        # => f(x-y) % K != 0\n        # => 10^y % K = 0\n        # => K % 2 = 0 or K % 5 = 0\n        # => -><-\n        # it proves that there must be some N in range (1..K) s.t. f(N) % K = 0\n        result = 0\n        for N in xrange(1, K+1):\n            result = (result*10+1) % K\n            if not result:\n                return N\n        assert(False)\n        return -1  # never reach\n"
    },
    {
        "problem_name": "smallest-k-length-subsequence-with-occurrences-of-a-letter",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def smallestSubsequence(self, s, k, letter, repetition):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :type letter: str\n        :type repetition: int\n        :rtype: str\n        \"\"\"\n        stk = []\n        suffix = [0]*(len(s)+1)\n        for i in reversed(xrange(len(suffix)-1)):\n            suffix[i] = suffix[i+1]+(s[i] == letter)\n        for i, c in enumerate(s): \n            while stk and stk[-1] > c and len(stk)+(len(s)-i) > k and (stk[-1] != letter or repetition+1 <= suffix[i]):\n                repetition += (stk.pop() == letter)\n            if len(stk) < min(k-(repetition-(c == letter)), k):\n                repetition -= (c == letter)\n                stk.append(c)\n        return \"\".join(stk)\n"
    },
    {
        "problem_name": "smallest-missing-genetic-value-in-each-subtree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def smallestMissingValueSubtree(self, parents, nums):\n        \"\"\"\n        :type parents: List[int]\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def iter_dfs(adj, nums, i, lookup):\n            stk = [i]\n            while stk:\n                i = stk.pop()\n                if nums[i] in lookup:\n                    continue\n                lookup.add(nums[i])\n                for j in adj[i]:\n                    stk.append(j)\n\n        result = [1]*len(parents)\n        i = next((i for i in xrange(len(nums)) if nums[i] == 1), -1)\n        if i == -1:\n            return result\n        adj = [[] for _ in xrange(len(parents))]\n        for j in xrange(1, len(parents)):\n            adj[parents[j]].append(j)\n        lookup = set()\n        miss = 1\n        while i >= 0:\n            iter_dfs(adj, nums, i, lookup)\n            while miss in lookup:\n                miss += 1\n            result[i] = miss\n            i = parents[i]\n        return result\n"
    },
    {
        "problem_name": "smallest-missing-integer-greater-than-sequential-prefix-sum",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table\nclass Solution(object):\n    def missingInteger(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        total = nums[0]\n        for i in xrange(1, len(nums)):\n            if nums[i] != nums[i-1]+1:\n                break\n            total += nums[i]\n        lookup = set(nums)\n        while total in lookup:\n            total += 1\n        return total\n"
    },
    {
        "problem_name": "smallest-missing-non-negative-integer-after-operations",
        "solution": "# Time:  O(n)\n# Space: O(k), k = value\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def findSmallestInteger(self, nums, value):\n        \"\"\"\n        :type nums: List[int]\n        :type value: int\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(x%value for x in nums)\n        mn = min((cnt[i], i) for i in xrange(value))[1]\n        return value*cnt[mn]+mn\n        \n\n# Time:  O(n)\n# Space: O(k), k = value\nimport collections\n\n\n# freq table\nclass Solution2(object):\n    def findSmallestInteger(self, nums, value):\n        \"\"\"\n        :type nums: List[int]\n        :type value: int\n        :rtype: int\n        \"\"\"\n        cnt = collections.Counter(x%value for x in nums)\n        for i in xrange(len(nums)+1):\n            if not cnt[i%value]:\n                return i\n            cnt[i%value] -= 1\n"
    },
    {
        "problem_name": "smallest-number-in-infinite-set",
        "solution": "# Time:  ctor:        O(1)\n#        popSmallest: O(logn)\n#        addBack:     O(logn)\n# Space: O(n)\n\nimport heapq\n\n\n# heap\nclass SmallestInfiniteSet(object):\n\n    def __init__(self):\n        self.__n = 1\n        self.__lookup = set()\n        self.__min_heap = []\n\n    def popSmallest(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.__min_heap:\n            result = heapq.heappop(self.__min_heap)\n            self.__lookup.remove(result)\n            return result\n        result = self.__n\n        self.__n += 1\n        return result\n\n    def addBack(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: None\n        \"\"\"\n        if num >= self.__n or num in self.__lookup:\n            return\n        self.__lookup.add(num)\n        heapq.heappush(self.__min_heap, num)\n"
    },
    {
        "problem_name": "smallest-number-with-given-digit-product",
        "solution": "# Time:  O(logn)\n# Space: O(logn)\n\n# greedy\nclass Solution(object):\n    def smallestNumber(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        result = []\n        for d in reversed(xrange(2, 9+1)):\n            while n%d == 0:\n                result.append(d)\n                n //= d\n        return \"\".join(map(str, reversed(result))) or \"1\" if n == 1 else \"-1\"\n"
    },
    {
        "problem_name": "smallest-range-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def smallestRangeI(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        return max(0, max(A) - min(A) - 2*K)\n\n"
    },
    {
        "problem_name": "smallest-range-ii",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def smallestRangeII(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        A.sort()\n        result = A[-1]-A[0]\n        for i in xrange(len(A)-1):\n            result = min(result,\n                         max(A[-1]-K, A[i]+K) -\n                         min(A[0]+K, A[i+1]-K))\n        return result\n\n"
    },
    {
        "problem_name": "smallest-range",
        "solution": "# Time:  O(nlogk)\n# Space: O(k)\n\nimport heapq\n\n\nclass Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        left, right = float(\"inf\"), float(\"-inf\")\n        min_heap = []\n        for row in nums:\n            left = min(left, row[0])\n            right = max(right, row[0])\n            it = iter(row)\n            heapq.heappush(min_heap, (next(it, None), it))\n\n        result = (left, right)\n        while min_heap:\n            (val, it) = heapq.heappop(min_heap)\n            val = next(it, None)\n            if val is None:\n                break\n            heapq.heappush(min_heap, (val, it))\n            left, right = min_heap[0][0], max(right, val)\n            if right - left < result[1] - result[0]:\n                result = (left, right)\n        return result\n\n"
    },
    {
        "problem_name": "smallest-rectangle-enclosing-black-pixels",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nimport bisect\nimport itertools\n\n\nclass Solution(object):\n    def minArea(self, image, x, y):\n        \"\"\"\n        :type image: List[List[str]]\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        def binarySearch(left, right, find, image, has_one):\n            while left <= right:  # O(logn) times\n                mid = left + (right - left) / 2\n                if find(image, has_one, mid):  # Time: O(n)\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n\n\n        searchColumns = lambda image, has_one, mid: any([int(row[mid]) for row in image]) == has_one\n        left = binarySearch(0, y - 1, searchColumns, image, True)\n        right = binarySearch(y + 1, len(image[0]) - 1, searchColumns, image, False)\n\n        searchRows = lambda image, has_one, mid: any(itertools.imap(int, image[mid])) == has_one\n        top = binarySearch(0, x - 1, searchRows, image, True)\n        bottom = binarySearch(x + 1, len(image) - 1, searchRows, image, False)\n\n        return (right - left) * (bottom - top)\n\n"
    },
    {
        "problem_name": "smallest-rotation-with-highest-score",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def bestRotation(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        N = len(A)\n        change = [1] * N\n        for i in xrange(N):\n            change[(i-A[i]+1)%N] -= 1\n        for i in xrange(1, N):\n            change[i] += change[i-1]\n        return change.index(max(change))\n\n\n"
    },
    {
        "problem_name": "smallest-string-starting-from-leaf",
        "solution": "# Time:  O(n + l * h), l is the number of leaves\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def smallestFromLeaf(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def dfs(node, candidate, result):\n            if not node:\n                return\n\n            candidate.append(chr(ord('a') + node.val))\n            if not node.left and not node.right:\n                result[0] = min(result[0], \"\".join(reversed(candidate)))\n            dfs(node.left, candidate, result)\n            dfs(node.right, candidate, result)\n            candidate.pop()\n\n        result = [\"~\"]\n        dfs(root, [], result)\n        return result[0]\n"
    },
    {
        "problem_name": "smallest-string-with-a-given-numeric-value",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def getSmallestString(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        MAX_DIFF = ord('z')-ord('a')\n\n        k -= n\n        result = ['a']*n\n        for i in reversed(xrange(n)):\n            tmp = min(k, MAX_DIFF)\n            result[i] = chr(ord('a')+tmp)\n            k -= tmp\n            if k == 0:\n                break\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "smallest-string-with-swaps",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[max(x_root, y_root)] = min(x_root, y_root)\n        return True\n\n\nclass Solution(object):\n    def smallestStringWithSwaps(self, s, pairs):\n        \"\"\"\n        :type s: str\n        :type pairs: List[List[int]]\n        :rtype: str\n        \"\"\"\n        union_find = UnionFind(len(s))\n        for x,y in pairs: \n            union_find.union_set(x, y)\n        components = collections.defaultdict(list)\n        for i in xrange(len(s)): \n            components[union_find.find_set(i)].append(s[i])\n        for i in components.iterkeys(): \n            components[i].sort(reverse=True)\n        result = []\n        for i in xrange(len(s)): \n            result.append(components[union_find.find_set(i)].pop())\n        return \"\".join(result)\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nimport itertools\nclass Solution2(object):\n    def smallestStringWithSwaps(self, s, pairs):\n        \"\"\"\n        :type s: str\n        :type pairs: List[List[int]]\n        :rtype: str\n        \"\"\"\n        def dfs(i, adj, lookup, component):\n            lookup.add(i)\n            component.append(i)\n            for j in adj[i]:\n                if j in lookup:\n                    continue\n                dfs(j, adj, lookup, component)\n            \n        adj = collections.defaultdict(list)\n        for i, j in pairs:\n            adj[i].append(j)\n            adj[j].append(i)\n        lookup = set()\n        result = list(s)\n        for i in xrange(len(s)):\n            if i in lookup:\n                continue\n            component = []\n            dfs(i, adj, lookup, component)\n            component.sort()\n            chars = sorted(result[k] for k in component)\n            for comp, char in itertools.izip(component, chars):\n                result[comp] = char\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "smallest-subarrays-with-maximum-bitwise-or",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# bitmasks, hash table\nclass Solution(object):\n    def smallestSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(nums)\n        lookup = [-1]*max(max(nums).bit_length(), 1)\n        for i in reversed(xrange(len(nums))):\n            for bit in xrange(len(lookup)):\n                if nums[i]&(1<<bit):\n                    lookup[bit] = i\n            result[i] = max(max(lookup)-i+1, 1)\n        return result\n"
    },
    {
        "problem_name": "smallest-subsequence-of-distinct-characters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def smallestSubsequence(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: str\n        \"\"\"\n        count = collections.Counter(text)\n\n        lookup, stk = set(), []\n        for c in text:\n            if c not in lookup:\n                while stk and stk[-1] > c and count[stk[-1]]:\n                    lookup.remove(stk.pop())\n                stk += c\n                lookup.add(c)\n            count[c] -= 1\n        return \"\".join(stk)\n"
    },
    {
        "problem_name": "smallest-subtree-with-all-the-deepest-nodes",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nimport collections\n\n\nclass Solution(object):\n    def subtreeWithAllDeepest(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        Result = collections.namedtuple(\"Result\", (\"node\", \"depth\"))\n\n        def dfs(node):\n            if not node:\n                return Result(None, 0)\n            left, right = dfs(node.left), dfs(node.right)\n            if left.depth > right.depth:\n                return Result(left.node, left.depth+1)\n            if left.depth < right.depth:\n                return Result(right.node, right.depth+1)\n            return Result(node, left.depth+1)\n\n        return dfs(root).node\n\n"
    },
    {
        "problem_name": "smallest-sufficient-team",
        "solution": "# Time:  O(m * 2^n), n is the number of skills\n#                    m is the number of people\n# Space: O(2^n)\n\nclass Solution(object):\n    def smallestSufficientTeam(self, req_skills, people):\n        \"\"\"\n        :type req_skills: List[str]\n        :type people: List[List[str]]\n        :rtype: List[int]\n        \"\"\"\n        lookup = {v: i for i, v in enumerate(req_skills)}\n        dp = {0: []}\n        for i, p in enumerate(people):\n            his_skill_set = 0\n            for skill in p:\n                if skill in lookup:\n                    his_skill_set |= 1 << lookup[skill]\n            for skill_set, people in dp.items():\n                with_him = skill_set | his_skill_set\n                if with_him == skill_set: continue\n                if with_him not in dp or \\\n                   len(dp[with_him]) > len(people)+1:\n                    dp[with_him] = people + [i]\n        return dp[(1<<len(req_skills))-1]\n"
    },
    {
        "problem_name": "smallest-value-after-replacing-with-sum-of-prime-factors",
        "solution": "# Time:  O(s * logn), s is the times of simulation\n# Space: O(max_n^0.5)\n\n# number theory, simulation\ndef linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)\n    primes = []\n    spf = [-1]*(n+1)  # the smallest prime factor\n    for i in xrange(2, n+1):\n        if spf[i] == -1:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if i*p > n or p > spf[i]:\n                break\n            spf[i*p] = p\n    return primes\n\n\nMAX_N = 10**5\nPRIMES = linear_sieve_of_eratosthenes(int(MAX_N**0.5))\nclass Solution(object):\n    def smallestValue(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        while True:\n            curr, new_n = n, 0\n            for p in PRIMES:\n                if p**2 > curr:\n                    break\n                while curr%p == 0:\n                    curr //= p\n                    new_n += p\n            if curr > 1:  # curr is a prime\n                new_n += curr\n            if new_n == n:\n                break\n            n = new_n\n        return n\n"
    },
    {
        "problem_name": "smallest-value-of-the-rearranged-number",
        "solution": "# Time:  O(d), d is the number of digits\n# Space: O(d)\n\n# greedy, counting sort\nclass Solution(object):\n    def smallestNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        def inplace_counting_sort(nums, reverse=False):  # Time: O(n)\n            count = [0]*(max(nums)+1)\n            for num in nums:\n                count[num] += 1\n            for i in xrange(1, len(count)):\n                count[i] += count[i-1]\n            for i in reversed(xrange(len(nums))):  # inplace but unstable sort\n                while nums[i] >= 0:\n                    count[nums[i]] -= 1\n                    j = count[nums[i]]\n                    nums[i], nums[j] = nums[j], ~nums[i]\n            for i in xrange(len(nums)):\n                nums[i] = ~nums[i]  # restore values\n            if reverse:  # unstable sort\n                nums.reverse()\n\n        sign = 1 if num >= 0 else -1\n        nums = map(int, list(str(abs(num))))\n        inplace_counting_sort(nums, reverse=(sign == -1))\n        i = next((i for i in xrange(len(nums)) if nums[i] != 0), 0)\n        nums[0], nums[i] = nums[i], nums[0]\n        return sign*int(\"\".join(map(str, nums)))\n\n\n# Time:  O(dlogd), d is the number of digits\n# Space: O(d)\n# greedy\nclass Solution2(object):\n    def smallestNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        sign = 1 if num >= 0 else -1\n        nums = sorted(str(abs(num)), reverse=(sign == -1))\n        i = next((i for i in xrange(len(nums)) if nums[i] != '0'), 0)\n        nums[0], nums[i] = nums[i], nums[0]\n        return sign*int(\"\".join(nums))\n"
    },
    {
        "problem_name": "snakes-and-ladders",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nimport collections\n\n\nclass Solution(object):\n    def snakesAndLadders(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def coordinate(n, s):\n            a, b = divmod(s-1, n)\n            r = n-1-a\n            c = b if r%2 != n%2 else n-1-b\n            return r, c\n\n        n = len(board)\n        lookup = {1: 0}\n        q = collections.deque([1])\n        while q:\n            s = q.popleft()\n            if s == n*n:\n                return lookup[s]\n            for s2 in xrange(s+1, min(s+6, n*n)+1):\n                r, c = coordinate(n, s2)\n                if board[r][c] != -1:\n                    s2 = board[r][c]\n                if s2 not in lookup:\n                    lookup[s2] = lookup[s]+1\n                    q.append(s2)\n        return -1\n\n"
    },
    {
        "problem_name": "snapshot-array",
        "solution": "# Time:  set: O(1)\n#        get: O(logn), n is the total number of set\n# Space: O(n)\n\nimport collections\nimport bisect\n\n\nclass SnapshotArray(object):\n\n    def __init__(self, length):\n        \"\"\"\n        :type length: int\n        \"\"\"\n        self.__A = collections.defaultdict(lambda: [[0, 0]])\n        self.__snap_id = 0\n\n\n    def set(self, index, val):\n        \"\"\"\n        :type index: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if self.__A[index][-1][0] == self.__snap_id:\n            self.__A[index][-1][1] = val\n        else:\n            self.__A[index].append([self.__snap_id, val])\n\n\n    def snap(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.__snap_id += 1\n        return self.__snap_id - 1\n\n\n    def get(self, index, snap_id):\n        \"\"\"\n        :type index: int\n        :type snap_id: int\n        :rtype: int\n        \"\"\"\n        i = bisect.bisect_left(self.__A[index], [snap_id+1, float(\"-inf\")]) - 1\n        return self.__A[index][i][1]   \n"
    },
    {
        "problem_name": "solve-the-equation",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport re\n\n\nclass Solution(object):\n    def solveEquation(self, equation):\n        \"\"\"\n        :type equation: str\n        :rtype: str\n        \"\"\"\n        a, b, side = 0, 0, 1\n        for eq, sign, num, isx in re.findall('(=)|([-+]?)(\\d*)(x?)', equation):\n            if eq:\n                side = -1\n            elif isx:\n                a += side * int(sign + '1') * int(num or 1)\n            elif num:\n                b -= side * int(sign + num)\n        return 'x=%d' % (b / a) if a else 'No solution' if b else 'Infinite solutions'\n\n"
    },
    {
        "problem_name": "solving-questions-with-brainpower",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# dp\nclass Solution(object):\n    def mostPoints(self, questions):\n        \"\"\"\n        :type questions: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = [0]*(len(questions)+1)\n        for i in reversed(xrange(len(dp)-1)):\n            dp[i] = max(dp[i+1], questions[i][0] + (dp[i+1+questions[i][1]] if i+1+questions[i][1] < len(dp) else 0))\n        return dp[0]\n"
    },
    {
        "problem_name": "sort-an-array",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# merge sort solution\nclass Solution(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def mergeSort(left, right, nums):\n            if left == right:\n                return\n            mid = left + (right-left)//2\n            mergeSort(left, mid, nums)\n            mergeSort(mid+1, right,  nums)\n            r = mid+1\n            tmp = []\n            for l in xrange(left, mid+1):\n                while r <= right and nums[r] < nums[l]:\n                    tmp.append(nums[r])\n                    r += 1\n                tmp.append(nums[l])\n            nums[left:left+len(tmp)] = tmp\n\n        mergeSort(0, len(nums)-1, nums)\n        return nums\n\n\n# Time:  O(nlogn), on average\n# Space: O(logn)\nimport random\n# quick sort solution\nclass Solution2(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def nth_element(nums, left, n, right, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target):\n                i = left\n                while i <= right:\n                    if compare(nums[i], target):\n                        nums[i], nums[left] = nums[left], nums[i]\n                        left += 1\n                        i += 1\n                    elif compare(target, nums[i]):\n                        nums[i], nums[right] = nums[right], nums[i]\n                        right -= 1\n                    else:\n                        i += 1\n                return left, right\n\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx])\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        def quickSort(left, right, nums):\n            if left > right:\n                return\n            mid = left + (right-left)//2\n            nth_element(nums, left, mid, right)\n            quickSort(left, mid-1, nums)\n            quickSort(mid+1, right, nums)\n\n        quickSort(0, len(nums)-1, nums)\n        return nums\n"
    },
    {
        "problem_name": "sort-array-by-increasing-frequency",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def frequencySort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        count = collections.Counter(nums)\n        return sorted(nums, key=lambda x: (count[x], -x))\n"
    },
    {
        "problem_name": "sort-array-by-moving-items-to-empty-space",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# greedy, sort\nclass Solution(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def min_moves(d):\n            def index(x):\n                return d*(len(nums)-1) if x == 0 else x-d\n\n            lookup = [False]*len(nums)\n            result = len(nums)\n            for i in xrange(len(nums)):\n                if lookup[nums[i]]:\n                    continue\n                l = 0\n                while not lookup[nums[i]]:\n                    lookup[nums[i]] = True\n                    l += 1\n                    i = index(nums[i])\n                result -= 1\n                if l >= 2:\n                    result += 2\n            return result-2*int(nums[d*(len(nums)-1)] != 0)\n\n        return min(min_moves(0), min_moves(1))\n\n\n# Time:  O(n)\n# Space: O(n)\n# greedy, sort\nclass Solution2(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def min_moves(d):\n            def index(x):\n                return d*(len(nums)-1) if x == 0 else x-d\n\n            a = nums[:]\n            result = 0\n            for i in xrange(len(a)):\n                l, has_zero = 1, (a[i] == 0)\n                while index(a[i]) != i:\n                    j = index(a[i])\n                    a[i], a[j] = a[j], a[i]\n                    l += 1\n                    has_zero |= (a[i] == 0)\n                if l >= 2:\n                    result += l-1 if has_zero else l+1\n            return result\n\n        return min(min_moves(0), min_moves(1))\n"
    },
    {
        "problem_name": "sort-array-by-parity-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def sortArrayByParityII(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        j = 1\n        for i in xrange(0, len(A), 2):\n            if A[i] % 2:\n                while A[j] % 2:\n                    j += 2\n                A[i], A[j] = A[j], A[i]\n        return A\n"
    },
    {
        "problem_name": "sort-array-by-parity",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def sortArrayByParity(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        i = 0\n        for j in xrange(len(A)):\n            if A[j] % 2 == 0:\n                A[i], A[j] = A[j], A[i]\n                i += 1\n        return A\n\n"
    },
    {
        "problem_name": "sort-characters-by-frequency",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def frequencySort(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        freq = collections.defaultdict(int)\n        for c in s:\n            freq[c] += 1\n\n        counts = [\"\"] * (len(s)+1)\n        for c in freq:\n            counts[freq[c]] += c\n\n        result = \"\"\n        for count in reversed(xrange(len(counts)-1)):\n            for c in counts[count]:\n                result += c * count\n\n        return result\n\n"
    },
    {
        "problem_name": "sort-colors",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        def triPartition(nums, target):\n            i, left, right = 0, 0, len(nums)-1\n            while i <= right:\n                if nums[i] > target:\n                    nums[i], nums[right] = nums[right], nums[i]\n                    right -= 1\n                else:\n                    if nums[i] < target:\n                        nums[left], nums[i] = nums[i], nums[left]\n                        left += 1\n                    i += 1\n\n        triPartition(nums, 1)\n"
    },
    {
        "problem_name": "sort-even-and-odd-indices-independently",
        "solution": "# Time:  O(n)\n# Space: O(c), c is the max of nums\n\n# counting sort, inplace solution\nclass Solution(object):\n    def sortEvenOdd(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def partition(index, nums):\n            for i in xrange(len(nums)):\n                j = i\n                while nums[i] >= 0:\n                    j = index(j)\n                    nums[i], nums[j] = nums[j], ~nums[i]  # processed\n            for i in xrange(len(nums)):\n                nums[i] = ~nums[i]  # restore values\n\n        def inplace_counting_sort(nums, left, right, reverse=False):  # Time: O(n)\n            if right-left+1 == 0:\n                return\n            count = [0]*(max(nums[i] for i in xrange(left, right+1))+1)\n            for i in xrange(left, right+1):\n                count[nums[i]] += 1\n            for i in xrange(1, len(count)):\n                count[i] += count[i-1]\n            for i in reversed(xrange(left, right+1)):  # inplace but unstable sort\n                while nums[i] >= 0:\n                    count[nums[i]] -= 1\n                    j = left+count[nums[i]]\n                    nums[i], nums[j] = nums[j], ~nums[i]\n            for i in xrange(left, right+1):\n                nums[i] = ~nums[i]  # restore values\n            if reverse:  # unstable\n                while left < right:\n                    nums[left], nums[right] = nums[right], nums[left]\n                    left += 1\n                    right -= 1\n\n        partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums)\n        inplace_counting_sort(nums, 0, (len(nums)+1)//2-1)\n        inplace_counting_sort(nums, (len(nums)+1)//2, len(nums)-1, True)\n        partition(lambda i: 2*i if i < (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums)\n        return nums\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# sort, inplace solution\nclass Solution2(object):\n    def sortEvenOdd(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def partition(index, nums):\n            for i in xrange(len(nums)):\n                j = i\n                while nums[i] >= 0:\n                    j = index(j)\n                    nums[i], nums[j] = nums[j], ~nums[i]  # processed\n            for i in xrange(len(nums)):\n                nums[i] = ~nums[i]  # restore values\n        \n        partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums)\n        nums[:(len(nums)+1)//2], nums[(len(nums)+1)//2:] = sorted(nums[:(len(nums)+1)//2]), sorted(nums[(len(nums)+1)//2:], reverse=True)\n        partition(lambda i: 2*i if i < (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums)\n        return nums\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# sort\nclass Solution3(object):\n    def sortEvenOdd(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        nums[::2], nums[1::2] = sorted(nums[::2]), sorted(nums[1::2], reverse=True)\n        return nums\n"
    },
    {
        "problem_name": "sort-features-by-popularity",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def sortFeatures(self, features, responses):\n        \"\"\"\n        :type features: List[str]\n        :type responses: List[str]\n        :rtype: List[str]\n        \"\"\"\n        features_set = set(features)\n        order = {word: i for i, word in enumerate(features)}\n        freq = collections.defaultdict(int)\n        for r in responses:\n            for word in set(r.split(' ')):\n                if word in features_set:\n                    freq[word] += 1\n        features.sort(key=lambda x: (-freq[x], order[x]))\n        return features\n"
    },
    {
        "problem_name": "sort-integers-by-the-number-of-1-bits",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def sortByBits(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def popcount(n):  # Time: O(logn) ~= O(1) if n is a 32-bit number\n            result = 0\n            while n:\n                n &= n - 1\n                result += 1\n            return result\n        \n        arr.sort(key=lambda x: (popcount(x), x))\n        return arr\n"
    },
    {
        "problem_name": "sort-integers-by-the-power-value",
        "solution": "# Time:  O(n) on average\n# Space: O(n)\n\nimport random\n\n\nclass Solution(object):\n    dp = {}\n\n    def getKth(self, lo, hi, k):\n        \"\"\"\n        :type lo: int\n        :type hi: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def partition_around_pivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == n:\n                    return\n                elif new_pivot_idx > n:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < n\n                    left = new_pivot_idx + 1\n                    \n        def power_value(x):\n            y, result = x, 0\n            while x > 1 and x not in Solution.dp:\n                result += 1\n                if x%2:\n                    x = 3*x + 1\n                else:\n                    x //= 2\n            Solution.dp[y] = result + (Solution.dp[x] if x > 1 else 0)\n            return Solution.dp[y], y\n        \n        arr = map(power_value, range(lo, hi+1))\n        nth_element(arr, k-1)\n        return arr[k-1][1]\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nclass Solution2(object):\n    dp = {}\n\n    def getKth(self, lo, hi, k):\n        \"\"\"\n        :type lo: int\n        :type hi: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def power_value(x):\n            y, result = x, 0\n            while x > 1 and x not in Solution2.dp:\n                result += 1\n                if x%2:\n                    x = 3*x + 1\n                else:\n                    x //= 2\n            Solution2.dp[y] = result + (Solution2.dp[x] if x > 1 else 0)\n            return Solution2.dp[y], y\n        \n        return sorted(range(lo, hi+1), key=power_value)[k-1]\n"
    },
    {
        "problem_name": "sort-items-by-groups-respecting-dependencies",
        "solution": "# Time:  O(n + e)\n# Space: O(n + e)\n\nimport collections\n\n\nclass Topo(object):\n    def __init__(self):\n        self.__nodes = set()\n        self.__in_degree = collections.defaultdict(set)\n        self.__out_degree = collections.defaultdict(set)\n        \n    def add_node(self, node):\n        self.__nodes.add(node)\n    \n    def add_edge(self, src, dst):\n        self.add_node(src), self.add_node(dst)\n        self.__in_degree[dst].add(src)\n        self.__out_degree[src].add(dst)\n    \n    def sort(self):\n        q = collections.deque()\n        result = []\n        for node in self.__nodes:\n            if node not in self.__in_degree:\n                q.append(node)\n        while q:\n            node = q.popleft()\n            result.append(node)\n            for nei in self.__out_degree[node]:\n                self.__in_degree[nei].remove(node)\n                if not self.__in_degree[nei]:\n                    self.__in_degree.pop(nei)\n                    q.append(nei)\n        if len(result) < len(self.__nodes):\n            return\n        return result\n\n\nclass Solution(object):\n    def sortItems(self, n, m, group, beforeItems):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :type group: List[int]\n        :type beforeItems: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        for i in xrange(n):\n            if group[i] == -1:\n                group[i] = m\n                m += 1    \n        global_group = Topo()\n        for i in xrange(m):\n            global_group.add_node(i)\n        local_groups = collections.defaultdict(Topo)\n        for i in xrange(n):\n            local_groups[group[i]].add_node(i)\n        for i in xrange(n):\n            for j in beforeItems[i]:\n                if group[i] == group[j]:\n                    local_groups[group[i]].add_edge(j, i)\n                else:\n                    global_group.add_edge(group[j], group[i]);\n        result = []\n        global_order = global_group.sort()\n        if global_order is None:\n            return []\n        for i in global_order:\n            local_order = local_groups[i].sort();\n            if local_order is None:\n                return []\n            for x in local_order:\n                result.append(x)\n        return result\n"
    },
    {
        "problem_name": "sort-linked-list-already-sorted-using-absolute-values",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution(object):\n    def sortLinkedList(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        tail, curr, head.next = head, head.next, None\n        while curr:\n            if curr.val > 0:\n                curr.next, tail.next, tail, curr = None, curr, curr, curr.next\n            else:\n                curr.next, head, curr = head, curr, curr.next\n        return head\n"
    },
    {
        "problem_name": "sort-list",
        "solution": "# Time:  O(nlogn)\n# Space: O(logn) for stack call\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, repr(self.next))\n\nclass Solution(object):\n    # @param head, a ListNode\n    # @return a ListNode\n    def sortList(self, head):\n        if head == None or head.next == None:\n            return head\n\n        fast, slow, prev = head, head, None\n        while fast != None and fast.next != None:\n            prev, fast, slow = slow, fast.next.next, slow.next\n        prev.next = None\n\n        sorted_l1 = self.sortList(head)\n        sorted_l2 = self.sortList(slow)\n\n        return self.mergeTwoLists(sorted_l1, sorted_l2)\n\n    def mergeTwoLists(self, l1, l2):\n        dummy = ListNode(0)\n\n        cur = dummy\n        while l1 != None and l2 != None:\n            if l1.val <= l2.val:\n                cur.next, cur, l1 = l1, l1, l1.next\n            else:\n                cur.next, cur, l2 = l2, l2, l2.next\n\n        if l1 != None:\n            cur.next = l1\n        if l2 != None:\n            cur.next = l2\n\n        return dummy.next\n\n"
    },
    {
        "problem_name": "sort-the-jumbled-numbers",
        "solution": "# Time:  O(nlogm + nlogn), m is the max of nums\n# Space: O(n)\n\n# sort\nclass Solution(object):\n    def sortJumbled(self, mapping, nums):\n        \"\"\"\n        :type mapping: List[int]\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def transform(mapping, x):\n            if not x:\n                return mapping[x]\n            result, base = 0, 1\n            while x:\n                result += mapping[x%10]*base\n                x //= 10\n                base *= 10\n            return result\n\n        return [nums[i] for _, i in sorted((transform(mapping, nums[i]), i) for i in xrange(len(nums)))]\n"
    },
    {
        "problem_name": "sort-the-matrix-diagonally",
        "solution": "# Time:  O(m * n * log(min(m, n))\n# Space: O(m * n)\n\nimport collections\n\n\nclass Solution(object):\n    def diagonalSort(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        lookup = collections.defaultdict(list)\n        for i in xrange(len(mat)):\n            for j in xrange(len(mat[0])):\n                lookup[i-j].append(mat[i][j])\n        for v in lookup.itervalues():\n            v.sort()\n        for i in reversed(xrange(len(mat))):\n            for j in reversed(xrange(len(mat[0]))):\n                mat[i][j] = lookup[i-j].pop()\n        return mat\n"
    },
    {
        "problem_name": "sort-the-people",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# sort\nclass Solution(object):\n    def sortPeople(self, names, heights):\n        \"\"\"\n        :type names: List[str]\n        :type heights: List[int]\n        :rtype: List[str]\n        \"\"\"\n        order = range(len(names))\n        order.sort(key=lambda x: heights[x], reverse=True)\n        return [names[i] for i in order]\n"
    },
    {
        "problem_name": "sort-the-students-by-their-kth-score",
        "solution": "# Time:  O(mlogm)\n# Space: O(1)\n\n# sort\nclass Solution(object):\n    def sortTheStudents(self, score, k):\n        \"\"\"\n        :type score: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        score.sort(key=lambda x: x[k], reverse=True)\n        return score\n"
    },
    {
        "problem_name": "sort-transformed-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def sortTransformedArray(self, nums, a, b, c):\n        \"\"\"\n        :type nums: List[int]\n        :type a: int\n        :type b: int\n        :type c: int\n        :rtype: List[int]\n        \"\"\"\n        f = lambda x, a, b, c : a * x * x + b * x + c\n\n        result = []\n        if not nums:\n            return result\n\n        left, right = 0, len(nums) - 1\n        d = -1 if a > 0 else 1\n        while left <= right:\n            if d * f(nums[left], a, b, c) < d * f(nums[right], a, b, c):\n                result.append(f(nums[left], a, b, c))\n                left += 1\n            else:\n                result.append(f(nums[right], a, b, c))\n                right -= 1\n\n        return result[::d]\n\n"
    },
    {
        "problem_name": "sort-vowels-in-a-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# counting sort\nclass Solution(object):\n    def sortVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def inplace_counting_sort(nums, reverse=False):  # Time: O(n)\n            if not nums:\n                return\n            count = [0]*(max(nums)+1)\n            for num in nums:\n                count[num] += 1\n            for i in xrange(1, len(count)):\n                count[i] += count[i-1]\n            for i in reversed(xrange(len(nums))):  # inplace but unstable sort\n                while nums[i] >= 0:\n                    count[nums[i]] -= 1\n                    j = count[nums[i]]\n                    nums[i], nums[j] = nums[j], ~nums[i]\n            for i in xrange(len(nums)):\n                nums[i] = ~nums[i]  # restore values\n            if reverse:  # unstable sort\n                nums.reverse()\n    \n        VOWELS = \"AEIOUaeiou\"\n        LOOKUP = {x:i for i, x in enumerate(VOWELS)}\n        vowels = [LOOKUP[x] for x in s if x in LOOKUP]\n        inplace_counting_sort(vowels, reverse=True)\n        return \"\".join(VOWELS[vowels.pop()] if x in LOOKUP else x for x in s)\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# sort\nclass Solution2(object):\n    def sortVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        VOWELS = \"AEIOUaeiou\"\n        LOOKUP = set(VOWELS)\n        vowels = [x for x in s if x in LOOKUP]\n        vowels.sort(reverse=True)\n        return \"\".join(vowels.pop() if x in LOOKUP else x for x in s)\n"
    },
    {
        "problem_name": "sorting-the-sentence",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport itertools\n\n\nclass Solution(object):\n    def sortSentence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        words = s.split()\n        for i in xrange(len(words)):\n            while int(words[i][-1])-1 != i:\n                words[int(words[i][-1])-1], words[i] = words[i], words[int(words[i][-1])-1]\n        return \" \".join(itertools.imap(lambda x: x[:-1], words))\n"
    },
    {
        "problem_name": "sorting-three-groups",
        "solution": "# Time:  O(k * n) = O(n)\n# Space: O(k) = O(1)\n\n# dp\nclass Solution(object):\n    def minimumOperations(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        k = 3\n\n        dp = [0]*k\n        for x in nums:\n            dp[x-1] += 1\n            for i in xrange(x, len(dp)):\n                dp[i] = max(dp[i], dp[i-1])\n        return len(nums)-dp[-1]\n"
    },
    {
        "problem_name": "soup-servings",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def soupServings(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: float\n        \"\"\"\n        def dp(a, b, lookup):\n            if (a, b) in lookup:\n                return lookup[a, b]\n            if a <= 0 and b <= 0:\n                return 0.5\n            if a <= 0:\n                return 1.0\n            if b <= 0:\n                return 0.0\n            lookup[a, b] = 0.25 * (dp(a-4, b, lookup) +\n                                   dp(a-3, b-1, lookup) +\n                                   dp(a-2, b-2, lookup) +\n                                   dp(a-1, b-3, lookup))\n            return lookup[a, b]\n\n        if N >= 4800:\n            return 1.0\n        lookup = {}\n        N = (N+24)//25\n        return dp(N, N, lookup)\n\n"
    },
    {
        "problem_name": "sparse-matrix-multiplication",
        "solution": "# Time:  O(m * n * l), A is m x n matrix, B is n x l matrix\n# Space: O(m * l)\n\nclass Solution(object):\n    def multiply(self, A, B):\n        \"\"\"\n        :type A: List[List[int]]\n        :type B: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        m, n, l = len(A), len(A[0]), len(B[0])\n        res = [[0 for _ in xrange(l)] for _ in xrange(m)]\n        for i in xrange(m):\n            for k in xrange(n):\n                if A[i][k]:\n                    for j in xrange(l):\n                        res[i][j] += A[i][k] * B[k][j]\n        return res\n\n"
    },
    {
        "problem_name": "special-array-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def isArraySpecial(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return all(nums[i]&1 != nums[i+1]&1 for i in xrange(len(nums)-1))\n"
    },
    {
        "problem_name": "special-array-ii",
        "solution": "# Time:  O(n + q)\n# Space: O(n)\n\n# prefix sum\nclass Solution(object):\n    def isArraySpecial(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        prefix = [0]*len(nums)\n        for i in xrange(len(nums)-1):\n            prefix[i+1] = prefix[i]+int(nums[i+1]&1 != nums[i]&1)\n        result = [False]*len(queries)\n        for i, (l, r) in enumerate(queries):\n            result[i] = prefix[r]-prefix[l] == r-l\n        return result\n"
    },
    {
        "problem_name": "special-array-with-x-elements-greater-than-or-equal-x",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# counting sort solution\nclass Solution(object):\n    def specialArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MAX_NUM = 1000\n        count = [0]*(MAX_NUM+1)\n        for num in nums:\n            count[num] += 1\n        n = len(nums)\n        for i in xrange(len(count)):\n            if i == n:\n                return i\n            n -= count[i]\n        return -1\n\n\n# Time:  O(n)\n# Space: O(1)\n# counting sort + binary search solution\nclass Solution2(object):\n    def specialArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MAX_NUM = 1000\n        def inplace_counting_sort(nums, reverse=False):  # Time: O(n)\n            count = [0]*(MAX_NUM+1)\n            for num in nums:\n                count[num] += 1\n            for i in xrange(1, len(count)):\n                count[i] += count[i-1]\n            for i in reversed(xrange(len(nums))):  # inplace but unstable sort\n                while nums[i] >= 0:\n                    count[nums[i]] -= 1\n                    j = count[nums[i]]\n                    nums[i], nums[j] = nums[j], ~nums[i]\n            for i in xrange(len(nums)):\n                nums[i] = ~nums[i]  # restore values\n            if reverse:  # unstable sort\n                nums.reverse()\n    \n        inplace_counting_sort(nums, reverse=True)\n        left, right = 0, len(nums)-1\n        while left <= right:  # Time: O(logn)\n            mid = left + (right-left)//2\n            if nums[mid] <= mid:\n                right = mid-1\n            else:\n                left = mid+1\n        return -1 if left < len(nums) and nums[left] == left else left\n\n\n# Time:  O(n)\n# Space: O(n)\n# counting sort + binary search solution\nclass Solution3(object):\n    def specialArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MAX_NUM = 1000\n        def counting_sort(nums, reverse=False):  # Time: O(n), Space: O(n)\n            count = [0]*(MAX_NUM+1)\n            for num in nums:\n                count[num] += 1\n            for i in xrange(1, len(count)):\n                count[i] += count[i-1]\n            result = [0]*len(nums)\n            if not reverse:\n                for num in reversed(nums):  # stable sort\n                    count[num] -= 1\n                    result[count[num]] = num\n            else:\n                for num in nums:  # stable sort\n                    count[num] -= 1\n                    result[count[num]] = num\n                result.reverse()\n            return result\n    \n        nums = counting_sort(nums, reverse=True)  # extra O(n) space for stable sort\n        left, right = 0, len(nums)-1\n        while left <= right:  # Time: O(logn)\n            mid = left + (right-left)//2\n            if nums[mid] <= mid:\n                right = mid-1\n            else:\n                left = mid+1\n        return -1 if left < len(nums) and nums[left] == left else left\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# sort solution\nclass Solution4(object):\n    def specialArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort(reverse=True)  # Time: O(nlogn)\n        for i in xrange(len(nums)):  # Time: O(n)\n            if nums[i] <= i:\n                break\n        else:\n            i += 1\n        return -1 if i < len(nums) and nums[i] == i else i\n"
    },
    {
        "problem_name": "special-binary-string",
        "solution": "# Time:  f(n) = k * f(n/k) + n/k * klogk <= O(logn * nlogk) <= O(n^2)\n#        n is the length of S, k is the max number of special strings in each depth\n# Space: O(n)\n\nclass Solution(object):\n    def makeLargestSpecial(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: str\n        \"\"\"\n        result = []\n        anchor = count = 0\n        for i, v in enumerate(S):\n            count += 1 if v == '1' else -1\n            if count == 0:\n                result.append(\"1{}0\".format(self.makeLargestSpecial(S[anchor+1:i])))\n                anchor = i+1\n        result.sort(reverse = True)\n        return \"\".join(result)\n\n"
    },
    {
        "problem_name": "special-permutations",
        "solution": "# Time:  O(n^2 * 2^n)\n# Space: O(n * 2^n)\n\n# backtracking, memoization\nclass Solution(object):\n    def specialPerm(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def backtracking(i, mask):\n            if mask == (1<<len(nums))-1:\n                return 1\n            if lookup[i+1][mask] == -1:\n                total = 0\n                for j in xrange(len(nums)):\n                    if mask&(1<<j):\n                        continue\n                    if not (i == -1 or nums[i]%nums[j] == 0 or nums[j]%nums[i] == 0):\n                        continue\n                    total = (total+backtracking(j, mask|(1<<j)))%MOD\n                lookup[i+1][mask] = total\n            return lookup[i+1][mask]\n\n        lookup = [[-1]*(1<<len(nums)) for _ in xrange(len(nums)+1)]\n        return backtracking(-1, 0)\n"
    },
    {
        "problem_name": "special-positions-in-a-binary-matrix",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def numSpecial(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: int\n        \"\"\"\n        rows, cols = [0]*len(mat), [0]*len(mat[0])\n        for i in xrange(len(rows)):\n            for j in xrange(len(cols)):\n                if mat[i][j]:\n                    rows[i] += 1\n                    cols[j] += 1\n        result = 0\n        for i in xrange(len(rows)):\n            for j in xrange(len(cols)):\n                if mat[i][j] == rows[i] == cols[j] == 1:\n                    result += 1\n        return result\n"
    },
    {
        "problem_name": "spiral-matrix-ii",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    # @return a list of lists of integer\n    def generateMatrix(self, n):\n        matrix = [[0 for _ in xrange(n)] for _ in xrange(n)]\n\n        left, right, top, bottom, num = 0, n - 1, 0, n - 1, 1\n\n        while left <= right and top <= bottom:\n            for j in xrange(left, right + 1):\n                matrix[top][j] = num\n                num += 1\n            for i in xrange(top + 1, bottom):\n                matrix[i][right] = num\n                num += 1\n            for j in reversed(xrange(left, right + 1)):\n                if top < bottom:\n                    matrix[bottom][j] = num\n                    num += 1\n            for i in reversed(xrange(top + 1, bottom)):\n                if left < right:\n                    matrix[i][left] = num\n                    num += 1\n            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1\n\n        return matrix\n\n\n"
    },
    {
        "problem_name": "spiral-matrix-iii",
        "solution": "# Time:  O(max(m, n)^2)\n# Space: O(1)\n\nclass Solution(object):\n    def spiralMatrixIII(self, R, C, r0, c0):\n        \"\"\"\n        :type R: int\n        :type C: int\n        :type r0: int\n        :type c0: int\n        :rtype: List[List[int]]\n        \"\"\"\n        r, c = r0, c0\n        result = [[r, c]]\n        x, y, n, i = 0, 1, 0, 0\n        while len(result) < R*C:\n            r, c, i = r+x, c+y, i+1\n            if 0 <= r < R and 0 <= c < C:\n                result.append([r, c])\n            if i == n//2+1:\n                x, y, n, i = y, -x, n+1, 0\n        return result\n\n"
    },
    {
        "problem_name": "spiral-matrix-iv",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        pass\n\n\n# linked list, array\nclass Solution(object):\n    def spiralMatrix(self, m, n, head):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type head: Optional[ListNode]\n        :rtype: List[List[int]]\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        result = [[-1]*n for _ in xrange(m)]\n        i = j = d = 0\n        while head:\n            result[i][j] = head.val\n            if not (0 <= i+directions[d][0] < m and 0 <= j+directions[d][1] < n and result[i+directions[d][0]][j+directions[d][1]] == -1):\n                d = (d+1)%4\n            i, j = i+directions[d][0], j+directions[d][1]\n            head = head.next\n        return result\n"
    },
    {
        "problem_name": "spiral-matrix",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param matrix, a list of lists of integers\n    # @return a list of integers\n    def spiralOrder(self, matrix):\n        result = []\n        if matrix == []:\n            return result\n\n        left, right, top, bottom = 0, len(matrix[0]) - 1, 0, len(matrix) - 1\n\n        while left <= right and top <= bottom:\n            for j in xrange(left, right + 1):\n                result.append(matrix[top][j])\n            for i in xrange(top + 1, bottom):\n                result.append(matrix[i][right])\n            for j in reversed(xrange(left, right + 1)):\n                if top < bottom:\n                    result.append(matrix[bottom][j])\n            for i in reversed(xrange(top + 1, bottom)):\n                if left < right:\n                    result.append(matrix[i][left])\n            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1\n\n        return result\n\n\n"
    },
    {
        "problem_name": "split-a-circular-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        pass\n\n\n# two pointers, slow and fast pointers\nclass Solution(object):\n    def splitCircularLinkedList(self, list):\n        \"\"\"\n        :type list: Optional[ListNode]\n        :rtype: List[Optional[ListNode]]\n        \"\"\"\n        head1 = list\n        slow, fast = head1, head1.next\n        while head1  != fast.next:\n            slow = slow.next\n            fast = fast.next.next if head1 != fast.next.next else fast.next\n        head2 = slow.next\n        slow.next, fast.next = head1, head2\n        return [head1, head2]\n"
    },
    {
        "problem_name": "split-a-string-in-balanced-strings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def balancedStringSplit(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, count = 0, 0      \n        for c in s:\n            count += 1 if c == 'L' else -1            \n            if count == 0:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "split-a-string-into-the-max-number-of-unique-substrings",
        "solution": "# Time:  O(n * 2^(n - 1))\n# Space: O(n)\n\nclass Solution(object):\n    def maxUniqueSplit(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def popcount(n):\n            count = 0\n            while n:\n                n &= n-1\n                count += 1\n            return count\n    \n        result = 1\n        total = 2**(len(s)-1)\n        mask = 0\n        while mask < total:\n            if popcount(mask) < result:\n                mask += 1\n                continue\n            lookup, curr, base = set(), [], total//2\n            for i in xrange(len(s)):\n                curr.append(s[i])\n                if (mask&base) or base == 0:\n                    if \"\".join(curr) in lookup:\n                        mask = (mask | (base-1)) + 1 if base else mask+1  # pruning, try next mask without base\n                        break\n                    lookup.add(\"\".join(curr))\n                    curr = []\n                base >>= 1\n            else:\n                result = max(result, len(lookup))\n                mask += 1\n        return result\n"
    },
    {
        "problem_name": "split-array-into-consecutive-subsequences",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isPossible(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        pre, cur = float(\"-inf\"), 0\n        cnt1, cnt2, cnt3 = 0, 0, 0\n        i = 0\n        while i < len(nums):\n            cnt = 0\n            cur = nums[i]\n            while i < len(nums) and cur == nums[i]:\n                cnt += 1\n                i += 1\n\n            if cur != pre + 1:\n                if cnt1 != 0 or cnt2 != 0:\n                    return False\n                cnt1, cnt2, cnt3 = cnt, 0, 0\n            else:\n                if cnt < cnt1 + cnt2:\n                    return False\n                cnt1, cnt2, cnt3 = max(0, cnt - (cnt1 + cnt2 + cnt3)), \\\n                                   cnt1, \\\n                                   cnt2 + min(cnt3, cnt - (cnt1 + cnt2))\n            pre = cur\n        return cnt1 == 0 and cnt2 == 0\n\n"
    },
    {
        "problem_name": "split-array-into-fibonacci-sequence",
        "solution": "# Time:  O(n^3)\n# Space: O(n)\n\n\nclass Solution(object):\n    def splitIntoFibonacci(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[int]\n        \"\"\"\n        def startswith(S, k, x):\n            y = 0\n            for i in xrange(k, len(S)):\n                y = 10*y + int(S[i])\n                if y == x:\n                    return i-k+1\n                elif y > x:\n                    break\n            return 0\n\n        MAX_INT = 2**31-1\n        a = 0\n        for i in xrange(len(S)-2):\n            a = 10*a + int(S[i])\n            b = 0\n            for j in xrange(i+1, len(S)-1):\n                b = 10*b + int(S[j])\n                fib = [a, b]\n                k = j+1\n                while k < len(S):\n                    if fib[-2] > MAX_INT-fib[-1]:\n                        break\n                    c = fib[-2]+fib[-1]\n                    length = startswith(S, k, c)\n                    if length == 0:\n                        break\n                    fib.append(c)\n                    k += length\n                else:\n                    return fib\n                if b == 0:\n                    break\n            if a == 0:\n                break\n        return []\n\n"
    },
    {
        "problem_name": "split-array-into-maximum-number-of-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# greedy\nclass Solution(object):\n    def maxSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = curr = 0\n        for x in nums:\n            curr = curr&x if curr else x\n            if not curr:\n                result += 1\n        return max(result, 1)\n"
    },
    {
        "problem_name": "split-array-largest-sum",
        "solution": "# Time:  O(nlogs), s is the sum of nums\n# Space: O(1)\n\nclass Solution(object):\n    def splitArray(self, nums, m):\n        \"\"\"\n        :type nums: List[int]\n        :type m: int\n        :rtype: int\n        \"\"\"\n        def check(nums, m, s):\n            cnt, curr_sum = 1, 0\n            for num in nums:\n                curr_sum += num\n                if curr_sum > s:\n                    curr_sum = num\n                    cnt += 1\n            return cnt <= m\n\n        left, right = max(nums), sum(nums)\n        while left <= right:\n            mid = left + (right - left) // 2\n            if check(nums, m, mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n"
    },
    {
        "problem_name": "split-array-with-equal-sum",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def splitArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(nums) < 7:\n            return False\n\n        accumulated_sum = [0] * len(nums)\n        accumulated_sum[0] = nums[0]\n        for i in xrange(1, len(nums)):\n            accumulated_sum[i] = accumulated_sum[i-1] + nums[i]\n        for j in xrange(3, len(nums)-3):\n            lookup = set()\n            for i in xrange(1, j-1):\n                if accumulated_sum[i-1] == accumulated_sum[j-1] - accumulated_sum[i]:\n                    lookup.add(accumulated_sum[i-1])\n            for k in xrange(j+2, len(nums)-1):\n                if accumulated_sum[-1] - accumulated_sum[k] == accumulated_sum[k-1] - accumulated_sum[j] and \\\n                   accumulated_sum[k - 1] - accumulated_sum[j] in lookup:\n                    return True\n        return False\n\n"
    },
    {
        "problem_name": "split-array-with-same-average",
        "solution": "# Time:  O(n^4)\n# Space: O(n^3)\n\nclass Solution(object):\n    def splitArraySameAverage(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: bool\n        \"\"\"\n        def possible(total, n):\n            for i in xrange(1, n//2+1):\n                if total*i%n == 0:\n                    return True\n            return False\n        n, s = len(A), sum(A)\n        if not possible(n, s):\n            return False\n\n        sums = [set() for _ in xrange(n//2+1)]\n        sums[0].add(0)\n        for num in A:  # O(n) times\n            for i in reversed(xrange(1, n//2+1)):  # O(n) times\n                for prev in sums[i-1]:  # O(1) + O(2) + ... O(n/2) = O(n^2) times\n                    sums[i].add(prev+num)\n        for i in xrange(1, n//2+1):\n            if s*i%n == 0 and s*i//n in sums[i]:\n                return True\n        return False\n\n"
    },
    {
        "problem_name": "split-bst",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def splitBST(self, root, V):\n        \"\"\"\n        :type root: TreeNode\n        :type V: int\n        :rtype: List[TreeNode]\n        \"\"\"\n        if not root:\n            return None, None\n        elif root.val <= V:\n            result = self.splitBST(root.right, V)\n            root.right = result[0]\n            return root, result[1]\n        else:\n            result = self.splitBST(root.left, V)\n            root.left = result[1]\n            return result[0], root\n\n"
    },
    {
        "problem_name": "split-concatenated-strings",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def splitLoopedString(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        tmp = []\n        for s in strs:\n            tmp += max(s, s[::-1])\n        s = \"\".join(tmp)\n\n        result, st = \"a\", 0\n        for i in xrange(len(strs)):\n            body = \"\".join([s[st + len(strs[i]):], s[0:st]])\n            for p in strs[i], strs[i][::-1]:\n                for j in xrange(len(strs[i])):\n                    if p[j] >= result[0]:\n                        result = max(result, \"\".join([p[j:], body, p[:j]]))\n            st += len(strs[i])\n        return result\n\n"
    },
    {
        "problem_name": "split-linked-list-in-parts",
        "solution": "# Time:  O(n + k)\n# Space: O(1)\n\nclass Solution(object):\n    def splitListToParts(self, root, k):\n        \"\"\"\n        :type root: ListNode\n        :type k: int\n        :rtype: List[ListNode]\n        \"\"\"\n        n = 0\n        curr = root\n        while curr:\n            curr = curr.next\n            n += 1\n        width, remainder = divmod(n, k)\n\n        result = []\n        curr = root\n        for i in xrange(k):\n            head = curr\n            for j in xrange(width-1+int(i < remainder)):\n                if curr:\n                    curr = curr.next\n            if curr:\n                curr.next, curr = None, curr.next\n            result.append(head)\n        return result\n\n"
    },
    {
        "problem_name": "split-message-based-on-limit",
        "solution": "# Time:  O(n + rlogr), r is the number of messages\n# Space: O(1)\n\n# brute force, linear search (binary search doesn't work)\nclass Solution(object):\n    def splitMessage(self, message, limit):\n        \"\"\"\n        :type message: str\n        :type limit: int\n        :rtype: List[str]\n        \"\"\"\n        cnt, l, total, base = 1, 1, len(message)+1, 1\n        while 3+l*2 < limit:\n            if total+(3+l)*cnt <= limit*cnt:\n                break\n            cnt += 1\n            if cnt == base*10:\n                l += 1\n                base *= 10\n            total += l\n        if 3+l*2 >= limit:\n            return []\n        result = []\n        j = 0\n        for i in xrange(cnt):\n            l = limit-(3+len(str(i+1))+len(str(cnt)))\n            result.append(\"%s<%s/%s>\"%(message[j:j+l], i+1, cnt))\n            j += l\n        return result\n"
    },
    {
        "problem_name": "split-strings-by-separator",
        "solution": "# Time:  O(n * l)\n# Space: O(l)\n\n# string\nclass Solution(object):\n    def splitWordsBySeparator(self, words, separator):\n        \"\"\"\n        :type words: List[str]\n        :type separator: str\n        :rtype: List[str]\n        \"\"\"\n        return [w for word in words for w in word.split(separator) if w]\n"
    },
    {
        "problem_name": "split-the-array-to-make-coprime-products",
        "solution": "# Time:  O(n * sqrt(r)), r = max(nums)\n# Space: O(sqrt(r))\n\nimport collections\n\n\n# number theory\nclass Solution(object):\n    def findValidSplit(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def factorize(x):\n            result = []\n            d = 2\n            while d*d <= x:\n                e = 0\n                while x%d == 0:\n                    x //= d\n                    e += 1\n                if e:\n                    result.append([d, e])\n                d += 1 if d == 2 else 2\n            if x > 1:\n                result.append([x, 1])\n            return result\n        \n        right = collections.Counter()\n        for x in reversed(nums):\n            for p, c in factorize(x):\n                right[p] += c\n        left = collections.Counter()\n        cnt = 0\n        for i in xrange(len(nums)-1):\n            for p, c in factorize(nums[i]):\n                if not left[p]:\n                    cnt += 1\n                left[p] += c\n                right[p] -= c\n                if not right[p]:\n                    cnt -= 1\n            if not cnt:\n                return i\n        return -1\n"
    },
    {
        "problem_name": "split-the-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table\nclass Solution(object):\n    def isPossibleToSplit(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return all(v <= 2 for v in collections.Counter(nums).itervalues())\n"
    },
    {
        "problem_name": "split-two-strings-to-make-palindrome",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def checkPalindromeFormation(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: bool\n        \"\"\"\n        def is_palindrome(s, i, j):\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n\n        def check(a, b):\n            i, j = 0, len(b)-1\n            while i < j:\n                if a[i] != b[j]:\n                    return is_palindrome(a, i, j) or is_palindrome(b, i, j)\n                i += 1\n                j -= 1\n            return True\n\n        return check(a, b) or check(b, a)\n"
    },
    {
        "problem_name": "split-with-minimum-sum",
        "solution": "# Time:  O(mlogm), m = O(logn)\n# Space: O(m)\n\n# sort, greedy\nclass Solution(object):\n    def splitNum(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        sorted_num = \"\".join(sorted(str(num)))\n        return int(sorted_num[::2])+int(sorted_num[1::2])\n"
    },
    {
        "problem_name": "splitting-a-string-into-descending-consecutive-values",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def splitString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        def backtracking(s, i, num, cnt):\n            if i == len(s):\n                return cnt >= 2\n            new_num = 0\n            for j in xrange(i, len(s)):\n                new_num = new_num*10 + int(s[j])\n                if new_num >= num >= 0:\n                    break\n                if (num == -1 or num-1 == new_num) and backtracking(s, j+1, new_num, cnt+1):\n                    return True\n            return False\n            \n        return backtracking(s, 0, -1, 0)\n"
    },
    {
        "problem_name": "sqrtx",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 2:\n            return x\n\n        left, right = 1, x // 2\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid > x / mid:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left - 1\n\n\n"
    },
    {
        "problem_name": "squares-of-a-sorted-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport bisect\n\n\nclass Solution(object):\n    def sortedSquares(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        right = bisect.bisect_left(A, 0)\n        left = right-1\n        result = []\n        while 0 <= left or right < len(A):\n            if right == len(A) or \\\n               (0 <= left and A[left]**2 < A[right]**2):\n                result.append(A[left]**2)\n                left -= 1\n            else:\n                result.append(A[right]**2)\n                right += 1\n        return result\n"
    },
    {
        "problem_name": "squirrel-simulation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minDistance(self, height, width, tree, squirrel, nuts):\n        \"\"\"\n        :type height: int\n        :type width: int\n        :type tree: List[int]\n        :type squirrel: List[int]\n        :type nuts: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def distance(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        result = 0\n        d = float(\"inf\")\n        for nut in nuts:\n            result += (distance(nut, tree) * 2)\n            d = min(d, distance(nut, squirrel) - distance(nut, tree))\n        return result + d\n\n"
    },
    {
        "problem_name": "stamping-the-grid",
        "solution": "# Time:  O(m * n)\n# Space: O(m * n)\n\nclass Solution(object):\n    def possibleToStamp(self, grid, stampHeight, stampWidth):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type stampHeight: int\n        :type stampWidth: int\n        :rtype: bool\n        \"\"\"\n        prefix = [[0]*(len(grid[0])+1) for _ in xrange(len(grid)+1)]\n        fit = [[0]*len(grid[0]) for _ in xrange(len(grid))]\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                prefix[i+1][j+1] = prefix[i+1][j]+prefix[i][j+1]-prefix[i][j]+(1^grid[i][j])\n                if i+1 >= stampHeight and j+1 >= stampWidth:\n                    x, y = i+1-stampHeight, j+1-stampWidth\n                    fit[i][j] = int(prefix[i+1][j+1]-prefix[x][j+1]-prefix[i+1][y]+prefix[x][y] == stampWidth*stampHeight)\n        prefix2 = [[0]*(len(grid[0])+1) for _ in xrange(len(grid)+1)]\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                prefix2[i+1][j+1] = prefix2[i+1][j]+prefix2[i][j+1]-prefix2[i][j]+fit[i][j]\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid[0])):\n                x, y = min(i+stampHeight, len(grid)), min(j+stampWidth, len(grid[0]))\n                if not grid[i][j] and not prefix2[x][y]-prefix2[i][y]-prefix2[x][j]+prefix2[i][j]:\n                    return False\n        return True\n"
    },
    {
        "problem_name": "stamping-the-sequence",
        "solution": "# Time:  O((n - m) * m)\n# Space: O((n - m) * m)\n\nimport collections\n\n\nclass Solution(object):\n    def movesToStamp(self, stamp, target):\n        M, N = len(stamp), len(target)\n\n        q = collections.deque()\n        lookup = [False]*N\n        result = []\n        A = []\n        for i in xrange(N-M+1):\n            made, todo = set(), set()\n            for j, c in enumerate(stamp):\n                if c == target[i+j]:\n                    made.add(i+j)\n                else:\n                    todo.add(i+j)\n            A.append((made, todo))\n            if todo:\n                continue\n            result.append(i)\n            for m in made:\n                if lookup[m]:\n                    continue\n                q.append(m)\n                lookup[m] = True\n\n        while q:\n            i = q.popleft()\n            for j in xrange(max(0, i-M+1), min(N-M, i)+1):\n                made, todo = A[j]\n                if i not in todo:\n                    continue\n                todo.discard(i)\n                if todo:\n                    continue\n                result.append(j)\n                for m in made:\n                    if lookup[m]:\n                        continue\n                    q.append(m)\n                    lookup[m] = True\n        return result[::-1] if all(lookup) else []\n"
    },
    {
        "problem_name": "statistics-from-a-large-sample",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport bisect\n\n\nclass Solution(object):\n    def sampleStats(self, count):\n        \"\"\"\n        :type count: List[int]\n        :rtype: List[float]\n        \"\"\"\n        n = sum(count)\n        mi = next(i for i in xrange(len(count)) if count[i]) * 1.0\n        ma = next(i for i in reversed(xrange(len(count))) if count[i]) * 1.0\n        mean = sum(i * v for i, v in enumerate(count)) * 1.0 / n\n        mode = count.index(max(count)) * 1.0\n        for i in xrange(1, len(count)):\n            count[i] += count[i-1]\n        median1 = bisect.bisect_left(count, (n+1) // 2)\n        median2 = bisect.bisect_left(count, (n+2) // 2)\n        median = (median1+median2) / 2.0\n        return [mi, ma, mean, median, mode]\n"
    },
    {
        "problem_name": "step-by-step-directions-from-a-binary-tree-node-to-another",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution(object):\n    def getDirections(self, root, startValue, destValue):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type startValue: int\n        :type destValue: int\n        :rtype: str\n        \"\"\"\n        def iter_dfs(root, val):\n            path = []\n            stk = [(1, (root,))]\n            while stk:\n                step, args = stk.pop()\n                if step == 1:\n                    node = args[0]\n                    if node.val == val:\n                        path.reverse()\n                        return path\n                    for i, child in enumerate((node.left, node.right)):\n                        if not child:\n                            continue\n                        stk.append((3, None))\n                        stk.append((1, (child,)))\n                        stk.append((2, (\"LR\"[i],)))\n                elif step == 2:\n                    path.append(args[0])\n                elif step == 3:\n                    path.pop()\n            return []\n    \n        src = iter_dfs(root, startValue)\n        dst = iter_dfs(root, destValue)\n        while len(src) and len(dst) and src[-1] == dst[-1]:\n            src.pop()\n            dst.pop()\n        dst.reverse()\n        return \"\".join(['U']*len(src) + dst)\n\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def getDirections(self, root, startValue, destValue):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type startValue: int\n        :type destValue: int\n        :rtype: str\n        \"\"\"\n        def dfs(node, val, path):\n            if node.val == val:\n                return True\n            if node.left and dfs(node.left, val, path):\n                path.append('L')\n            elif node.right and dfs(node.right, val, path):\n                path.append('R')\n            return path\n\n        src, dst = [], []\n        dfs(root, startValue, src)\n        dfs(root, destValue, dst)\n        while len(src) and len(dst) and src[-1] == dst[-1]:\n            src.pop()\n            dst.pop()\n        dst.reverse()\n        return \"\".join(['U']*len(src) + dst)\n"
    },
    {
        "problem_name": "stepping-numbers",
        "solution": "# Time:  O(logk + r), r is the size of result\n# Space: O(k), k is the size of stepping numbers in [0, high]\n\nimport bisect\n\n\nMAX_HIGH = int(2e9)\nresult = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nfor i in xrange(1, MAX_HIGH):\n    if result[-1] >= MAX_HIGH:\n        break\n    d1 = result[i]%10 - 1\n    if d1 >= 0:\n        result.append(result[i]*10 + d1)\n    d2 = result[i]%10 + 1\n    if d2 <= 9:\n        result.append(result[i]*10 + d2)\nresult.append(float(\"inf\"))\n\n\nclass Solution(object):\n    def countSteppingNumbers(self, low, high):\n        \"\"\"\n        :type low: int\n        :type high: int\n        :rtype: List[int]\n        \"\"\"\n        lit = bisect.bisect_left(result, low);\n        rit = bisect.bisect_right(result, high);\n        return result[lit:rit]\n\n\n# Time:  O(k + r), r is the size of result\n# Space: O(k), k is the size of stepping numbers in [0, high]\nclass Solution2(object):\n    def countSteppingNumbers(self, low, high):\n        \"\"\"\n        :type low: int\n        :type high: int\n        :rtype: List[int]\n        \"\"\"\n        result = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        for i in xrange(1, high):\n            if result[-1] >= high:\n                break\n            d1 = result[i]%10 - 1\n            if d1 >= 0:\n                result.append(result[i]*10 + d1)\n            d2 = result[i]%10 + 1\n            if d2 <= 9:\n                result.append(result[i]*10 + d2)\n        result.append(float(\"inf\"))\n        lit = bisect.bisect_left(result, low);\n        rit = bisect.bisect_right(result, high);\n        return result[lit:rit]\n"
    },
    {
        "problem_name": "steps-to-make-array-non-decreasing",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# mono stack, dp\nclass Solution(object):\n    def totalSteps(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [0]*len(nums)  # dp[i]: number of rounds for nums[i] to remove all the covered elements\n        stk = []\n        for i in reversed(xrange(len(nums))):\n            while stk and nums[stk[-1]] < nums[i]:\n                dp[i] = max(dp[i]+1, dp[stk.pop()])\n            stk.append(i)\n        return max(dp)\n\n\n# Time:  O(n)\n# Space: O(n)\n# mono stack, dp\nclass Solution2(object):\n    def totalSteps(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dp = [0]*len(nums)  # dp[i]: number of rounds for nums[i] to be removed\n        stk = []\n        for i in xrange(len(nums)):\n            curr = 0\n            while stk and nums[stk[-1]] <= nums[i]:\n                curr = max(curr, dp[stk.pop()])\n            if stk:\n                dp[i] = curr+1\n            stk.append(i)\n        return max(dp)\n"
    },
    {
        "problem_name": "stickers-to-spell-word",
        "solution": "# Time:  O(T * S^T)\n# Space: O(T * S^T)\n\nimport collections\n\n\nclass Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        def minStickersHelper(sticker_counts, target, dp):\n            if \"\".join(target) in dp:\n                return dp[\"\".join(target)]\n            target_count = collections.Counter(target)\n            result = float(\"inf\")\n            for sticker_count in sticker_counts:\n                if sticker_count[target[0]] == 0:\n                    continue\n                new_target = []\n                for k in target_count.keys():\n                    if target_count[k] > sticker_count[k]:\n                       new_target += [k]*(target_count[k] - sticker_count[k])\n                if len(new_target) != len(target):\n                    num = minStickersHelper(sticker_counts, new_target, dp)\n                    if num != -1:\n                        result = min(result, 1+num)\n            dp[\"\".join(target)] = -1 if result == float(\"inf\") else result\n            return dp[\"\".join(target)]\n\n        sticker_counts = map(collections.Counter, stickers)\n        dp = { \"\":0 }\n        return minStickersHelper(sticker_counts, target, dp)\n\n"
    },
    {
        "problem_name": "stock-price-fluctuation",
        "solution": "# Time:  ctor:    O(1)\n#        update:  O(logn)\n#        current: O(1)\n#        max:     O(1)\n#        min:     O(1)\n# Space: O(n)\n\nfrom sortedcontainers import SortedList\n\n\nclass StockPrice(object):\n\n    def __init__(self):\n        self.__curr = 0\n        self.__lookup = {}\n        self.__sl_by_price = SortedList()\n\n    def update(self, timestamp, price):\n        \"\"\"\n        :type timestamp: int\n        :type price: int\n        :rtype: None\n        \"\"\"\n        if timestamp > self.__curr:\n            self.__curr = timestamp\n        if timestamp in self.__lookup:\n            self.__sl_by_price.remove(self.__lookup[timestamp])\n        self.__lookup[timestamp] = price\n        self.__sl_by_price.add(price)\n\n    def current(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.__lookup[self.__curr]\n\n    def maximum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return next(reversed(self.__sl_by_price))\n\n    def minimum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return next(iter(self.__sl_by_price))\n\n\n# Time:  ctor:    O(1)\n#        update:  O(logn)\n#        current: O(1)\n#        max:     O(logn) on average\n#        min:     O(logn) on average\n# Space: O(n)\nimport heapq\n\n\nclass StockPrice2(object):\n\n    def __init__(self):\n        self.__curr = 0\n        self.__lookup = {}\n        self.__min_heap = []\n        self.__max_heap = []\n\n    def update(self, timestamp, price):\n        \"\"\"\n        :type timestamp: int\n        :type price: int\n        :rtype: None\n        \"\"\"\n        def full_delete(heap, sign):  # Time: O(n), Space: O(n)\n            heap[:] = [x for x in set(heap) if sign*x[0] == self.__lookup[x[1]]]\n            heapq.heapify(heap)\n\n        if timestamp > self.__curr:\n            self.__curr = timestamp\n        self.__lookup[timestamp] = price\n        heapq.heappush(self.__min_heap, (price, timestamp))\n        heapq.heappush(self.__max_heap, (-price, timestamp))\n        if len(self.__min_heap) > 2*len(self.__lookup):  # avoid too much expired or duplicated data\n            full_delete(self.__min_heap, 1)\n            full_delete(self.__max_heap, -1)\n\n    def current(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.__lookup[self.__curr]\n\n    def maximum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.__max_heap and self.__lookup[self.__max_heap[0][1]] != -self.__max_heap[0][0]:  # lazy delete\n            heapq.heappop(self.__max_heap)\n        return -self.__max_heap[0][0]\n\n    def minimum(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.__min_heap and self.__lookup[self.__min_heap[0][1]] != self.__min_heap[0][0]:  # lazy delete\n            heapq.heappop(self.__min_heap)\n        return self.__min_heap[0][0]\n"
    },
    {
        "problem_name": "stone-game-ii",
        "solution": "# Time:  O(n*(logn)^2)\n# Space: O(nlogn)\n\nclass Solution(object):\n    def stoneGameII(self, piles):\n        \"\"\"\n        :type piles: List[int]\n        :rtype: int\n        \"\"\"\n        def dp(piles, lookup, i, m):\n            if i+2*m >= len(piles):\n                return piles[i]\n            if (i, m) not in lookup:\n                lookup[i, m] = piles[i] - \\\n                               min(dp(piles, lookup, i+x, max(m, x))\n                                   for x in xrange(1, 2*m+1))\n            return lookup[i, m]\n\n        for i in reversed(xrange(len(piles)-1)):\n            piles[i] += piles[i+1]\n        return dp(piles, {}, 0, 1)\n"
    },
    {
        "problem_name": "stone-game-iii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def stoneGameIII(self, stoneValue):\n        \"\"\"\n        :type stoneValue: List[int]\n        :rtype: str\n        \"\"\"\n        dp = [float(\"-inf\")]*3\n        dp[len(stoneValue)%3] = 0\n        for i in reversed(xrange(len(stoneValue))):\n            max_dp, curr = float(\"-inf\"), 0\n            for j in xrange(min(3, len(stoneValue)-i)):\n                curr += stoneValue[i+j]\n                max_dp = max(max_dp, curr-dp[(i+j+1)%3])\n            dp[i%3] = max_dp\n        return [\"Tie\", \"Alice\", \"Bob\"][cmp(dp[0], 0)]\n"
    },
    {
        "problem_name": "stone-game-iv",
        "solution": "# Time:  O(n * sqrt(n))\n# Space: O(n)\n\nclass Solution(object):\n    def winnerSquareGame(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        dp = [False]*(n+1)\n        for i in xrange(1, n+1):\n            j = 1\n            while j*j <= i:\n                if not dp[i-j*j]:\n                    dp[i] = True\n                    break\n                j += 1\n        return dp[-1]\n"
    },
    {
        "problem_name": "stone-game-ix",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def stoneGameIX(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        count = collections.Counter(x%3 for x in stones)\n        if count[0]%2 == 0:\n            # iff both counts are not zero, then alice takes the least one at first, the remains are deterministic for bob to lose:\n            # - assumed count[1] is the least one:\n            #   1(,1,2)*,2,(,2)* => bob loses\n            #            ^\n            # - assumed count[2] is the least one:\n            #   2(,2,1)*,1,(,1)* => bob loses\n            #            ^\n            return count[1] and count[2]\n        # iff abs(count[1] - count[2]) >= 3, then alice takes the most one at first, the remains are deterministic for bob to lose:\n        # - assumed count[1] is the most one\n        #   1(,1,2)*,0,1(,2,1)*,1,(,1)* => bob loses\n        #                       ^\n        #   1(,1,2)*,1,0,1,(,1)* => bob loses\n        #                ^\n        # - assumed count[2] is the most one\n        #   2(,2,1)*,0,2(,1,2)*,2,(,2)* => bob loses\n        #                       ^\n        #   2(,2,1)*,2,0,2,(,2)* => bob loses\n        #                ^\n        return abs(count[1]-count[2]) >= 3  \n"
    },
    {
        "problem_name": "stone-game-v",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nclass Solution(object):\n    def stoneGameV(self, stoneValue):\n        \"\"\"\n        :type stoneValue: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(stoneValue)\n        prefix = [0]\n        for v in stoneValue:\n            prefix.append(prefix[-1] + v)\n\n        mid = range(n)\n\n        dp = [[0]*n for _ in xrange(n)]\n        for i in xrange(n):\n            dp[i][i] = stoneValue[i]\n\n        max_score = 0\n        for l in xrange(2, n+1):\n            for i in xrange(n-l+1):\n                j = i+l-1\n                while prefix[mid[i]]-prefix[i] < prefix[j+1]-prefix[mid[i]]:\n                    mid[i] += 1  # Time: O(n^2) in total\n                p = mid[i]\n                max_score = 0\n                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:\n                    max_score = max(dp[i][p-1], dp[j][p])\n                else:\n                    if i <= p-2:\n                        max_score = max(max_score, dp[i][p-2])\n                    if p <= j:\n                        max_score = max(max_score, dp[j][p])\n                dp[i][j] = max(dp[i][j-1], (prefix[j+1]-prefix[i]) + max_score)\n                dp[j][i] = max(dp[j][i+1], (prefix[j+1]-prefix[i]) + max_score)\n        return max_score\n\n\n# Time:  O(n^2)\n# Space: O(n^2)\nclass Solution2(object):\n    def stoneGameV(self, stoneValue):\n        \"\"\"\n        :type stoneValue: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(stoneValue)\n        prefix = [0]\n        for v in stoneValue:\n            prefix.append(prefix[-1] + v)\n\n        mid = [[0]*n for _ in xrange(n)]\n        for l in xrange(1, n+1):\n            for i in xrange(n-l+1):\n                j = i+l-1\n                p = i if l == 1 else mid[i][j-1]\n                while prefix[p]-prefix[i] < prefix[j+1]-prefix[p]:\n                    p += 1  # Time: O(n^2) in total\n                mid[i][j] = p\n        \n        rmq = [[0]*n for _ in xrange(n)]\n        for i in xrange(n):\n            rmq[i][i] = stoneValue[i]\n\n        dp = [[0]*n for _ in xrange(n)]\n        for l in xrange(2, n+1):\n            for i in xrange(n-l+1):\n                j = i+l-1\n                p = mid[i][j]\n                max_score = 0\n                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:\n                    max_score = max(rmq[i][p-1], rmq[j][p])\n                else:\n                    if i <= p-2:\n                        max_score = max(max_score, rmq[i][p-2])\n                    if p <= j:\n                        max_score = max(max_score, rmq[j][p])\n                dp[i][j] = max_score\n                rmq[i][j] = max(rmq[i][j-1], (prefix[j+1]-prefix[i]) + max_score)\n                rmq[j][i] = max(rmq[j][i+1], (prefix[j+1]-prefix[i]) + max_score)\n        return dp[0][n-1]\n"
    },
    {
        "problem_name": "stone-game-vi",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def stoneGameVI(self, aliceValues, bobValues):\n        \"\"\"\n        :type aliceValues: List[int]\n        :type bobValues: List[int]\n        :rtype: int\n        \"\"\"\n        sorted_vals = sorted(((a, b) for a, b in zip(aliceValues, bobValues)), key=sum, reverse=True)\n        return cmp(sum(a for a, _ in sorted_vals[::2]), sum(b for _, b in sorted_vals[1::2]))\n"
    },
    {
        "problem_name": "stone-game-vii",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def stoneGameVII(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: int\n        \"\"\"\n        def score(i, j):\n            return prefix[j+1]-prefix[i]\n\n        prefix = [0]\n        for stone in stones:\n            prefix.append(prefix[-1]+stone)\n        dp = [[0 for _ in xrange(len(stones))] for _ in xrange(2)]\n        for i in reversed(xrange(len(stones))):\n            for j in xrange(i+1, len(stones)):\n                dp[i%2][j] = max(score(i+1, j)-dp[(i+1)%2][j], score(i, j-1)-dp[i%2][j-1])\n        return dp[0][-1]\n"
    },
    {
        "problem_name": "stone-game-viii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def stoneGameVIII(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: int\n        \"\"\"\n        for i in xrange(len(stones)-1):\n            stones[i+1] += stones[i]\n        return reduce(lambda curr, i: max(curr, stones[i]-curr), reversed(xrange(1, len(stones)-1)), stones[-1])\n"
    },
    {
        "problem_name": "stone-game",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def stoneGame(self, piles):\n        \"\"\"\n        :type piles: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(piles) % 2 == 0 or len(piles) == 1:\n            return True\n\n        dp = [0] * len(piles)\n        for i in reversed(xrange(len(piles))):\n            dp[i] = piles[i]\n            for j in xrange(i+1, len(piles)):\n                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])\n        return dp[-1] >= 0\n\n"
    },
    {
        "problem_name": "strange-printer-ii",
        "solution": "# Time:  O(c * m * n + e), c is the number of colors\n#                        , e is the number of edges in adj, at most O(c^2)\n# Space: O(e)\n\nimport collections\n\n\nclass Solution(object):\n    def isPrintable(self, targetGrid):\n        \"\"\"\n        :type targetGrid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        VISITING, VISITED = range(2)\n        def has_cycle(adj, color, lookup):\n            stk = [(1, color)]\n            while stk:\n                step, color = stk.pop()\n                if step == 1:\n                    lookup[color] = VISITING\n                    stk.append((2, color))\n                    for new_color in adj[color]:\n                        if new_color in lookup:\n                            if lookup[new_color] == VISITED:\n                                continue\n                            return True  # VISITING\n                        stk.append((1, new_color))\n                elif step == 2:\n                    lookup[color] = VISITED\n            return False\n\n        boxes = collections.defaultdict(lambda:[len(targetGrid), len(targetGrid[0]), -1, -1])\n        for r, row in enumerate(targetGrid):\n            for c, color in enumerate(row):\n                boxes[color][0] = min(boxes[color][0], r)\n                boxes[color][1] = min(boxes[color][1], c)\n                boxes[color][2] = max(boxes[color][2], r)\n                boxes[color][3] = max(boxes[color][3], c)\n        adj = collections.defaultdict(set)\n        for color, (min_r, min_c, max_r, max_c) in boxes.iteritems():\n            for r in xrange(min_r, max_r+1):\n                for c in xrange(min_c, max_c+1):\n                    if targetGrid[r][c] != color:\n                        adj[color].add(targetGrid[r][c])\n\n        lookup = {}\n        return all(color in lookup or not has_cycle(adj, color, lookup) for color in boxes.iterkeys())\n            \n\n# Time:  O(c * m * n + e), c is the number of colors\n#                        , e is the number of edges in adj, at most O(c^2)\n# Space: O(e)\nclass Solution2(object):\n    def isPrintable(self, targetGrid):\n        \"\"\"\n        :type targetGrid: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        VISITING, VISITED = range(2)\n        def has_cycle(adj, color, lookup):\n            lookup[color] = VISITING\n            for new_color in adj[color]:\n                if (new_color not in lookup and has_cycle(adj, new_color, lookup)) or \\\n                   lookup[new_color] == VISITING:\n                    return True\n            lookup[color] = VISITED\n            return False          \n\n        MAX_COLOR = 60\n        adj = collections.defaultdict(set)\n        for color in xrange(1, MAX_COLOR+1):\n            min_r = len(targetGrid)\n            min_c = len(targetGrid[0])\n            max_r = -1\n            max_c = -1\n            for r in xrange(len(targetGrid)):\n                for c in xrange(len(targetGrid[r])):\n                    if targetGrid[r][c] == color:\n                        min_r = min(min_r, r)\n                        min_c = min(min_c, c)\n                        max_r = max(max_r, r)\n                        max_c = max(max_c, c)\n            for r in xrange(min_r, max_r+1):\n                for c in xrange(min_c, max_c+1):\n                    if targetGrid[r][c] != color:\n                        adj[color].add(targetGrid[r][c])\n\n        lookup = {}\n        return all(color in lookup or not has_cycle(adj, color, lookup) for color in xrange(1, MAX_COLOR+1))\n"
    },
    {
        "problem_name": "strange-printer",
        "solution": "# Time:  O(n^3)\n# Space: O(n^2)\n\nclass Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def dp(s, i, j, lookup):\n            if i > j:\n                return 0\n            if (i, j) not in lookup:\n                lookup[(i, j)]  = dp(s, i, j-1, lookup) + 1\n                for k in xrange(i, j):\n                    if s[k] == s[j]:\n                        lookup[(i, j)] = min(lookup[(i, j)], \\\n                                             dp(s, i, k, lookup) + dp(s, k+1, j-1, lookup))\n            return lookup[(i, j)]\n\n        lookup = {}\n        return dp(s, 0, len(s)-1, lookup)\n\n"
    },
    {
        "problem_name": "stream-of-characters",
        "solution": "# Time:  ctor:  O(n)    , n is the total size of patterns\n#        query: O(m + z), m is the total size of query string\n#                       , z is the number of all matched strings\n#                       , query time could be further improved to O(m) if we don't return all matched patterns\n# Space: O(t), t is the total size of ac automata trie\n#            , space could be further improved by DAT (double-array trie)\n\n# Aho\u2013Corasick automata\n# reference:\n# 1. http://web.stanford.edu/class/archive/cs/cs166/cs166.1166/lectures/02/Small02.pdf\n# 2. http://algo.pw/algo/64/python\n\nimport collections\n\n\nclass AhoNode(object):\n    def __init__(self):\n        self.children = collections.defaultdict(AhoNode)\n        self.indices = []\n        self.suffix = None\n        self.output = None\n\n\nclass AhoTrie(object):\n\n    def step(self, letter):\n        while self.__node and letter not in self.__node.children:\n            self.__node = self.__node.suffix\n        self.__node = self.__node.children[letter] if self.__node else self.__root\n        return self.__get_ac_node_outputs(self.__node)\n    \n    def __init__(self, patterns):\n        self.__root = self.__create_ac_trie(patterns)\n        self.__node = self.__create_ac_suffix_and_output_links(self.__root)\n    \n    def __create_ac_trie(self, patterns):  # Time:  O(n), Space: O(t)\n        root = AhoNode()\n        for i, pattern in enumerate(patterns):\n            node = root\n            for c in pattern:\n                node = node.children[c]\n            node.indices.append(i)\n        return root\n\n    def __create_ac_suffix_and_output_links(self, root):  # Time:  O(n), Space: O(t)\n        queue = collections.deque()\n        for node in root.children.itervalues():\n            queue.append(node)\n            node.suffix = root\n\n        while queue:\n            node = queue.popleft()\n            for c, child in node.children.iteritems():\n                queue.append(child)\n                suffix = node.suffix\n                while suffix and c not in suffix.children:\n                    suffix = suffix.suffix\n                child.suffix = suffix.children[c] if suffix else root\n                child.output = child.suffix if child.suffix.indices else child.suffix.output\n                \n        return root\n\n    def __get_ac_node_outputs(self, node):  # Time:  O(z), in this question, it could be improved to O(1)\n                                            # if we only return a matched pattern without all matched ones\n        result = []\n        for i in node.indices:\n            result.append(i)\n            # return result\n        output = node.output\n        while output:\n            for i in output.indices:\n                result.append(i)\n                # return result\n            output = output.output\n        return result\n\n\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        \"\"\"\n        :type words: List[str]\n        \"\"\"\n        self.__trie = AhoTrie(words)\n\n    def query(self, letter):  # O(m) times\n        \"\"\"\n        :type letter: str\n        :rtype: bool\n        \"\"\"\n        return len(self.__trie.step(letter)) > 0\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n"
    },
    {
        "problem_name": "stream-of-characters2",
        "solution": "# Time:  ctor:  O(n + p^2), n is the total size of patterns\n#                         , p is the number of patterns\n#        query: O(m + z), m is the total size of query string\n#                       , z is the number of all matched strings \n#                       , query time would be O(m) if we don't use all the matched patterns\n# Space: O(t + p^2), t is the total size of ac automata trie\n#                  , space could be further improved by DAT (double-array trie)\n\n# Aho\u2013Corasick automata\n# reference:\n# - http://web.stanford.edu/class/archive/cs/cs166/cs166.1166/lectures/02/Small02.pdf\n# - http://algo.pw/algo/64/python\n\nimport collections\n\n\nclass AhoNode(object):\n    def __init__(self):\n        self.children = collections.defaultdict(AhoNode)\n        self.suffix = None\n        self.outputs = []\n\n\nclass AhoTrie(object):\n\n    def step(self, letter):\n        while self.__node and letter not in self.__node.children:\n            self.__node = self.__node.suffix\n        self.__node = self.__node.children[letter] if self.__node else self.__root\n        return self.__node.outputs  # Time:  O(z), it would be O(m) if we don't use all the matched patterns\n    \n    def __init__(self, patterns):\n        self.__root = self.__create_ac_trie(patterns)\n        self.__node = self.__create_ac_suffix_and_output_links(self.__root)\n    \n    def __create_ac_trie(self, patterns):  # Time:  O(n), Space: O(t)\n        root = AhoNode()\n        for i, pattern in enumerate(patterns):\n            node = root\n            for c in pattern:\n                node = node.children[c]\n            node.outputs.append(i)\n        return root\n\n    def __create_ac_suffix_and_output_links(self, root):  # Time:  O(n + p^2), Space: O(t + p^2)\n        queue = collections.deque()\n        for node in root.children.itervalues():\n            queue.append(node)\n            node.suffix = root\n\n        while queue:\n            node = queue.popleft()\n            for c, child in node.children.iteritems():\n                queue.append(child)\n                suffix = node.suffix\n                while suffix and c not in suffix.children:\n                    suffix = suffix.suffix\n                child.suffix = suffix.children[c] if suffix else root\n                child.outputs += child.suffix.outputs  # Time: O(p^2)\n        \n        return root\n\n\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        \"\"\"\n        :type words: List[str]\n        \"\"\"\n        self.__trie = AhoTrie(words)\n\n    def query(self, letter):  # O(m) times\n        \"\"\"\n        :type letter: str\n        :rtype: bool\n        \"\"\"\n        return len(self.__trie.step(letter)) > 0\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n"
    },
    {
        "problem_name": "strictly-palindromic-number",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def isStrictlyPalindromic(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return False\n"
    },
    {
        "problem_name": "string-compression-ii",
        "solution": "# Time:  O(n^2 * k)\n# Space: O(n * k)\n\nclass Solution(object):\n    def getLengthOfOptimalCompression(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def length(cnt):\n            l = 2 if cnt >= 2 else 1\n            while cnt >= 10:\n                l += 1\n                cnt //= 10\n            return l\n\n        dp = [[len(s)]*(k+1) for _ in xrange(len(s)+1)]\n        dp[0][0] = 0\n        for i in xrange(1, len(s)+1):\n            for j in xrange(k+1):\n                if i-1 >= 0 and j-1 >= 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-1])\n                keep = delete = 0\n                for m in xrange(i, len(s)+1):\n                    if s[i-1] == s[m-1]:\n                        keep += 1\n                    else:\n                        delete += 1\n                    if j+delete <= k:\n                        dp[m][j+delete] = min(dp[m][j+delete], dp[i-1][j]+length(keep));\n        return dp[len(s)][k]\n"
    },
    {
        "problem_name": "string-compression",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def compress(self, chars):\n        \"\"\"\n        :type chars: List[str]\n        :rtype: int\n        \"\"\"\n        anchor, write = 0, 0\n        for read, c in enumerate(chars):\n            if read+1 == len(chars) or chars[read+1] != c:\n                chars[write] = chars[anchor]\n                write += 1\n                if read > anchor:\n                    n, left = read-anchor+1, write\n                    while n > 0:\n                        chars[write] = chr(n%10+ord('0'))\n                        write += 1\n                        n /= 10\n                    right = write-1\n                    while left < right:\n                        chars[left], chars[right] = chars[right], chars[left]\n                        left += 1\n                        right -= 1\n                anchor = read+1\n        return write\n\n"
    },
    {
        "problem_name": "string-matching-in-an-array",
        "solution": "# Time:  O(n + m + z) = O(n), n is the total size of patterns\n#                           , m is the total size of query string\n#                           , z is the number of all matched strings\n#                           , O(n) = O(m) = O(z) in this problem\n# Space: O(t), t is the total size of ac automata trie\n\nimport collections\n\n\nclass AhoNode(object):\n    def __init__(self):\n        self.children = collections.defaultdict(AhoNode)\n        self.indices = []\n        self.suffix = None\n        self.output = None\n\n\nclass AhoTrie(object):\n\n    def step(self, letter):\n        while self.__node and letter not in self.__node.children:\n            self.__node = self.__node.suffix\n        self.__node = self.__node.children[letter] if self.__node else self.__root\n        return self.__get_ac_node_outputs(self.__node)\n    \n    def reset(self):\n        self.__node = self.__root\n    \n    def __init__(self, patterns):\n        self.__root = self.__create_ac_trie(patterns)\n        self.__node = self.__create_ac_suffix_and_output_links(self.__root)\n    \n    def __create_ac_trie(self, patterns):  # Time:  O(n), Space: O(t)\n        root = AhoNode()\n        for i, pattern in enumerate(patterns):\n            node = root\n            for c in pattern:\n                node = node.children[c]\n            node.indices.append(i)\n        return root\n\n    def __create_ac_suffix_and_output_links(self, root):  # Time:  O(n), Space: O(t)\n        queue = collections.deque()\n        for node in root.children.itervalues():\n            queue.append(node)\n            node.suffix = root\n\n        while queue:\n            node = queue.popleft()\n            for c, child in node.children.iteritems():\n                queue.append(child)\n                suffix = node.suffix\n                while suffix and c not in suffix.children:\n                    suffix = suffix.suffix\n                child.suffix = suffix.children[c] if suffix else root\n                child.output = child.suffix if child.suffix.indices else child.suffix.output\n                \n        return root\n\n    def __get_ac_node_outputs(self, node):  # Time:  O(z)\n        result = []\n        for i in node.indices:\n            result.append(i)\n        output = node.output\n        while output:\n            for i in output.indices:\n                result.append(i)\n            output = output.output\n        return result\n    \n    \nclass Solution(object):\n    def stringMatching(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        trie = AhoTrie(words)\n        lookup = set()\n        for i in xrange(len(words)):\n            trie.reset()\n            for c in words[i]:\n                for j in trie.step(c):\n                    if j != i:\n                        lookup.add(j)\n        return [words[i] for i in lookup]\n\n\n# Time:  O(n^2 * l), n is the number of strings\n# Space: O(l)      , l is the max length of strings\nclass Solution2(object):\n    def stringMatching(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j != -1 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n            \n        def kmp(text, pattern, prefix):\n            if not pattern:\n                return 0\n            if len(text) < len(pattern):\n                return -1\n            j = -1\n            for i in xrange(len(text)):\n                while j != -1 and pattern[j+1] != text[i]:\n                    j = prefix[j]\n                if pattern[j+1] == text[i]:\n                    j += 1\n                if j+1 == len(pattern):\n                    return i-j\n            return -1\n            \n        result = []\n        for i, pattern in enumerate(words):\n            prefix = getPrefix(pattern)\n            for j, text in enumerate(words):\n                if i != j and kmp(text, pattern, prefix) != -1:\n                    result.append(pattern)\n                    break\n        return result\n\n\n# Time:  O(n^2 * l^2), n is the number of strings\n# Space: O(1)        , l is the max length of strings\nclass Solution3(object):\n    def stringMatching(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        for i, pattern in enumerate(words):\n            for j, text in enumerate(words):\n                if i != j and pattern in text:\n                    result.append(pattern)\n                    break\n        return result\n"
    },
    {
        "problem_name": "string-to-integer-atoi",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        INT_MAX =  2147483647\n        INT_MIN = -2147483648\n        result = 0\n\n        if not str:\n            return result\n\n        i = 0\n        while i < len(str) and str[i].isspace():\n            i += 1\n\n        if len(str) == i:\n            return result\n\n        sign = 1\n        if str[i] == \"+\":\n            i += 1\n        elif str[i] == \"-\":\n            sign = -1\n            i += 1\n\n        while i < len(str) and '0' <= str[i] <= '9':\n            if result > (INT_MAX - int(str[i])) / 10:\n                return INT_MAX if sign > 0 else INT_MIN\n            result = result * 10 + int(str[i])\n            i += 1\n\n        return sign * result\n\n"
    },
    {
        "problem_name": "string-transformation",
        "solution": "# Time:  O(n + logk)\n# Space: O(n)\n\n# dp, math, kmp\nclass Solution(object):\n    def numberOfWays(self, s, t, k):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j+1 > 0 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        def KMP(text, pattern):\n            prefix = getPrefix(pattern)\n            j = -1\n            for i in xrange(len(text)):\n                while j+1 > 0 and pattern[j+1] != text[i]:\n                    j = prefix[j]\n                if pattern[j+1] == text[i]:\n                    j += 1\n                if j+1 == len(pattern):\n                    yield i-j\n                    j = prefix[j]\n\n        n = len(s)\n        dp = [0]*2\n        dp[1] = ((pow(n-1, k, MOD)-(-1)**k)*pow(n, MOD-2, MOD))%MOD\n        dp[0] = (dp[1]+(-1)**k)%MOD\n        return reduce(lambda a, b: (a+b)%MOD, (dp[int(i != 0)] for i in KMP(s+s[:-1], t)), 0)\n\n\n# Time:  O(n + logk)\n# Space: O(n)\n# dp, matrix exponentiation, kmp\nclass Solution2(object):\n    def numberOfWays(self, s, t, k):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A]\n \n        def matrix_expo(A, K):\n            result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        def getPrefix(pattern):\n            prefix = [-1]*len(pattern)\n            j = -1\n            for i in xrange(1, len(pattern)):\n                while j+1 > 0 and pattern[j+1] != pattern[i]:\n                    j = prefix[j]\n                if pattern[j+1] == pattern[i]:\n                    j += 1\n                prefix[i] = j\n            return prefix\n\n        def KMP(text, pattern):\n            prefix = getPrefix(pattern)\n            j = -1\n            for i in xrange(len(text)):\n                while j+1 > 0 and pattern[j+1] != text[i]:\n                    j = prefix[j]\n                if pattern[j+1] == text[i]:\n                    j += 1\n                if j+1 == len(pattern):\n                    yield i-j\n                    j = prefix[j]\n\n        n = len(s)\n        T = [[0, 1],\n             [n-1, (n-1)-1]]\n        dp = [1, 0]\n        dp = matrix_mult([dp], matrix_expo(T, k))[0]  # [dp[0], dp[1]] * T^k\n        return reduce(lambda a, b: (a+b)%MOD, (dp[int(i != 0)] for i in KMP(s+s[:-1], t)), 0)\n\n\n# Time:  O(n + logk)\n# Space: O(n)\n# dp, matrix exponentiation, z-function\nclass Solution3(object):\n    def numberOfWays(self, s, t, k):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        def matrix_mult(A, B):\n            ZB = zip(*B)\n            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A]\n \n        def matrix_expo(A, K):\n            result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))]\n            while K:\n                if K % 2:\n                    result = matrix_mult(result, A)\n                A = matrix_mult(A, A)\n                K /= 2\n            return result\n\n        # Template: https://cp-algorithms.com/string/z-function.html\n        def z_function(s):  # Time: O(n), Space: O(n)\n            z = [0]*len(s)\n            l, r = 0, 0\n            for i in xrange(1, len(z)):\n                if i <= r:\n                    z[i] = min(r-i+1, z[i-l])\n                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:\n                    z[i] += 1\n                if i+z[i]-1 > r:\n                    l, r = i, i+z[i]-1\n            return z\n\n        n = len(s)\n        T = [[0, 1],\n             [n-1, (n-1)-1]]\n        dp = [1, 0]\n        dp = matrix_mult([dp], matrix_expo(T, k))[0]  # [dp[0], dp[1]] * T^k\n        z = z_function(t+s+s[:-1])\n        return reduce(lambda a, b: (a+b)%MOD, (dp[int(i != 0)] for i in xrange(n) if z[i+len(t)] >= len(t)), 0)\n"
    },
    {
        "problem_name": "string-transforms-into-another-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\n\n\nclass Solution(object):\n    def canConvert(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: bool\n        \"\"\"\n        if str1 == str2:\n            return True\n        lookup = {}\n        for i, j in itertools.izip(str1, str2):\n            if lookup.setdefault(i, j) != j:\n                return False\n        return len(set(str2)) < 26\n"
    },
    {
        "problem_name": "string-without-aaa-or-bbb",
        "solution": "# Time:  O(a + b)\n# Space: O(1)\n\nclass Solution(object):\n    def strWithout3a3b(self, A, B):\n        \"\"\"\n        :type A: int\n        :type B: int\n        :rtype: str\n        \"\"\"\n        result = []\n        put_A = None\n        while A or B:\n            if len(result) >= 2 and result[-1] == result[-2]:\n                put_A = result[-1] == 'b'\n            else:\n                put_A = A >= B\n\n            if put_A:\n                A -= 1\n                result.append('a')\n            else:\n                B -= 1\n                result.append('b')\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "strings-differ-by-one-character",
        "solution": "# Time:  O(n * m)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def differByOne(self, dict):\n        \"\"\"\n        :type dict: List[str]\n        :rtype: bool\n        \"\"\"\n        MOD, P = 10**9+7, 113\n\n        hashes = [0]*len(dict)\n        for i, word in enumerate(dict):\n            for c in word:\n                hashes[i] = (P*hashes[i] + (ord(c)-ord('a'))) % MOD\n\n        base = 1\n        for p in reversed(xrange(len(dict[0]))):        \n            lookup = collections.defaultdict(list)\n            for i, word in enumerate(dict):\n                new_hash = (hashes[i] - base*(ord(word[p])-ord('a'))) % MOD\n                if new_hash in lookup:\n                    for j in lookup[new_hash]:\n                        if dict[j][:p]+dict[j][p+1:] == word[:p]+word[p+1:]:\n                            return True\n                lookup[new_hash].append(i)\n            base = P*base % MOD\n        return False\n"
    },
    {
        "problem_name": "strobogrammatic-number-ii",
        "solution": "# Time:  O(n * 5^(n/2))\n# Space: O(n)\n\nclass Solution(object):\n    def findStrobogrammatic(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}\n        result = ['0', '1', '8'] if n%2 else ['']\n        for i in xrange(n%2, n, 2):\n            result = [a + num + b for a, b in lookup.iteritems() if i != n-2 or a != '0' for num in result]\n        return result\n\n\n# Time:  O(n * 5^(n/2))\n# Space: O(n)\nclass Solution2(object):\n    def findStrobogrammatic(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}\n        def findStrobogrammaticRecu(n, k):\n            if k == 0:\n                return ['']\n            elif k == 1:\n                return ['0', '1', '8']\n            result = []\n            for num in findStrobogrammaticRecu(n, k - 2):\n                for key, val in lookup.iteritems():\n                    if n != k or key != '0':\n                        result.append(key + num + val)\n            return result\n\n        return findStrobogrammaticRecu(n, n)\n\n"
    },
    {
        "problem_name": "strobogrammatic-number-iii",
        "solution": "# Time:  O(5^(n/2))\n# Space: O(n)\n\nclass Solution(object):\n    lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}\n    cache = {}\n\n    # @param {string} low\n    # @param {string} high\n    # @return {integer}\n    def strobogrammaticInRange(self, low, high):\n        count = self.countStrobogrammaticUntil(high, False) - \\\n                self.countStrobogrammaticUntil(low, False) + \\\n                self.isStrobogrammatic(low)\n        return count if count >= 0 else 0\n\n    def countStrobogrammaticUntil(self, num,  can_start_with_0):\n        if can_start_with_0 and num in self.cache:\n            return self.cache[num]\n\n        count = 0\n        if len(num) == 1:\n            for c in ['0', '1', '8']:\n                if num[0] >= c:\n                    count += 1\n            self.cache[num] = count\n            return count\n\n        for key, val in self.lookup.iteritems():\n            if can_start_with_0 or key != '0':\n                if num[0] > key:\n                    if len(num) == 2:  # num is like \"21\"\n                        count += 1\n                    else:  # num is like \"201\"\n                        count += self.countStrobogrammaticUntil('9' * (len(num) - 2), True)\n                elif num[0] == key:\n                    if len(num) == 2:  # num is like 12\".\n                        if num[-1] >= val:\n                            count += 1\n                    else:\n                        if num[-1] >= val:  # num is like \"102\".\n                            count += self.countStrobogrammaticUntil(self.getMid(num), True)\n                        elif (self.getMid(num) != '0' * (len(num) - 2)):  # num is like \"110\".\n                            count += self.countStrobogrammaticUntil(self.getMid(num), True) - \\\n                                     self.isStrobogrammatic(self.getMid(num))\n\n        if not can_start_with_0: # Sum up each length.\n            for i in xrange(len(num) - 1, 0, -1):\n                count += self.countStrobogrammaticByLength(i)\n        else:\n            self.cache[num] = count\n\n        return count\n\n    def getMid(self, num):\n        return num[1:len(num) - 1]\n\n    def countStrobogrammaticByLength(self, n):\n        if n == 1:\n            return 3\n        elif n == 2:\n            return 4\n        elif n == 3:\n            return 4 * 3\n        else:\n            return 5 * self.countStrobogrammaticByLength(n - 2)\n\n    def isStrobogrammatic(self, num):\n        n = len(num)\n        for i in xrange((n+1) / 2):\n            if num[n-1-i] not in self.lookup or \\\n               num[i] != self.lookup[num[n-1-i]]:\n                return False\n        return True\n\n"
    },
    {
        "problem_name": "strobogrammatic-number",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'}\n\n    # @param {string} num\n    # @return {boolean}\n    def isStrobogrammatic(self, num):\n        n = len(num)\n        for i in xrange((n+1) / 2):\n            if num[n-1-i] not in self.lookup or \\\n               num[i] != self.lookup[num[n-1-i]]:\n                return False\n        return True\n\n"
    },
    {
        "problem_name": "strong-password-checker-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def strongPasswordCheckerII(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: bool\n        \"\"\"\n        SPECIAL = set(\"!@#$%^&*()-+\")\n        return (len(password) >= 8 and\n                any(c.islower() for c in password) and\n                any(c.isupper() for c in password) and\n                any(c.isdigit() for c in password) and\n                any(c in SPECIAL for c in password) and\n                all(password[i] != password[i+1] for i in xrange(len(password)-1)))\n"
    },
    {
        "problem_name": "strong-password-checker",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def strongPasswordChecker(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        missing_type_cnt = 3\n        if any('a' <= c <= 'z' for c in s):\n            missing_type_cnt -= 1\n        if any('A' <= c <= 'Z' for c in s):\n            missing_type_cnt -= 1\n        if any(c.isdigit() for c in s):\n            missing_type_cnt -= 1\n\n        total_change_cnt = 0\n        one_change_cnt, two_change_cnt, three_change_cnt = 0, 0, 0\n        i = 2\n        while i < len(s):\n            if s[i] == s[i-1] == s[i-2]:\n                length = 2\n                while i < len(s) and s[i] == s[i-1]:\n                    length += 1\n                    i += 1\n\n                total_change_cnt += length / 3\n                if length % 3 == 0:\n                    one_change_cnt += 1\n                elif length % 3 == 1:\n                    two_change_cnt += 1\n                else:\n                    three_change_cnt += 1\n            else:\n                i += 1\n\n        if len(s) < 6:\n            return max(missing_type_cnt, 6 - len(s))\n        elif len(s) <= 20:\n            return max(missing_type_cnt, total_change_cnt)\n        else:\n            delete_cnt = len(s) - 20\n\n            total_change_cnt -= min(delete_cnt, one_change_cnt * 1) / 1\n            total_change_cnt -= min(max(delete_cnt - one_change_cnt, 0), two_change_cnt * 2) / 2\n            total_change_cnt -= min(max(delete_cnt - one_change_cnt - 2 * two_change_cnt, 0), three_change_cnt * 3) / 3\n\n            return delete_cnt + max(missing_type_cnt, total_change_cnt)\n\n"
    },
    {
        "problem_name": "student-attendance-record-i",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def checkRecord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        count_A = 0\n        for i in xrange(len(s)):\n            if s[i] == 'A':\n                count_A += 1\n                if count_A == 2:\n                    return False\n            if i < len(s) - 2 and s[i] == s[i+1] == s[i+2] == 'L':\n                return False\n        return True\n\n\n"
    },
    {
        "problem_name": "student-attendance-record-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        M = 1000000007\n        a0l0, a0l1, a0l2, a1l0, a1l1, a1l2 = 1, 0, 0, 0, 0, 0\n        for i in xrange(n+1):\n            a0l2, a0l1, a0l0 = a0l1, a0l0, (a0l0 + a0l1 + a0l2) % M\n            a1l2, a1l1, a1l0 = a1l1, a1l0, (a0l0 + a1l0 + a1l1 + a1l2) % M\n        return a1l0\n\n"
    },
    {
        "problem_name": "subarray-product-less-than-k",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numSubarrayProductLessThanK(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k <= 1: return 0\n        result, start, prod = 0, 0, 1\n        for i, num in enumerate(nums):\n            prod *= num\n            while prod >= k:\n                prod /= nums[start]\n                start += 1\n            result += i-start+1\n        return result\n\n\n"
    },
    {
        "problem_name": "subarray-sum-equals-k",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def subarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        accumulated_sum = 0\n        lookup = collections.defaultdict(int)\n        lookup[0] += 1\n        for num in nums:\n            accumulated_sum += num\n            result += lookup[accumulated_sum - k]\n            lookup[accumulated_sum] += 1\n        return result\n\n"
    },
    {
        "problem_name": "subarray-sums-divisible-by-k",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\nimport collections\n\n\nclass Solution(object):\n    def subarraysDivByK(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        count = collections.defaultdict(int)\n        count[0] = 1\n        result, prefix = 0, 0\n        for a in A:\n            prefix = (prefix+a) % K\n            result += count[prefix]\n            count[prefix] += 1\n        return result\n"
    },
    {
        "problem_name": "subarray-with-elements-greater-than-varying-threshold",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# mono stack\nclass Solution(object):\n    def validSubarraySize(self, nums, threshold):\n        \"\"\"\n        :type nums: List[int]\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        stk = [-1]\n        for i in xrange(len(nums)+1):\n            while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]):\n                if nums[stk.pop()]*((i-1)-stk[-1]) > threshold:\n                    return (i-1)-stk[-1]\n            stk.append(i)\n        return -1\n"
    },
    {
        "problem_name": "subarrays-distinct-element-sum-of-squares-i",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\nfrom sortedcontainers import SortedList\n\n\n# bit, fenwick tree, sorted list, math\nclass Solution(object):\n    def sumCounts(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n):\n                self.__bit = [0]*(n+1)  # Extra one for dummy node.\n\n            def add(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] = (self.__bit[i]+val) % MOD\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = 0\n                while i > 0:\n                    ret = (ret+self.__bit[i]) % MOD\n                    i -= (i & -i)\n                return ret\n\n        def update(accu, d):\n            i = sl.bisect_left(idxs[x][-1])\n            accu = (accu + d*(len(nums)*(2*len(sl)-1) - (2*i+1)*idxs[x][-1] - 2*(bit.query(len(nums)-1)-bit.query(idxs[x][-1])))) % MOD\n            bit.add(idxs[x][-1], d*idxs[x][-1])\n            return accu\n\n        idxs = collections.defaultdict(list)\n        for i in reversed(xrange(len(nums))):\n            idxs[nums[i]].append(i)\n        result = 0\n        sl = SortedList(idxs[x][-1] for x in idxs)\n        accu = (len(nums)*len(sl)**2) % MOD\n        for i, x in enumerate(sl):\n            accu = (accu-(2*i+1)*x) % MOD\n        bit = BIT(len(nums))\n        for x in sl:\n            bit.add(x, x)\n        for x in nums:\n            result = (result+accu) % MOD  # accu = sum(count(i, k) for k in range(i, len(nums)))\n            accu = update(accu, -1)\n            del sl[0]\n            idxs[x].pop()\n            if not idxs[x]:\n                continue\n            sl.add(idxs[x][-1])\n            accu = update(accu, +1)\n        assert(accu == 0)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# dp, segment tree, math\nclass Solution2(object):\n    def sumCounts(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        # Template:\n        # https://github.com/kamyu104/LeetCode-Solutions/blob/master/Python/longest-substring-of-one-repeating-character.py\n        class SegmentTree(object):\n            def __init__(self, N,\n                         build_fn=None,\n                         query_fn=lambda x, y: y if x is None else x if y is None else (x+y)%MOD,\n                         update_fn=lambda x, y: y if x is None else (x+y)%MOD):\n                self.tree = [None]*(1<<((N-1).bit_length()+1))\n                self.base = len(self.tree)>>1\n                self.lazy = [None]*self.base\n                self.query_fn = query_fn\n                self.update_fn = update_fn\n                if build_fn is not None:\n                    for i in xrange(self.base, self.base+N):\n                        self.tree[i] = build_fn(i-self.base)\n                    for i in reversed(xrange(1, self.base)):\n                        self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])\n                self.count = [1]*len(self.tree)  # added\n                for i in reversed(xrange(1, self.base)):  # added\n                    self.count[i] = self.count[i<<1] + self.count[(i<<1)+1]\n\n            def __apply(self, x, val):\n                self.tree[x] = self.update_fn(self.tree[x], val*self.count[x])  # modified\n                if x < self.base:\n                    self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n            def __push(self, x):\n                for h in reversed(xrange(1, x.bit_length())):\n                    y = x>>h\n                    if self.lazy[y] is not None:\n                        self.__apply(y<<1, self.lazy[y])\n                        self.__apply((y<<1)+1, self.lazy[y])\n                        self.lazy[y] = None\n\n            def update(self, L, R, h):  # Time: O(logN), Space: O(N)\n                def pull(x):\n                    while x > 1:\n                        x >>= 1\n                        self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])\n                        if self.lazy[x] is not None:\n                            self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x])  # modified\n\n                L += self.base\n                R += self.base\n                # self.__push(L)  # enable if range assignment\n                # self.__push(R)  # enable if range assignment\n                L0, R0 = L, R\n                while L <= R:\n                    if L & 1:  # is right child\n                        self.__apply(L, h)\n                        L += 1\n                    if R & 1 == 0:  # is left child\n                        self.__apply(R, h)\n                        R -= 1\n                    L >>= 1\n                    R >>= 1\n                pull(L0)\n                pull(R0)\n\n            def query(self, L, R):\n                if L > R:\n                    return None\n                L += self.base\n                R += self.base\n                self.__push(L)\n                self.__push(R)\n                left = right = None\n                while L <= R:\n                    if L & 1:\n                        left = self.query_fn(left, self.tree[L])\n                        L += 1\n                    if R & 1 == 0:\n                        right = self.query_fn(self.tree[R], right)\n                        R -= 1\n                    L >>= 1\n                    R >>= 1\n                return self.query_fn(left, right)\n\n        result = accu = 0\n        sl = {}\n        st = SegmentTree(len(nums))\n        for i in xrange(len(nums)):\n            j = sl[nums[i]] if nums[i] in sl else -1\n            # sum(count(k, i)^2 for k in range(i+1)) - sum(count(k, i-1)^2 for k in range(i))\n            # = sum(2*count(k, i-1)+1 for k in range(j+1, i+1))\n            # = (i-j) + sum(2*count(k, i-1) for k in range(j+1, i+1))\n            accu = (accu+((i-j)+2*max(st.query(j+1, i), 0)))%MOD\n            result = (result+accu)%MOD\n            st.update(j+1, i, 1)  # count(k, i) = count(k, i-1)+(1 if k >= j+1 else 0) for k in range(i+1)\n            sl[nums[i]] = i\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# hash table\nclass Solution3(object):\n    def sumCounts(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result = 0\n        for i in xrange(len(nums)):\n            lookup = set()\n            for j in reversed(xrange(i+1)):\n                lookup.add(nums[j])\n                result = (result+len(lookup)**2) % MOD\n        return result\n"
    },
    {
        "problem_name": "subarrays-distinct-element-sum-of-squares-ii",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\nfrom sortedcontainers import SortedList\n\n\n# bit, fenwick tree, sorted list, math\nclass Solution(object):\n    def sumCounts(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        class BIT(object):  # 0-indexed.\n            def __init__(self, n):\n                self.__bit = [0]*(n+1)  # Extra one for dummy node.\n\n            def add(self, i, val):\n                i += 1  # Extra one for dummy node.\n                while i < len(self.__bit):\n                    self.__bit[i] = (self.__bit[i]+val) % MOD\n                    i += (i & -i)\n\n            def query(self, i):\n                i += 1  # Extra one for dummy node.\n                ret = 0\n                while i > 0:\n                    ret = (ret+self.__bit[i]) % MOD\n                    i -= (i & -i)\n                return ret\n\n        def update(accu, d):\n            i = sl.bisect_left(idxs[x][-1])\n            accu = (accu + d*(len(nums)*(2*len(sl)-1) - (2*i+1)*idxs[x][-1] - 2*(bit.query(len(nums)-1)-bit.query(idxs[x][-1])))) % MOD\n            bit.add(idxs[x][-1], d*idxs[x][-1])\n            return accu\n\n        idxs = collections.defaultdict(list)\n        for i in reversed(xrange(len(nums))):\n            idxs[nums[i]].append(i)\n        result = 0\n        sl = SortedList(idxs[x][-1] for x in idxs)\n        accu = (len(nums)*len(sl)**2) % MOD\n        for i, x in enumerate(sl):\n            accu = (accu-(2*i+1)*x) % MOD\n        bit = BIT(len(nums))\n        for x in sl:\n            bit.add(x, x)\n        for x in nums:\n            result = (result+accu) % MOD  # accu = sum(count(i, k) for k in range(i, len(nums)))\n            accu = update(accu, -1)\n            del sl[0]\n            idxs[x].pop()\n            if not idxs[x]:\n                continue\n            sl.add(idxs[x][-1])\n            accu = update(accu, +1)\n        assert(accu == 0)\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(n)\n# dp, segment tree, math\nclass Solution2(object):\n    def sumCounts(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        # Template:\n        # https://github.com/kamyu104/LeetCode-Solutions/blob/master/Python/longest-substring-of-one-repeating-character.py\n        class SegmentTree(object):\n            def __init__(self, N,\n                         build_fn=None,\n                         query_fn=lambda x, y: y if x is None else x if y is None else (x+y)%MOD,\n                         update_fn=lambda x, y: y if x is None else (x+y)%MOD):\n                self.tree = [None]*(1<<((N-1).bit_length()+1))\n                self.base = len(self.tree)>>1\n                self.lazy = [None]*self.base\n                self.query_fn = query_fn\n                self.update_fn = update_fn\n                if build_fn is not None:\n                    for i in xrange(self.base, self.base+N):\n                        self.tree[i] = build_fn(i-self.base)\n                    for i in reversed(xrange(1, self.base)):\n                        self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1])\n                self.count = [1]*len(self.tree)  # added\n                for i in reversed(xrange(1, self.base)):  # added\n                    self.count[i] = self.count[i<<1] + self.count[(i<<1)+1]\n\n            def __apply(self, x, val):\n                self.tree[x] = self.update_fn(self.tree[x], val*self.count[x])  # modified\n                if x < self.base:\n                    self.lazy[x] = self.update_fn(self.lazy[x], val)\n\n            def __push(self, x):\n                for h in reversed(xrange(1, x.bit_length())):\n                    y = x>>h\n                    if self.lazy[y] is not None:\n                        self.__apply(y<<1, self.lazy[y])\n                        self.__apply((y<<1)+1, self.lazy[y])\n                        self.lazy[y] = None\n\n            def update(self, L, R, h):  # Time: O(logN), Space: O(N)\n                def pull(x):\n                    while x > 1:\n                        x >>= 1\n                        self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1])\n                        if self.lazy[x] is not None:\n                            self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x])  # modified\n\n                L += self.base\n                R += self.base\n                # self.__push(L)  # enable if range assignment\n                # self.__push(R)  # enable if range assignment\n                L0, R0 = L, R\n                while L <= R:\n                    if L & 1:  # is right child\n                        self.__apply(L, h)\n                        L += 1\n                    if R & 1 == 0:  # is left child\n                        self.__apply(R, h)\n                        R -= 1\n                    L >>= 1\n                    R >>= 1\n                pull(L0)\n                pull(R0)\n\n            def query(self, L, R):\n                if L > R:\n                    return None\n                L += self.base\n                R += self.base\n                self.__push(L)\n                self.__push(R)\n                left = right = None\n                while L <= R:\n                    if L & 1:\n                        left = self.query_fn(left, self.tree[L])\n                        L += 1\n                    if R & 1 == 0:\n                        right = self.query_fn(self.tree[R], right)\n                        R -= 1\n                    L >>= 1\n                    R >>= 1\n                return self.query_fn(left, right)\n\n        result = accu = 0\n        sl = {}\n        st = SegmentTree(len(nums))\n        for i in xrange(len(nums)):\n            j = sl[nums[i]] if nums[i] in sl else -1\n            # sum(count(k, i)^2 for k in range(i+1)) - sum(count(k, i-1)^2 for k in range(i))\n            # = sum(2*count(k, i-1)+1 for k in range(j+1, i+1))\n            # = (i-j) + sum(2*count(k, i-1) for k in range(j+1, i+1))\n            accu = (accu+((i-j)+2*max(st.query(j+1, i), 0)))%MOD\n            result = (result+accu)%MOD\n            st.update(j+1, i, 1)  # count(k, i) = count(k, i-1)+(1 if k >= j+1 else 0) for k in range(i+1)\n            sl[nums[i]] = i\n        return result\n"
    },
    {
        "problem_name": "subarrays-with-k-different-integers",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\nimport collections\n\n\nclass Solution(object):\n    def subarraysWithKDistinct(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        def atMostK(A, K):\n            count = collections.defaultdict(int)\n            result, left = 0, 0\n            for right in xrange(len(A)):\n                count[A[right]] += 1\n                while len(count) > K:\n                    count[A[left]] -= 1\n                    if count[A[left]] == 0:\n                        count.pop(A[left])\n                    left += 1\n                result += right-left+1\n            return result\n        \n        return atMostK(A, K) - atMostK(A, K-1)\n\n\n# Time:  O(n)\n# Space: O(k)\nclass Window(object):\n    def __init__(self):\n        self.__count = collections.defaultdict(int)\n\n    def add(self, x):\n        self.__count[x] += 1\n\n    def remove(self, x):\n        self.__count[x] -= 1\n        if self.__count[x] == 0:\n            self.__count.pop(x)\n            \n    def size(self):\n        return len(self.__count)\n\n\nclass Solution2(object):\n    def subarraysWithKDistinct(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        window1, window2 = Window(), Window()\n        result, left1, left2 = 0, 0, 0\n        for i in A:\n            window1.add(i)\n            while window1.size() > K:\n                window1.remove(A[left1])\n                left1 += 1\n            window2.add(i)\n            while window2.size() >= K:\n                window2.remove(A[left2])\n                left2 += 1\n            result += left2-left1\n        return result\n"
    },
    {
        "problem_name": "subdomain-visit-count",
        "solution": "# Time:  O(n), is the length of cpdomains (assuming the length of cpdomains[i] is fixed)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def subdomainVisits(self, cpdomains):\n        \"\"\"\n        :type cpdomains: List[str]\n        :rtype: List[str]\n        \"\"\"\n        result = collections.defaultdict(int)\n        for domain in cpdomains:\n            count, domain = domain.split()\n            count = int(count)\n            frags = domain.split('.')\n            curr = []\n            for i in reversed(xrange(len(frags))):\n                curr.append(frags[i])\n                result[\".\".join(reversed(curr))] += count\n\n        return [\"{} {}\".format(count, domain) \\\n                for domain, count in result.iteritems()]\n\n"
    },
    {
        "problem_name": "subrectangle-queries",
        "solution": "# Time:  ctor:   O(1)\n#        update: O(1)\n#        get:    O(u), u is the number of updates\n# Space: O(u)\n\nclass SubrectangleQueries(object):\n\n    def __init__(self, rectangle):\n        \"\"\"\n        :type rectangle: List[List[int]]\n        \"\"\"\n        self.__rectangle = rectangle\n        self.__updates = []\n        \n\n    def updateSubrectangle(self, row1, col1, row2, col2, newValue):\n        \"\"\"\n        :type row1: int\n        :type col1: int\n        :type row2: int\n        :type col2: int\n        :type newValue: int\n        :rtype: None\n        \"\"\"\n        self.__updates.append((row1, col1, row2, col2, newValue))\n\n    def getValue(self, row, col):\n        \"\"\"\n        :type row: int\n        :type col: int\n        :rtype: int\n        \"\"\"\n        for (row1, col1, row2, col2, newValue) in reversed(self.__updates):\n            if row1 <= row <= row2 and col1 <= col <= col2:\n                return newValue\n        return self.__rectangle[row][col]\n\n\n# Time:  ctor:   O(1)\n#        update: O(m * n)\n#        get:    O(1)\n# Space: O(1)\nclass SubrectangleQueries2(object):\n\n    def __init__(self, rectangle):\n        \"\"\"\n        :type rectangle: List[List[int]]\n        \"\"\"\n        self.__rectangle = rectangle\n        \n\n    def updateSubrectangle(self, row1, col1, row2, col2, newValue):\n        \"\"\"\n        :type row1: int\n        :type col1: int\n        :type row2: int\n        :type col2: int\n        :type newValue: int\n        :rtype: None\n        \"\"\"\n        for r in xrange(row1, row2+1):\n            for c in xrange(col1, col2+1):\n                self.__rectangle[r][c] = newValue\n\n    def getValue(self, row, col):\n        \"\"\"\n        :type row: int\n        :type col: int\n        :rtype: int\n        \"\"\"\n        return self.__rectangle[row][col]\n"
    },
    {
        "problem_name": "subsequence-of-size-k-with-the-largest-even-sum",
        "solution": "# Time:  O(n) on average\n# Space: O(1)\n\nimport random\n\n\n# quick select solution\nclass Solution(object):\n    def largestEvenSum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        nth_element(nums, k-1, compare=lambda a, b: a > b)\n        total = sum(nums[i] for i in xrange(k))\n        if total%2 == 0:\n            return total\n        min_k = [float(\"inf\")]*2\n        for i in xrange(k):\n            min_k[nums[i]%2] = min(min_k[nums[i]%2], nums[i])\n        result = -1\n        for i in xrange(k, len(nums)):\n            result = max(result, total-min_k[not (nums[i]%2)]+nums[i])\n        return result\n"
    },
    {
        "problem_name": "subsequence-with-the-minimum-score",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# two pointers, dp\nclass Solution(object):\n    def minimumScore(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        right = [-1]*len(s)  # right[i]: min removed rightmost index in s[i:]\n        j = len(t)-1\n        for i in reversed(xrange(len(s))):\n            if j >= 0 and t[j] == s[i]:\n                j -= 1\n            right[i] = j\n        result = j+1\n        left = 0  # left at i: max removed leftmost index in s[:i]\n        for i in xrange(len(s)):\n            result = max(min(result, right[i]-left+1), 0)\n            if left < len(t) and t[left] == s[i]:\n                left += 1\n        result = min(result, len(t)-left)\n        return result\n"
    },
    {
        "problem_name": "subsets-ii",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(1)\n\nclass Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = [[]]\n        previous_size = 0\n        for i in xrange(len(nums)):\n            size = len(result)\n            for j in xrange(size):\n                # Only union non-duplicate element or new union set.\n                if i == 0 or nums[i] != nums[i - 1] or j >= previous_size:\n                    result.append(list(result[j]))\n                    result[-1].append(nums[i])\n            previous_size = size\n        return result\n\n\n# Time:  O(n * 2^n) ~ O((n * 2^n)^2)\n# Space: O(1)\nclass Solution2(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i, count = 0, 1 << len(nums)\n        nums.sort()\n\n        while i < count:\n            cur = []\n            for j in xrange(len(nums)):\n                if i & 1 << j:\n                    cur.append(nums[j])\n            if cur not in result:\n                result.append(cur)\n            i += 1\n\n        return result\n\n\n# Time:  O(n * 2^n) ~ O((n * 2^n)^2)\n# Space: O(1)\nclass Solution3(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        self.subsetsWithDupRecu(result, [], sorted(nums))\n        return result\n\n    def subsetsWithDupRecu(self, result, cur, nums):\n        if not nums:\n            if cur not in result:\n                result.append(cur)\n        else:\n            self.subsetsWithDupRecu(result, cur, nums[1:])\n            self.subsetsWithDupRecu(result, cur + [nums[0]], nums[1:])\n\n\n"
    },
    {
        "problem_name": "subsets",
        "solution": "# Time:  O(n * 2^n)\n# Space: O(1)\n\nclass Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = [[]]\n        for i in xrange(len(nums)):\n            size = len(result)\n            for j in xrange(size):\n                result.append(list(result[j]))\n                result[-1].append(nums[i])\n        return result\n\n\n# Time:  O(n * 2^n)\n# Space: O(1)\nclass Solution2(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i, count = 0, 1 << len(nums)\n        nums.sort()\n\n        while i < count:\n            cur = []\n            for j in xrange(len(nums)):\n                if i & 1 << j:\n                    cur.append(nums[j])\n            result.append(cur)\n            i += 1\n\n        return result\n\n\n# Time:  O(n * 2^n)\n# Space: O(1)\nclass Solution3(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        return self.subsetsRecu([], sorted(nums))\n\n    def subsetsRecu(self, cur, nums):\n        if not nums:\n            return [cur]\n\n        return self.subsetsRecu(cur, nums[1:]) + self.subsetsRecu(cur + [nums[0]], nums[1:])\n\n\n"
    },
    {
        "problem_name": "substring-with-concatenation-of-all-words",
        "solution": "# Time:  O((m + n) * k), where m is string length, n is dictionary size, k is word length\n# Space: O(n * k)\n\nimport collections\n\n\nclass Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        if not words:\n            return []\n\n        result, m, n, k = [], len(s), len(words), len(words[0])\n        if m < n*k:\n            return result\n\n        lookup = collections.defaultdict(int)\n        for i in words:\n            lookup[i] += 1                # Space: O(n * k)\n\n        for i in xrange(k):               # Time:  O(k)\n            left, count = i, 0\n            tmp = collections.defaultdict(int)\n            for j in xrange(i, m-k+1, k): # Time:  O(m / k)\n                s1 = s[j:j+k]             # Time:  O(k)\n                if s1 in lookup:\n                    tmp[s1] += 1\n                    count += 1\n                    while tmp[s1] > lookup[s1]:\n                        tmp[s[left:left+k]] -= 1\n                        count -= 1\n                        left += k\n                    if count == n:\n                        result.append(left)\n                else:\n                    tmp = collections.defaultdict(int)\n                    count = 0\n                    left = j+k\n        return result\n\n\n# Time:  O(m * n * k), where m is string length, n is dictionary size, k is word length\n# Space: O(n * k)\nclass Solution2(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        result, m, n, k = [], len(s), len(words), len(words[0])\n        if m < n*k:\n            return result\n\n        lookup = collections.defaultdict(int)\n        for i in words:\n            lookup[i] += 1                            # Space: O(n * k)\n\n        for i in xrange(m+1-k*n):                     # Time: O(m)\n            cur, j = collections.defaultdict(int), 0\n            while j < n:                              # Time: O(n)\n                word = s[i+j*k:i+j*k+k]               # Time: O(k)\n                if word not in lookup:\n                    break\n                cur[word] += 1\n                if cur[word] > lookup[word]:\n                    break\n                j += 1\n            if j == n:\n                result.append(i)\n\n        return result\n\n\n"
    },
    {
        "problem_name": "substring-with-largest-variance",
        "solution": "# Time:  O(a^2 * n), a is the size of alphabets\n# Space: O(a)\n\nimport itertools\n\n\n# kadane's algorithm\nclass Solution(object):\n    def largestVariance(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def modified_kadane(a, x, y):\n            result = curr = 0\n            lookup = [0]*2\n            remain = [a.count(x), a.count(y)]\n            for c in a:\n                if c not in (x, y):\n                    continue\n                lookup[c != x] = 1\n                remain[c != x] -= 1\n                curr += 1 if c == x else -1\n                if curr < 0 and remain[0] and remain[1]:\n                    curr = lookup[0] = lookup[1] = 0  # reset states if the remain has both x, y\n                if lookup[0] and lookup[1]:\n                    result = max(result, curr)  # update result if x, y both exist\n            return result\n\n        alphabets = set(s)\n        return max(modified_kadane(s, x, y) for x, y in itertools.permutations(alphabets, 2)) if len(alphabets) >= 2 else 0\n"
    },
    {
        "problem_name": "substring-xor-queries",
        "solution": "# Time:  O(n * logr + q), r = max(a^b for a, b in queries)\n# Space: O(min(n * logr, r))\n\n# hash table\nclass Solution(object):\n    def substringXorQueries(self, s, queries):\n        \"\"\"\n        :type s: str\n        :type queries: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        mx = max(a^b for a, b in queries)\n        lookup = {}\n        for i in xrange(len(s)):\n            curr = 0\n            for j in xrange(i, len(s)):\n                curr = (curr<<1)+int(s[j])\n                if curr > mx:\n                    break\n                if curr not in lookup:\n                    lookup[curr] = [i, j]\n                if s[i] == '0':\n                    break\n        return [lookup[a^b] if a^b in lookup else [-1, -1] for a, b in queries]\n"
    },
    {
        "problem_name": "substrings-of-size-three-with-distinct-characters",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def countGoodSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        K = 3\n\n        result = 0\n        count = collections.Counter()\n        for i in xrange(len(s)):\n            if i >= K:\n                count[s[i-K]] -= 1\n                if not count[s[i-K]]:\n                    del count[s[i-K]]\n            count[s[i]] += 1\n            if len(count) == K:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "substrings-that-begin-and-end-with-the-same-letter",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def numberOfSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        cnt = collections.Counter()\n        for c in s:\n            cnt[c] += 1\n            result += cnt[c]\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\nimport collections\n\n\nclass Solution(object):\n    def numberOfSubstrings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return sum(v*(v+1)//2 for v in collections.Counter(s).itervalues())\n"
    },
    {
        "problem_name": "subtract-the-product-and-sum-of-digits-of-an-integer",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def subtractProductAndSum(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        product, total = 1, 0\n        while n:\n            n, r = divmod(n, 10)\n            product *= r\n            total += r\n        return product-total\n\n\n# Time:  O(logn)\n# Space: O(logn)\nimport operator\n\n\nclass Solution2(object):\n    def subtractProductAndSum(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        A = map(int, str(n))\n        return reduce(operator.mul, A) - sum(A)\n"
    },
    {
        "problem_name": "subtree-of-another-tree",
        "solution": "# Time:  O(m * n), m is the number of nodes of s, n is the number of nodes of t\n# Space: O(h), h is the height of s\n\nclass Solution(object):\n    def isSubtree(self, s, t):\n        \"\"\"\n        :type s: TreeNode\n        :type t: TreeNode\n        :rtype: bool\n        \"\"\"\n        def isSame(x, y):\n            if not x and not y:\n                return True\n            if not x or not y:\n                return False\n            return x.val == y.val and \\\n                   isSame(x.left, y.left) and \\\n                   isSame(x.right, y.right)\n\n        def preOrderTraverse(s, t):\n            return s != None and \\\n                   (isSame(s, t) or \\\n                    preOrderTraverse(s.left, t) or \\\n                    preOrderTraverse(s.right, t))\n\n        return preOrderTraverse(s, t)\n\n"
    },
    {
        "problem_name": "subtree-removal-game-with-fibonacci-tree",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findGameWinner(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\" \n        # a pattern appears every 6 grundy numbers in binary forms:\n        # 0000,       (0000)01,       (0000)11,                 ((0000)^(0000+1))10,       (0000)11,       (0000)11\n        # 0000,     (0000+1)01,     (0000+1)11,           ((0000+1)^((0000+1)+1))10,     (0000+1)11,     (0000+1)11\n        # 0000, ((0000+1)+1)01, ((0000+1)+1)11,   (((0000+1)+1)^(((0000+1)+1)+1))10, ((0000+1)+1)11, ((0000+1)+1)11\n        # ...\n        # 0000,       (XXXX)01,       (XXXX)11,                 ((XXXX)^(XXXX+1))10,       (XXXX)11,       (XXXX)11\n        # 0000,     (XXXX+1)01,     (XXXX+1)11,           ((XXXX+1)^((XXXX+1)+1))10,     (XXXX+1)11,     (XXXX+1)11\n        # => grundy[6k+1] = 0\n        #    grundy[6k+2] = 4k+1\n        #    grundy[6k+3] = 4k+3\n        #    grundy[6k+4] = 4(k^(k+1))+2\n        #    grundy[6k+5] = 4k+3\n        #    grundy[6k+6] = 4k+3\n        return n%6 != 1\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def findGameWinner(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\" \n        grundy = [0, 1]  # 0-indexed\n        for i in xrange(2, n):\n            grundy[i%2] = (grundy[(i-1)%2]+1)^(grundy[(i-2)%2]+1)  # colon principle, replace the branches by a non-branching stalk of length equal to their nim sum\n        return grundy[(n-1)%2] > 0\n"
    },
    {
        "problem_name": "successful-pairs-of-spells-and-potions",
        "solution": "# Time:  O(mlogm + nlogm)\n# Space: O(1)\n\n# binary search\nclass Solution(object):\n    def successfulPairs(self, spells, potions, success):\n        \"\"\"\n        :type spells: List[int]\n        :type potions: List[int]\n        :type success: int\n        :rtype: List[int]\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+(b-1))//b\n            \n        potions.sort()\n        return [len(potions)-bisect.bisect_left(potions, ceil_divide(success, s)) for s in spells]\n"
    },
    {
        "problem_name": "sudoku-solver",
        "solution": "# Time:  ((9!)^9)\n# Space: (1)\n\nclass Solution(object):\n    # @param board, a 9x9 2D array\n    # Solve the Sudoku by modifying the input board in-place.\n    # Do not return any value.\n    def solveSudoku(self, board):\n        def isValid(board, x, y):\n            for i in xrange(9):\n                if i != x and board[i][y] == board[x][y]:\n                    return False\n            for j in xrange(9):\n                if j != y and board[x][j] == board[x][y]:\n                    return False\n            i = 3 * (x / 3)\n            while i < 3 * (x / 3 + 1):\n                j = 3 * (y / 3)\n                while j < 3 * (y / 3 + 1):\n                    if (i != x or j != y) and board[i][j] == board[x][y]:\n                        return False\n                    j += 1\n                i += 1\n            return True\n\n        def solver(board):\n            for i in xrange(len(board)):\n                for j in xrange(len(board[0])):\n                    if(board[i][j] == '.'):\n                        for k in xrange(9):\n                            board[i][j] = chr(ord('1') + k)\n                            if isValid(board, i, j) and solver(board):\n                                return True\n                            board[i][j] = '.'\n                        return False\n            return True\n\n        solver(board)\n\n"
    },
    {
        "problem_name": "sum-game",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def sumGame(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: bool\n        \"\"\"\n        # (1) if both halfs have '?',\n        #     alice will optimally choose 9 or 0 from one half to maximize or minimize the diff of both half sums,\n        #     and bob will optimally choose the same number from the other half to minimize or maximize the diff of both half sums.\n        #     in the end, it turns that only one half has '?' and the diff of both half sums is still the same as original\n        # (2) if smaller half has no '?', then alice wins\n        # (3) if smaller half has '?'\n        #     (3.1) if cnt of '?' is odd, alice can choose the last number to make the diff of both half sums != 0, then alice wins\n        #     (3.2) if cnt of '?' is even\n        #           (3.2.1) if larger-smaller = cnt/2 * 9, bob can always make a pair of sum 9 no matter what alice chooses, then bob wins\n        #           (3.2.2) if larger-smaller > cnt/2 * 9, alice can always choose 0 no matter what bob chooses, then alice wins\n        #           (3.2.3) if larger-smaller < cnt/2 * 9, alice can always choose 9 no matter what bob chooses, then alice wins\n        cnt = total = 0\n        for i in xrange(len(num)):\n            if num[i] == '?':\n                cnt += (-1 if i < len(num)//2 else 1)\n            else:\n                total += (int(num[i]) if i < len(num)//2 else -int(num[i]))\n        return True if cnt%2 else total != cnt//2*9\n"
    },
    {
        "problem_name": "sum-in-a-matrix",
        "solution": "# Time:  O(m * nlogn)\n# Space: O(1)\n\n# sort\nclass Solution(object):\n    def matrixSum(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: int\n        \"\"\"\n        for row in nums:\n            row.sort()\n        return sum(max(nums[r][c] for r in xrange(len(nums))) for c in xrange(len(nums[0])))\n"
    },
    {
        "problem_name": "sum-multiples",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math, principle of inclusion and exclusion\nclass Solution(object):\n    def sumOfMultiples(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def f(d):\n            return d*((1+(n//d))*(n//d)//2)\n        \n        return (f(3)+f(5)+f(7))-(f(3*5)+f(5*7)+f(7*3))+f(3*5*7)\n"
    },
    {
        "problem_name": "sum-of-absolute-differences-in-a-sorted-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def getSumAbsoluteDifferences(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        prefix, suffix = 0, sum(nums)\n        result = []\n        for i, num in enumerate(nums):\n            suffix -= num\n            result.append((i*num-prefix) + (suffix-((len(nums)-1)-i)*num))\n            prefix += num\n        return result\n"
    },
    {
        "problem_name": "sum-of-all-odd-length-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def sumOddLengthSubarrays(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        def ceil_divide(a, b):\n            return (a+(b-1))//b\n \n        # begin\\pos |0   i       (n-1)\n        # ----------------------------\n        # 0          --101....      \u2191\n        # 1           -010....    i-0+1\n        # i            101....      \u2193\n        #              \u2190 (n-1-i+1) \u2192\n        #\n        # for each number x with its position i, we want to know how many odd length subarrays is with x,\n        # as the graph depicted above,\n        # (begin, pos) pair represents a subarray arr[begin:pos+1] containing x, marked 1 if odd length else 0,\n        # so the total number of 0 and 1 are exactly the total number of subarrays with x, which is (i-0+1)*((len(arr)-1)-i+1),\n        # because the number of 1 is always equal to or one more than the number of 0, (always begins with 1010... and alternatively flips)\n        # so there are ceil((i-0+1)*((len(arr)-1)-i+1)/2) odd length subarrays with x\n        # \n        return sum(x * ceil_divide((i-0+1)*((len(arr)-1)-i+1), 2) for i, x in enumerate(arr))\n"
    },
    {
        "problem_name": "sum-of-all-subset-xor-totals",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def subsetXORSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # given there are k (k >= 1) nums of which ith bit is 1,\n        # the bit contributes to sum is:\n        # (nCr(k, 1) + nCr(k, 3) + ...) * (nCr(n - k, 0) + nCr(n - k, 1) + ...) * 2^i\n        # = 2^(k-1) * 2^(n-k) = 2^(n-1) * 2^i\n        result = 0\n        for x in nums:\n            result |= x\n        return result * 2**(len(nums)-1)\n"
    },
    {
        "problem_name": "sum-of-beauty-in-the-array",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def sumOfBeauties(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        right = [nums[-1]]*len(nums)\n        for i in reversed(xrange(2, len(nums)-1)):\n            right[i] = min(right[i+1], nums[i])\n        result, left = 0, nums[0]\n        for i in xrange(1, len(nums)-1):\n            if left < nums[i] < right[i+1]:\n                result += 2\n            elif nums[i-1] < nums[i] < nums[i+1]:\n                result += 1\n            left = max(left, nums[i])\n        return result\n"
    },
    {
        "problem_name": "sum-of-beauty-of-all-substrings",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def beautySum(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = 0 \n        for i in xrange(len(s)):\n            lookup = [0]*26\n            for j in xrange(i, len(s)):\n                lookup[ord(s[j])-ord('a')] += 1\n                result += max(lookup) - min(x for x in lookup if x)\n        return result\n"
    },
    {
        "problem_name": "sum-of-digit-differences-of-all-pairs",
        "solution": "# Time:  O(nlogr)\n# Space: O(10 * logr)\n\n# prefix sum\nclass Solution(object):\n    def sumDigitDifferences(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        base, l = 1, 0\n        while base <= nums[0]:\n            base *= 10\n            l += 1\n        cnts = [[0]*10 for _ in xrange(l)]\n        for x in nums:\n            for i in xrange(l):\n                cnts[i][x%10] += 1\n                x //= 10\n        return sum(c*(len(nums)-c) for cnt in cnts for c in cnt)//2\n"
    },
    {
        "problem_name": "sum-of-digits-in-base-k",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def sumBase(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while n:\n            n, r = divmod(n, k)\n            result += r\n        return result\n"
    },
    {
        "problem_name": "sum-of-digits-in-the-minimum-number",
        "solution": "# Time:  O(n * l)\n# Space: O(l)\n\nclass Solution(object):\n    def sumOfDigits(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        total = sum([int(c) for c in str(min(A))])\n        return 1 if total % 2 == 0 else 0\n"
    },
    {
        "problem_name": "sum-of-digits-of-string-after-convert",
        "solution": "# Time:  O(n + logn + log(logn) + ...) = O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def getLucky(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        total = reduce(lambda total, x: total+sum(divmod((ord(x)-ord('a')+1), 10)), s, 0)\n        while k > 1 and total > 9:\n            new_total = 0\n            while total:\n                total, x = divmod(total, 10)\n                new_total += x\n            total = new_total\n            k -= 1\n        return total\n"
    },
    {
        "problem_name": "sum-of-distances-in-tree",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def sumOfDistancesInTree(self, N, edges):\n        \"\"\"\n        :type N: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        def dfs(graph, node, parent, count, result):\n            for nei in graph[node]:\n                if nei != parent:\n                    dfs(graph, nei, node, count, result)\n                    count[node] += count[nei]\n                    result[node] += result[nei]+count[nei]\n\n        def dfs2(graph, node, parent, count, result):\n            for nei in graph[node]:\n                if nei != parent:\n                    result[nei] = result[node]-count[nei] + \\\n                                  len(count)-count[nei]\n                    dfs2(graph, nei, node, count, result)\n\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        count = [1] * N\n        result = [0] * N\n\n        dfs(graph, 0, None, count, result)\n        dfs2(graph, 0, None, count, result)\n        return result\n\n"
    },
    {
        "problem_name": "sum-of-distances",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table, prefix sum\nclass Solution(object):\n    def distance(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = [0]*len(nums)\n        cnt1, left = collections.Counter(), collections.Counter()\n        for i in xrange(len(nums)):\n            result[i] += cnt1[nums[i]]*i-left[nums[i]]\n            cnt1[nums[i]] += 1\n            left[nums[i]] += i\n        cnt2, right = collections.Counter(), collections.Counter()\n        for i in reversed(xrange(len(nums))):\n            result[i] += right[nums[i]]-cnt2[nums[i]]*i\n            cnt2[nums[i]] += 1\n            right[nums[i]] += i\n        return result\n"
    },
    {
        "problem_name": "sum-of-even-numbers-after-queries",
        "solution": "# Time:  O(n + q)\n# Space: O(1)\n\nclass Solution(object):\n    def sumEvenAfterQueries(self, A, queries):\n        \"\"\"\n        :type A: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        total = sum(v for v in A if v % 2 == 0)\n        \n        result = []\n        for v, i in queries:\n            if A[i] % 2 == 0:\n                total -= A[i]\n            A[i] += v\n            if A[i] % 2 == 0:\n                total += A[i]\n            result.append(total)\n        return result\n"
    },
    {
        "problem_name": "sum-of-floored-pairs",
        "solution": "# Time:  O(n/1+n/2+...+n/n) = O(nlogn), n is the max of nums\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def sumOfFlooredPairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        prefix, counter = [0]*(max(nums)+1), collections.Counter(nums)\n        for num, cnt in counter.iteritems():\n            for j in xrange(num, len(prefix), num):\n                prefix[j] += counter[num]\n        for i in xrange(len(prefix)-1):\n            prefix[i+1] += prefix[i]\n        return reduce(lambda total, num: (total+prefix[num])%MOD, nums, 0)\n"
    },
    {
        "problem_name": "sum-of-imbalance-numbers-of-all-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# hash table, combinatorics\nclass Solution(object):\n    def sumImbalanceNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        right = [len(nums)]*len(nums)\n        lookup = [len(nums)]*((len(nums)+1)+1)\n        for i in reversed(xrange(len(nums))):\n            right[i] = min(lookup[nums[i]], lookup[nums[i]+1])  # to avoid duplicated count\n            lookup[nums[i]] = i\n        result = left = 0\n        lookup = [-1]*((len(nums)+1)+1)\n        for i in xrange(len(nums)):\n            left = lookup[nums[i]+1]\n            lookup[nums[i]] = i\n            result += (i-left)*(right[i]-i)\n        return result - (len(nums)+1)*len(nums)//2  # since we overcount 1 in each subarray, we have to subtract all of them\n\n\n# Time:  O(n^2)\n# Space: O(n)\n# hash table, two pointers\nclass Solution2(object):\n    def sumImbalanceNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for right in xrange(len(nums)):\n            lookup = {nums[right]}\n            curr = 0\n            for left in reversed(xrange(right)):\n                if nums[left] not in lookup:\n                    lookup.add(nums[left])\n                    curr += 1-(nums[left]-1 in lookup)-(nums[left]+1 in lookup)\n                result += curr\n        return result\n"
    },
    {
        "problem_name": "sum-of-k-mirror-numbers",
        "solution": "# Time:  O(10^6), the most times of finding x is 665502 (k = 7, n = 30)\n# Space: O(1)\n\nclass Solution(object):\n    def kMirror(self, k, n):\n        \"\"\"\n        :type k: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def mirror(n, base, odd):\n            result = n\n            if odd:\n                n //= base\n            while n:\n                result = result*base+n%base\n                n //= base\n            return result\n\n        def num_gen(base):\n            prefix_num, total = [1]*2, [base]*2\n            odd = 1\n            while True:\n                x = mirror(prefix_num[odd], base, odd)\n                prefix_num[odd] += 1\n                if prefix_num[odd] == total[odd]:\n                    total[odd] *= base\n                    odd ^= 1\n                yield x\n\n        def reverse(n, base):\n            result = 0\n            while n:\n                result = result*base+n%base\n                n = n//base\n            return result\n\n        def mirror_num(gen, base):\n            while True:\n                x = next(gen)\n                if x == reverse(x, base):\n                    break\n            return x\n\n        base1, base2 = k, 10  # (10, k) is slower\n        gen = num_gen(base1)\n        return sum(mirror_num(gen, base2) for _ in xrange(n))\n\n\n# Time:  O(10^6), the most times of finding x is 665502 (k = 7, n = 30)\n# Space: O(1)\nclass Solution2(object):\n    def kMirror(self, k, n):\n        \"\"\"\n        :type k: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def num_gen(k):\n            digits = ['0']\n            while True:\n                for i in xrange(len(digits)//2, len(digits)): \n                    if int(digits[i])+1 < k:\n                        digits[i] = digits[-1-i] = str(int(digits[i])+1)\n                        break\n                    digits[i] = digits[-1-i] = '0'\n                else:\n                    digits.insert(0, '1')\n                    digits[-1] = '1'\n                yield \"\".join(digits)\n        \n        def mirror_num(gen):\n            while True:\n                x = int(next(gen, k), k)\n                if str(x) == str(x)[::-1]:\n                    break\n            return x\n\n        gen = num_gen(k)\n        return sum(mirror_num(gen) for _ in xrange(n))\n"
    },
    {
        "problem_name": "sum-of-left-leaves",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def sumOfLeftLeavesHelper(root, is_left):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return root.val if is_left else 0\n            return sumOfLeftLeavesHelper(root.left, True) + \\\n                   sumOfLeftLeavesHelper(root.right, False)\n\n        return sumOfLeftLeavesHelper(root, False)\n\n"
    },
    {
        "problem_name": "sum-of-matrix-after-queries",
        "solution": "# Time:  O(n + q)\n# Space: O(n)\n\n# hash table\nclass Solution(object):\n    def matrixSumQueries(self, n, queries):\n        \"\"\"\n        :type n: int\n        :type queries: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = [[False]*n for _ in xrange(2)]\n        cnt = [0]*2\n        result = 0\n        for t, i, v in reversed(queries):\n            if lookup[t][i]:\n                continue\n            lookup[t][i] = True\n            cnt[t] += 1\n            result += v*(n-cnt[t^1])\n        return result\n"
    },
    {
        "problem_name": "sum-of-mutated-array-closest-to-target",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def findBestValue(self, arr, target):\n        \"\"\"\n        :type arr: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        arr.sort(reverse=True)\n        max_arr = arr[0]\n        while arr and arr[-1]*len(arr) <= target:\n            target -= arr.pop()\n        # let x = ceil(t/n)-1\n        # (1) (t/n-1/2) <= x:\n        #    return x, which is equal to ceil(t/n)-1 = ceil(t/n-1/2) = (2t+n-1)//2n\n        # (2) (t/n-1/2) > x:\n        #    return x+1, which is equal to ceil(t/n) = ceil(t/n-1/2) = (2t+n-1)//2n\n        # (1) + (2) => both return (2t+n-1)//2n\n        return max_arr if not arr else (2*target+len(arr)-1)//(2*len(arr))\n\n\n# Time:  O(nlogn)\n# Space: O(1)\nclass Solution2(object):\n    def findBestValue(self, arr, target):\n        \"\"\"\n        :type arr: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        arr.sort(reverse=True)\n        max_arr = arr[0]\n        while arr and arr[-1]*len(arr) <= target:\n            target -= arr.pop()\n        if not arr:\n            return max_arr\n        x = (target-1)//len(arr)\n        return x if target-x*len(arr) <= (x+1)*len(arr)-target else x+1\n\n\n# Time:  O(nlogm), m is the max of arr, which may be larger than n\n# Space: O(1)\nclass Solution3(object):\n    def findBestValue(self, arr, target):\n        \"\"\"\n        :type arr: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        def total(arr, v):\n            result = 0\n            for x in arr:\n                result += min(v, x)\n            return result\n\n        def check(arr, v, target):\n            return total(arr, v) >= target\n        \n        left, right = 1, max(arr)\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(arr, mid, target):\n                right = mid-1\n            else:\n                left = mid+1\n        return left-1 if target-total(arr, left-1) <= total(arr, left)-target else left\n"
    },
    {
        "problem_name": "sum-of-nodes-with-even-valued-grandparent",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def sumEvenGrandparent(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def sumEvenGrandparentHelper(root, p, gp):\n            return sumEvenGrandparentHelper(root.left, root.val, p) + \\\n                   sumEvenGrandparentHelper(root.right, root.val, p) + \\\n                   (root.val if gp is not None and gp % 2 == 0 else 0) if root else 0\n\n        return sumEvenGrandparentHelper(root, None, None)\n"
    },
    {
        "problem_name": "sum-of-number-and-its-reverse",
        "solution": "# Time:  O(2^(log10(n)/2)) = O(n^(1/(2*log2(10))))\n# Space: O(log10(n)/2)\n\n# backtracking\nclass Solution(object):\n    def sumOfNumberAndReverse(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        def backtracking(num, chosen):\n            if num == 0:\n                return True\n            if chosen == 1:\n                return False\n            if num <= 18:\n                return (num%2 == 0) or (num == 11 and chosen == 0)\n            if chosen == 2:\n                return False\n            for x in (num%10, 10+num%10):\n                if not (1 <= x <= 18):\n                    continue\n                base = 11\n                if chosen:\n                    base = chosen\n                else:\n                    while x*((base-1)*10+1) <= num:\n                        base = (base-1)*10+1\n                if num-x*base >= 0 and backtracking((num-x*base)//10, base//100+1):\n                    return True\n            return False\n\n        return backtracking(num, 0)\n\n\n# Time:  O(nlogn)\n# Space: O(1)\n# brute force\nclass Solution2(object):\n    def sumOfNumberAndReverse(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        def reverse(n):\n            result = 0\n            while n:\n                result = result*10 + n%10\n                n //= 10            \n            return result\n\n        return any(x+reverse(x) == num for x in xrange(num//2, num+1))\n\n\n# Time:  O(nlogn)\n# Space: O(logn)\n# brute force\nclass Solution3(object):\n    def sumOfNumberAndReverse(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        return any(x+int(str(x)[::-1]) == num for x in xrange(num//2, num+1))\n"
    },
    {
        "problem_name": "sum-of-numbers-with-units-digit-k",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def minimumNumbers(self, num, k):\n        \"\"\"\n        :type num: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return next((i for i in xrange(1, (min(num//k, 10) if k else 1)+1) if (num-i*k)%10 == 0), -1) if num else 0\n"
    },
    {
        "problem_name": "sum-of-prefix-scores-of-strings",
        "solution": "# Time:  O(n * l), n is the number of words, l is the max length of words\n# Space: O(t), t is the size of trie\n    \nimport collections\n\n\n# trie\nclass Solution(object):\n    def sumPrefixScores(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        _trie = lambda: collections.defaultdict(_trie)\n        trie = _trie()\n        for w in words:\n            curr = trie\n            for c in w:\n                curr = curr[c]\n                curr[\"_cnt\"] = curr[\"_cnt\"]+1 if \"_cnt\" in curr else 1\n        result = []\n        for w in words:\n            cnt = 0\n            curr = trie\n            for c in w:\n                curr = curr[c]\n                cnt += curr[\"_cnt\"]\n            result.append(cnt)\n        return result\n"
    },
    {
        "problem_name": "sum-of-remoteness-of-all-cells",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\n# flood fill, bfs, math\nclass Solution(object):\n    def sumRemoteness(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1))\n        def bfs(i, j):\n            total, cnt = grid[i][j], 1\n            grid[i][j] = -1\n            q = [(i, j)]\n            while q:\n                new_q = []\n                for i, j in q:\n                    for di, dj in DIRECTIONS:\n                        ni, nj = i+di, j+dj\n                        if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] != -1):\n                            continue\n                        total += grid[ni][nj]\n                        cnt += 1\n                        grid[ni][nj] = -1\n                        new_q.append((ni, nj))\n                q = new_q\n            return total, cnt\n    \n        groups = [bfs(i, j) for i in xrange(len(grid)) for j in xrange(len(grid[0])) if grid[i][j] != -1]\n        total = sum(t for t, _ in groups)\n        return sum((total-t)*c for t, c in groups)\n"
    },
    {
        "problem_name": "sum-of-root-to-leaf-binary-numbers",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def sumRootToLeaf(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        M = 10**9 + 7\n        def sumRootToLeafHelper(root, val):\n            if not root:\n                return 0\n            val = (val*2 + root.val) % M\n            if not root.left and not root.right:\n                return val\n            return (sumRootToLeafHelper(root.left, val) +\n                    sumRootToLeafHelper(root.right, val)) % M\n        \n        return sumRootToLeafHelper(root, 0)\n"
    },
    {
        "problem_name": "sum-of-scores-of-built-strings",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# z-function\nclass Solution(object):\n    def sumScores(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # Template: https://cp-algorithms.com/string/z-function.html\n        def z_function(s):  # Time: O(n), Space: O(n)\n            z = [0]*len(s)\n            l, r = 0, 0\n            for i in xrange(1, len(z)):\n                if i <= r:\n                    z[i] = min(r-i+1, z[i-l])\n                while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]:\n                    z[i] += 1\n                if i+z[i]-1 > r:\n                    l, r = i, i+z[i]-1\n            return z\n\n        z = z_function(s)\n        z[0] = len(s)\n        return sum(z)\n"
    },
    {
        "problem_name": "sum-of-special-evenly-spaced-elements-in-array",
        "solution": "# Time:  O(n * sqrt(n))\n# Space: O(n * sqrt(n))\n\nclass Solution(object):\n    def solve(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        MOD = 10**9+7\n\n        prefix = {}          \n        result = []\n        for x, y in queries:\n            if y*y > len(nums):\n                total = 0\n                for i in xrange(x, len(nums), y):\n                    total += nums[i]\n                    total %= MOD\n                result.append(total)\n            else:\n                begin = x%y\n                if (begin, y) not in prefix:\n                    prefix[(begin, y)] = [0]\n                    for i in xrange(begin, len(nums), y):\n                        prefix[(begin, y)].append((prefix[(begin, y)][-1] + nums[i]) % MOD)\n                result.append((prefix[(begin, y)][-1]-prefix[(begin, y)][x//y]) % MOD)\n        return result\n"
    },
    {
        "problem_name": "sum-of-square-numbers",
        "solution": "# Time:  O(sqrt(c) * logc)\n# Space: O(1)\n\nimport math\n\n\nclass Solution(object):\n    def judgeSquareSum(self, c):\n        \"\"\"\n        :type c: int\n        :rtype: bool\n        \"\"\"\n        for a in xrange(int(math.sqrt(c))+1):\n            b = int(math.sqrt(c-a**2))\n            if a**2 + b**2 == c:\n                return True\n        return False\n\n"
    },
    {
        "problem_name": "sum-of-squares-of-special-elements",
        "solution": "# Time:  O(sqrt(n))\n# Space: O(1)\n\n# number theory\nclass Solution(object):\n    def sumOfSquares(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(1, int(len(nums)**0.5)+1):\n            if len(nums)%i:\n                continue\n            result += nums[i-1]**2\n            if len(nums)//i != i:\n                result += nums[len(nums)//i-1]**2\n        return result\n"
    },
    {
        "problem_name": "sum-of-subarray-minimums",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport itertools\n\n\n# Ascending stack solution\nclass Solution(object):\n    def sumSubarrayMins(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        M = 10**9 + 7\n\n        left, s1 = [0]*len(A), []\n        for i in xrange(len(A)):\n            count = 1\n            while s1 and s1[-1][0] > A[i]:\n                count += s1.pop()[1]\n            left[i] = count\n            s1.append([A[i], count])\n\n        right, s2 = [0]*len(A), []\n        for i in reversed(xrange(len(A))):\n            count = 1\n            while s2 and s2[-1][0] >= A[i]:\n                count += s2.pop()[1]\n            right[i] = count\n            s2.append([A[i], count])\n\n        return sum(a*l*r for a, l, r in itertools.izip(A, left, right)) % M\n\n"
    },
    {
        "problem_name": "sum-of-subarray-ranges",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def subArrayRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = []\n        for i in xrange(len(nums)+1):\n            x = nums[i] if i < len(nums) else float(\"inf\")\n            while stk and nums[stk[-1]] <= x:\n                j = stk.pop()\n                k = stk[-1] if stk else -1\n                result += nums[j]*(j-k)*(i-j)\n            stk.append(i)\n        stk = []\n        for i in xrange(len(nums)+1):\n            x = nums[i] if i < len(nums) else float(\"-inf\")\n            while stk and nums[stk[-1]] >= x:\n                j = stk.pop()\n                k = stk[-1] if stk else -1\n                result -= nums[j]*(j-k)*(i-j)\n            stk.append(i)\n        return result\n"
    },
    {
        "problem_name": "sum-of-subsequence-widths",
        "solution": "# Time:  O(n)\n# Spce:  O(1)\n\nclass Solution(object):\n    def sumSubseqWidths(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        M = 10**9+7\n        # sum(A[i] * (2^i - 2^(len(A)-1-i))), i = 0..len(A)-1\n        # <=>\n        # sum(((A[i] - A[len(A)-1-i]) * 2^i), i = 0..len(A)-1\n        result, c = 0, 1\n        A.sort()\n        for i in xrange(len(A)):\n            result = (result + (A[i]-A[len(A)-1-i])*c % M) % M\n            c = (c<<1) % M\n        return result\n\n"
    },
    {
        "problem_name": "sum-of-total-strength-of-wizards",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# mono stack, prefix sum, optimized from solution2\nclass Solution(object):\n    def totalStrength(self, strength):\n        \"\"\"\n        :type strength: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        curr = 0\n        prefix = [0]*(len(strength)+1)\n        for i in xrange(len(strength)):\n            curr = (curr+strength[i])%MOD\n            prefix[i+1] = (prefix[i]+curr)%MOD\n        stk, result = [-1], 0\n        for i in xrange(len(strength)+1):\n            while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] >= strength[i]):\n                x, y, z = stk[-2]+1, stk.pop(), i-1\n                # assert(all(strength[j] >= strength[y] for j in xrange(x, y+1)))\n                # assert(all(strength[j] > strength[y] for j in xrange(y+1, z+1)))\n                result = (result+(strength[y]*((y-x+1)*(prefix[z+1]-prefix[y])-(z-y+1)*(prefix[y]-prefix[max(x-1, 0)]))))%MOD\n            stk.append(i)\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\n# mono stack, prefix sum\nclass Solution2(object):\n    def totalStrength(self, strength):\n        \"\"\"\n        :type strength: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        prefix, prefix2 = [0]*(len(strength)+1), [0]*(len(strength)+1)\n        for i in xrange(len(strength)):\n            prefix[i+1] = (prefix[i]+strength[i])%MOD\n            prefix2[i+1] = (prefix2[i]+strength[i]*(i+1))%MOD\n        suffix, suffix2 = [0]*(len(strength)+1), [0]*(len(strength)+1)\n        for i in reversed(xrange(len(strength))):\n            suffix[i] = (suffix[i+1]+strength[i])%MOD\n            suffix2[i] = (suffix2[i+1]+strength[i]*(len(strength)-i))%MOD\n        stk, result = [-1], 0\n        for i in xrange(len(strength)+1):\n            while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] >= strength[i]):\n                x, y, z = stk[-2]+1, stk.pop(), i-1\n                # assert(all(strength[j] >= strength[y] for j in xrange(x, y+1)))\n                # assert(all(strength[j] > strength[y] for j in xrange(y+1, z+1)))\n                result = (result+(strength[y]*((z-y+1)*((prefix2[y+1]-prefix2[x])-x*(prefix[y+1]-prefix[x]))+\n                                               (y-x+1)*((suffix2[y+1]-suffix2[z+1])-(len(strength)-(z+1))*(suffix[y+1]-suffix[z+1])))))%MOD\n            stk.append(i)\n        return result\n"
    },
    {
        "problem_name": "sum-of-two-integers",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def getSum(self, a, b):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :rtype: int\n        \"\"\"\n        bit_length = 32\n        neg_bit, mask = (1 << bit_length) >> 1, ~(~0 << bit_length)\n\n        a = (a | ~mask) if (a & neg_bit) else (a & mask)\n        b = (b | ~mask) if (b & neg_bit) else (b & mask)\n\n        while b:\n            carry = a & b\n            a ^= b\n            a = (a | ~mask) if (a & neg_bit) else (a & mask)\n            b = carry << 1\n            b = (b | ~mask) if (b & neg_bit) else (b & mask)\n\n        return a\n\n    def getSum2(self, a, b):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :rtype: int\n        \"\"\"\n        # 32 bits integer max\n        MAX = 0x7FFFFFFF\n        # 32 bits interger min\n        MIN = 0x80000000\n        # mask to get last 32 bits\n        mask = 0xFFFFFFFF\n        while b:\n            # ^ get different bits and & gets double 1s, << moves carry\n            a, b = (a ^ b) & mask, ((a & b) << 1) & mask\n        # if a is negative, get a's 32 bits complement positive first\n        # then get 32-bit positive's Python complement negative\n        return a if a <= MAX else ~(a ^ mask)\n\n    def minus(self, a, b):\n        b = self.getSum(~b, 1)\n        return self.getSum(a, b)\n\n    def multiply(self, a, b):\n        isNeg = (a > 0) ^ (b > 0)\n        x = a if a > 0 else self.getSum(~a, 1)\n        y = b if b > 0 else self.getSum(~b, 1)\n        ans = 0\n        while y & 0x01:\n            ans = self.getSum(ans, x)\n            y >>= 1\n            x <<= 1\n        return self.getSum(~ans, 1) if isNeg else ans\n\n    def divide(self, a, b):\n        isNeg = (a > 0) ^ (b > 0)\n        x = a if a > 0 else self.getSum(~a, 1)\n        y = b if b > 0 else self.getSum(~b, 1)\n        ans = 0\n        for i in range(31, -1, -1):\n            if (x >> i) >= y:\n                x = self.minus(x, y << i)\n                ans = self.getSum(ans, 1 << i)\n        return self.getSum(~ans, 1) if isNeg else ans\n\n\n"
    },
    {
        "problem_name": "sum-of-unique-elements",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def sumOfUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(x for x, c in collections.Counter(nums).iteritems() if c == 1)\n"
    },
    {
        "problem_name": "sum-of-values-at-indices-with-k-set-bits",
        "solution": "# Time:  O(C(ceil(log2(n)), k))\n# Space: O(1)\n\n# bit manipulation, hakmem-175\nclass Solution(object):\n    def sumIndicesWithKSetBits(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def next_popcount(n):  # reference: https://massivealgorithms.blogspot.com/2014/06/hakmem-item-175.html\n            lowest_bit = n&-n\n            left_bits = n+lowest_bit\n            changed_bits = n^left_bits\n            right_bits = (changed_bits//lowest_bit)>>2\n            return left_bits|right_bits\n\n        result = 0 \n        i = (1<<k)-1\n        while i < len(nums):\n            result += nums[i]\n            if i == 0:\n                break\n            i = next_popcount(i)\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\n# bit manipulation\nclass Solution2(object):\n    def sumIndicesWithKSetBits(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def popcount(x):\n            return bin(x)[1:].count('1')\n        \n        return sum(x for i, x in enumerate(nums) if popcount(i) == k)\n"
    },
    {
        "problem_name": "sum-root-to-leaf-numbers",
        "solution": "# Time:  O(n)\n# Space: O(h), h is height of binary tree\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    # @param root, a tree node\n    # @return an integer\n    def sumNumbers(self, root):\n        return self.sumNumbersRecu(root, 0)\n\n    def sumNumbersRecu(self, root, num):\n        if root is None:\n            return 0\n\n        if root.left is None and root.right is None:\n            return num * 10 + root.val\n\n        return self.sumNumbersRecu(root.left, num * 10 + root.val) + self.sumNumbersRecu(root.right, num * 10 + root.val)\n\n"
    },
    {
        "problem_name": "summary-ranges",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport itertools\nimport re\n\n\nclass Solution(object):\n    # @param {integer[]} nums\n    # @return {string[]}\n    def summaryRanges(self, nums):\n        ranges = []\n        if not nums:\n            return ranges\n\n        start, end = nums[0], nums[0]\n        for i in xrange(1, len(nums) + 1):\n            if i < len(nums) and nums[i] == end + 1:\n                end = nums[i]\n            else:\n                interval = str(start)\n                if start != end:\n                    interval += \"->\" + str(end)\n                ranges.append(interval)\n                if i < len(nums):\n                    start = end = nums[i]\n\n        return ranges\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    # @param {integer[]} nums\n    # @return {string[]}\n    def summaryRanges(self, nums):\n        return [re.sub('->.*>', '->', '->'.join(repr(n) for _, n in g))\n            for _, g in itertools.groupby(enumerate(nums), lambda i_n: i_n[1]-i_n[0])]\n\n"
    },
    {
        "problem_name": "super-egg-drop",
        "solution": "# Time:  O(klogn)\n# Space: O(1)\n\nclass Solution(object):\n    def superEggDrop(self, K, N):\n        \"\"\"\n        :type K: int\n        :type N: int\n        :rtype: int\n        \"\"\"\n        def check(n, K, N):\n            # let f(n, K) be the max number of floors could be solved by n moves and K eggs,\n            # we want to do binary search to find min of n, s.t. f(n, K) >= N,\n            # if we use one move to drop egg with X floors\n            # 1. if it breaks, we can search new X in the range [X+1, X+f(n-1, K-1)]\n            # 2. if it doesn't break, we can search new X in the range [X-f(n-1, K), X-1]\n            # => f(n, K) = (X+f(n-1, K-1))-(X-f(n-1, K))+1 = f(n-1, K-1)+f(n-1, K)+1\n            # => (1) f(n, K)   = f(n-1, K)  +1+f(n-1, K-1)\n            #    (2) f(n, K-1) = f(n-1, K-1)+1+f(n-1, K-2)\n            # let g(n, K) = f(n, K)-f(n, K-1), and we subtract (1) by (2)\n            # => g(n, K) = g(n-1, K)+g(n-1, K-1), obviously, it is binomial coefficient\n            # => C(n, K) = g(n, K) = f(n, K)-f(n, K-1),\n            #    which also implies if we have one more egg with n moves and x-1 egges, we can have more C(n, x) floors solvable\n            # => f(n, K) = C(n, K)+f(n, K-1) = C(n, K) + C(n, K-1) + ... + C(n, 1) + f(n, 0) = sum(C(n, k) for k in [1, K])\n            # => all we have to do is to check sum(C(n, k) for k in [1, K]) >= N,\n            #    if true, there must exist a 1-to-1 mapping from each F in [1, N] to each sucess and failure sequence of every C(n, k) combinations for k in [1, K]\n            total, c = 0, 1\n            for k in xrange(1, K+1):\n                c *= n-k+1\n                c //= k\n                total += c\n                if total >= N:\n                    return True\n            return False\n\n        left, right = 1, N\n        while left <= right:\n            mid = left + (right-left)//2\n            if check(mid, K, N):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n\n"
    },
    {
        "problem_name": "super-palindromes",
        "solution": "# Time:  O(n^0.25 * logn)\n# Space: O(logn)\n\nclass Solution(object):\n    def superpalindromesInRange(self, L, R):\n        \"\"\"\n        :type L: str\n        :type R: str\n        :rtype: int\n        \"\"\"\n        def is_palindrome(k):\n            return str(k) == str(k)[::-1]\n\n        K = int((10**((len(R)+1)*0.25)))\n        l, r = int(L), int(R)\n\n        result = 0\n\n        # count odd length\n        for k in xrange(K):\n            s = str(k)\n            t = s + s[-2::-1]\n            v = int(t)**2\n            if v > r:\n                break\n            if v >= l and is_palindrome(v):\n                result += 1\n\n        # count even length\n        for k in xrange(K):\n            s = str(k)\n            t = s + s[::-1]\n            v = int(t)**2\n            if v > r:\n                break\n            if v >= l and is_palindrome(v):\n                result += 1\n\n        return result\n\n"
    },
    {
        "problem_name": "super-pow",
        "solution": "# Time:  O(n), n is the size of b.\n# Space: O(1)\n\nclass Solution(object):\n    def superPow(self, a, b):\n        \"\"\"\n        :type a: int\n        :type b: List[int]\n        :rtype: int\n        \"\"\"\n        def myPow(a, n, b):\n            result = 1\n            x = a % b\n            while n:\n                if n & 1:\n                    result = result * x % b\n                n >>= 1\n                x = x * x % b\n            return result % b\n\n        result = 1\n        for digit in b:\n            result = myPow(result, 10, 1337) * myPow(a, digit, 1337) % 1337\n        return result\n\n"
    },
    {
        "problem_name": "super-ugly-number",
        "solution": "# Time:  O(n * k)\n# Space: O(n + k)\n\nimport heapq\n\n\n# Heap solution. (620ms)\nclass Solution(object):\n    def nthSuperUglyNumber(self, n, primes):\n        \"\"\"\n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n        heap, uglies, idx, ugly_by_last_prime = [], [0] * n, [0] * len(primes), [0] * n\n        uglies[0] = 1\n\n        for k, p in enumerate(primes):\n            heapq.heappush(heap, (p, k))\n\n        for i in xrange(1, n):\n            uglies[i], k = heapq.heappop(heap)\n            ugly_by_last_prime[i] = k\n            idx[k] += 1\n            while ugly_by_last_prime[idx[k]] > k:\n                idx[k] += 1\n            heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n\n        return uglies[-1]\n\n# Time:  O(n * k)\n# Space: O(n + k)\n# Hash solution. (932ms)\nclass Solution2(object):\n    def nthSuperUglyNumber(self, n, primes):\n        \"\"\"\n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n        uglies, idx, heap, ugly_set = [0] * n, [0] * len(primes), [], set([1])\n        uglies[0] = 1\n\n        for k, p in enumerate(primes):\n            heapq.heappush(heap, (p, k))\n            ugly_set.add(p)\n\n        for i in xrange(1, n):\n            uglies[i], k = heapq.heappop(heap)\n            while (primes[k] * uglies[idx[k]]) in ugly_set:\n                idx[k] += 1\n            heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n            ugly_set.add(primes[k] * uglies[idx[k]])\n\n        return uglies[-1]\n\n# Time:  O(n * logk) ~ O(n * klogk)\n# Space: O(n + k)\nclass Solution3(object):\n    def nthSuperUglyNumber(self, n, primes):\n        \"\"\"\n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n        uglies, idx, heap = [1], [0] * len(primes), []\n        for k, p in enumerate(primes):\n            heapq.heappush(heap, (p, k))\n\n        for i in xrange(1, n):\n            min_val, k = heap[0]\n            uglies += [min_val]\n\n            while heap[0][0] == min_val:  # worst time: O(klogk)\n                min_val, k = heapq.heappop(heap)\n                idx[k] += 1\n                heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))\n\n        return uglies[-1]\n\n# Time:  O(n * k)\n# Space: O(n + k)\n# TLE due to the last test case, but it passess and performs the best in C++.\nclass Solution4(object):\n    def nthSuperUglyNumber(self, n, primes):\n        \"\"\"\n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n        uglies = [0] * n\n        uglies[0] = 1\n        ugly_by_prime = list(primes)\n        idx = [0] * len(primes)\n\n        for i in xrange(1, n):\n            uglies[i] = min(ugly_by_prime)\n            for k in xrange(len(primes)):\n                if uglies[i] == ugly_by_prime[k]:\n                    idx[k] += 1\n                    ugly_by_prime[k] = primes[k] * uglies[idx[k]]\n\n        return uglies[-1]\n\n# Time:  O(n * logk) ~ O(n * klogk)\n# Space: O(k^2)\n# TLE due to the last test case, but it passess and performs well in C++.\nclass Solution5(object):\n    def nthSuperUglyNumber(self, n, primes):\n        \"\"\"\n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n        ugly_number = 0\n\n        heap = []\n        heapq.heappush(heap, 1)\n        for p in primes:\n            heapq.heappush(heap, p)\n        for _ in xrange(n):\n            ugly_number = heapq.heappop(heap)\n            for i in xrange(len(primes)):\n                if ugly_number % primes[i] == 0:\n                    for j in xrange(i + 1):\n                        heapq.heappush(heap, ugly_number * primes[j])\n                    break\n\n        return ugly_number\n\n"
    },
    {
        "problem_name": "super-washing-machines",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        total = sum(machines)\n        if total % len(machines): return -1\n\n        result, target, curr = 0, total / len(machines), 0\n        for n in machines:\n            curr += n - target\n            result = max(result, max(n - target, abs(curr)))\n        return result\n\n"
    },
    {
        "problem_name": "surface-area-of-3d-shapes",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def surfaceArea(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(len(grid)):\n            for j in xrange(len(grid)):\n                if grid[i][j]:\n                    result += 2 + grid[i][j]*4\n                if i:\n                    result -= min(grid[i][j], grid[i-1][j])*2\n                if j:\n                    result -= min(grid[i][j], grid[i][j-1])*2\n        return result\n\n"
    },
    {
        "problem_name": "surrounded-regions",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nimport collections\n\n\nclass Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: void Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board:\n            return\n\n        q = collections.deque()\n\n        for i in xrange(len(board)):\n            if board[i][0] == 'O':\n                board[i][0] = 'V'\n                q.append((i, 0))\n            if board[i][len(board[0])-1] == 'O':\n                board[i][len(board[0])-1] = 'V'\n                q.append((i, len(board[0])-1))\n\n        for j in xrange(1, len(board[0])-1):\n            if board[0][j] == 'O':\n                board[0][j] = 'V'\n                q.append((0, j))\n            if board[len(board)-1][j] == 'O':\n                board[len(board)-1][j] = 'V'\n                q.append((len(board)-1, j))\n\n        while q:\n            i, j = q.popleft()\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < len(board) and 0 <= y < len(board[0]) and \\\n                   board[x][y] == 'O':\n                    board[x][y] = 'V'\n                    q.append((x, y))\n\n        for i in xrange(len(board)):\n            for j in xrange(len(board[0])):\n                if board[i][j] != 'V':\n                    board[i][j] = 'X'\n                else:\n                    board[i][j] = 'O'\n"
    },
    {
        "problem_name": "swap-adjacent-in-lr-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# the followings are invariant if the number of 'X' in both strings are the same\n# 1. the ordering of 'L', 'R' in both strings are the same\n# 2. for each position (i, j) of paired 'L' character in both strings, i >= j\n# 3. for each position (i, j) of paired 'R' character in both strings, i <= j\nclass Solution(object):\n    def canTransform(self, start, end):\n        \"\"\"\n        :type start: str\n        :type end: str\n        :rtype: bool\n        \"\"\"\n        if start.count('X') != end.count('X'):\n            return False\n        i, j = 0, 0\n        while i < len(start) and j < len(end):\n            while i < len(start) and start[i] == 'X':\n                i += 1\n            while j < len(end) and end[j] == 'X':\n                j += 1\n            if (i < len(start)) != (j < len(end)):\n                return False\n            elif i < len(start) and j < len(end):\n                if start[i] != end[j] or \\\n                   (start[i] == 'L' and i < j) or \\\n                   (start[i] == 'R' and i > j):\n                    return False\n            i += 1\n            j += 1\n        return True\n\n"
    },
    {
        "problem_name": "swap-for-longest-repeated-character-substring",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def maxRepOpt1(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: int\n        \"\"\"\n        K = 1\n        result = 0\n        total_count, count = collections.Counter(), collections.Counter()\n        left, max_count = 0, 0\n        for i in xrange(len(text)):\n            total_count[text[i]] += 1\n            count[text[i]] += 1\n            max_count = max(max_count, count[text[i]])\n            if i-left+1 - max_count > K:\n                count[text[left]] -= 1\n                left += 1\n            result = max(result, min(i-left+1, total_count[text[i]]))\n        return result\n\n\n    \n# Time:  O(n)\n# Space: O(n)\nimport itertools\n\n\nclass Solution2(object):\n    def maxRepOpt1(self, text):\n        \"\"\"\n        :type text: str\n        :rtype: int\n        \"\"\"\n        A = [[c, len(list(group))] for c, group in itertools.groupby(text)]\n        total_count = collections.Counter(text)\n        result = max(min(l+1, total_count[c]) for c, l in A)\n        for i in xrange(1, len(A)-1):\n            if A[i-1][0] == A[i+1][0] and A[i][1] == 1:\n                result = max(result, min(A[i-1][1] + 1 + A[i+1][1], total_count[A[i+1][0]]))\n        return result\n"
    },
    {
        "problem_name": "swap-nodes-in-pairs",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return \"{} -> {}\".format(self.val, self.next)\n\nclass Solution(object):\n    # @param a ListNode\n    # @return a ListNode\n    def swapPairs(self, head):\n        dummy = ListNode(0)\n        dummy.next = head\n        current = dummy\n        while current.next and current.next.next:\n            next_one, next_two, next_three = current.next, current.next.next, current.next.next.next\n            current.next = next_two\n            next_two.next = next_one\n            next_one.next = next_three\n            current = next_one\n        return dummy.next\n\n"
    },
    {
        "problem_name": "swapping-nodes-in-a-linked-list",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        pass\n\n\nclass Solution(object):\n    def swapNodes(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        left, right, curr = None, None, head\n        while curr:\n            k -= 1\n            if right:\n                right = right.next\n            if k == 0:\n                left = curr\n                right = head\n            curr = curr.next\n        left.val, right.val = right.val, left.val\n        return head\n"
    },
    {
        "problem_name": "swim-in-rising-water",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[min(x_root, y_root)] = max(x_root, y_root)\n        return True\n\n\nclass Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        positions = [None] * (n**2)\n        for i in xrange(n):\n            for j in xrange(n):\n                positions[grid[i][j]] = (i, j)\n        directions = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n        union_find = UnionFind(n**2)\n        for elevation in xrange(n**2):\n            i, j = positions[elevation]\n            for direction in directions:\n                x, y = i+direction[0], j+direction[1]\n                if 0 <= x < n and 0 <= y < n and grid[x][y] <= elevation:\n                    union_find.union_set(i*n+j, x*n+y)\n                    if union_find.find_set(0) == union_find.find_set(n**2-1):\n                        return elevation\n        return n**2-1\n\n\n"
    },
    {
        "problem_name": "symmetric-tree",
        "solution": "# Time:  O(n)\n# Space: O(h), h is height of binary tree\n# Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# Iterative solution\nclass Solution(object):\n    # @param root, a tree node\n    # @return a boolean\n    def isSymmetric(self, root):\n        if root is None:\n            return True\n        stack = []\n        stack.append(root.left)\n        stack.append(root.right)\n\n        while stack:\n            p, q = stack.pop(), stack.pop()\n\n            if p is None and q is None:\n                continue\n\n            if p is None or q is None or p.val != q.val:\n                return False\n\n            stack.append(p.left)\n            stack.append(q.right)\n\n            stack.append(p.right)\n            stack.append(q.left)\n\n        return True\n\n# Recursive solution\nclass Solution2(object):\n    # @param root, a tree node\n    # @return a boolean\n    def isSymmetric(self, root):\n        if root is None:\n            return True\n\n        return self.isSymmetricRecu(root.left, root.right)\n\n    def isSymmetricRecu(self, left, right):\n        if left is None and right is None:\n            return True\n        if left is None or right is None or left.val != right.val:\n            return False\n        return self.isSymmetricRecu(left.left, right.right) and self.isSymmetricRecu(left.right, right.left)\n\n"
    },
    {
        "problem_name": "synonymous-sentences",
        "solution": "# Time:  O(p*l * log(p*l)), p is the production of all number of synonyms\n#                         , l is the length of a word\n# Space: O(p*l)\n\nimport collections\nimport itertools\n\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[max(x_root, y_root)] = min(x_root, y_root)\n        return True\n\n\nclass Solution(object):\n    def generateSentences(self, synonyms, text):\n        \"\"\"\n        :type synonyms: List[List[str]]\n        :type text: str\n        :rtype: List[str]\n        \"\"\"\n        def assign_id(x, lookup, inv_lookup):\n            if x in lookup:\n                return\n            lookup[x] = len(lookup)\n            inv_lookup[lookup[x]] = x\n        \n        lookup, inv_lookup = {}, {}\n        for u, v in synonyms:\n            assign_id(u, lookup, inv_lookup), assign_id(v, lookup, inv_lookup)\n        union_find = UnionFind(len(lookup))\n        for u, v in synonyms:\n            union_find.union_set(lookup[u], lookup[v])\n        groups = collections.defaultdict(list)\n        for i in xrange(len(union_find.set)):\n            groups[union_find.find_set(i)].append(i)\n        result = []\n        for w in text.split(' '):\n            if w not in lookup:\n                result.append([w])\n                continue\n            result.append(sorted(map(lambda x: inv_lookup[x], \n                                 groups[union_find.find_set(lookup[w])])))\n        return [\" \".join(sentense) for sentense in itertools.product(*result)]\n"
    },
    {
        "problem_name": "tag-validator",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def isValid(self, code):\n        \"\"\"\n        :type code: str\n        :rtype: bool\n        \"\"\"\n        def validText(s, i):\n            j = i\n            i = s.find(\"<\", i)\n            return i != j, i\n\n        def validCData(s, i):\n            if s.find(\"<![CDATA[\", i) != i:\n                return False, i\n            j = s.find(\"]]>\", i)\n            if j == -1:\n                return False, i\n            return True, j+3\n\n        def parseTagName(s, i):\n            if s[i] != '<':\n                return \"\", i\n            j = s.find('>', i)\n            if j == -1 or not (1 <= (j-1-i) <= 9):\n                return \"\", i\n            tag = s[i+1:j]\n            for c in tag:\n                if not (ord('A') <= ord(c) <= ord('Z')):\n                    return \"\", i\n            return tag, j+1\n\n        def parseContent(s, i):\n            while i < len(s):\n                result, i = validText(s, i)\n                if result:\n                    continue\n                result, i = validCData(s, i)\n                if result:\n                    continue\n                result, i = validTag(s, i)\n                if result:\n                    continue\n                break\n            return i\n\n        def validTag(s, i):\n            tag, j = parseTagName(s, i)\n            if not tag:\n                return False, i\n            j = parseContent(s, j)\n            k = j + len(tag) + 2\n            if k >= len(s) or s[j:k+1] != \"</\" + tag + \">\":\n                return False, i\n            return True, k+1\n\n        result, i = validTag(code, 0)\n        return result and i == len(code)\n\n"
    },
    {
        "problem_name": "take-gifts-from-the-richest-pile",
        "solution": "# Time:  O(n + klogn)\n# Space: O(1)\n\nimport heapq\n\n\n# heap\nclass Solution(object):\n    def pickGifts(self, gifts, k):\n        \"\"\"\n        :type gifts: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for i, x in enumerate(gifts):\n            gifts[i] = -x\n        heapq.heapify(gifts)\n        for _ in xrange(k):\n            x = heapq.heappop(gifts)\n            heapq.heappush(gifts, -int((-x)**0.5))\n        return -sum(gifts)\n"
    },
    {
        "problem_name": "take-k-of-each-character-from-left-and-right",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# sliding window, two pointers\nclass Solution(object):\n    def takeCharacters(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        cnt = [0]*3\n        for c in s:\n            cnt[ord(c)-ord('a')] += 1\n        if min(cnt) < k:\n            return -1\n        result = left = 0\n        for right in xrange(len(s)):\n            cnt[ord(s[right])-ord('a')] -= 1\n            while cnt[ord(s[right])-ord('a')] < k:\n                cnt[ord(s[left])-ord('a')] += 1\n                left += 1\n            result = max(result, right-left+1)\n        return len(s)-result\n"
    },
    {
        "problem_name": "taking-maximum-energy-from-the-mystic-dungeon",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def maximumEnergy(self, energy, k):\n        \"\"\"\n        :type energy: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = float(\"-inf\")\n        for i in xrange(k):\n            curr = 0\n            for j in reversed(xrange(((len(energy)-i)-1)%k, len(energy)-i, k)):  # xrange(len(energy)-1-i, -1, -k)\n                curr += energy[j]\n                result = max(result, curr)\n        return result\n"
    },
    {
        "problem_name": "tallest-billboard",
        "solution": "# Time:  O(n * 3^(n/2))\n# Space: O(3^(n/2))\n\nimport collections\n\n\nclass Solution(object):\n    def tallestBillboard(self, rods):\n        \"\"\"\n        :type rods: List[int]\n        :rtype: int\n        \"\"\"\n        def dp(A):\n            lookup = collections.defaultdict(int)\n            lookup[0] = 0\n            for x in A:\n                for d, y in lookup.items():\n                    lookup[d+x] = max(lookup[d+x], y)\n                    lookup[abs(d-x)] = max(lookup[abs(d-x)], y + min(d, x))\n            return lookup\n\n        left, right = dp(rods[:len(rods)//2]), dp(rods[len(rods)//2:])\n        return max(left[d]+right[d]+d for d in left if d in right)\n"
    },
    {
        "problem_name": "target-sum",
        "solution": "# Time:  O(n * S)\n# Space: O(S)\n\nimport collections\n\n\nclass Solution(object):\n    def findTargetSumWays(self, nums, S):\n        \"\"\"\n        :type nums: List[int]\n        :type S: int\n        :rtype: int\n        \"\"\"\n        def subsetSum(nums, S):\n            dp = collections.defaultdict(int)\n            dp[0] = 1\n            for n in nums:\n                for i in reversed(xrange(n, S+1)):\n                    if i-n in dp:\n                        dp[i] += dp[i-n]\n            return dp[S]\n\n        total = sum(nums)\n        if total < S or (S + total) % 2: return 0\n        P = (S + total) // 2\n        return subsetSum(nums, P)\n\n"
    },
    {
        "problem_name": "task-scheduler-ii",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# hash table\nclass Solution(object):\n    def taskSchedulerII(self, tasks, space):\n        \"\"\"\n        :type tasks: List[int]\n        :type space: int\n        :rtype: int\n        \"\"\"\n        lookup = collections.defaultdict(int)\n        result = 0\n        for t in tasks:\n            result = max(lookup[t], result+1)\n            lookup[t] = result+space+1\n        return result\n"
    },
    {
        "problem_name": "task-scheduler",
        "solution": "# Time:  O(n)\n# Space: O(26) = O(1)\n\nfrom collections import Counter\n\n\nclass Solution(object):\n    def leastInterval(self, tasks, n):\n        \"\"\"\n        :type tasks: List[str]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        counter = Counter(tasks)\n        _, max_count = counter.most_common(1)[0]\n        return max((max_count-1) * (n+1) + counter.values().count(max_count), len(tasks))\n"
    },
    {
        "problem_name": "teemo-attacking",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findPoisonedDuration(self, timeSeries, duration):\n        \"\"\"\n        :type timeSeries: List[int]\n        :type duration: int\n        :rtype: int\n        \"\"\"\n        result = duration * len(timeSeries)\n        for i in xrange(1, len(timeSeries)):\n            result -= max(0, duration - (timeSeries[i] - timeSeries[i-1]))\n        return result\n\n"
    },
    {
        "problem_name": "ternary-expression-parser",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def parseTernary(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: str\n        \"\"\"\n        if not expression:\n            return \"\"\n\n        stack = []\n        for c in expression[::-1]:\n            if stack and stack[-1] == '?':\n                stack.pop()  # pop '?'\n                first = stack.pop()\n                stack.pop()  # pop ':'\n                second = stack.pop()\n\n                if c == 'T':\n                    stack.append(first)\n                else:\n                    stack.append(second)\n            else:\n                stack.append(c)\n\n\n        return str(stack[-1])\n\n"
    },
    {
        "problem_name": "text-justification",
        "solution": "# Time:  O(n)\n# Space: O(k), k is maxWidth.\n\nclass Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        def addSpaces(i, spaceCnt, maxWidth, is_last):\n            if i < spaceCnt:\n                # For the last line of text, it should be left justified,\n                # and no extra space is inserted between words.\n                return 1 if is_last else (maxWidth // spaceCnt) + int(i < maxWidth % spaceCnt)\n            return 0\n\n        def connect(words, maxWidth, begin, end, length, is_last):\n            s = []  # The extra space O(k) is spent here.\n            n = end - begin\n            for i in xrange(n):\n                s += words[begin + i],\n                s += ' ' * addSpaces(i, n - 1, maxWidth - length, is_last),\n            # For only one word in a line.\n            line = \"\".join(s)\n            if len(line) < maxWidth:\n                line += ' ' * (maxWidth - len(line))\n            return line\n\n        res = []\n        begin, length = 0, 0\n        for i in xrange(len(words)):\n            if length + len(words[i]) + (i - begin) > maxWidth:\n                res += connect(words, maxWidth, begin, i, length, False),\n                begin, length = i, 0\n            length += len(words[i])\n\n        # Last line.\n        res += connect(words, maxWidth, begin, len(words), length, True),\n        return res\n\n\n"
    },
    {
        "problem_name": "the-dining-philosophers",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport threading\n\n\nclass DiningPhilosophers(object):\n    def __init__(self):\n        self._l = [threading.Lock() for _ in xrange(5)]\n\n    # call the functions directly to execute, for example, eat()\n    def wantsToEat(self, philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork):\n        \"\"\"\n        :type philosopher: int\n        :type pickLeftFork: method\n        :type pickRightFork: method\n        :type eat: method\n        :type putLeftFork: method\n        :type putRightFork: method\n        :rtype: void\n        \"\"\"\n        left, right = philosopher, (philosopher+4)%5\n        first, second = left, right\n        if  philosopher%2 == 0:\n            first, second = left, right\n        else:\n            first, second = right, left\n\n        with self._l[first]:\n            with self._l[second]:\n                pickLeftFork()\n                pickRightFork()\n                eat()\n                putLeftFork()\n                putRightFork()\n"
    },
    {
        "problem_name": "the-earliest-and-latest-rounds-where-players-compete",
        "solution": "# Time:  O(n^2) states * O(n^2) per state = O(n^4)\n# Space: O(n^2 + (n/2)^2 + (n/4)^2 + ... ) = O(n^2)\n\nclass Solution(object):\n    def earliestAndLatest(self, n, firstPlayer, secondPlayer):\n        \"\"\"\n        :type n: int\n        :type firstPlayer: int\n        :type secondPlayer: int\n        :rtype: List[int]\n        \"\"\"\n        def memoization(t, l, r, lookup):\n            # t: total number of players,\n            # l: number of players left to the nearest top2 player,\n            # r: number of players right to the nearest top2 player\n            if (t, l, r) not in lookup:\n                if l == r:\n                    return (1, 1)\n                if l > r:  # make sure l <= r\n                    l, r, = r, l\n                result = [float(\"inf\"), 0]\n                for i in xrange(l+1):\n                    l_win_cnt, l_lose_cnt, nt, pair_cnt = i+1, l-i, (t+1)//2, t//2\n                    min_j = max(l_lose_cnt, r-(pair_cnt-l_lose_cnt))  # j >= l_lose_cnt and j >= r-(pair_cnt-l_lose_cnt)\n                    max_j = min(r-l_win_cnt, (nt-l_win_cnt)-1)  # j <= r-l_win_cnt and j <= (nt-l_win_cnt)-1\n                    for j in xrange(min_j, max_j+1):\n                        tmp = memoization(nt, i, j, lookup)\n                        result = min(result[0], tmp[0]+1), max(result[1], tmp[1]+1)\n                lookup[t, l, r] = result\n            return lookup[t, l, r]\n        \n        return memoization(n, firstPlayer-1, n-secondPlayer, {})\n"
    },
    {
        "problem_name": "the-earliest-moment-when-everyone-become-friends",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.set = range(n)\n        self.count = n\n\n    def find_set(self, x):\n        if self.set[x] != x:\n            self.set[x] = self.find_set(self.set[x])  # path compression.\n        return self.set[x]\n\n    def union_set(self, x, y):\n        x_root, y_root = map(self.find_set, (x, y))\n        if x_root == y_root:\n            return False\n        self.set[max(x_root, y_root)] = min(x_root, y_root)\n        self.count -= 1\n        return True\n\n\nclass Solution(object):\n    def earliestAcq(self, logs, N):\n        \"\"\"\n        :type logs: List[List[int]]\n        :type N: int\n        :rtype: int\n        \"\"\"\n        logs.sort()\n        union_find = UnionFind(N)\n        for t, a, b in logs:\n            union_find.union_set(a, b)\n            if union_find.count == 1:\n                return t\n        return -1\n"
    },
    {
        "problem_name": "the-employee-that-worked-on-the-longest-task",
        "solution": "# Time:  O(l)\n# Space: O(1)\n\n# array\nclass Solution(object):\n    def hardestWorker(self, n, logs):\n        \"\"\"\n        :type n: int\n        :type logs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        return logs[max(xrange(len(logs)), key=lambda x: (logs[x][1]-(logs[x-1][1] if x-1 >= 0 else 0), -logs[x][0]))][0]\n"
    },
    {
        "problem_name": "the-k-strongest-values-in-an-array",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def getStrongest(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        arr.sort()\n        m = arr[(len(arr)-1)//2]\n        result = []\n        left, right = 0, len(arr)-1\n        while len(result) < k:\n            if m-arr[left] > arr[right]-m:\n                result.append(arr[left])\n                left += 1\n            else:\n                result.append(arr[right])\n                right -= 1\n        return result\n\n\n# Time:  O(nlogn)\n# Space: O(1)\nclass Solution2(object):\n    def getStrongest(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        arr.sort()\n        m = arr[(len(arr)-1)//2]\n        arr.sort(key=lambda x: (-abs(x-m), -x))\n        return arr[:k]\n\n\n# Time:  O(n)\n# Space: O(1)\nimport random\n\n\nclass Solution_TLE(object):\n    def getStrongest(self, arr, k):\n        \"\"\"\n        :type arr: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def partition_around_pivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == n:\n                    return\n                elif new_pivot_idx > n:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < n\n                    left = new_pivot_idx + 1\n        \n        nth_element(arr, (len(arr)-1)//2)\n        m = arr[(len(arr)-1)//2]\n        nth_element(arr, k, lambda a, b: abs(a-m) > abs(b-m) if abs(a-m) != abs(b-m) else a > b)\n        return arr[:k]\n"
    },
    {
        "problem_name": "the-k-th-lexicographical-string-of-all-happy-strings-of-length-n",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def getHappyString(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        base = 2**(n-1)\n        if k > 3*base:\n            return \"\"\n        result = [chr(ord('a')+(k-1)//base)]\n        while base > 1:\n            k -= (k-1)//base*base\n            base //= 2\n            result.append(('a' if result[-1] != 'a' else 'b') if (k-1)//base == 0 else\n                          ('c' if result[-1] != 'c' else 'b'))\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "the-k-weakest-rows-in-a-matrix",
        "solution": "# Time:  O(m * n)\n# Space: O(k)\n\nclass Solution(object):\n    def kWeakestRows(self, mat, k):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result, lookup = [], set()\n        for j in xrange(len(mat[0])):\n            for i in xrange(len(mat)):\n                if mat[i][j] or i in lookup:\n                    continue\n                lookup.add(i)\n                result.append(i)\n                if len(result) == k:\n                    return result\n        for i in xrange(len(mat)):\n            if i in lookup:\n                continue\n            lookup.add(i)\n            result.append(i)\n            if len(result) == k:\n                break\n        return result\n\n\n# Time:  O(m * n)\n# Space: O(k)\nimport collections\n\n\nclass Solution2(object):\n    def kWeakestRows(self, mat, k):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        lookup = collections.OrderedDict()\n        for j in xrange(len(mat[0])):\n            for i in xrange(len(mat)):\n                if mat[i][j] or i in lookup:\n                    continue\n                lookup[i] = True\n                if len(lookup) == k:\n                    return lookup.keys()\n        for i in xrange(len(mat)):\n            if i in lookup:\n                continue\n            lookup[i] = True\n            if len(lookup) == k:\n                break\n        return lookup.keys()\n\n\n# Time:  O(m * n + klogk)\n# Space: O(m)\nimport random\n\n\nclass Solution3(object):\n    def kWeakestRows(self, mat, k):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def partition_around_pivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == n:\n                    return\n                elif new_pivot_idx > n:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < n\n                    left = new_pivot_idx + 1\n        \n        nums = [(sum(mat[i]), i) for i in xrange(len(mat))]\n        nth_element(nums, k)\n        return map(lambda x: x[1], sorted(nums[:k]))\n"
    },
    {
        "problem_name": "the-knights-tour",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\n# backtracking, greedy, warnsdorff's rule\nclass Solution(object):\n    def tourOfKnight(self, m, n, r, c):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type r: int\n        :type c: int\n        :rtype: List[List[int]]\n        \"\"\"\n        DIRECTIONS = ((1, 2), (-1, 2), (1, -2), (-1, -2),\n                      (2, 1), (-2, 1), (2, -1), (-2, -1))\n        def backtracking(r, c, i):\n            def degree(x):\n                cnt = 0\n                r, c = x\n                for dr, dc in DIRECTIONS:\n                    nr, nc = r+dr, c+dc\n                    if 0 <= nr < m and 0 <= nc < n and result[nr][nc] == -1:\n                        cnt += 1\n                return cnt\n\n            if i == m*n:\n                return True\n            candidates = []\n            for dr, dc in DIRECTIONS:\n                nr, nc = r+dr, c+dc\n                if 0 <= nr < m and 0 <= nc < n and result[nr][nc] == -1:\n                    candidates.append((nr, nc))\n            for nr, nc in sorted(candidates, key=degree):  # warnsdorff's rule\n                result[nr][nc] = i\n                if backtracking(nr, nc, i+1):\n                    return True\n                result[nr][nc] = -1\n            return False\n    \n        result = [[-1]*n for _ in xrange(m)]\n        result[r][c] = 0\n        backtracking(r, c, 1)\n        return result\n\n\n# Time:  O(8^(m * n - 1))\n# Space: O(1)\n# backtracking\nclass Solution2(object):\n    def tourOfKnight(self, m, n, r, c):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type r: int\n        :type c: int\n        :rtype: List[List[int]]\n        \"\"\"\n        DIRECTIONS = ((1, 2), (-1, 2), (1, -2), (-1, -2),\n                      (2, 1), (-2, 1), (2, -1), (-2, -1))\n        def backtracking(r, c, i):\n            if i == m*n:\n                return True\n            for dr, dc in DIRECTIONS:\n                nr, nc = r+dr, c+dc\n                if not (0 <= nr < m and 0 <= nc < n and result[nr][nc] == -1):\n                    continue\n                result[nr][nc] = i\n                if backtracking(nr, nc, i+1):\n                    return True\n                result[nr][nc] = -1\n            return False\n    \n        result = [[-1]*n for _ in xrange(m)]\n        result[r][c] = 0\n        backtracking(r, c, 1)\n        return result\n"
    },
    {
        "problem_name": "the-kth-factor-of-n",
        "solution": "# Time:  O(sqrt(n))\n# Space: O(1)\n\nclass Solution(object):\n    def kthFactor(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def kth_factor(n, k=0):\n            mid = None\n            i = 1\n            while i*i <= n:\n                if not n%i:\n                    mid = i\n                    k -= 1\n                    if not k:\n                        break\n                i += 1\n            return mid, -k\n    \n        mid, count = kth_factor(n)\n        total = 2*count-(mid*mid == n)\n        if k > total:\n            return -1\n        result = kth_factor(n, k if k <= count else total-(k-1))[0]\n        return result if k <= count else n//result\n\n\n# Time:  O(sqrt(n))\n# Space: O(sqrt(n))\nclass Solution2(object):\n    def kthFactor(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        result = []\n        i = 1\n        while i*i <= n:\n            if not n%i:\n                if i*i != n:\n                    result.append(i)\n                k -= 1\n                if not k:\n                    return i\n            i += 1\n        return -1 if k > len(result) else n//result[-k]\n"
    },
    {
        "problem_name": "the-latest-time-to-catch-a-bus",
        "solution": "# Time:  O(nlogn + mlogm)\n# Space: O(1)\n\n# sort, two pointers\nclass Solution(object):\n    def latestTimeCatchTheBus(self, buses, passengers, capacity):\n        \"\"\"\n        :type buses: List[int]\n        :type passengers: List[int]\n        :type capacity: int\n        :rtype: int\n        \"\"\"\n        buses.sort()\n        passengers.sort()\n        cnt = j = 0\n        for i in xrange(len(buses)-1):\n            while j < len(passengers) and passengers[j] <= buses[i]:\n                cnt += 1\n                j += 1\n            cnt = max(cnt-capacity, 0)\n        j -= max(cnt-capacity, 0)\n        cnt = min(cnt, capacity)\n        while j < len(passengers) and passengers[j] <= buses[-1] and cnt+1 <= capacity:\n            cnt += 1\n            j += 1\n        return buses[-1] if cnt < capacity and (j-1 < 0 or passengers[j-1] != buses[-1]) else next(passengers[i]-1 for i in reversed(xrange(j)) if i-1 < 0 or passengers[i]-1 != passengers[i-1])\n"
    },
    {
        "problem_name": "the-maze-ii",
        "solution": "# Time:  O(max(r, c) * wlogw)\n# Space: O(w)\n\nimport heapq\n\n\nclass Solution(object):\n    def shortestDistance(self, maze, start, destination):\n        \"\"\"\n        :type maze: List[List[int]]\n        :type start: List[int]\n        :type destination: List[int]\n        :rtype: int\n        \"\"\"\n        start, destination = tuple(start), tuple(destination)\n\n        def neighbors(maze, node):\n            for dir in [(-1, 0), (0, 1), (0, -1), (1, 0)]:\n                cur_node, dist = list(node), 0\n                while 0 <= cur_node[0]+dir[0] < len(maze) and \\\n                      0 <= cur_node[1]+dir[1] < len(maze[0]) and \\\n                      not maze[cur_node[0]+dir[0]][cur_node[1]+dir[1]]:\n                    cur_node[0] += dir[0]\n                    cur_node[1] += dir[1]\n                    dist += 1\n                yield dist, tuple(cur_node)\n\n        heap = [(0, start)]\n        visited = set()\n        while heap:\n            dist, node = heapq.heappop(heap)\n            if node in visited: continue\n            if node == destination:\n                return dist\n            visited.add(node)\n            for neighbor_dist, neighbor in neighbors(maze, node):\n                heapq.heappush(heap, (dist+neighbor_dist, neighbor))\n\n        return -1\n\n"
    },
    {
        "problem_name": "the-maze-iii",
        "solution": "# Time:  O(max(r, c) * wlogw)\n# Space: O(w^2)\n\nimport heapq\n\n\nclass Solution(object):\n    def findShortestWay(self, maze, ball, hole):\n        \"\"\"\n        :type maze: List[List[int]]\n        :type ball: List[int]\n        :type hole: List[int]\n        :rtype: str\n        \"\"\"\n        ball, hole = tuple(ball), tuple(hole)\n        dirs = {'u' : (-1, 0), 'r' : (0, 1), 'l' : (0, -1), 'd': (1, 0)}\n\n        def neighbors(maze, node):\n            for dir, vec in dirs.iteritems():\n                cur_node, dist = list(node), 0\n                while 0 <= cur_node[0]+vec[0] < len(maze) and \\\n                      0 <= cur_node[1]+vec[1] < len(maze[0]) and \\\n                      not maze[cur_node[0]+vec[0]][cur_node[1]+vec[1]]:\n                    cur_node[0] += vec[0]\n                    cur_node[1] += vec[1]\n                    dist += 1\n                    if tuple(cur_node) == hole:\n                        break\n                yield tuple(cur_node), dir, dist\n\n        heap = [(0, '', ball)]\n        visited = set()\n        while heap:\n            dist, path, node = heapq.heappop(heap)\n            if node in visited: continue\n            if node == hole: return path\n            visited.add(node)\n            for neighbor, dir, neighbor_dist in neighbors(maze, node):\n                heapq.heappush(heap, (dist+neighbor_dist, path+dir, neighbor))\n\n        return \"impossible\"\n\n"
    },
    {
        "problem_name": "the-maze",
        "solution": "# Time:  O(max(r, c) * w)\n# Space: O(w)\n\nimport collections\n\n\nclass Solution(object):\n    def hasPath(self, maze, start, destination):\n        \"\"\"\n        :type maze: List[List[int]]\n        :type start: List[int]\n        :type destination: List[int]\n        :rtype: bool\n        \"\"\"\n        def neighbors(maze, node):\n            for i, j in [(-1, 0), (0, 1), (0, -1), (1, 0)]:\n                x, y = node\n                while 0 <= x + i < len(maze) and \\\n                      0 <= y + j < len(maze[0]) and \\\n                      not maze[x+i][y+j]:\n                    x += i\n                    y += j\n                yield x, y\n\n        start, destination = tuple(start), tuple(destination)\n        queue = collections.deque([start])\n        visited = set()\n        while queue:\n            node = queue.popleft()\n            if node in visited: continue\n            if node == destination:\n                return True\n            visited.add(node)\n            for neighbor in neighbors(maze, node):\n                queue.append(neighbor)\n\n        return False\n"
    },
    {
        "problem_name": "the-most-similar-path-in-a-graph",
        "solution": "# Time:  O(n^2 * m), m is the length of targetPath\n# Space: O(n * m)\n\nclass Solution(object):\n    def mostSimilar(self, n, roads, names, targetPath):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :type names: List[str]\n        :type targetPath: List[str]\n        :rtype: List[int]\n        \"\"\"\n        adj = [[] for _ in xrange(n)]\n        for u, v in roads:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        dp = [[0]*n for _ in xrange(len(targetPath)+1)]\n        for i in xrange(1, len(targetPath)+1):\n            for v in xrange(n):\n                dp[i][v] = (names[v] != targetPath[i-1]) + min(dp[i-1][u] for u in adj[v]) \n\n        path = [dp[-1].index(min(dp[-1]))]\n        for i in reversed(xrange(2, len(targetPath)+1)):\n            for u in adj[path[-1]]:\n                if dp[i-1][u]+(names[path[-1]] != targetPath[i-1]) == dp[i][path[-1]]:\n                    path.append(u)\n                    break\n        return path[::-1]\n"
    },
    {
        "problem_name": "the-number-of-beautiful-subsets",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\nimport operator\n\n\n# combinatorics, dp\nclass Solution(object):\n    def beautifulSubsets(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def count(x):\n            y = x\n            while y-k in cnt:\n                y -= k\n            dp = [1, 0]  # dp[0]: count without i, dp[1]: count with i\n            for i in xrange(y, x+1, k):\n                dp = [dp[0]+dp[1], dp[0]*((1<<cnt[i])-1)]\n            return sum(dp)\n\n        cnt = collections.Counter(nums)\n        return reduce(operator.mul, (count(i) for i in cnt.iterkeys() if i+k not in cnt))-1\n"
    },
    {
        "problem_name": "the-number-of-full-rounds-you-have-played",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfRounds(self, startTime, finishTime):\n        \"\"\"\n        :type startTime: str\n        :type finishTime: str\n        :rtype: int\n        \"\"\"\n        h1, m1 = map(int, startTime.split(\":\"))\n        h2, m2 = map(int, finishTime.split(\":\"))\n        start = h1*60+m1\n        finish = h2*60+m2\n        if start > finish:\n            finish += 1440\n        return max(finish//15-(start+15-1)//15, 0)\n\n\n# Time:  O(1)\n# Space: O(1)\nclass Solution2(object):\n    def numberOfRounds(self, startTime, finishTime):\n        \"\"\"\n        :type startTime: str\n        :type finishTime: str\n        :rtype: int\n        \"\"\"\n        h1, m1 = map(int, startTime.split(\":\"))\n        h2, m2 = map(int, finishTime.split(\":\"))\n        if m1 > m2:\n            h2 -= 1\n            m2 += 60\n        return max((h2-h1)%24*4 + m2//15 - (m1+15-1)//15, 0)\n"
    },
    {
        "problem_name": "the-number-of-good-subsets",
        "solution": "# Time:  O(n * 2^p), p is the number of primes in [1, n]\n# Space: O(2^p)\n\nimport collections\n\n\nclass Solution(object):\n    def numberOfGoodSubsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def sieve_of_eratosthenes(n):  # Time: O(n * log(logn)), Space: O(n)\n            if n < 2:\n                return []\n            primes = [2]\n            is_prime = [True]*((n+1)//2)\n            for i in xrange(1, len(is_prime)):\n                if not is_prime[i]:\n                    continue\n                primes.append(2*i+1)\n                for j in xrange(2*i*(i+1), len(is_prime), (2*i+1)):\n                    is_prime[j] = False\n            return primes\n\n        def to_mask(primes, x):\n            mask, basis = 0, 1\n            for p in primes:\n                if x%p == 0:\n                    mask |= basis\n                basis <<= 1\n            return mask\n\n        MOD = 10**9+7\n        primes = sieve_of_eratosthenes(max(nums))\n        dp = [0]*(1<<len(primes))  # dp[i] = the number of different good subsets of which the total product equals to the product of the primes in bitset i\n        dp[0] = 1\n        cnts = collections.Counter(nums)\n        for x, cnt in cnts.iteritems():\n            if x == 1 or any(x%(p*p) == 0 for p in primes if p*p <= x):\n                continue\n            mask = to_mask(primes, x)\n            for i in xrange(len(dp)-1):\n                if i&mask:\n                    continue\n                dp[i|mask] = (dp[i|mask]+cnt*dp[i])%MOD\n        return (pow(2, cnts[1], MOD))*(reduce(lambda total, x: (total+x)%MOD, dp, 0)-1)%MOD\n"
    },
    {
        "problem_name": "the-number-of-the-smallest-unoccupied-chair",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def smallestChair(self, times, targetFriend):\n        \"\"\"\n        :type times: List[List[int]]\n        :type targetFriend: int\n        :rtype: int\n        \"\"\"\n        events = []\n        for i, (s, e) in enumerate(times): \n            events.append((s, True, i))\n            events.append((e, False, i))\n        events.sort()\n\n        lookup = {}\n        min_heap = []\n        for _, arrival, i in events: \n            if not arrival: \n                heapq.heappush(min_heap, lookup.pop(i))\n                continue\n            lookup[i] = heapq.heappop(min_heap) if min_heap else len(lookup)\n            if i == targetFriend:\n                break\n        return lookup[targetFriend]\n"
    },
    {
        "problem_name": "the-number-of-weak-characters-in-the-game",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def numberOfWeakCharacters(self, properties):\n        \"\"\"\n        :type properties: List[List[int]]\n        :rtype: int\n        \"\"\"\n        properties.sort(cmp=lambda a, b: cmp(b[1], a[1]) if a[0] == b[0] else cmp(a[0], b[0]))\n        result = max_d = 0\n        for a, d in reversed(properties):\n            if d < max_d:\n                result += 1\n            max_d = max(max_d, d)\n        return result\n\n    \n# Time:  O(nlogn)\n# Space: O(n)\nimport collections\n\n\n# faster in sort by using more space\nclass Solution(object):\n    def numberOfWeakCharacters(self, properties):\n        \"\"\"\n        :type properties: List[List[int]]\n        :rtype: int\n        \"\"\"\n        lookup = collections.defaultdict(list)\n        for a, d in properties:\n            lookup[a].append(d)\n        result = max_d = 0\n        for a in sorted(lookup.iterkeys(), reverse=True):\n            result += sum(d < max_d for d in lookup[a])\n            max_d = max(max_d, max(lookup[a]))\n        return result\n"
    },
    {
        "problem_name": "the-score-of-students-solving-math-expression",
        "solution": "# Time:  O(n^3 * a^2)\n# Space: O(n^2)\n\nclass Solution(object):\n    def scoreOfStudents(self, s, answers):\n        \"\"\"\n        :type s: str\n        :type answers: List[int]\n        :rtype: int\n        \"\"\"\n        MAX_ANS = 1000\n        n = (len(s)+1)//2\n        dp = [[set() for _ in xrange(n)] for _ in xrange(n)]\n        for i in xrange(n):\n            dp[i][i].add(int(s[i*2]))\n        for l in xrange(1, n):\n            for left in xrange(n-l):\n                right = left+l\n                for k in xrange(left, right):\n                    if s[2*k+1] == '+':\n                        dp[left][right].update((x+y for x in dp[left][k] for y in dp[k+1][right] if x+y <= MAX_ANS))\n                    else:\n                        dp[left][right].update((x*y for x in dp[left][k] for y in dp[k+1][right] if x*y <= MAX_ANS))\n        target = eval(s)\n        return sum(5 if ans == target else 2 if ans in dp[0][-1] else 0 for ans in answers)\n\n\n# Time:  O(n^3 * a^2)\n# Space: O(n^2)\nclass Solution2(object):\n    def scoreOfStudents(self, s, answers):\n        \"\"\"\n        :type s: str\n        :type answers: List[int]\n        :rtype: int\n        \"\"\"\n        MAX_ANS = 1000\n        def evaluate(s):\n            def compute(operands, operators):\n                right, left = operands.pop(), operands.pop()\n                operands.append(ops[operators.pop()](left, right))\n\n            ops = {'+':operator.add, '*':operator.mul}\n            precedence = {'+':0, '*':1}\n            operands, operators, operand = [], [], 0\n            for c in s:\n                if c.isdigit():\n                    operands.append(int(c))\n                else:\n                    while operators and precedence[operators[-1]] >= precedence[c]:\n                        compute(operands, operators)\n                    operators.append(c)\n            while operators:\n                compute(operands, operators)\n            return operands[-1]\n\n        n = (len(s)+1)//2\n        dp = [[set() for _ in xrange(n)] for _ in xrange(n)]\n        for i in xrange(n):\n            dp[i][i].add(int(s[i*2]))\n        for l in xrange(1, n):\n            for left in xrange(n-l):\n                right = left+l\n                for k in xrange(left, right):\n                    if s[2*k+1] == '+':\n                        dp[left][right].update((x+y for x in dp[left][k] for y in dp[k+1][right] if x+y <= MAX_ANS))\n                    else:\n                        dp[left][right].update((x*y for x in dp[left][k] for y in dp[k+1][right] if x*y <= MAX_ANS))\n        target = evaluate(s)\n        return sum(5 if ans == target else 2 if ans in dp[0][-1] else 0 for ans in answers)\n"
    },
    {
        "problem_name": "the-skyline-problem",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nstart, end, height = 0, 1, 2\nclass Solution(object):\n    # @param {integer[][]} buildings\n    # @return {integer[][]}\n    def getSkyline(self, buildings):\n        intervals = self.ComputeSkylineInInterval(buildings, 0, len(buildings))\n\n        res = []\n        last_end = -1\n        for interval in intervals:\n            if last_end != -1 and last_end < interval[start]:\n                res.append([last_end, 0])\n            res.append([interval[start], interval[height]])\n            last_end = interval[end]\n        if last_end != -1:\n            res.append([last_end, 0])\n\n        return res\n\n    # Divide and Conquer.\n    def ComputeSkylineInInterval(self, buildings, left_endpoint, right_endpoint):\n        if right_endpoint - left_endpoint <= 1:\n            return buildings[left_endpoint:right_endpoint]\n        mid = left_endpoint + ((right_endpoint - left_endpoint) / 2)\n        left_skyline = self.ComputeSkylineInInterval(buildings, left_endpoint, mid)\n        right_skyline = self.ComputeSkylineInInterval(buildings, mid, right_endpoint)\n        return self.MergeSkylines(left_skyline, right_skyline)\n\n    # Merge Sort.\n    def MergeSkylines(self, left_skyline, right_skyline):\n        i, j = 0, 0\n        merged = []\n\n        while i < len(left_skyline) and j < len(right_skyline):\n            if left_skyline[i][end] < right_skyline[j][start]:\n                merged.append(left_skyline[i])\n                i += 1\n            elif right_skyline[j][end] < left_skyline[i][start]:\n                merged.append(right_skyline[j])\n                j += 1\n            elif left_skyline[i][start] <= right_skyline[j][start]:\n                i, j = self.MergeIntersectSkylines(merged, left_skyline[i], i,\\\n                                                   right_skyline[j], j)\n            else: # left_skyline[i][start] > right_skyline[j][start].\n                j, i = self.MergeIntersectSkylines(merged, right_skyline[j], j, \\\n                                                   left_skyline[i], i)\n\n        # Insert the remaining skylines.\n        merged += left_skyline[i:]\n        merged += right_skyline[j:]\n        return merged\n\n    # a[start] <= b[start]\n    def MergeIntersectSkylines(self, merged, a, a_idx, b, b_idx):\n        if a[end] <= b[end]:\n            if a[height] > b[height]:   # |aaa|\n                if b[end] != a[end]:    # |abb|b\n                    b[start] = a[end]\n                    merged.append(a)\n                    a_idx += 1\n                else:             # aaa\n                    b_idx += 1    # abb\n            elif a[height] == b[height]:  # abb\n                b[start] = a[start]       # abb\n                a_idx += 1\n            else:  # a[height] < b[height].\n                if a[start] != b[start]:                            #    bb\n                    merged.append([a[start], b[start], a[height]])  # |a|bb\n                a_idx += 1\n        else:  # a[end] > b[end].\n            if a[height] >= b[height]:  # aaaa\n                b_idx += 1              # abba\n            else:\n                #    |bb|\n                # |a||bb|a\n                if a[start] != b[start]:\n                    merged.append([a[start], b[start], a[height]])\n                a[start] = b[end]\n                merged.append(b)\n                b_idx += 1\n        return a_idx, b_idx\n\n"
    },
    {
        "problem_name": "the-time-when-the-network-becomes-idle",
        "solution": "# Time:  O(|V| + |E|) = O(|E|) since graph is connected, O(|E|) >= O(|V|) \n# Space: O(|V| + |E|) = O(|E|)\n\nclass Solution(object):\n    def networkBecomesIdle(self, edges, patience):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type patience: List[int]\n        :rtype: int\n        \"\"\"\n        adj = [[] for _ in xrange(len(patience))]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        q = [0]\n        lookup = [False]*len(patience)\n        lookup[0] = True\n        step = 1\n        result = 0\n        while q:\n            new_q = []\n            for u in q:\n                for v in adj[u]:\n                    if lookup[v]:\n                        continue\n                    lookup[v] = True\n                    new_q.append(v)\n                    result = max(result, ((step*2)-1)//patience[v]*patience[v] + (step*2))\n            q = new_q\n            step += 1\n        return 1+result\n"
    },
    {
        "problem_name": "the-wording-game",
        "solution": "# Time:  O(m + n), m = sum(len(w) for w in a), n = sum(len(w) for w in b)\n# Space: O(1)\n\n# game, greedy\nclass Solution(object):\n    def canAliceWin(self, a, b):\n        \"\"\"\n        :type a: List[str]\n        :type b: List[str]\n        :rtype: bool\n        \"\"\"\n        def is_closely_greater(a, b):\n            return ord(a[0])-ord(b[0]) <= 1 and a > b\n\n        result = True\n        i, j = 0, -1\n        for _ in xrange(len({w[0] for w in a})+len({w[0] for w in b})):  # each player takes turns using a word with a different first letter than the last word he played\n            j = next((j for j in xrange(j+1, len(b)) if is_closely_greater(b[j], a[i])), len(b))\n            if j == len(b):\n                break\n            while j+1 < len(b) and b[j+1][0] == b[j][0]:  # play the lexicographically greatest word with the same first letter\n                j += 1\n            a, b, i, j, result = b, a, j, i, not result\n        return result\n"
    },
    {
        "problem_name": "third-maximum-number",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count = 0\n        top = [float(\"-inf\")] * 3\n        for num in nums:\n            if num > top[0]:\n                top[0], top[1], top[2] = num, top[0], top[1]\n                count += 1\n            elif num != top[0] and num > top[1]:\n                top[1], top[2] = num, top[1]\n                count += 1\n            elif num != top[0] and num != top[1] and num >= top[2]:\n                top[2] = num\n                count += 1\n\n        if count < 3:\n            return top[0]\n\n        return top[2]\n\n"
    },
    {
        "problem_name": "thousand-separator",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def thousandSeparator(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        result = []\n        s = str(n)\n        for i, c in enumerate(str(n)):\n            if i and (len(s)-i)%3 == 0:\n                result.append(\".\")\n            result.append(c)\n        return \"\".join(result)\n"
    },
    {
        "problem_name": "three-consecutive-odds",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def threeConsecutiveOdds(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        count = 0\n        for x in arr:\n            count = count+1 if x%2 else 0\n            if count == 3:\n                return True\n        return False\n"
    },
    {
        "problem_name": "three-divisors",
        "solution": "# Time:  O(sqrt(n))\n# Space: O(1)\n\nclass Solution(object):\n    def isThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        cnt = 0\n        i = 1\n        while i*i <= n and cnt <= 3:\n            if n%i == 0:\n                cnt += 1 if i*i == n else 2\n            i += 1\n        return cnt == 3\n"
    },
    {
        "problem_name": "three-equal-parts",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def threeEqualParts(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: List[int]\n        \"\"\"\n        total = sum(A)\n        if total % 3 != 0:\n            return [-1, -1]\n        if total == 0:\n            return [0, len(A)-1]\n\n        count = total//3\n        nums = [0]*3\n        c = 0\n        for i in xrange(len(A)):\n            if A[i] == 1:\n                if c % count == 0:\n                    nums[c//count] = i\n                c += 1\n\n        while nums[2] != len(A):\n            if not A[nums[0]] == A[nums[1]] == A[nums[2]]:\n                return [-1, -1]\n            nums[0] += 1\n            nums[1] += 1\n            nums[2] += 1\n        return [nums[0]-1, nums[1]]\n"
    },
    {
        "problem_name": "throne-inheritance",
        "solution": "# Time:  ctor:    O(1)\n#        birth:   O(1)\n#        death:   O(1)\n#        inherit: O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass ThroneInheritance(object):\n\n    def __init__(self, kingName):\n        \"\"\"\n        :type kingName: str\n        \"\"\"\n        self.__king = kingName\n        self.__family_tree = collections.defaultdict(list)\n        self.__dead = set()\n        \n\n    def birth(self, parentName, childName):\n        \"\"\"\n        :type parentName: str\n        :type childName: str\n        :rtype: None\n        \"\"\"\n        self.__family_tree[parentName].append(childName)\n\n\n    def death(self, name):\n        \"\"\"\n        :type name: str\n        :rtype: None\n        \"\"\"\n        self.__dead.add(name)\n        \n    \n    def getInheritanceOrder(self):\n        \"\"\"\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        stk = [self.__king]\n        while stk:  # preorder traversal\n            node = stk.pop()\n            if node not in self.__dead:\n                result.append(node)\n            if node not in self.__family_tree:\n                continue\n            for child in reversed(self.__family_tree[node]):\n                stk.append(child)\n        return result\n\n"
    },
    {
        "problem_name": "tiling-a-rectangle-with-the-fewest-squares",
        "solution": "# Time:  O(n^2 * m^2 * m^(n * m)), given m < n\n# Space: O(n * m)\n\nclass Solution(object):\n    def tilingRectangle(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        :rtype: int\n        \"\"\"\n        def find_next(board):\n            for i in xrange(len(board)):\n                for j in xrange(len(board[0])):\n                    if not board[i][j]:\n                        return i, j\n            return -1, -1\n\n        def find_max_length(board, i, j):\n            max_length = 1\n            while i+max_length-1 < len(board) and \\\n                  j+max_length-1 < len(board[0]):\n                for r in xrange(i, i+max_length-1):\n                    if board[r][j+max_length-1]:\n                        return max_length-1\n                for c in xrange(j, j+max_length):\n                    if board[i+max_length-1][c]:\n                        return max_length-1\n                max_length += 1\n            return max_length-1\n\n        def fill(board, i, j, length, val):\n            for r in xrange(i, i+length):\n                for c in xrange(j, j+length):\n                    board[r][c] = val\n\n        def backtracking(board, count, result):\n            if count >= result[0]:  # pruning\n                return\n            i, j = find_next(board)\n            if (i, j) == (-1, -1):  # finished\n                result[0] = min(result[0], count)\n                return\n            max_length = find_max_length(board, i, j)\n            for k in reversed(xrange(1, max_length+1)):\n                fill(board, i, j, k, 1)\n                backtracking(board, count+1, result)\n                fill(board, i, j, k, 0)\n\n        if m > n:\n            return self.tilingRectangle(m, n)\n        board = [[0]*m for _ in xrange(n)]\n        result = [float(\"inf\")]\n        backtracking(board, 0, result)\n        return result[0]\n"
    },
    {
        "problem_name": "time-based-key-value-store",
        "solution": "# Time:  set: O(1)\n#        get: O(logn)\n# Space: O(n)\n\nimport collections\nimport bisect\n\n\nclass TimeMap(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.lookup = collections.defaultdict(list)\n\n    def set(self, key, value, timestamp):\n        \"\"\"\n        :type key: str\n        :type value: str\n        :type timestamp: int\n        :rtype: None\n        \"\"\"\n        self.lookup[key].append((timestamp, value))\n        \n\n    def get(self, key, timestamp):\n        \"\"\"\n        :type key: str\n        :type timestamp: int\n        :rtype: str\n        \"\"\"\n        A = self.lookup.get(key, None)\n        if A is None:\n            return \"\"\n        i = bisect.bisect_right(A, (timestamp+1, 0))\n        return A[i-1][1] if i else \"\"\n\n\n# Your TimeMap object will be instantiated and called as such:\n# obj = TimeMap()\n# obj.set(key,value,timestamp)\n# param_2 = obj.get(key,timestamp)\n"
    },
    {
        "problem_name": "time-needed-to-buy-tickets",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def timeRequiredToBuy(self, tickets, k):\n        \"\"\"\n        :type tickets: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return sum(min(x, tickets[k] if i <= k else tickets[k]-1) for i, x in enumerate(tickets))\n"
    },
    {
        "problem_name": "time-needed-to-inform-all-employees",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# dfs solution with stack\nclass Solution(object):\n    def numOfMinutes(self, n, headID, manager, informTime):\n        \"\"\"\n        :type n: int\n        :type headID: int\n        :type manager: List[int]\n        :type informTime: List[int]\n        :rtype: int\n        \"\"\"\n        children = collections.defaultdict(list)\n        for child, parent in enumerate(manager):\n            if parent != -1:\n                children[parent].append(child)\n\n        result = 0\n        stk = [(headID, 0)]\n        while stk:\n            node, curr = stk.pop()\n            curr += informTime[node]\n            result = max(result, curr)\n            if node not in children:\n                continue\n            for c in children[node]:\n                stk.append((c, curr))\n        return result\n\n    \n# Time:  O(n)\n# Space: O(n)\n# dfs solution with recursion\nclass Solution2(object):\n    def numOfMinutes(self, n, headID, manager, informTime):\n        \"\"\"\n        :type n: int\n        :type headID: int\n        :type manager: List[int]\n        :type informTime: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(informTime, children, node):\n            return (max(dfs(informTime, children, c)\n                        for c in children[node])\n                    if node in children\n                    else 0) + informTime[node]\n\n        children = collections.defaultdict(list)\n        for child, parent in enumerate(manager):\n            if parent != -1:\n                children[parent].append(child)\n        return dfs(informTime, children, headID)\n"
    },
    {
        "problem_name": "time-needed-to-rearrange-a-binary-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def secondsToRemoveOccurrences(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = cnt = 0\n        for c in s: \n            if c == '0':\n                cnt += 1\n                continue\n            if cnt:\n                result = max(result+1, cnt)\n        return result \n"
    },
    {
        "problem_name": "time-taken-to-cross-the-door",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\nimport itertools\n\n\n# queue, simulation\nclass Solution(object):\n    def timeTaken(self, arrival, state):\n        \"\"\"\n        :type arrival: List[int]\n        :type state: List[int]\n        :rtype: List[int]\n        \"\"\"\n        def go_until(t):\n            while curr[0] <= t and any(q):\n                if not q[direction[0]]:\n                    direction[0] ^= 1\n                result[q[direction[0]].popleft()] = curr[0]\n                curr[0] += 1\n    \n        UNKNOWN, ENTERING, EXITING = range(-1, 1+1)\n        result = [0]*len(arrival)\n        curr, direction = [float(\"-inf\")], [UNKNOWN]\n        q = [collections.deque(), collections.deque()]\n        for i, (a, s) in enumerate(itertools.izip(arrival, state)):\n            go_until(a-1)\n            q[s].append(i)\n            if not (a <= curr[0]):\n                curr, direction = [a], [EXITING]\n        go_until(float(\"inf\"))\n        return result\n"
    },
    {
        "problem_name": "time-to-cross-a-bridge",
        "solution": "# Time:  O(k + nlogk)\n# Space: O(k)\n\nimport heapq\n\n\n# heap, simulation\nclass Solution(object):\n    def findCrossingTime(self, n, k, time):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type time: List[List[int]]\n        :rtype: int\n        \"\"\"\n        left_bridge, right_ware, right_bridge, left_ware = [(-(time[i][0]+time[i][2]), -i) for i in xrange(k)], [], [], []\n        heapq.heapify(left_bridge)\n        curr = 0\n        while n:\n            while left_ware and left_ware[0][0] <= curr:\n                _, i = heapq.heappop(left_ware)\n                heapq.heappush(left_bridge, (-(time[i][0]+time[i][2]), -i))\n            while right_ware and right_ware[0][0] <= curr:\n                _, i = heapq.heappop(right_ware)\n                heapq.heappush(right_bridge, (-(time[i][0]+time[i][2]), -i))\n            if right_bridge:\n                _, i = heapq.heappop(right_bridge)\n                i = -i\n                curr += time[i][2]\n                heapq.heappush(left_ware, (curr+time[i][3], i))\n                n -= 1\n            elif left_bridge and n-len(right_ware):\n                _, i = heapq.heappop(left_bridge)\n                i = -i\n                curr += time[i][0]\n                heapq.heappush(right_ware, (curr+time[i][1], i))\n            else:\n                curr = min(left_ware[0][0] if left_ware else float(\"inf\"),\n                           right_ware[0][0] if right_ware else float(\"inf\"))\n        return curr\n"
    },
    {
        "problem_name": "to-lower-case",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def toLowerCase(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: str\n        \"\"\"\n        return \"\".join([chr(ord('a')+ord(c)-ord('A')) \n                        if 'A' <= c <= 'Z' else c for c in str])\n\n"
    },
    {
        "problem_name": "toeplitz-matrix",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def isToeplitzMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        return all(i == 0 or j == 0 or matrix[i-1][j-1] == val\n                   for i, row in enumerate(matrix)\n                   for j, val in enumerate(row))\n\n\nclass Solution2(object):\n    def isToeplitzMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        for row_index, row in enumerate(matrix):\n            for digit_index, digit in enumerate(row):\n                if not row_index or not digit_index:\n                    continue\n                if matrix[row_index - 1][digit_index - 1] != digit:\n                    return False\n        return True\n\n"
    },
    {
        "problem_name": "top-k-frequent-elements",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        buckets = [[] for _ in xrange(len(nums)+1)]\n        for i, count in counts.iteritems():\n            buckets[count].append(i)\n\n        result = []\n        for i in reversed(xrange(len(buckets))):\n            for j in xrange(len(buckets[i])):\n                result.append(buckets[i][j])\n                if len(result) == k:\n                    return result\n        return result\n\n\n# Time:  O(n) ~ O(n^2), O(n) on average.\n# Space: O(n)\n# Quick Select Solution\nfrom random import randint\nclass Solution2(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        counts = collections.Counter(nums)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        for i in xrange(k):\n            result.append(p[i][1])\n        return result\n\n    def kthElement(self, nums, k):\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\n\n# Time:  O(nlogk)\n# Space: O(n)\nclass Solution3(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [key for key, _ in collections.Counter(nums).most_common(k)]\n\n"
    },
    {
        "problem_name": "top-k-frequent-words",
        "solution": "# Time:  O(n + klogk) on average\n# Space: O(n)\n\nimport collections\nimport heapq\nfrom random import randint\n\n\nclass Solution(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counts = collections.Counter(words)\n        p = []\n        for key, val in counts.iteritems():\n            p.append((-val, key))\n        self.kthElement(p, k-1)\n\n        result = []\n        sorted_p = sorted(p[:k])\n        for i in xrange(k):\n            result.append(sorted_p[i][1])\n        return result\n\n    def kthElement(self, nums, k):  # O(n) on average\n        def PartitionAroundPivot(left, right, pivot_idx, nums):\n            pivot_value = nums[pivot_idx]\n            new_pivot_idx = left\n            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n            for i in xrange(left, right):\n                if nums[i] < pivot_value:\n                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                    new_pivot_idx += 1\n\n            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n            return new_pivot_idx\n\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot_idx = randint(left, right)\n            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)\n            if new_pivot_idx == k:\n                return\n            elif new_pivot_idx > k:\n                right = new_pivot_idx - 1\n            else:  # new_pivot_idx < k.\n                left = new_pivot_idx + 1\n\n\n# Time:  O(nlogk)\n# Space: O(n)\n# Heap Solution\nclass Solution2(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        class MinHeapObj(object):\n            def __init__(self,val):\n                self.val = val\n            def __lt__(self,other):\n                return self.val[1] > other.val[1] if self.val[0] == other.val[0] else \\\n                       self.val < other.val\n            def __eq__(self,other):\n                return self.val == other.val\n            def __str__(self):\n                return str(self.val)\n\n        counts = collections.Counter(words)\n        min_heap = []\n        for word, count in counts.iteritems():\n            heapq.heappush(min_heap, MinHeapObj((count, word)))\n            if len(min_heap) == k+1:\n                heapq.heappop(min_heap)\n        result = []\n        while min_heap:\n            result.append(heapq.heappop(min_heap).val[1])\n        return result[::-1]\n\n\n# Time:  O(n + klogk) ~ O(n + nlogn)\n# Space: O(n)\n# Bucket Sort Solution\nclass Solution3(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counts = collections.Counter(words)\n        buckets = [[] for _ in xrange(len(words)+1)]\n        for word, count in counts.iteritems():\n            buckets[count].append(word)\n        pairs = []\n        for i in reversed(xrange(len(words))):\n            for word in buckets[i]:\n                pairs.append((-i, word))\n            if len(pairs) >= k:\n                break\n        pairs.sort()\n        return [pair[1] for pair in pairs[:k]]\n\n\n# time: O(nlogn)\n# space: O(n)\n\nfrom collections import Counter\n\n\nclass Solution4(object):\n    def topKFrequent(self, words, k):\n        \"\"\"\n        :type words: List[str]\n        :type k: int\n        :rtype: List[str]\n        \"\"\"\n        counter = Counter(words)\n        candidates = counter.keys()\n        candidates.sort(key=lambda w: (-counter[w], w))\n        return candidates[:k]\n"
    },
    {
        "problem_name": "toss-strange-coins",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def probabilityOfHeads(self, prob, target):\n        \"\"\"\n        :type prob: List[float]\n        :type target: int\n        :rtype: float\n        \"\"\"\n        dp = [0.0]*(target+1)\n        dp[0] = 1.0\n        for p in prob:\n            for i in reversed(xrange(target+1)):\n                dp[i] = (dp[i-1] if i >= 1 else 0.0)*p + dp[i]*(1-p)\n        return dp[target]\n"
    },
    {
        "problem_name": "total-appeal-of-a-string",
        "solution": "# Time:  O(n)\n# Space: O(26)\n\n# combinatorics\nclass Solution(object):\n    def appealSum(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = curr = 0\n        lookup = [-1]*26\n        for i, c in enumerate(s):\n            result += (i-lookup[ord(c)-ord('a')])*(len(s)-i)\n            lookup[ord(c)-ord('a')] = i\n        return result\n\n\n# Time:  O(n)\n# Space: O(26)\n# counting\nclass Solution2(object):\n    def appealSum(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = cnt = 0\n        lookup = [-1]*26\n        for i, c in enumerate(s):\n            cnt += i-lookup[ord(c)-ord('a')]\n            lookup[ord(c)-ord('a')] = i\n            result += cnt\n        return result\n\n"
    },
    {
        "problem_name": "total-cost-to-hire-k-workers",
        "solution": "# Time:  O(c + klogc)\n# Space: O(c)\n\nimport heapq\n\n\n# heap, two pointers\nclass Solution(object):\n    def totalCost(self, costs, k, candidates):\n        \"\"\"\n        :type costs: List[int]\n        :type k: int\n        :type candidates: int\n        :rtype: int\n        \"\"\"\n        left, right = candidates, max(len(costs)-candidates, candidates)-1\n        min_heap1, min_heap2 = costs[:left], costs[right+1:]\n        heapq.heapify(min_heap1), heapq.heapify(min_heap2)\n        result = 0\n        for _ in xrange(k):\n            if not min_heap2 or (min_heap1 and min_heap1[0] <= min_heap2[0]):\n                result += heapq.heappop(min_heap1)\n                if left <= right:\n                    heapq.heappush(min_heap1, costs[left])\n                    left += 1\n            else:\n                result += heapq.heappop(min_heap2)\n                if left <= right:\n                    heapq.heappush(min_heap2, costs[right])\n                    right -= 1\n        return result\n"
    },
    {
        "problem_name": "total-distance-traveled",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def distanceTraveled(self, mainTank, additionalTank):\n        \"\"\"\n        :type mainTank: int\n        :type additionalTank: int\n        :rtype: int\n        \"\"\"\n        USE, REFILL, DIST = 5, 1, 10\n        cnt = min((mainTank-REFILL)//(USE-REFILL), additionalTank)\n        return (mainTank+cnt*REFILL)*DIST\n"
    },
    {
        "problem_name": "total-hamming-distance",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def totalHammingDistance(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i in xrange(32):\n            counts = [0] * 2\n            for num in nums:\n                counts[(num >> i) & 1] += 1\n            result += counts[0] * counts[1]\n        return result\n\n\n"
    },
    {
        "problem_name": "traffic-light-controlled-intersection",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport threading\n\n\nclass TrafficLight(object):\n    \n    def __init__(self):\n        self.__l = threading.Lock()\n        self.__light = 1\n\n    def carArrived(self, carId, roadId, direction, turnGreen, crossCar):\n        \"\"\"\n        :type roadId: int --> // ID of the car\n        :type carId: int --> // ID of the road the car travels on. Can be 1 (road A) or 2 (road B)\n        :type direction: int --> // Direction of the car\n        :type turnGreen: method --> // Use turnGreen() to turn light to green on current road\n        :type crossCar: method --> // Use crossCar() to make car cross the intersection\n        :rtype: void\n        \"\"\"\n        with self.__l:\n            if self.__light != roadId:\n                self.__light = roadId\n                turnGreen()\n            crossCar()\n"
    },
    {
        "problem_name": "transform-to-chessboard",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2), used by Counter, this could be reduced to O(n) by skipping invalid input\n\nimport collections\nimport itertools\n\n\nclass Solution(object):\n    def movesToChessboard(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        N = len(board)\n        result = 0\n        for count in (collections.Counter(map(tuple, board)), \\\n                      collections.Counter(itertools.izip(*board))):\n            if len(count) != 2 or \\\n               sorted(count.values()) != [N/2, (N+1)/2]:\n                return -1\n\n            seq1, seq2 = count\n            if any(x == y for x, y in itertools.izip(seq1, seq2)):\n                return -1\n            begins = [int(seq1.count(1) * 2 > N)] if N%2 else [0, 1]\n            result += min(sum(int(i%2 != v) for i, v in enumerate(seq1, begin)) \\\n                          for begin in begins) / 2\n        return result\n\n"
    },
    {
        "problem_name": "transpose-matrix",
        "solution": "# Time:  O(r * c)\n# Space: O(1)\n\n\nclass Solution(object):\n    def transpose(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = [[None] * len(A) for _ in xrange(len(A[0]))]\n        for r, row in enumerate(A):\n            for c, val in enumerate(row):\n                result[c][r] = val\n        return result\n\n\n# Time:  O(r * c)\n# Space: O(1)\nclass Solution2(object):\n    def transpose(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        return zip(*A)\n\n"
    },
    {
        "problem_name": "trapping-rain-water-ii",
        "solution": "# Time:  O(m * n * log(m + n)) ~ O(m * n * log(m * n))\n# Space: O(m * n)\n\nfrom heapq import heappush, heappop\n\nclass Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(heightMap)\n        if not m:\n            return 0\n        n = len(heightMap[0])\n        if not n:\n            return 0\n\n        is_visited = [[False for i in xrange(n)] for j in xrange(m)]\n\n        heap = []\n        for i in xrange(m):\n            heappush(heap, [heightMap[i][0], i, 0])\n            is_visited[i][0] = True\n            heappush(heap, [heightMap[i][n-1], i, n-1])\n            is_visited[i][n-1] = True\n        for j in xrange(1, n-1):\n            heappush(heap, [heightMap[0][j], 0, j])\n            is_visited[0][j] = True\n            heappush(heap, [heightMap[m-1][j], m-1, j])\n            is_visited[m-1][j] = True\n\n        trap = 0\n        while heap:\n            height, i, j = heappop(heap)\n            for (dx, dy) in [(1,0), (-1,0), (0,1), (0,-1)]:\n                x, y = i+dx, j+dy\n                if 0 <= x < m and 0 <= y < n and not is_visited[x][y]:\n                    trap += max(0, height - heightMap[x][y])\n                    heappush(heap, [max(height, heightMap[x][y]), x, y])\n                    is_visited[x][y] = True\n\n        return trap\n\n"
    },
    {
        "problem_name": "trapping-rain-water",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result, left, right, level = 0, 0, len(height)-1, 0\n        while left < right:\n            if height[left] < height[right]:\n                lower = height[left]\n                left += 1\n            else:\n                lower = height[right]\n                right -= 1\n            level = max(level, lower)\n            result += level-lower\n        return result\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    # @param A, a list of integers\n    # @return an integer\n    def trap(self, A):\n        result = 0\n        top = 0\n        for i in xrange(len(A)):\n            if A[top] < A[i]:\n                top = i\n\n        second_top = 0\n        for i in xrange(top):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        second_top = len(A) - 1\n        for i in reversed(xrange(top, len(A))):\n            if A[second_top] < A[i]:\n                second_top = i\n            result += A[second_top] - A[i]\n\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution3(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        right = [0]*len(height)\n        mx = 0\n        for i in reversed(xrange(len(height))):\n            right[i] = mx\n            mx = max(mx, height[i])\n        result = left = 0\n        for i in xrange(len(height)):\n            left = max(left, height[i])\n            result += max(min(left, right[i])-height[i], 0)\n        return result\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution4(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        stk = []\n        for i in xrange(len(height)):\n            prev = 0\n            while stk and height[stk[-1]] <= height[i]:\n                j = stk.pop()\n                result += (height[j] - prev) * (i - j - 1)\n                prev = height[j]\n            if stk:\n                result += (height[i] - prev) * (i - stk[-1] - 1)\n            stk.append(i)\n        return result\n"
    },
    {
        "problem_name": "tree-diameter",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|E|)\n\nimport collections\n\n\nclass Solution(object):\n    def treeDiameter(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        graph, length = collections.defaultdict(set), 0\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n        curr_level = {(None, u) for u, neighbors in graph.iteritems() if len(neighbors) == 1}\n        while curr_level:\n            curr_level = {(u, v) for prev, u in curr_level\n                          for v in graph[u] if v != prev}\n            length += 1\n        return max(length-1, 0)\n"
    },
    {
        "problem_name": "tree-of-coprimes",
        "solution": "# Time:  O(50 * n) = O(n)\n# Space: O(n)\n\nimport collections\nimport fractions\n\n\nclass Solution(object):\n    def getCoprimes(self, nums, edges):\n        \"\"\"\n        :type nums: List[int]\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"        \n        def iter_dfs(nums, adj):\n            result = [-1]*len(nums)\n            path = collections.defaultdict(list)\n            stk = [(1, (-1, 0, 0))]\n            while stk:\n                step, params = stk.pop()\n                if step == 1:\n                    prev, node, depth = params\n                    stk.append((4, (node,)))\n                    stk.append((3, (prev, node, depth)))\n                    stk.append((2, (node,)))\n                elif step == 2:\n                    node = params[0]\n                    max_d = -1\n                    for x in path.iterkeys():\n                        if fractions.gcd(nums[node], x) != 1:\n                            continue\n                        if path[x][-1][1] > max_d:\n                            max_d = path[x][-1][1]\n                            result[node] = path[x][-1][0]\n                elif step == 3:\n                    prev, node, depth = params\n                    path[nums[node]].append((node, depth))\n                    for nei in adj[node]:\n                        if nei == prev:\n                            continue\n                        stk.append((1, (node, nei, depth+1)))\n                elif step == 4:\n                    node = params[0]\n                    path[nums[node]].pop()\n                    if not path[nums[node]]:\n                        path.pop(nums[node])\n            return result\n\n        adj = collections.defaultdict(list)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        return iter_dfs(nums, adj)\n\n\n# Time:  O(50 * n) = O(n)\n# Space: O(n)\nimport collections\nimport fractions\n\n\nclass Solution2(object):\n    def getCoprimes(self, nums, edges):\n        \"\"\"\n        :type nums: List[int]\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"        \n        def dfs(nums, adj, prev, node, depth, path, result):\n            max_d = -1\n            for x in path.iterkeys():\n                if fractions.gcd(nums[node], x) != 1:\n                    continue\n                if path[x][-1][1] > max_d:\n                    max_d = path[x][-1][1]\n                    result[node] = path[x][-1][0]\n            path[nums[node]].append((node, depth))\n            for nei in adj[node]:\n                if nei == prev:\n                    continue\n                dfs(nums, adj, node, nei, depth+1, path, result)\n            path[nums[node]].pop()\n            if not path[nums[node]]:\n                path.pop(nums[node])\n\n        adj = collections.defaultdict(list)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        result = [-1]*len(nums)\n        path = collections.defaultdict(list)\n        dfs(nums, adj, -1, 0, 0, path, result)\n        return result\n"
    },
    {
        "problem_name": "triangle",
        "solution": "from functools import reduce\n# Time:  O(m * n)\n# Space: O(n)\n\nclass Solution(object):\n    # @param triangle, a list of lists of integers\n    # @return an integer\n    def minimumTotal(self, triangle):\n        if not triangle:\n            return 0\n\n        cur = triangle[0] + [float(\"inf\")]\n        for i in xrange(1, len(triangle)):\n            next = []\n            next.append(triangle[i][0] + cur[0])\n            for j in xrange(1, i + 1):\n                next.append(triangle[i][j] + min(cur[j - 1], cur[j]))\n            cur = next + [float(\"inf\")]\n\n        return reduce(min, cur)\n\n"
    },
    {
        "problem_name": "trim-a-binary-search-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def trimBST(self, root, L, R):\n        \"\"\"\n        :type root: TreeNode\n        :type L: int\n        :type R: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n        if root.val < L:\n            return self.trimBST(root.right, L, R)\n        if root.val > R:\n            return self.trimBST(root.left, L, R)\n        root.left, root.right = self.trimBST(root.left, L, R), self.trimBST(root.right, L, R)\n        return root\n\n\n"
    },
    {
        "problem_name": "triples-with-bitwise-and-equal-to-zero",
        "solution": "# Time:  O(nlogn), n is the max of A\n# Space: O(n)\n\nimport collections\n\n\n# Reference: https://blog.csdn.net/john123741/article/details/76576925\n# FWT solution\nclass Solution(object):\n    def countTriplets(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        def FWT(A, v):\n            B = A[:]\n            d = 1\n            while d < len(B):\n                for i in xrange(0, len(B), d << 1):\n                    for j in xrange(d):\n                        B[i+j] += B[i+j+d] * v\n                d <<= 1\n            return B\n\n        k = 3\n        n, max_A = 1, max(A)\n        while n <= max_A:\n            n *= 2\n        count = collections.Counter(A)\n        B = [count[i] for i in xrange(n)]\n        C = FWT(map(lambda x : x**k, FWT(B, 1)), -1)\n        return C[0]\n\n\n# Time:  O(n^3), n is the length of A\n# Space: O(n^2)\nimport collections\n\n\nclass Solution2(object):\n    def countTriplets(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        count = collections.defaultdict(int)\n        for i in xrange(len(A)):\n            for j in xrange(len(A)):\n                count[A[i]&A[j]] += 1\n        result = 0\n        for k in xrange(len(A)):\n            for v in count:\n                if A[k]&v == 0:\n                    result += count[v]\n        return result\n"
    },
    {
        "problem_name": "truncate-sentence",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def truncateSentence(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        for i in xrange(len(s)):\n            if s[i] == ' ':\n                k -= 1\n                if not k:\n                    return s[:i]\n        return s\n"
    },
    {
        "problem_name": "tuple-with-same-product",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nimport collections\n\n\nclass Solution(object):\n    def tupleSameProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        count = collections.Counter()\n        for i in xrange(len(nums)):\n            for j in xrange(i+1, len(nums)): \n                result += count[nums[i]*nums[j]]\n                count[nums[i]*nums[j]] += 1\n        return 8*result\n"
    },
    {
        "problem_name": "tweet-counts-per-frequency",
        "solution": "# Time:  add:   O(logn),\n#        query: O(c), c is the total count of matching records\n# Space: O(n)\n\nimport collections\nimport random\n\n\n# Template:\n# https://github.com/kamyu104/LeetCode-Solutions/blob/master/Python/design-skiplist.py\nclass SkipNode(object):\n    def __init__(self, level=0, val=None):\n        self.val = val\n        self.nexts = [None]*level\n        self.prevs = [None]*level\n\nclass SkipList(object):\n    P_NUMERATOR, P_DENOMINATOR = 1, 2  # P = 1/4 in redis implementation\n    MAX_LEVEL = 32  # enough for 2^32 elements\n\n    def __init__(self, end=float(\"inf\"), can_duplicated=False):\n        random.seed(0)\n        self.__head = SkipNode()\n        self.__len = 0\n        self.__can_duplicated = can_duplicated\n        self.add(end)\n    \n    def lower_bound(self, target):\n        return self.__lower_bound(target, self.__find_prev_nodes(target))\n\n    def find(self, target):\n        return self.__find(target, self.__find_prev_nodes(target))\n        \n    def add(self, val):\n        if not self.__can_duplicated and self.find(val):\n            return False\n        node = SkipNode(self.__random_level(), val)\n        if len(self.__head.nexts) < len(node.nexts): \n            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))\n        prevs = self.__find_prev_nodes(val)\n        for i in xrange(len(node.nexts)):\n            node.nexts[i] = prevs[i].nexts[i]\n            if prevs[i].nexts[i]:\n                prevs[i].nexts[i].prevs[i] = node\n            prevs[i].nexts[i] = node\n            node.prevs[i] = prevs[i]\n        self.__len += 1\n        return True\n\n    def remove(self, val):\n        prevs = self.__find_prev_nodes(val)\n        curr = self.__find(val, prevs)\n        if not curr:\n            return False\n        self.__len -= 1   \n        for i in reversed(xrange(len(curr.nexts))):\n            prevs[i].nexts[i] = curr.nexts[i]\n            if curr.nexts[i]:\n                curr.nexts[i].prevs[i] = prevs[i]\n            if not self.__head.nexts[i]:\n                self.__head.nexts.pop()\n        return True\n    \n    def __lower_bound(self, val, prevs):\n        if prevs:\n            candidate = prevs[0].nexts[0]\n            if candidate:\n                return candidate\n        return None\n\n    def __find(self, val, prevs):\n        candidate = self.__lower_bound(val, prevs)\n        if candidate and candidate.val == val:\n            return candidate\n        return None\n\n    def __find_prev_nodes(self, val):\n        prevs = [None]*len(self.__head.nexts)\n        curr = self.__head\n        for i in reversed(xrange(len(self.__head.nexts))):\n            while curr.nexts[i] and curr.nexts[i].val < val:\n                curr = curr.nexts[i]\n            prevs[i] = curr\n        return prevs\n\n    def __random_level(self):\n        level = 1\n        while random.randint(1, SkipList.P_DENOMINATOR) <= SkipList.P_NUMERATOR and \\\n              level < SkipList.MAX_LEVEL:\n            level += 1\n        return level\n\n    def __len__(self):\n        return self.__len-1  # excluding end node\n    \n    def __str__(self):\n        result = []\n        for i in reversed(xrange(len(self.__head.nexts))):\n            result.append([])\n            curr = self.__head.nexts[i]\n            while curr:\n                result[-1].append(str(curr.val))\n                curr = curr.nexts[i]\n        return \"\\n\".join(map(lambda x: \"->\".join(x), result))\n\n    \nclass TweetCounts(object):\n\n    def __init__(self):\n        self.__records = collections.defaultdict(lambda: SkipList(can_duplicated=True))\n        self.__lookup = {\"minute\":60, \"hour\":3600, \"day\":86400}\n\n    def recordTweet(self, tweetName, time):\n        \"\"\"\n        :type tweetName: str\n        :type time: int\n        :rtype: None\n        \"\"\"\n        self.__records[tweetName].add(time)\n\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n        \"\"\"\n        :type freq: str\n        :type tweetName: str\n        :type startTime: int\n        :type endTime: int\n        :rtype: List[int]\n        \"\"\"\n        delta = self.__lookup[freq]\n        result = [0]*((endTime-startTime)//delta+1)\n        it = self.__records[tweetName].lower_bound(startTime)\n        while it is not None and it.val <= endTime:\n            result[(it.val-startTime)//delta] += 1\n            it = it.nexts[0]\n        return result\n\n\n# Time:  add:   O(n),\n#        query: O(rlogn), r is the size of result\n# Space: O(n)\nimport bisect\nclass TweetCounts2(object):\n\n    def __init__(self):\n        self.__records = collections.defaultdict(list)\n        self.__lookup = {\"minute\":60, \"hour\":3600, \"day\":86400}\n\n    def recordTweet(self, tweetName, time):\n        \"\"\"\n        :type tweetName: str\n        :type time: int\n        :rtype: None\n        \"\"\"\n        bisect.insort(self.__records[tweetName], time)\n\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n        \"\"\"\n        :type freq: str\n        :type tweetName: str\n        :type startTime: int\n        :type endTime: int\n        :rtype: List[int]\n        \"\"\"\n        delta = self.__lookup[freq]\n        i = startTime\n        result = []\n        while i <= endTime:\n            j = min(i+delta, endTime+1)\n            result.append(bisect.bisect_left(self.__records[tweetName], j) - \\\n                          bisect.bisect_left(self.__records[tweetName], i))\n            i += delta\n        return result\n\n    \n# Time:  add:   O(1),\n#        query: O(n)\n# Space: O(n)\nclass TweetCounts3(object):\n\n    def __init__(self):\n        self.__records = collections.defaultdict(list)\n        self.__lookup = {\"minute\":60, \"hour\":3600, \"day\":86400}\n\n    def recordTweet(self, tweetName, time):\n        \"\"\"\n        :type tweetName: str\n        :type time: int\n        :rtype: None\n        \"\"\"\n        self.__records[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n        \"\"\"\n        :type freq: str\n        :type tweetName: str\n        :type startTime: int\n        :type endTime: int\n        :rtype: List[int]\n        \"\"\"\n        delta = self.__lookup[freq]\n        result = [0]*((endTime- startTime)//delta+1)\n        for t in self.__records[tweetName]:\n            if startTime <= t <= endTime:\n                result[(t-startTime)//delta] += 1\n        return result\n"
    },
    {
        "problem_name": "two-best-non-overlapping-events",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport heapq\n\n\nclass Solution(object):\n    def maxTwoEvents(self, events):\n        \"\"\"\n        :type events: List[List[int]]\n        :rtype: int\n        \"\"\"\n        events.sort()\n        result = best = 0\n        min_heap = []\n        for left, right, v in events:\n            heapq.heappush(min_heap, (right, v))\n            while min_heap and min_heap[0][0] < left:\n                best = max(best, heapq.heappop(min_heap)[1])\n            result = max(result, best+v)\n        return result\n"
    },
    {
        "problem_name": "two-city-scheduling",
        "solution": "# Time:  O(n) ~ O(n^2), O(n) on average.\n# Space: O(1)\n\nimport random\n\n\n# quick select solution\nclass Solution(object):\n    def twoCitySchedCost(self, costs):\n        \"\"\"\n        :type costs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def kthElement(nums, k, compare):\n            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):\n                new_pivot_idx = left\n                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n                for i in xrange(left, right):\n                    if compare(nums[i], nums[right]):\n                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]\n                        new_pivot_idx += 1\n\n                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]\n                return new_pivot_idx\n\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                pivot_idx = random.randint(left, right)\n                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)\n                if new_pivot_idx == k:\n                    return\n                elif new_pivot_idx > k:\n                    right = new_pivot_idx - 1\n                else:  # new_pivot_idx < k.\n                    left = new_pivot_idx + 1\n                    \n        kthElement(costs, len(costs)//2, lambda a, b: a[0]-a[1] < b[0]-b[1])\n        result = 0\n        for i in xrange(len(costs)):\n            result += costs[i][0] if i < len(costs)//2 else costs[i][1]\n        return result\n"
    },
    {
        "problem_name": "two-furthest-houses-with-different-colors",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def maxDistance(self, colors):\n        \"\"\"\n        :type colors: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for i, x in enumerate(colors):\n            if x != colors[0]:\n                result = max(result, i)\n            if x != colors[-1]:\n                result = max(result, len(colors)-1-i)\n        return result\n\n"
    },
    {
        "problem_name": "two-out-of-three",
        "solution": "# Time:  O(n)\n# Space: O(min(n, r)), r is the range size of nums\n\nimport collections\n\n\nclass Solution(object):\n    def twoOutOfThree(self, nums1, nums2, nums3):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :rtype: List[int]\n        \"\"\"\n        K = 2\n        cnt = collections.Counter()\n        for nums in nums1, nums2, nums3:\n            cnt.update(set(nums))\n        return [x for x, c in cnt.iteritems() if c >= K]\n\n\n# Time:  O(n)\n# Space: O(min(n, r)), r is the range size of nums\nimport collections\n\n\nclass Solution2(object):\n    def twoOutOfThree(self, nums1, nums2, nums3):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :rtype: List[int]\n        \"\"\"\n        K = 2\n        cnt = collections.Counter()\n        result = []\n        for nums in nums1, nums2, nums3:\n            for x in set(nums):\n                cnt[x] += 1\n                if cnt[x] == K:\n                    result.append(x)\n        return result\n"
    },
    {
        "problem_name": "two-sum-bsts",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def twoSumBSTs(self, root1, root2, target):\n        \"\"\"\n        :type root1: TreeNode\n        :type root2: TreeNode\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        def inorder_gen(root, asc=True):\n            result, stack = [], [(root, False)]\n            while stack:\n                root, is_visited = stack.pop()\n                if root is None:\n                    continue\n                if is_visited:\n                    yield root.val\n                else:\n                    if asc:\n                        stack.append((root.right, False))\n                        stack.append((root, True))\n                        stack.append((root.left, False))\n                    else:\n                        stack.append((root.left, False))\n                        stack.append((root, True))\n                        stack.append((root.right, False))\n        \n        left_gen, right_gen = inorder_gen(root1, True), inorder_gen(root2, False)\n        left, right = next(left_gen), next(right_gen)\n        while left is not None and right is not None:\n            if left + right < target:\n                left = next(left_gen)\n            elif left + right > target:\n                right = next(right_gen)\n            else:\n                return True\n        return False\n"
    },
    {
        "problem_name": "two-sum-ii-input-array-is-sorted",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def twoSum(self, nums, target):\n        start, end = 0, len(nums) - 1\n\n        while start != end:\n            sum = nums[start] + nums[end]\n            if sum > target:\n                end -= 1\n            elif sum < target:\n                start += 1\n            else:\n                return [start + 1, end + 1]\n\n"
    },
    {
        "problem_name": "two-sum-iii-data-structure-design",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nfrom collections import defaultdict\n\nclass TwoSum(object):\n\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here\n        \"\"\"\n        self.lookup = defaultdict(int)\n\n\n\n    def add(self, number):\n        \"\"\"\n        Add the number to an internal data structure.\n        :rtype: nothing\n        \"\"\"\n        self.lookup[number] += 1\n\n\n    def find(self, value):\n        \"\"\"\n        Find if there exists any pair of numbers which sum is equal to the value.\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        for key in self.lookup:\n            num = value - key\n            if num in self.lookup and (num != key or self.lookup[key] > 1):\n                return True\n        return False\n\n\n"
    },
    {
        "problem_name": "two-sum-iv-input-is-a-bst",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\nclass Solution(object):\n    def findTarget(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        class BSTIterator(object):\n            def __init__(self, root, forward):\n                self.__node = root\n                self.__forward = forward\n                self.__s = []\n                self.__cur = None\n                self.next()\n\n            def val(self):\n                return self.__cur\n\n            def next(self):\n                while self.__node or self.__s:\n                    if self.__node:\n                        self.__s.append(self.__node)\n                        self.__node = self.__node.left if self.__forward else self.__node.right\n                    else:\n                        self.__node = self.__s.pop()\n                        self.__cur = self.__node.val\n                        self.__node = self.__node.right if self.__forward else self.__node.left\n                        break\n\n\n        if not root:\n            return False\n        left, right = BSTIterator(root, True), BSTIterator(root, False)\n        while left.val() < right.val():\n            if left.val() + right.val() == k:\n                return True\n            elif left.val() + right.val() < k:\n                left.next()\n            else:\n                right.next()\n        return False\n\n"
    },
    {
        "problem_name": "two-sum-less-than-k",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def twoSumLessThanK(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: int\n        \"\"\"\n        A.sort()\n        result = -1\n        left, right = 0, len(A)-1\n        while left < right:\n            if A[left]+A[right] >= K:\n                right -= 1\n            else:\n                result = max(result, A[left]+A[right])\n                left += 1\n        return result\n"
    },
    {
        "problem_name": "two-sum",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        lookup = {}\n        for i, num in enumerate(nums):\n            if target - num in lookup:\n                return [lookup[target - num], i]\n            lookup[num] = i\n\n    def twoSum2(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in nums:\n            j = target - i\n            tmp_nums_start_index = nums.index(i) + 1\n            tmp_nums = nums[tmp_nums_start_index:]\n            if j in tmp_nums:\n                return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]\n\n\n"
    },
    {
        "problem_name": "type-of-triangle-ii",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\n# math\nclass Solution(object):\n    def triangleType(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: str\n        \"\"\"\n        nums.sort()\n        a, b, c = nums\n        if a+b <= c:\n            return \"none\"\n        if a == b == c:\n            return \"equilateral\"\n        if a == b or b == c:\n            return \"isosceles\"\n        return \"scalene\"\n"
    },
    {
        "problem_name": "ugly-number-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport heapq\n\nclass Solution(object):\n    # @param {integer} n\n    # @return {integer}\n    def nthUglyNumber(self, n):\n        ugly_number = 0\n\n        heap = []\n        heapq.heappush(heap, 1)\n        for _ in xrange(n):\n            ugly_number = heapq.heappop(heap)\n            if ugly_number % 2 == 0:\n                heapq.heappush(heap, ugly_number * 2)\n            elif ugly_number % 3 == 0:\n                heapq.heappush(heap, ugly_number * 2)\n                heapq.heappush(heap, ugly_number * 3)\n            else:\n                heapq.heappush(heap, ugly_number * 2)\n                heapq.heappush(heap, ugly_number * 3)\n                heapq.heappush(heap, ugly_number * 5)\n\n        return ugly_number\n\n    def nthUglyNumber2(self, n):\n        ugly = [1]\n        i2 = i3 = i5 = 0\n        while len(ugly) < n:\n            while ugly[i2] * 2 <= ugly[-1]: i2 += 1\n            while ugly[i3] * 3 <= ugly[-1]: i3 += 1\n            while ugly[i5] * 5 <= ugly[-1]: i5 += 1\n            ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))\n        return ugly[-1]\n\n    def nthUglyNumber3(self, n):\n        q2, q3, q5 = [2], [3], [5]\n        ugly = 1\n        for u in heapq.merge(q2, q3, q5):\n            if n == 1:\n                return ugly\n            if u > ugly:\n                ugly = u\n                n -= 1\n                q2 += 2 * u,\n                q3 += 3 * u,\n                q5 += 5 * u,\n\n\nclass Solution2(object):\n    ugly = sorted(2**a * 3**b * 5**c\n                  for a in range(32) for b in range(20) for c in range(14))\n\n    def nthUglyNumber(self, n):\n        return self.ugly[n-1]\n\n"
    },
    {
        "problem_name": "ugly-number-iii",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def nthUglyNumber(self, n, a, b, c):\n        \"\"\"\n        :type n: int\n        :type a: int\n        :type b: int\n        :type c: int\n        :rtype: int\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        def lcm(x, y):\n            return x//gcd(x, y)*y\n\n        def count(x, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c):\n            return x//a + x//b + x//c - (x//lcm_a_b + x//lcm_b_c + x//lcm_c_a) + x//lcm_a_b_c\n\n        lcm_a_b, lcm_b_c, lcm_c_a = lcm(a, b), lcm(b, c), lcm(c, a)\n        lcm_a_b_c = lcm(lcm_a_b, lcm_b_c)\n\n        left, right = 1, 2*10**9\n        while left <= right:\n            mid = left + (right-left)//2\n            if count(mid, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c) >= n:\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n"
    },
    {
        "problem_name": "ugly-number",
        "solution": "# Time:  O(logn) = O(1)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {integer} num\n    # @return {boolean}\n    def isUgly(self, num):\n        if num == 0:\n            return False\n        for i in [2, 3, 5]:\n            while num % i == 0:\n                num /= i\n        return num == 1\n\n"
    },
    {
        "problem_name": "uncommon-words-from-two-sentences",
        "solution": "# Time:  O(m + n)\n# Space: O(m + n)\n\nimport collections\n\n    \nclass Solution(object):\n    def uncommonFromSentences(self, A, B):\n        \"\"\"\n        :type A: str\n        :type B: str\n        :rtype: List[str]\n        \"\"\"\n        count = collections.Counter(A.split())\n        count += collections.Counter(B.split())\n        return [word for word in count if count[word] == 1]\n\n"
    },
    {
        "problem_name": "uncrossed-lines",
        "solution": "# Time:  O(m * n)\n# Space: O(min(m, n))\n\nclass Solution(object):\n    def maxUncrossedLines(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: List[int]\n        :rtype: int\n        \"\"\"\n        if len(A) < len(B):\n            return self.maxUncrossedLines(B, A)\n\n        dp = [[0 for _ in xrange(len(B)+1)] for _ in xrange(2)]\n        for i in xrange(len(A)):\n            for j in xrange(len(B)):\n                dp[(i+1)%2][j+1] = max(dp[i%2][j] + int(A[i] == B[j]),\n                                       dp[i%2][j+1],\n                                       dp[(i+1)%2][j])\n        return dp[len(A)%2][len(B)]\n"
    },
    {
        "problem_name": "unique-binary-search-trees-ii",
        "solution": "# Time:  O(4^n / n^(3/2)) ~= Catalan numbers\n# Space: O(4^n / n^(3/2)) ~= Catalan numbers\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        if self:\n            serial = []\n            queue = [self]\n\n            while queue:\n                cur = queue[0]\n\n                if cur:\n                    serial.append(cur.val)\n                    queue.append(cur.left)\n                    queue.append(cur.right)\n                else:\n                    serial.append(\"#\")\n\n                queue = queue[1:]\n\n            while serial[-1] == \"#\":\n                serial.pop()\n\n            return repr(serial)\n\n        else:\n            return None\n\nclass Solution(object):\n    # @return a list of tree node\n    def generateTrees(self, n):\n        return self.generateTreesRecu(1, n)\n\n    def generateTreesRecu(self, low, high):\n        result = []\n        if low > high:\n            result.append(None)\n        for i in xrange(low, high + 1):\n            left = self.generateTreesRecu(low, i - 1)\n            right = self.generateTreesRecu(i + 1, high)\n            for j in left:\n                for k in right:\n                    cur = TreeNode(i)\n                    cur.left = j\n                    cur.right = k\n                    result.append(cur)\n        return result\n\n"
    },
    {
        "problem_name": "unique-binary-search-trees",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 1\n\n        def combination(n, k):\n            count = 1\n            # C(n, k) = (n) / 1 * (n - 1) / 2 ... * (n - k + 1) / k\n            for i in xrange(1, k + 1):\n                count = count * (n - i + 1) / i\n            return count\n\n        return combination(2 * n, n) - combination(2 * n, n - 1)\n\n# Time:  O(n^2)\n# Space: O(n)\n# DP solution.\nclass Solution2(object):\n    # @return an integer\n    def numTrees(self, n):\n        counts = [1, 1]\n        for i in xrange(2, n + 1):\n            count = 0\n            for j in xrange(i):\n                count += counts[j] * counts[i - j - 1]\n            counts.append(count)\n        return counts[-1]\n\n"
    },
    {
        "problem_name": "unique-email-addresses",
        "solution": "# Time:  O(n * l)\n# Space: O(n * l)\n\nclass Solution(object):\n    def numUniqueEmails(self, emails):\n        \"\"\"\n        :type emails: List[str]\n        :rtype: int\n        \"\"\"\n        def convert(email):\n            name, domain = email.split('@')\n            name = name[:name.index('+')]\n            return \"\".join([\"\".join(name.split(\".\")), '@', domain])\n\n        lookup = set()\n        for email in emails:\n            lookup.add(convert(email))\n        return len(lookup)\n  \n"
    },
    {
        "problem_name": "unique-length-3-palindromic-subsequences",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countPalindromicSubsequence(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        first, last = [len(s)]*26, [-1]*26\n        for i, c in enumerate(s):\n            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)\n            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)\n        return sum(len(set(s[i] for i in xrange(first[c]+1, last[c]))) for c in xrange(26))\n"
    },
    {
        "problem_name": "unique-morse-code-words",
        "solution": "# Time:  O(n), n is the sume of all word lengths\n# Space: O(n)\n\nclass Solution(object):\n    def uniqueMorseRepresentations(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        MORSE = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\",\n                 \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\",\n                 \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\n                 \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\n\n        lookup = {\"\".join(MORSE[ord(c) - ord('a')] for c in word) \\\n                  for word in words}\n        return len(lookup)\n\n"
    },
    {
        "problem_name": "unique-number-of-occurrences",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def uniqueOccurrences(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        count = collections.Counter(arr)\n        lookup = set()\n        for v in count.itervalues():\n            if v in lookup:\n                return False\n            lookup.add(v)\n        return True\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def uniqueOccurrences(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        count = collections.Counter(arr)\n        return len(count) == len(set(count.itervalues()))\n"
    },
    {
        "problem_name": "unique-paths-ii",
        "solution": "# Time:  O(m * n)\n# Space: O(m + n)\n\nclass Solution(object):\n    # @param obstacleGrid, a list of lists of integers\n    # @return an integer\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n\n        ways = [0]*n\n        ways[0] = 1\n        for i in xrange(m):\n            if obstacleGrid[i][0] == 1:\n                ways[0] = 0\n            for j in xrange(n):\n                if obstacleGrid[i][j] == 1:\n                    ways[j] = 0\n                elif j>0:\n                    ways[j] += ways[j-1]\n        return ways[-1]\n\n"
    },
    {
        "problem_name": "unique-paths-iii",
        "solution": "# Time:  O(m * n * 2^(m * n))\n# Space: O(m * n * 2^(m * n))\n\nclass Solution(object):\n    def uniquePathsIII(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        def index(grid, r, c):\n            return 1 << (r*len(grid[0])+c)\n\n        def dp(grid, src, dst, todo, lookup):\n            if src == dst:\n                return int(todo == 0)\n            key = (src, todo)\n            if key in lookup:\n                return lookup[key]\n\n            result = 0\n            for d in directions:\n                r, c = src[0]+d[0], src[1]+d[1]\n                if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and \\\n                   grid[r][c] % 2 == 0 and \\\n                   todo & index(grid, r, c):\n                    result += dp(grid, (r, c), dst, todo ^ index(grid, r, c), lookup)\n\n            lookup[key] = result\n            return lookup[key]\n\n        todo = 0\n        src, dst = None, None\n        for r, row in enumerate(grid):\n            for c, val in enumerate(row):\n                if val % 2 == 0:\n                    todo |= index(grid, r, c)\n                if val == 1:\n                    src = (r, c)\n                elif val == 2:\n                    dst = (r, c)\n        return dp(grid, src, dst, todo, {})\n"
    },
    {
        "problem_name": "unique-paths",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nclass Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def nCr(n, r):  # Time: O(n), Space: O(1)\n            if n-r < r:\n                r = n-r\n            c = 1\n            for k in xrange(1, r+1):\n                c *= n-k+1\n                c //= k\n            return c\n\n        return nCr((m-1)+(n-1), n-1)\n\n\n# Time:  O(m * n)\n# Space: O(min(m, n))\nclass Solution2(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if m < n:\n            m, n  = n, m\n\n        dp = [1]*n\n        for i in xrange(1, m):\n            for j in xrange(1, n):\n                dp[j] += dp[j-1]\n        return dp[n-1]\n"
    },
    {
        "problem_name": "unique-substrings-in-wraparound-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def findSubstringInWraproundString(self, p):\n        \"\"\"\n        :type p: str\n        :rtype: int\n        \"\"\"\n        letters = [0] * 26\n        result, length = 0, 0\n        for i in xrange(len(p)):\n            curr = ord(p[i]) - ord('a')\n            if i > 0 and ord(p[i-1]) != (curr-1)%26 + ord('a'):\n                length = 0\n            length += 1\n            if length > letters[curr]:\n                result += length - letters[curr]\n                letters[curr] = length\n        return result\n\n"
    },
    {
        "problem_name": "unique-substrings-with-equal-digit-frequency",
        "solution": "# Time:  O(n^2)\n# Space: O(n^2)\n\nimport collections\n\n\n# rolling hash\nclass Solution(object):\n    def equalDigitFrequency(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        D = 27\n        lookup = set()\n        for i in xrange(len(s)):\n            cnt = collections.Counter()\n            h = max_cnt = 0\n            for j in xrange(i, len(s)):\n                d = ord(s[j])-ord('0')+1\n                h = (h*D+d)%MOD\n                cnt[d] += 1\n                max_cnt = max(max_cnt, cnt[d])\n                if len(cnt)*max_cnt == j-i+1:\n                    lookup.add(h)\n        return len(lookup)\n"
    },
    {
        "problem_name": "unique-word-abbreviation",
        "solution": "# Time:  ctor:   O(n), n is number of words in the dictionary.\n#        lookup: O(1)\n# Space: O(k), k is number of unique words.\n\nimport collections\n\n\nclass ValidWordAbbr(object):\n    def __init__(self, dictionary):\n        \"\"\"\n        initialize your data structure here.\n        :type dictionary: List[str]\n        \"\"\"\n        self.lookup_ = collections.defaultdict(set)\n        for word in dictionary:\n            abbr = self.abbreviation(word)\n            self.lookup_[abbr].add(word)\n\n\n    def isUnique(self, word):\n        \"\"\"\n        check if a word is unique.\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        abbr = self.abbreviation(word)\n        return self.lookup_[abbr] <= {word}\n\n\n    def abbreviation(self, word):\n        if len(word) <= 2:\n            return word\n        return word[0] + str(len(word)-2) + word[-1]\n\n\n\n"
    },
    {
        "problem_name": "univalued-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(h)\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def isUnivalTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        s = [root]\n        while s:\n            node = s.pop()\n            if not node:\n                continue\n            if node.val != root.val:\n                return False\n            s.append(node.left)\n            s.append(node.right)\n        return True\n    \n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    def isUnivalTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        return (not root.left or (root.left.val == root.val and self.isUnivalTree(root.left))) and \\\n               (not root.right or (root.right.val == root.val and self.isUnivalTree(root.right)))\n"
    },
    {
        "problem_name": "using-a-robot-to-print-the-lexicographically-smallest-string",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport collections\n\n\n# freq table, greedy\nclass Solution(object):\n    def robotWithString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        cnt = collections.Counter(s)\n        result, stk = [], []\n        mn = 'a'\n        for c in s:\n            stk.append(c)\n            cnt[c] -= 1\n            while mn < 'z' and cnt[mn] == 0:\n                mn = chr(ord(mn)+1)\n            while stk and stk[-1] <= mn:\n                result.append(stk.pop())\n        return \"\".join(result) \n"
    },
    {
        "problem_name": "utf-8-validation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def validUtf8(self, data):\n        \"\"\"\n        :type data: List[int]\n        :rtype: bool\n        \"\"\"\n        count = 0\n        for c in data:\n            if count == 0:\n                if (c >> 5) == 0b110:\n                    count = 1\n                elif (c >> 4) == 0b1110:\n                    count = 2\n                elif (c >> 3) == 0b11110:\n                    count = 3\n                elif (c >> 7):\n                    return False\n            else:\n                if (c >> 6) != 0b10:\n                    return False\n                count -= 1\n        return count == 0\n\n"
    },
    {
        "problem_name": "valid-anagram",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n        count = collections.defaultdict(int)\n        for c in s:\n            count[c] += 1\n        for c in t:\n            count[c] -= 1\n            if count[c] < 0:\n                return False\n        return True\n\n\n# Time:  O(n)\n# Space: O(1)\nclass Solution2(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        return collections.Counter(s) == collections.Counter(t)\n\n\n# Time:  O(nlogn)\n# Space: O(n)\nclass Solution3(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        return sorted(s) == sorted(t)\n\n"
    },
    {
        "problem_name": "valid-arrangement-of-pairs",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|V| + |E|)\n\nimport collections\n\n\n# Hierholzer Algorithm\nclass Solution(object):\n    def validArrangement(self, pairs):\n        \"\"\"\n        :type pairs: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        adj = collections.defaultdict(list)\n        degree = collections.defaultdict(int)\n        for u, v in pairs: \n            adj[u].append(v)\n            degree[u] += 1\n            degree[v] -= 1       \n        result = []\n        stk = [next((u for u, c in degree.iteritems() if c == 1), next(degree.iterkeys()))]\n        while stk:\n            while adj[stk[-1]]: \n                stk.append(adj[stk[-1]].pop())\n            result.append(stk.pop())\n        result.reverse()\n        return [[result[i], result[i+1]] for i in xrange(len(result)-1)]\n"
    },
    {
        "problem_name": "valid-boomerang",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def isBoomerang(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        return (points[0][0] - points[1][0]) * (points[0][1] - points[2][1]) - \\\n               (points[0][0] - points[2][0]) * (points[0][1] - points[1][1]) != 0\n"
    },
    {
        "problem_name": "valid-mountain-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def validMountainArray(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: bool\n        \"\"\"\n        i = 0\n        while i+1 < len(A) and A[i] < A[i+1]:\n            i += 1\n        j = len(A)-1\n        while j-1 >= 0 and A[j-1] > A[j]:\n            j -= 1\n        return 0 < i == j < len(A)-1\n"
    },
    {
        "problem_name": "valid-number",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass InputType(object):\n    INVALID    = 0\n    SPACE      = 1\n    SIGN       = 2\n    DIGIT      = 3\n    DOT        = 4\n    EXPONENT   = 5\n\n\n# regular expression: \"^\\s*[\\+-]?((\\d+(\\.\\d*)?)|\\.\\d+)([eE][\\+-]?\\d+)?\\s*$\"\n# automata: http://images.cnitblog.com/i/627993/201405/012016243309923.png\nclass Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        transition_table = [[-1,  0,  3,  1,  2, -1],     # next states for state 0\n                            [-1,  8, -1,  1,  4,  5],     # next states for state 1\n                            [-1, -1, -1,  4, -1, -1],     # next states for state 2\n                            [-1, -1, -1,  1,  2, -1],     # next states for state 3\n                            [-1,  8, -1,  4, -1,  5],     # next states for state 4\n                            [-1, -1,  6,  7, -1, -1],     # next states for state 5\n                            [-1, -1, -1,  7, -1, -1],     # next states for state 6\n                            [-1,  8, -1,  7, -1, -1],     # next states for state 7\n                            [-1,  8, -1, -1, -1, -1]]     # next states for state 8\n\n        state = 0\n        for char in s:\n            inputType = InputType.INVALID\n            if char.isspace():\n                inputType = InputType.SPACE\n            elif char == '+' or char == '-':\n                inputType = InputType.SIGN\n            elif char.isdigit():\n                inputType = InputType.DIGIT\n            elif char == '.':\n                inputType = InputType.DOT\n            elif char == 'e' or char == 'E':\n                inputType = InputType.EXPONENT\n\n            state = transition_table[state][inputType]\n\n            if state == -1:\n                return False\n\n        return state == 1 or state == 4 or state == 7 or state == 8\n\n\nclass Solution2(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        import re\n        return bool(re.match(\"^\\s*[\\+-]?((\\d+(\\.\\d*)?)|\\.\\d+)([eE][\\+-]?\\d+)?\\s*$\", s))\n\n\n"
    },
    {
        "problem_name": "valid-palindrome-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def validPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        def validPalindrome(s, left, right):\n            while left < right:\n                if s[left] != s[right]:\n                    return False\n                left, right = left+1, right-1\n            return True\n\n        left, right = 0, len(s)-1\n        while left < right:\n            if s[left] != s[right]:\n                return validPalindrome(s, left, right-1) or validPalindrome(s, left+1, right)\n            left, right = left+1, right-1\n        return True\n\n"
    },
    {
        "problem_name": "valid-palindrome-iii",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def isValidPalindrome(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        if s == s[::-1]:  # optional, to optimize special case\n            return True\n\n        dp = [[1] * len(s) for _ in xrange(2)]\n        for i in reversed(xrange(len(s))):\n            for j in xrange(i+1, len(s)):\n                if s[i] == s[j]:\n                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2\n                else:\n                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])\n        return len(s) <= k + dp[0][-1]\n"
    },
    {
        "problem_name": "valid-palindrome-iv",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string, two pointers\nclass Solution(object):\n    def makePalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return sum(s[i] != s[~i] for i in xrange(len(s)//2)) <= 2\n\n\n# Time:  O(n)\n# Space: O(1)\n# string, two pointers\nclass Solution2(object):\n    def makePalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        cnt = 0\n        left, right = 0, len(s)-1\n        while left < right:\n            if s[left] != s[right]:\n                cnt += 1\n                if cnt > 2:\n                    return False\n            left += 1\n            right -= 1\n        return True\n"
    },
    {
        "problem_name": "valid-palindrome",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param s, a string\n    # @return a boolean\n    def isPalindrome(self, s):\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and not s[i].isalnum():\n                i += 1\n            while i < j and not s[j].isalnum():\n                j -= 1\n            if s[i].lower() != s[j].lower():\n                return False\n            i, j = i + 1, j - 1\n        return True\n\n"
    },
    {
        "problem_name": "valid-parentheses",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    # @return a boolean\n    def isValid(self, s):\n        stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        for parenthese in s:\n            if parenthese in lookup:\n                stack.append(parenthese)\n            elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                return False\n        return len(stack) == 0\n\n"
    },
    {
        "problem_name": "valid-parenthesis-string",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def checkValidString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        lower, upper = 0, 0  # keep lower bound and upper bound of '(' counts\n        for c in s:\n            lower += 1 if c == '(' else -1\n            upper -= 1 if c == ')' else -1\n            if upper < 0: break\n            lower = max(lower, 0)\n        return lower == 0  # range of '(' count is valid\n\n"
    },
    {
        "problem_name": "valid-perfect-square",
        "solution": "# Time:  O(logn)\n# Space: O(1)\n\nclass Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        left, right = 1, num\n        while left <= right:\n            mid = left + (right - left) / 2\n            if mid >= num / mid:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left == num / left and num % left == 0\n\n"
    },
    {
        "problem_name": "valid-permutations-for-di-sequence",
        "solution": "# Time:  O(n^2)\n# Space: O(n)\n\nclass Solution(object):\n    def numPermsDISequence(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: int\n        \"\"\"\n        dp = [1]*(len(S)+1)\n        for c in S:\n            if c == \"I\":\n                dp = dp[:-1]\n                for i in xrange(1, len(dp)):\n                    dp[i] += dp[i-1]\n            else:\n                dp = dp[1:]\n                for i in reversed(xrange(len(dp)-1)):\n                    dp[i] += dp[i+1]\n        return dp[0] % (10**9+7)\n\n"
    },
    {
        "problem_name": "valid-square",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def validSquare(self, p1, p2, p3, p4):\n        \"\"\"\n        :type p1: List[int]\n        :type p2: List[int]\n        :type p3: List[int]\n        :type p4: List[int]\n        :rtype: bool\n        \"\"\"\n        def dist(p1, p2):\n            return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n        lookup = set([dist(p1, p2), dist(p1, p3),\\\n                      dist(p1, p4), dist(p2, p3),\\\n                      dist(p2, p4), dist(p3, p4)])\n        return 0 not in lookup and len(lookup) == 2\n\n"
    },
    {
        "problem_name": "valid-sudoku",
        "solution": "# Time:  O(9^2)\n# Space: O(9)\n\nclass Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        for i in xrange(9):\n            if not self.isValidList([board[i][j] for j in xrange(9)]) or \\\n               not self.isValidList([board[j][i] for j in xrange(9)]):\n                return False\n        for i in xrange(3):\n            for j in xrange(3):\n                if not self.isValidList([board[m][n] for n in xrange(3 * j, 3 * j + 3) \\\n                                                     for m in xrange(3 * i, 3 * i + 3)]):\n                    return False\n        return True\n\n    def isValidList(self, xs):\n        xs = filter(lambda x: x != '.', xs)\n        return len(set(xs)) == len(xs)\n\n\n"
    },
    {
        "problem_name": "valid-tic-tac-toe-state",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def validTicTacToe(self, board):\n        \"\"\"\n        :type board: List[str]\n        :rtype: bool\n        \"\"\"\n        def win(board, player):\n            for i in xrange(3):\n                if all(board[i][j] == player for j in xrange(3)):\n                    return True\n                if all(board[j][i] == player for j in xrange(3)):\n                    return True\n\n            return (player == board[1][1] == board[0][0] == board[2][2] or \\\n                    player == board[1][1] == board[0][2] == board[2][0])\n\n        FIRST, SECOND = ('X', 'O')\n        x_count = sum(row.count(FIRST) for row in board)\n        o_count = sum(row.count(SECOND) for row in board)\n        if o_count not in {x_count-1, x_count}: return False\n        if win(board, FIRST) and x_count-1 != o_count: return False\n        if win(board, SECOND) and x_count != o_count: return False\n\n        return True\n\n"
    },
    {
        "problem_name": "valid-triangle-number",
        "solution": "# Time:  O(n^2)\n# Space: O(1)\n\nclass Solution(object):\n    def triangleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        nums.sort()\n        for i in reversed(xrange(2, len(nums))):\n            left, right = 0, i-1\n            while left < right:\n                if nums[left]+nums[right] > nums[i]:\n                    result += right-left\n                    right -= 1\n                else:\n                    left += 1\n        return result\n\n\n# Time:  O(n^2)\n# Space: O(1)\nclass Solution2(object):\n    def triangleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        nums.sort()\n        for i in xrange(len(nums)-2):\n            if nums[i] == 0:\n                continue\n            k = i+2\n            for j in xrange(i+1, len(nums)-1):\n                while k < len(nums) and nums[i] + nums[j] > nums[k]:\n                    k += 1\n                result += k-j-1\n        return result\n\n"
    },
    {
        "problem_name": "valid-word-abbreviation",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def validWordAbbreviation(self, word, abbr):\n        \"\"\"\n        :type word: str\n        :type abbr: str\n        :rtype: bool\n        \"\"\"\n        i , digit = 0, 0\n        for c in abbr:\n            if c.isdigit():\n                if digit == 0 and c == '0':\n                    return False\n                digit *= 10\n                digit += int(c)\n            else:\n                if digit:\n                    i += digit\n                    digit = 0\n                if i >= len(word) or word[i] != c:\n                    return False\n                i += 1\n        if digit:\n            i += digit\n\n        return i == len(word)\n\n"
    },
    {
        "problem_name": "valid-word-square",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def validWordSquare(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: bool\n        \"\"\"\n        for i in xrange(len(words)):\n            for j in xrange(len(words[i])):\n                if j >= len(words) or i >= len(words[j]) or \\\n                   words[j][i] != words[i][j]:\n                   return False\n        return True\n\n"
    },
    {
        "problem_name": "valid-word",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# string\nclass Solution(object):\n    def isValid(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        VOWELS = \"aeiou\"\n\n        if len(word) < 3:\n            return False\n        vowel = consonant = False\n        for x in word:\n            if x.isalpha():\n                if x.lower() in VOWELS:\n                    vowel = True\n                else:\n                    consonant = True\n            elif not x.isdigit():\n                return False\n        return vowel and consonant\n"
    },
    {
        "problem_name": "validate-binary-search-tree",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n# Morris Traversal Solution\nclass Solution(object):\n    # @param root, a tree node\n    # @return a list of integers\n    def isValidBST(self, root):\n        prev, cur = None, root\n        while cur:\n            if cur.left is None:\n                if prev and prev.val >= cur.val:\n                    return False\n                prev = cur\n                cur = cur.right\n            else:\n                node = cur.left\n                while node.right and node.right != cur:\n                    node = node.right\n\n                if node.right is None:\n                    node.right = cur\n                    cur = cur.left\n                else:\n                    if prev and prev.val >= cur.val:\n                        return False\n                    node.right = None\n                    prev = cur\n                    cur = cur.right\n\n        return True\n\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    # @param root, a tree node\n    # @return a boolean\n    def isValidBST(self, root):\n        return self.isValidBSTRecu(root, float(\"-inf\"), float(\"inf\"))\n\n    def isValidBSTRecu(self, root, low, high):\n        if root is None:\n            return True\n\n        return low < root.val and root.val < high \\\n            and self.isValidBSTRecu(root.left, low, root.val) \\\n            and self.isValidBSTRecu(root.right, root.val, high)\n\n\n"
    },
    {
        "problem_name": "validate-binary-tree-nodes",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def validateBinaryTreeNodes(self, n, leftChild, rightChild):\n        \"\"\"\n        :type n: int\n        :type leftChild: List[int]\n        :type rightChild: List[int]\n        :rtype: bool\n        \"\"\"\n        roots = set(range(n)) - set(leftChild) - set(rightChild)\n        if len(roots) != 1:\n            return False\n        root, = roots\n        stk = [root]\n        lookup = set([root])\n        while stk:\n            node = stk.pop()\n            for c in (leftChild[node], rightChild[node]):\n                if c < 0:\n                    continue\n                if c in lookup:\n                    return False\n                lookup.add(c)\n                stk.append(c)\n        return len(lookup) == n\n"
    },
    {
        "problem_name": "validate-ip-address",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nimport string\n\n\nclass Solution(object):\n    def validIPAddress(self, IP):\n        \"\"\"\n        :type IP: str\n        :rtype: str\n        \"\"\"\n        blocks = IP.split('.')\n        if len(blocks) == 4:\n            for i in xrange(len(blocks)):\n                if not blocks[i].isdigit() or not 0 <= int(blocks[i]) < 256 or \\\n                   (blocks[i][0] == '0' and len(blocks[i]) > 1):\n                    return \"Neither\"\n            return \"IPv4\"\n\n        blocks = IP.split(':')\n        if len(blocks) == 8:\n            for i in xrange(len(blocks)):\n                if not (1 <= len(blocks[i]) <= 4) or \\\n                   not all(c in string.hexdigits for c in blocks[i]):\n                    return \"Neither\"\n            return \"IPv6\"\n        return \"Neither\"\n\n"
    },
    {
        "problem_name": "validate-stack-sequences",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def validateStackSequences(self, pushed, popped):\n        \"\"\"\n        :type pushed: List[int]\n        :type popped: List[int]\n        :rtype: bool\n        \"\"\"\n        i = 0\n        s = []\n        for v in pushed:\n            s.append(v)\n            while s and i < len(popped) and s[-1] == popped[i]:\n                s.pop()\n                i += 1\n        return i == len(popped)\n"
    },
    {
        "problem_name": "verbal-arithmetic-puzzle",
        "solution": "# Time:  O(10! * n * l)\n# Space: O(n * l)\n\nimport collections\n\n\nclass Solution(object):\n    def isSolvable(self, words, result):\n        \"\"\"\n        :type words: List[str]\n        :type result: str\n        :rtype: bool\n        \"\"\"\n        def backtracking(words, result, i, j, carry, lookup, used):\n            if j == len(result):\n                return carry == 0\n\n            if i != len(words):\n                if j >= len(words[i]) or words[i][j] in lookup:\n                    return backtracking(words, result, i+1, j, carry, lookup, used)     \n                for val in xrange(10):\n                    if val in used or (val == 0 and j == len(words[i])-1):\n                        continue\n                    lookup[words[i][j]] = val\n                    used.add(val)\n                    if backtracking(words, result, i+1, j, carry, lookup, used):\n                        return True\n                    used.remove(val)\n                    del lookup[words[i][j]]\n                return False\n\n            carry, val = divmod(carry + sum(lookup[w[j]] for w in words if j < len(w)), 10)\n            if result[j] in lookup:\n                return val == lookup[result[j]] and \\\n                       backtracking(words, result, 0, j+1, carry, lookup, used)\n            if val in used or (val == 0 and j == len(result)-1):\n                return False\n            lookup[result[j]] = val\n            used.add(val)\n            if backtracking(words, result, 0, j+1, carry, lookup, used):\n                return True\n            used.remove(val)\n            del lookup[result[j]]\n            return False\n        \n        return backtracking([w[::-1] for w in words], result[::-1], 0, 0, 0, {}, set())\n"
    },
    {
        "problem_name": "verify-preorder-sequence-in-binary-search-tree",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    # @param {integer[]} preorder\n    # @return {boolean}\n    def verifyPreorder(self, preorder):\n        low, i = float(\"-inf\"), -1\n        for p in preorder:\n            if p < low:\n                return False\n            while i >= 0 and p > preorder[i]:\n                low = preorder[i]\n                i -= 1\n            i += 1\n            preorder[i] = p\n        return True\n\n# Time:  O(n)\n# Space: O(h)\nclass Solution2(object):\n    # @param {integer[]} preorder\n    # @return {boolean}\n    def verifyPreorder(self, preorder):\n        low = float(\"-inf\")\n        path = []\n        for p in preorder:\n            if p < low:\n                return False\n            while path and p > path[-1]:\n                low = path[-1]\n                path.pop()\n            path.append(p)\n        return True\n\n"
    },
    {
        "problem_name": "verify-preorder-serialization-of-a-binary-tree",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def isValidSerialization(self, preorder):\n        \"\"\"\n        :type preorder: str\n        :rtype: bool\n        \"\"\"\n        def split_iter(s, tok):\n            start = 0\n            for i in xrange(len(s)):\n                if s[i] == tok:\n                    yield s[start:i]\n                    start = i + 1\n            yield s[start:]\n\n        if not preorder:\n            return False\n\n        depth, cnt = 0, preorder.count(',') + 1\n        for tok in split_iter(preorder, ','):\n            cnt -= 1\n            if tok == \"#\":\n                depth -= 1\n                if depth < 0:\n                    break\n            else:\n                depth += 1\n        return cnt == 0 and depth < 0\n\n"
    },
    {
        "problem_name": "verifying-an-alien-dictionary",
        "solution": "# Time:  O(n * l), l is the average length of words\n# Space: O(1)\n\nclass Solution(object):\n    def isAlienSorted(self, words, order):\n        \"\"\"\n        :type words: List[str]\n        :type order: str\n        :rtype: bool\n        \"\"\"\n        lookup = {c: i for i, c in enumerate(order)}\n        for i in xrange(len(words)-1):\n            word1 = words[i]\n            word2 = words[i+1]\n            for k in xrange(min(len(word1), len(word2))):\n                if word1[k] != word2[k]:\n                    if lookup[word1[k]] > lookup[word2[k]]:\n                        return False\n                    break\n            else:\n                if len(word1) > len(word2):\n                    return False\n        return True\n"
    },
    {
        "problem_name": "vertical-order-traversal-of-a-binary-tree",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport collections\n\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution(object):\n    def verticalTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        def dfs(node, lookup, x, y):\n            if not node:\n                return\n            lookup[x][y].append(node)\n            dfs(node.left, lookup, x-1, y+1)\n            dfs(node.right, lookup, x+1, y+1)\n                \n        lookup = collections.defaultdict(lambda: collections.defaultdict(list))\n        dfs(root, lookup, 0, 0)\n\n        result = []\n        for x in sorted(lookup):\n            report = []\n            for y in sorted(lookup[x]):\n                report.extend(sorted(node.val for node in lookup[x][y]))\n            result.append(report)\n        return result\n"
    },
    {
        "problem_name": "video-stitching",
        "solution": "# Time:  O(nlogn)\n# Space: O(1)\n\nclass Solution(object):\n    def videoStitching(self, clips, T):\n        \"\"\"\n        :type clips: List[List[int]]\n        :type T: int\n        :rtype: int\n        \"\"\"\n        if T == 0:\n            return 0\n        result = 1\n        curr_reachable, reachable = 0, 0\n        clips.sort()\n        for left, right in clips:\n            if left > reachable:\n                break\n            elif left > curr_reachable:\n                curr_reachable = reachable\n                result += 1\n            reachable = max(reachable, right)\n            if reachable >= T:\n                return result\n        return -1\n"
    },
    {
        "problem_name": "visit-array-positions-to-maximize-score",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# dp\nclass Solution(object):\n    def maxScore(self, nums, x):\n        \"\"\"\n        :type nums: List[int]\n        :type x: int\n        :rtype: int\n        \"\"\"\n        dp = [float(\"-inf\")]*2\n        dp[nums[0]%2] = nums[0]\n        for i in xrange(1, len(nums)):\n            dp[nums[i]%2] = max(dp[nums[i]%2], dp[(nums[i]+1)%2]-x)+nums[i]\n        return max(dp)\n"
    },
    {
        "problem_name": "vowel-spellchecker",
        "solution": "# Time:  O(n)\n# Space: O(w)\n\nclass Solution(object):\n    def spellchecker(self, wordlist, queries):\n        \"\"\"\n        :type wordlist: List[str]\n        :type queries: List[str]\n        :rtype: List[str]\n        \"\"\"\n        vowels = set(['a', 'e', 'i', 'o', 'u'])\n        def todev(word):\n            return \"\".join('*' if c.lower() in vowels else c.lower()\n                           for c in word)\n\n        words = set(wordlist)\n        caps = {}\n        vows = {}\n\n        for word in wordlist:\n            caps.setdefault(word.lower(), word)\n            vows.setdefault(todev(word), word)\n\n        def check(query):\n            if query in words:\n                return query\n            lower = query.lower()\n            if lower in caps:\n                return caps[lower]\n            devow = todev(lower)\n            if devow in vows:\n                return vows[devow]\n            return \"\"\n        return map(check, queries)\n"
    },
    {
        "problem_name": "vowels-of-all-substrings",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def countVowels(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        VOWELS = set(\"aeiou\")\n        return sum((i-0+1) * ((len(word)-1)-i+1) for i, c in enumerate(word) if c in VOWELS)\n"
    },
    {
        "problem_name": "walking-robot-simulation-ii",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Robot(object):\n\n    def __init__(self, width, height):\n        \"\"\"\n        :type width: int\n        :type height: int\n        \"\"\"\n        self.__w = width\n        self.__h = height\n        self.__curr = 0\n\n    def move(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: None\n        \"\"\"\n        self.__curr += num\n\n    def getPos(self):\n        \"\"\"\n        :rtype: List[int]\n        \"\"\"\n        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))\n        if n < self.__w:\n            return [n, 0]\n        n -= self.__w-1\n        if n < self.__h:\n            return [self.__w-1, n]\n        n -= self.__h-1\n        if n < self.__w:\n            return [(self.__w-1)-n, self.__h-1]\n        n -= self.__w-1\n        return [0, (self.__h-1)-n]\n\n    def getDir(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))\n        if n < self.__w:\n            return \"South\" if n == 0 and self.__curr else \"East\"\n        n -= self.__w-1\n        if n < self.__h:\n            return \"North\"\n        n -= self.__h-1\n        if n < self.__w:\n            return \"West\"\n        n -= self.__w-1\n        return \"South\"\n\n\n# Time:  O(1)\n# Space: O(1)\nclass Robot2(object):\n\n    def __init__(self, width, height):\n        \"\"\"\n        :type width: int\n        :type height: int\n        \"\"\"\n        self.__w = width\n        self.__h = height\n        self.__curr = 0\n\n    def move(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: None\n        \"\"\"\n        self.__curr += num\n\n    def getPos(self):\n        \"\"\"\n        :rtype: List[int]\n        \"\"\"\n        return self.__getPosDir()[0] \n\n    def getDir(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        return self.__getPosDir()[1]\n\n    def __getPosDir(self):\n        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))\n        if n < self.__w:\n            return [[n, 0], \"South\" if n == 0 and self.__curr else \"East\"]\n        n -= self.__w-1\n        if n < self.__h:\n            return [[self.__w-1, n], \"North\"]\n        n -= self.__h-1\n        if n < self.__w:\n            return [[(self.__w-1)-n, self.__h-1], \"West\"]\n        n -= self.__w-1\n        return [[0, (self.__h-1)-n], \"South\"]\n"
    },
    {
        "problem_name": "walking-robot-simulation",
        "solution": "# Time:  O(n + k)\n# Space: O(k)\n\nclass Solution(object):\n    def robotSim(self, commands, obstacles):\n        \"\"\"\n        :type commands: List[int]\n        :type obstacles: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        x, y, i = 0, 0, 0\n        lookup = set(map(tuple, obstacles))\n        result = 0\n        for cmd in commands:\n            if cmd == -2:\n                i = (i-1) % 4\n            elif cmd == -1:\n                i = (i+1) % 4\n            else:\n                for k in xrange(cmd):\n                    if (x+directions[i][0], y+directions[i][1]) not in lookup:\n                        x += directions[i][0]\n                        y += directions[i][1]\n                        result = max(result, x*x + y*y)\n        return result\n\n"
    },
    {
        "problem_name": "walls-and-gates",
        "solution": "# Time:  O(m * n)\n# Space: O(g)\n\nfrom collections import deque\n\nclass Solution(object):\n    def wallsAndGates(self, rooms):\n        \"\"\"\n        :type rooms: List[List[int]]\n        :rtype: void Do not return anything, modify rooms in-place instead.\n        \"\"\"\n        INF = 2147483647\n        q = deque([(i, j) for i, row in enumerate(rooms) for j, r in enumerate(row) if not r])\n        while q:\n            (i, j) = q.popleft()\n            for I, J in (i+1, j), (i-1, j), (i, j+1), (i, j-1):\n                if 0 <= I < len(rooms) and 0 <= J < len(rooms[0]) and \\\n                   rooms[I][J] == INF:\n                    rooms[I][J] = rooms[i][j] + 1\n                    q.append((I, J))\n\n\n"
    },
    {
        "problem_name": "water-and-jug-problem",
        "solution": "# Time:  O(logn),  n is the max of (x, y)\n# Space: O(1)\n\nclass Solution(object):\n    def canMeasureWater(self, x, y, z):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :type z: int\n        :rtype: bool\n        \"\"\"\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n\n        # The problem is to solve:\n        # - check z <= x + y\n        # - check if there is any (a, b) integers s.t. ax + by = z\n        return z == 0 or ((z <= x + y) and (z % gcd(x, y) == 0))\n\n"
    },
    {
        "problem_name": "water-bottles-ii",
        "solution": "# Time:  O(sqrt(n))\n# Space: O(1)\n\n# simulation\nclass Solution(object):\n    def maxBottlesDrunk(self, numBottles, numExchange):\n        \"\"\"\n        :type numBottles: int\n        :type numExchange: int\n        :rtype: int\n        \"\"\"\n        result = numBottles\n        while numBottles >= numExchange:\n            numBottles -= numExchange\n            numExchange += 1\n            result += 1\n            numBottles += 1\n        return result\n"
    },
    {
        "problem_name": "water-bottles",
        "solution": "# Time:  O(logn/logm), n is numBottles, m is numExchange\n# Space: O(1)\n\nclass Solution(object):\n    def numWaterBottles(self, numBottles, numExchange):\n        \"\"\"\n        :type numBottles: int\n        :type numExchange: int\n        :rtype: int\n        \"\"\"\n        result = numBottles\n        while numBottles >= numExchange:\n            numBottles, remainder = divmod(numBottles, numExchange)\n            result += numBottles\n            numBottles += remainder\n        return result\n"
    },
    {
        "problem_name": "watering-plants-ii",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def minimumRefill(self, plants, capacityA, capacityB):\n        \"\"\"\n        :type plants: List[int]\n        :type capacityA: int\n        :type capacityB: int\n        :rtype: int\n        \"\"\"\n        result = 0 \n        left, right = 0, len(plants)-1\n        canA, canB = capacityA, capacityB\n        while left < right: \n            if canA < plants[left]:\n                result += 1\n                canA = capacityA\n            canA -= plants[left]\n            if canB < plants[right]:\n                result += 1\n                canB = capacityB\n            canB -= plants[right]\n            left, right = left+1, right-1\n        if left == right:\n            if max(canA, canB) < plants[left]:\n                result += 1\n        return result\n"
    },
    {
        "problem_name": "watering-plants",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def wateringPlants(self, plants, capacity):\n        \"\"\"\n        :type plants: List[int]\n        :type capacity: int\n        :rtype: int\n        \"\"\"\n        result, can = len(plants), capacity\n        for i, x in enumerate(plants):\n            if can < x:\n                result += 2*i\n                can = capacity\n            can -= x\n        return result\n"
    },
    {
        "problem_name": "ways-to-express-an-integer-as-sum-of-powers",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\n# knapsack dp\nclass Solution(object):\n    def numberOfWays(self, n, x):\n        \"\"\"\n        :type n: int\n        :type x: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        dp = [0]*(n+1)\n        dp[0] = 1\n        for i in xrange(1, n+1):\n            i_pow_x = i**x\n            if i_pow_x > n:\n                break\n            for j in reversed(xrange(i_pow_x, n+1)):\n                dp[j] = (dp[j]+dp[j-i_pow_x])%MOD\n        return dp[-1]\n"
    },
    {
        "problem_name": "ways-to-make-a-fair-array",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def waysToMakeFair(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        prefix = [0]*2\n        suffix = [sum(nums[i] for i in xrange(k, len(nums), 2)) for k in xrange(2)]\n        result = 0\n        for i, num in enumerate(nums):\n            suffix[i%2] -= num\n            result += int(prefix[0]+suffix[1] == prefix[1]+suffix[0])\n            prefix[i%2] += num\n        return result\n"
    },
    {
        "problem_name": "ways-to-split-array-into-good-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# combinatorics\nclass Solution(object):\n    def numberOfGoodSubarraySplits(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n        result, prev = 1, -1\n        for i in xrange(len(nums)):\n            if nums[i] != 1:\n                continue\n            if prev != -1:\n                result = (result*(i-prev))%MOD\n            prev = i\n        return result if prev != -1 else 0\n"
    },
    {
        "problem_name": "ways-to-split-array-into-three-subarrays",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nclass Solution(object):\n    def waysToSplit(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9+7\n\n        prefix = [0]\n        for x in nums:\n            prefix.append(prefix[-1]+x)\n\n        result = left = right = 0 \n        for i in xrange(len(nums)): \n            left = max(left, i+1)\n            while left+1 < len(nums) and prefix[i+1] > prefix[left+1]-prefix[i+1]:\n                left += 1\n            right = max(right, left)\n            while right+1 < len(nums) and prefix[right+1]-prefix[i+1] <= prefix[-1]-prefix[right+1]:\n                right += 1\n            result = (result + (right-left))%MOD\n        return result\n"
    },
    {
        "problem_name": "web-crawler-multithreaded",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|V|)\n\nimport threading\nimport Queue\n\n\n# \"\"\"\n# This is HtmlParser's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\nclass HtmlParser(object):\n   def getUrls(self, url):\n       \"\"\"\n       :type url: str\n       :rtype List[str]\n       \"\"\"\n       pass\n\n\nclass Solution(object):\n    NUMBER_OF_WORKERS = 8\n    \n    def __init__(self):\n        self.__cv = threading.Condition()\n        self.__q = Queue.Queue()\n\n    def crawl(self, startUrl, htmlParser):\n        \"\"\"\n        :type startUrl: str\n        :type htmlParser: HtmlParser\n        :rtype: List[str]\n        \"\"\"\n        SCHEME = \"http://\"\n        def hostname(url):\n            pos = url.find('/', len(SCHEME))\n            if pos == -1:\n                return url\n            return url[:pos]\n\n        def worker(htmlParser, lookup):\n            while True:\n                from_url = self.__q.get()\n                if from_url is None:\n                    break\n                name = hostname(from_url)\n                for to_url in htmlParser.getUrls(from_url):\n                    if name != hostname(to_url):\n                        continue\n                    with self.__cv:\n                        if to_url not in lookup:\n                           lookup.add(to_url)\n                           self.__q.put(to_url)\n                self.__q.task_done()\n\n        workers = []\n        self.__q = Queue.Queue()\n        self.__q.put(startUrl)\n        lookup = set([startUrl])\n        for i in xrange(self.NUMBER_OF_WORKERS):\n            t = threading.Thread(target=worker, args=(htmlParser, lookup))\n            t.start()\n            workers.append(t)\n        self.__q.join()\n        for t in workers:\n            self.__q.put(None)\n        for t in workers:\n            t.join()\n        return list(lookup)\n\n\n# Time:  O(|V| + |E|)\n# Space: O(|V|)\nimport threading\nimport collections\n\n\nclass Solution2(object):\n    NUMBER_OF_WORKERS = 8\n    \n    def __init__(self):\n        self.__cv = threading.Condition()\n        self.__q = collections.deque()\n        self.__working_count = 0\n\n    def crawl(self, startUrl, htmlParser):\n        \"\"\"\n        :type startUrl: str\n        :type htmlParser: HtmlParser\n        :rtype: List[str]\n        \"\"\"\n        SCHEME = \"http://\"\n        def hostname(url):\n            pos = url.find('/', len(SCHEME))\n            if pos == -1:\n                return url\n            return url[:pos]\n\n        def worker(htmlParser, lookup):\n            while True:\n                with self.__cv:\n                    while not self.__q:\n                        self.__cv.wait()\n                    from_url = self.__q.popleft()\n                    if from_url is None:\n                        break\n                    self.__working_count += 1\n                name = hostname(from_url)\n                for to_url in htmlParser.getUrls(from_url):\n                    if name != hostname(to_url):\n                        continue\n                    with self.__cv:\n                        if to_url not in lookup:\n                           lookup.add(to_url)\n                           self.__q.append(to_url)\n                           self.__cv.notifyAll()\n                with self.__cv:\n                    self.__working_count -= 1\n                    if not self.__q and not self.__working_count:\n                        self.__cv.notifyAll()\n\n        workers = []\n        self.__q = collections.deque([startUrl])\n        lookup = set([startUrl])\n        for i in xrange(self.NUMBER_OF_WORKERS):\n            t = threading.Thread(target=worker, args=(htmlParser, lookup))\n            t.start()\n            workers.append(t)\n        with self.__cv:\n            while self.__q or self.__working_count:\n                self.__cv.wait()\n            for i in xrange(self.NUMBER_OF_WORKERS):\n                self.__q.append(None)\n            self.__cv.notifyAll()\n        for t in workers:\n            t.join()\n        return list(lookup)\n"
    },
    {
        "problem_name": "web-crawler",
        "solution": "# Time:  O(|V| + |E|)\n# Space: O(|V|)\n\n# \"\"\"\n# This is HtmlParser's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\nclass HtmlParser(object):\n   def getUrls(self, url):\n       \"\"\"\n       :type url: str\n       :rtype List[str]\n       \"\"\"\n       pass\n\n\nclass Solution(object):\n    def crawl(self, startUrl, htmlParser):\n        \"\"\"\n        :type startUrl: str\n        :type htmlParser: HtmlParser\n        :rtype: List[str]\n        \"\"\"\n        SCHEME = \"http://\"\n        def hostname(url):\n            pos = url.find('/', len(SCHEME))\n            if pos == -1:\n                return url\n            return url[:pos]\n\n        result = [startUrl]\n        lookup = set(result)\n        for from_url in result:\n            name = hostname(from_url)\n            for to_url in htmlParser.getUrls(from_url):\n                if to_url not in lookup and name == hostname(to_url):\n                    result.append(to_url)\n                    lookup.add(to_url)\n        return result\n"
    },
    {
        "problem_name": "where-will-the-ball-fall",
        "solution": "# Time:  O(m * n)\n# Space: O(1)\n\nclass Solution(object):\n    def findBall(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for c in xrange(len(grid[0])):\n            for r in xrange(len(grid)):\n                nc = c+grid[r][c]\n                if not (0 <= nc < len(grid[0]) and grid[r][nc] == grid[r][c]):\n                    c = -1\n                    break\n                c = nc\n            result.append(c)\n        return result\n"
    },
    {
        "problem_name": "widest-pair-of-indices-with-equal-range-sum",
        "solution": "# Time:  O(n)\n# Space: O(n)\n\nimport itertools\n\n\nclass Solution(object):\n    def widestPairOfIndices(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: int\n        \"\"\"\n        lookup = {0:-1}\n        result = total = 0\n        for i, (n1, n2) in enumerate(itertools.izip(nums1, nums2)):\n            total += n1-n2\n            if total not in lookup:\n                lookup[total] = i\n            result = max(result, i-lookup[total])\n        return result\n"
    },
    {
        "problem_name": "widest-vertical-area-between-two-points-containing-no-points",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nimport itertools\n\n\nclass Solution(object):\n    def maxWidthOfVerticalArea(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        sorted_x = sorted({x for x, y in points})\n        return max([b-a for a, b in itertools.izip(sorted_x, sorted_x[1:])] + [0])\n"
    },
    {
        "problem_name": "wiggle-sort-ii",
        "solution": "# Time:  O(nlogn)\n# Space: O(n)\n\nclass Solution(object):\n    def wiggleSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()\n        mid = (len(nums) - 1) / 2\n        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]\n\n\n# Time:  O(n) ~ O(n^2)\n# Space: O(1)\n# Tri Partition (aka Dutch National Flag Problem) with virtual index solution.\nfrom random import randint\n\n\nclass Solution2(object):\n    def wiggleSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        def nth_element(nums, n, compare=lambda a, b: a < b):\n            def tri_partition(nums, left, right, target, compare):\n                mid = left\n                while mid <= right:\n                    if nums[mid] == target:\n                        mid += 1\n                    elif compare(nums[mid], target):\n                        nums[left], nums[mid] = nums[mid], nums[left]\n                        left += 1\n                        mid += 1\n                    else:\n                        nums[mid], nums[right] = nums[right], nums[mid]\n                        right -= 1\n                return left, right\n\n            left, right = 0, len(nums)-1\n            while left <= right:\n                pivot_idx = randint(left, right)\n                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)\n                if pivot_left <= n <= pivot_right:\n                    return\n                elif pivot_left > n:\n                    right = pivot_left-1\n                else:  # pivot_right < n.\n                    left = pivot_right+1\n\n        def reversedTriPartitionWithVI(nums, val):\n            def idx(i, N):\n                return (1 + 2 * (i)) % N\n\n            N = len(nums) / 2 * 2 + 1\n            i, j, n = 0, 0, len(nums) - 1\n            while j <= n:\n                if nums[idx(j, N)] > val:\n                    nums[idx(i, N)], nums[idx(j, N)] = nums[idx(j, N)], nums[idx(i, N)]\n                    i += 1\n                    j += 1\n                elif nums[idx(j, N)] < val:\n                    nums[idx(j, N)], nums[idx(n, N)] = nums[idx(n, N)], nums[idx(j, N)]\n                    n -= 1\n                else:\n                    j += 1\n\n        mid = (len(nums)-1)//2\n        nth_element(nums, mid)\n        reversedTriPartitionWithVI(nums, nums[mid])\n"
    },
    {
        "problem_name": "wiggle-sort",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def wiggleSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in xrange(1, len(nums)):\n            if ((i % 2) and nums[i - 1] > nums[i]) or \\\n                (not (i % 2) and nums[i - 1] < nums[i]):\n                # Swap unordered elements.\n                nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\n\n# time: O(nlogn)\n# space: O(n)\nclass Solution2(object):\n    def wiggleSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums.sort()\n        med = (len(nums) - 1) // 2\n        nums[::2], nums[1::2] = nums[med::-1], nums[:med:-1]\n"
    },
    {
        "problem_name": "wiggle-subsequence",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def wiggleMaxLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) < 2:\n            return len(nums)\n\n        length, up = 1, None\n\n        for i in xrange(1, len(nums)):\n            if nums[i - 1] < nums[i] and (up is None or up is False):\n                length += 1\n                up = True\n            elif nums[i - 1] > nums[i] and (up is None or up is True):\n                length += 1\n                up = False\n\n        return length\n\n"
    },
    {
        "problem_name": "wildcard-matching",
        "solution": "# Time:  O(m + n) ~ O(m * n)\n# Space: O(1)\n\n# iterative solution with greedy\nclass Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        count = 0  # used for complexity check\n        p_ptr, s_ptr, last_s_ptr, last_p_ptr = 0, 0, -1, -1\n        while s_ptr < len(s):\n            if p_ptr < len(p) and (s[s_ptr] == p[p_ptr] or p[p_ptr] == '?'):\n                s_ptr += 1\n                p_ptr += 1\n            elif p_ptr < len(p) and p[p_ptr] == '*':\n                p_ptr += 1\n                last_s_ptr = s_ptr\n                last_p_ptr = p_ptr\n            elif last_p_ptr != -1:\n                last_s_ptr += 1\n                s_ptr = last_s_ptr\n                p_ptr = last_p_ptr\n            else:\n                assert(count <= (len(p)+1) * (len(s)+1))\n                return False\n            count += 1  # used for complexity check\n \n        while p_ptr < len(p) and p[p_ptr] == '*':\n            p_ptr += 1\n            count += 1  # used for complexity check\n\n        assert(count <= (len(p)+1) * (len(s)+1))\n        return p_ptr == len(p)\n\n\n# dp with rolling window\n# Time:  O(m * n)\n# Space: O(n)\nclass Solution2(object):\n    # @return a boolean\n    def isMatch(self, s, p):\n        k = 2\n        result = [[False for j in xrange(len(p) + 1)] for i in xrange(k)]\n\n        result[0][0] = True\n        for i in xrange(1, len(p) + 1):\n            if p[i-1] == '*':\n                result[0][i] = result[0][i-1]\n        for i in xrange(1,len(s) + 1):\n            result[i % k][0] = False\n            for j in xrange(1, len(p) + 1):\n                if p[j-1] != '*':\n                    result[i % k][j] = result[(i-1) % k][j-1] and (s[i-1] == p[j-1] or p[j-1] == '?')\n                else:\n                    result[i % k][j] = result[i % k][j-1] or result[(i-1) % k][j]\n\n        return result[len(s) % k][len(p)]\n\n\n# dp\n# Time:  O(m * n)\n# Space: O(m * n)\nclass Solution3(object):\n    # @return a boolean\n    def isMatch(self, s, p):\n        result = [[False for j in xrange(len(p) + 1)] for i in xrange(len(s) + 1)]\n\n        result[0][0] = True\n        for i in xrange(1, len(p) + 1):\n            if p[i-1] == '*':\n                result[0][i] = result[0][i-1]\n        for i in xrange(1,len(s) + 1):\n            result[i][0] = False\n            for j in xrange(1, len(p) + 1):\n                if p[j-1] != '*':\n                    result[i][j] = result[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '?')\n                else:\n                    result[i][j] = result[i][j-1] or result[i-1][j]\n\n        return result[len(s)][len(p)]\n\n\n# recursive, slowest, TLE\nclass Solution4(object):\n    # @return a boolean\n    def isMatch(self, s, p):\n        if not p or not s:\n            return not s and not p\n\n        if p[0] != '*':\n            if p[0] == s[0] or p[0] == '?':\n                return self.isMatch(s[1:], p[1:])\n            else:\n                return False\n        else:\n            while len(s) > 0:\n                if self.isMatch(s, p[1:]):\n                    return True\n                s = s[1:]\n            return self.isMatch(s, p[1:])\n\n"
    },
    {
        "problem_name": "winner-of-the-linked-list-game",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\n# linked list\nclass Solution(object):\n    def gameResult(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: str\n        \"\"\"\n        cnt = 0\n        while head:\n            cnt += cmp(head.val, head.next.val)\n            head = head.next.next\n        return \"Tie\" if cnt == 0 else \"Odd\" if cnt < 0 else \"Even\"\n"
    },
    {
        "problem_name": "word-abbreviation",
        "solution": "# Time:  O(n * l) ~ O(n^2 * l^2)\n# Space: O(n * l)\n\nimport collections\n\n\nclass Solution(object):\n    def wordsAbbreviation(self, dict):\n        \"\"\"\n        :type dict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        def isUnique(prefix, words):\n            return sum(word.startswith(prefix) for word in words) == 1\n\n        def toAbbr(prefix, word):\n            abbr = prefix + str(len(word) - 1 - len(prefix)) + word[-1]\n            return abbr if len(abbr) < len(word) else word\n\n        abbr_to_word = collections.defaultdict(set)\n        word_to_abbr = {}\n\n        for word in dict:\n            prefix = word[:1]\n            abbr_to_word[toAbbr(prefix, word)].add(word)\n\n        for abbr, conflicts in abbr_to_word.iteritems():\n            if len(conflicts) > 1:\n                for word in conflicts:\n                    for i in xrange(2, len(word)):\n                        prefix = word[:i]\n                        if isUnique(prefix, conflicts):\n                            word_to_abbr[word] = toAbbr(prefix, word)\n                            break\n            else:\n                word_to_abbr[conflicts.pop()] = abbr\n\n        return [word_to_abbr[word] for word in dict]\n\n"
    },
    {
        "problem_name": "word-break-ii",
        "solution": "# Time:  O(n * l^2 + n * r), l is the max length of the words,\n#                            r is the number of the results.\n# Space: O(n^2)\n\nclass Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: Set[str]\n        :rtype: List[str]\n        \"\"\"\n        n = len(s)\n\n        max_len = 0\n        for string in wordDict:\n            max_len = max(max_len, len(string))\n\n        can_break = [False for _ in xrange(n + 1)]\n        valid = [[False] * n for _ in xrange(n)]\n        can_break[0] = True\n        for i in xrange(1, n + 1):\n            for l in xrange(1, min(i, max_len) + 1):\n                if can_break[i-l] and s[i-l:i] in wordDict:\n                    valid[i-l][i-1] = True\n                    can_break[i] = True\n\n        result = []\n        if can_break[-1]:\n            self.wordBreakHelper(s, valid, 0, [], result)\n        return result\n\n    def wordBreakHelper(self, s, valid, start, path, result):\n        if start == len(s):\n            result.append(\" \".join(path))\n            return\n        for i in xrange(start, len(s)):\n            if valid[start][i]:\n                path += [s[start:i+1]]\n                self.wordBreakHelper(s, valid, i + 1, path, result)\n                path.pop()\n\n\n"
    },
    {
        "problem_name": "word-break",
        "solution": "# Time:  O(n * l^2)\n# Space: O(n)\n\nclass Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: Set[str]\n        :rtype: bool\n        \"\"\"\n        n = len(s)\n\n        max_len = 0\n        for string in wordDict:\n            max_len = max(max_len, len(string))\n\n        can_break = [False for _ in xrange(n + 1)]\n        can_break[0] = True\n        for i in xrange(1, n + 1):\n            for l in xrange(1, min(i, max_len) + 1):\n                if can_break[i-l] and s[i-l:i] in wordDict:\n                    can_break[i] = True\n                    break\n\n        return can_break[-1]\n\n\n"
    },
    {
        "problem_name": "word-ladder-ii",
        "solution": "# Time:  O(b^(d/2)), b is the branch factor of bfs, d is the result depth\n# Space: O(w * l), w is the number of words, l is the max length of words\n\nfrom collections import defaultdict\nfrom string import ascii_lowercase\n\n\nclass Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        def backtracking(tree, beginWord, word): \n            return [[beginWord]] if word == beginWord else [path + [word] for new_word in tree[word] for path in backtracking(tree, beginWord, new_word)]\n\n        words = set(wordList)\n        if endWord not in words:\n            return []\n        tree = defaultdict(set)\n        is_found, left, right, is_reversed = False, {beginWord}, {endWord}, False\n        while left:\n            words -= left\n            new_left = set()\n            for word in left:\n                for new_word in (word[:i]+c+word[i+1:] for i in xrange(len(beginWord)) for c in ascii_lowercase):\n                    if new_word not in words:\n                        continue\n                    if new_word in right: \n                        is_found = True\n                    else: \n                        new_left.add(new_word)\n                    tree[new_word].add(word) if not is_reversed else tree[word].add(new_word)\n            if is_found:\n                break\n            left = new_left\n            if len(left) > len(right): \n                left, right, is_reversed = right, left, not is_reversed\n        return backtracking(tree, beginWord, endWord)\n\n\n# Time:  O(b^d), b is the branch factor of bfs, d is the result depth\n# Space: O(w * l), w is the number of words, l is the max length of words\nclass Solution2(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        dictionary = set(wordList)\n        result, cur, visited, found, trace = [], [beginWord], set([beginWord]), False, defaultdict(list)\n\n        while cur and not found:\n            for word in cur:\n                visited.add(word)\n\n            next = set()\n            for word in cur:\n                for i in xrange(len(word)):\n                    for c in ascii_lowercase:\n                        candidate = word[:i] + c + word[i + 1:]\n                        if candidate not in visited and candidate in dictionary:\n                            if candidate == endWord:\n                                found = True\n                            next.add(candidate)\n                            trace[candidate].append(word)\n            cur = next\n\n        if found:\n            self.backtrack(result, trace, [], endWord)\n\n        return result\n\n    def backtrack(self, result, trace, path, word):\n        if not trace[word]:\n            path.append(word)\n            result.append(path[::-1])\n            path.pop()\n        else:\n            for prev in trace[word]:\n                path.append(word)\n                self.backtrack(result, trace, path, prev)\n                path.pop()\n"
    },
    {
        "problem_name": "word-ladder",
        "solution": "# Time:  O(b^(d/2)), b is the branch factor of bfs, d is the result depth\n# Space: O(w * l), w is the number of words, l is the max length of words\n\nfrom string import ascii_lowercase\n\n\n# two-end bfs\nclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        words = set(wordList)\n        if endWord not in words:\n            return 0\n        left, right = {beginWord}, {endWord}\n        ladder = 2\n        while left:\n            words -= left\n            new_left = set()\n            for word in left:\n                for new_word in (word[:i]+c+word[i+1:] for i in xrange(len(beginWord)) for c in ascii_lowercase):\n                    if new_word not in words:\n                        continue\n                    if new_word in right: \n                        return ladder\n                    new_left.add(new_word)\n            left = new_left\n            ladder += 1\n            if len(left) > len(right): \n                left, right = right, left\n        return 0\n\n\n# Time:  O(b^d), b is the branch factor of bfs, d is the result depth\n# Space: O(w * l), w is the number of words, l is the max length of words\nclass Solution2(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        lookup = set(wordList)\n        if endWord not in lookup:\n            return 0\n        ladder = 2\n        q = [beginWord]\n        while q:\n            new_q = []\n            for word in q:\n                for i in xrange(len(word)):\n                    for j in ascii_lowercase:\n                        new_word = word[:i] + j + word[i+1:]\n                        if new_word == endWord:\n                            return ladder\n                        if new_word in lookup:\n                            lookup.remove(new_word)\n                            new_q.append(new_word)\n            q = new_q\n            ladder += 1\n        return 0\n"
    },
    {
        "problem_name": "word-pattern-ii",
        "solution": "# Time:  O(n * C(n - 1, c - 1)), n is length of str, c is unique count of pattern,\n#                                there are H(n - c, c - 1) = C(n - 1, c - 1) possible splits of string,\n#                                and each one costs O(n) to check if it matches the word pattern.\n# Space: O(n + c)\n\nclass Solution(object):\n    def wordPatternMatch(self, pattern, str):\n        \"\"\"\n        :type pattern: str\n        :type str: str\n        :rtype: bool\n        \"\"\"\n        w2p, p2w = {}, {}\n        return self.match(pattern, str, 0, 0, w2p, p2w)\n\n\n    def match(self, pattern, str, i, j, w2p, p2w):\n        is_match = False\n        if i == len(pattern) and j == len(str):\n            is_match = True\n        elif i < len(pattern) and j < len(str):\n            p = pattern[i]\n            if p in p2w:\n                w = p2w[p]\n                if w == str[j:j+len(w)]:  # Match pattern.\n                    is_match = self.match(pattern, str, i + 1, j + len(w), w2p, p2w)\n                # Else return false.\n            else:\n                for k in xrange(j, len(str)):  # Try any possible word\n                    w = str[j:k+1]\n                    if w not in w2p:\n                        # Build mapping. Space: O(n + c)\n                        w2p[w], p2w[p] = p, w\n                        is_match = self.match(pattern, str, i + 1, k + 1, w2p, p2w)\n                        w2p.pop(w), p2w.pop(p)\n                    if is_match:\n                        break\n        return is_match\n\n\n"
    },
    {
        "problem_name": "word-pattern",
        "solution": "# Time:  O(n)\n# Space: O(c), c is unique count of pattern\n\nfrom itertools import izip  # Generator version of zip.\n\nclass Solution(object):\n    def wordPattern(self, pattern, str):\n        \"\"\"\n        :type pattern: str\n        :type str: str\n        :rtype: bool\n        \"\"\"\n        if len(pattern) != self.wordCount(str):\n            return False\n\n        w2p, p2w = {}, {}\n        for p, w in izip(pattern, self.wordGenerator(str)):\n            if w not in w2p and p not in p2w:\n                # Build mapping. Space: O(c)\n                w2p[w] = p\n                p2w[p] = w\n            elif w not in w2p or w2p[w] != p:\n                # Contradict mapping.\n                return False\n        return True\n\n    def wordCount(self, str):\n        cnt = 1 if str else 0\n        for c in str:\n            if c == ' ':\n                cnt += 1\n        return cnt\n\n    # Generate a word at a time without saving all the words.\n    def wordGenerator(self, str):\n        w = \"\"\n        for c in str:\n            if c == ' ':\n                yield w\n                w = \"\"\n            else:\n                w += c\n        yield w\n\n\n# Time:  O(n)\n# Space: O(n)\nclass Solution2(object):\n    def wordPattern(self, pattern, str):\n        \"\"\"\n        :type pattern: str\n        :type str: str\n        :rtype: bool\n        \"\"\"\n        words = str.split()  # Space: O(n)\n        if len(pattern) != len(words):\n            return False\n\n        w2p, p2w = {}, {}\n        for p, w in izip(pattern, words):\n            if w not in w2p and p not in p2w:\n                # Build mapping. Space: O(c)\n                w2p[w] = p\n                p2w[p] = w\n            elif w not in w2p or w2p[w] != p:\n                # Contradict mapping.\n                return False\n        return True\n\n"
    },
    {
        "problem_name": "word-search-ii",
        "solution": "# Time:  O(m * n * 4 * 3^(h - 1)) ~= O(m * n * 3^h), h is the height of trie\n# Space: O(t), t is the number of nodes in trie\n\nclass TrieNode(object):\n    # Initialize your data structure here.\n    def __init__(self):\n        self.is_string = False\n        self.leaves = {}\n\n    # Inserts a word into the trie.\n    def insert(self, word):\n        cur = self\n        for c in word:\n            if not c in cur.leaves:\n                cur.leaves[c] = TrieNode()\n            cur = cur.leaves[c]\n        cur.is_string = True\n\n\nclass Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        visited = [[False for j in xrange(len(board[0]))] for i in xrange(len(board))]\n        result = {}\n        trie = TrieNode()\n        for word in words:\n            trie.insert(word)\n\n        for i in xrange(len(board)):\n            for j in xrange(len(board[0])):\n                self.findWordsRecu(board, trie, 0, i, j, visited, [], result)\n\n        return result.keys()\n\n    def findWordsRecu(self, board, trie, cur, i, j, visited, cur_word, result):\n        if not trie or i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n            return\n\n        if board[i][j] not in trie.leaves:\n            return\n\n        cur_word.append(board[i][j])\n        next_node = trie.leaves[board[i][j]]\n        if next_node.is_string:\n            result[\"\".join(cur_word)] = True\n\n        visited[i][j] = True\n        self.findWordsRecu(board, next_node, cur + 1, i + 1, j, visited, cur_word, result)\n        self.findWordsRecu(board, next_node, cur + 1, i - 1, j, visited, cur_word, result)\n        self.findWordsRecu(board, next_node, cur + 1, i, j + 1, visited, cur_word, result)\n        self.findWordsRecu(board, next_node, cur + 1, i, j - 1, visited, cur_word, result)\n        visited[i][j] = False\n        cur_word.pop()\n"
    },
    {
        "problem_name": "word-search",
        "solution": "# Time:  O(m * n * 4 * 3^(l - 1)) ~= O(m * n * 3^l), l is the length of the word\n# Space: O(l)\n\nclass Solution(object):\n    # @param board, a list of lists of 1 length string\n    # @param word, a string\n    # @return a boolean\n    def exist(self, board, word):\n        visited = [[False for j in xrange(len(board[0]))] for i in xrange(len(board))]\n\n        for i in xrange(len(board)):\n            for j in xrange(len(board[0])):\n                if self.existRecu(board, word, 0, i, j, visited):\n                    return True\n\n        return False\n\n    def existRecu(self, board, word, cur, i, j, visited):\n        if cur == len(word):\n            return True\n\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[cur]:\n            return False\n\n        visited[i][j] = True\n        result = self.existRecu(board, word, cur + 1, i + 1, j, visited) or\\\n                 self.existRecu(board, word, cur + 1, i - 1, j, visited) or\\\n                 self.existRecu(board, word, cur + 1, i, j + 1, visited) or\\\n                 self.existRecu(board, word, cur + 1, i, j - 1, visited)\n        visited[i][j] = False\n\n        return result\n\n"
    },
    {
        "problem_name": "word-squares",
        "solution": "# Time:  O(n^2 * n!)\n# Space: O(n^2)\n\nclass TrieNode(object):\n    def __init__(self):\n        self.indices = []\n        self.children = [None] * 26\n\n    def insert(self, words, i):\n        cur = self\n        for c in words[i]:\n            if not cur.children[ord(c)-ord('a')]:\n                cur.children[ord(c)-ord('a')] = TrieNode()\n            cur = cur.children[ord(c)-ord('a')]\n            cur.indices.append(i)\n\n\nclass Solution(object):\n    def wordSquares(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        result = []\n\n        trie = TrieNode()\n        for i in xrange(len(words)):\n            trie.insert(words, i)\n\n        curr = []\n        for s in words:\n            curr.append(s)\n            self.wordSquaresHelper(words, trie, curr, result)\n            curr.pop()\n\n        return result\n\n    def wordSquaresHelper(self, words, trie, curr, result):\n        if len(curr) >= len(words[0]):\n            return result.append(list(curr))\n\n        node = trie\n        for s in curr:\n            node = node.children[ord(s[len(curr)]) - ord('a')]\n            if not node:\n                return\n\n        for i in node.indices:\n            curr.append(words[i])\n            self.wordSquaresHelper(words, trie, curr, result)\n            curr.pop()\n\n"
    },
    {
        "problem_name": "word-subsets",
        "solution": "# Time:  O(m + n)\n# Space: O(1)\n\nimport collections\n\n\nclass Solution(object):\n    def wordSubsets(self, A, B):\n        \"\"\"\n        :type A: List[str]\n        :type B: List[str]\n        :rtype: List[str]\n        \"\"\"\n        count = collections.Counter()\n        for b in B:\n            for c, n in collections.Counter(b).items():\n                count[c] = max(count[c], n)\n        result = []\n        for a in A:\n            count = collections.Counter(a)\n            if all(count[c] >= count[c] for c in count):\n                result.append(a)\n        return result\n\n"
    },
    {
        "problem_name": "words-within-two-edits-of-dictionary",
        "solution": "# Time:  O(25 * l * (n + q))\n# Space: O(25 * l * n)\n\nimport string\n\n\n# hash\nclass Solution(object):\n    def twoEditWords(self, queries, dictionary):\n        \"\"\"\n        :type queries: List[str]\n        :type dictionary: List[str]\n        :rtype: List[str]\n        \"\"\"\n        MOD = (1<<64)-59  # largest 64-bit prime\n        BASE = 113\n        POW = [1]\n        def add(a, b):\n            return (a+b)%MOD\n\n        def mult(a, b):\n            return (a*b)%MOD\n\n        def pow(i):\n            while not (i < len(POW)):\n                POW.append(mult(POW[-1], BASE))\n            return POW[i]\n    \n        lookup = set()\n        for w in dictionary:\n            h = reduce(lambda h, i: add(h, mult(ord(w[i])-ord('a'), pow(i))), xrange(len(w)), 0)\n            for i, c in enumerate(w):\n                for x in string.ascii_lowercase:\n                    if x == c:\n                        continue\n                    lookup.add(add(h, mult(ord(x)-ord(c), pow(i))))\n        result = []\n        for w in queries:\n            h = reduce(lambda h, i: add(h, mult(ord(w[i])-ord('a'), pow(i))), xrange(len(w)), 0)\n            for i, c in enumerate(w):\n                for x in string.ascii_lowercase:\n                    if x == c:\n                        continue\n                    if add(h, mult(ord(x)-ord(c), pow(i))) in lookup:\n                        break\n                else:\n                    continue\n                result.append(w)\n                break\n        return result\n\n\n# Time:  O(q * n * l)\n# Space: O(1)\nimport itertools\n\n\n# brute force\nclass Solution2(object):\n    def twoEditWords(self, queries, dictionary):\n        \"\"\"\n        :type queries: List[str]\n        :type dictionary: List[str]\n        :rtype: List[str]\n        \"\"\"\n        return [q for q in queries if any(sum(c1 != c2 for c1, c2 in itertools.izip(q, d)) <= 2 for d in dictionary)]\n"
    },
    {
        "problem_name": "x-of-a-kind-in-a-deck-of-cards",
        "solution": "# Time:  O(n * (logn)^2)\n# Space: O(n)\n\nimport collections\n\n\nclass Solution(object):\n    def hasGroupsSizeX(self, deck):\n        \"\"\"\n        :type deck: List[int]\n        :rtype: bool\n        \"\"\"\n        def gcd(a, b):  # Time: O((logn)^2)\n            while b:\n                a, b = b, a % b\n            return a\n\n        vals = collections.Counter(deck).values()\n        return reduce(gcd, vals) >= 2\n\n"
    },
    {
        "problem_name": "xor-operation-in-an-array",
        "solution": "# Time:  O(1)\n# Space: O(1)\n\nclass Solution(object):\n    def xorOperation(self, n, start):\n        \"\"\"\n        :type n: int\n        :type start: int\n        :rtype: int\n        \"\"\"\n        def xorNums(n, start):\n            def xorNumsBeginEven(n, start):\n                assert(start%2 == 0)\n                # 2*i ^ (2*i+1) = 1\n                return ((n//2)%2)^((start+n-1) if n%2 else 0)\n\n            return start^xorNumsBeginEven(n-1, start+1) if start%2 else xorNumsBeginEven(n, start)\n        \n        return int(n%2 and start%2) + 2*xorNums(n, start//2)\n\n\n# Time:  O(n)\n# Space: O(1)\nimport operator\n\n\nclass Solution2(object):\n    def xorOperation(self, n, start):\n        \"\"\"\n        :type n: int\n        :type start: int\n        :rtype: int\n        \"\"\"\n        return reduce(operator.xor, (i for i in xrange(start, start+2*n, 2)))\n"
    },
    {
        "problem_name": "xor-queries-of-a-subarray",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def xorQueries(self, arr, queries):\n        \"\"\"\n        :type arr: List[int]\n        :type queries: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        for i in xrange(1, len(arr)):\n            arr[i] ^= arr[i-1]\n        return [arr[right] ^ arr[left-1] if left else arr[right] for left, right in queries]\n"
    },
    {
        "problem_name": "zigzag-conversion",
        "solution": "# Time:  O(n)\n# Space: O(1)\n\nclass Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        if numRows == 1:\n            return s\n        step, zigzag = 2 * numRows - 2, \"\"\n        for i in xrange(numRows):\n            for j in xrange(i, len(s), step):\n                zigzag += s[j]\n                if 0 < i < numRows - 1 and j + step - 2 * i < len(s):\n                    zigzag += s[j + step - 2 * i]\n        return zigzag\n\n"
    },
    {
        "problem_name": "zigzag-iterator",
        "solution": "# Time:  O(n)\n# Space: O(k)\n\nimport collections\n\n\nclass ZigzagIterator(object):\n\n    def __init__(self, v1, v2):\n        \"\"\"\n        Initialize your q structure here.\n        :type v1: List[int]\n        :type v2: List[int]\n        \"\"\"\n        self.q = collections.deque([(len(v), iter(v)) for v in (v1, v2) if v])\n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        len, iter = self.q.popleft()\n        if len > 1:\n            self.q.append((len-1, iter))\n        return next(iter)\n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return bool(self.q)\n\n\n"
    },
    {
        "problem_name": "zuma-game",
        "solution": "# Time:  O((b+h)^2 * h!*(b+h-1)!/(b-1)!)\n# Space: O((b+h) * h!*(b+h-1)!/(b-1)!)\n\nimport collections\n\n\n# brute force solution with worse complexity but pass\nclass Solution(object):\n    def findMinStep(self, board, hand):\n        \"\"\"\n        :type board: str\n        :type hand: str\n        :rtype: int\n        \"\"\"\n        def shrink(s):  # Time: O(n^2), Space: O(1)\n            while True:\n                i = 0\n                for start in xrange(len(s)):\n                    while i < len(s) and s[start] == s[i]:\n                        i += 1\n                    if i-start >= 3:\n                        s = s[0:start]+s[i:]\n                        break\n                else:\n                    break\n            return s\n\n        def findMinStepHelper(board, hand, lookup):\n            if not board: return 0\n            if not hand: return float(\"inf\")\n            if tuple(hand) in lookup[tuple(board)]: return lookup[tuple(board)][tuple(hand)]\n\n            result = float(\"inf\")\n            for i in xrange(len(hand)):\n                for j in xrange(len(board)+1):\n                    next_board = shrink(board[0:j] + hand[i:i+1] + board[j:])\n                    next_hand = hand[0:i] + hand[i+1:]\n                    result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1)\n            lookup[tuple(board)][tuple(hand)] = result\n            return result\n\n        lookup = collections.defaultdict(dict)\n        board, hand = list(board), list(hand)\n        result = findMinStepHelper(board, hand, lookup)\n        return -1 if result == float(\"inf\") else result\n\n\n# Time:  O((b+h) * h!*(b+h-1)!/(b-1)!)\n# Space: O((b+h) * h!*(b+h-1)!/(b-1)!)\nimport collections\n\n\n# brute force solution\nclass Solution_TLE(object):\n    def findMinStep(self, board, hand):\n        \"\"\"\n        :type board: str\n        :type hand: str\n        :rtype: int\n        \"\"\"\n        def shrink(s):  # Time: O(n), Space: O(n)\n            stack = []\n            start = 0\n            for i in xrange(len(s)+1):\n                if i == len(s) or s[i] != s[start]:\n                    if stack and stack[-1][0] == s[start]:\n                        stack[-1][1] += i - start\n                        if stack[-1][1] >= 3:\n                            stack.pop()\n                    elif s and i - start < 3:\n                        stack += [s[start], i - start],\n                    start = i\n            result = []\n            for p in stack:\n                result += [p[0]] * p[1]\n            return result\n\n        def findMinStepHelper(board, hand, lookup):\n            if not board: return 0\n            if not hand: return float(\"inf\")\n            if tuple(hand) in lookup[tuple(board)]: return lookup[tuple(board)][tuple(hand)]\n\n            result = float(\"inf\")\n            for i in xrange(len(hand)):\n                for j in xrange(len(board)+1):\n                    next_board = shrink(board[0:j] + hand[i:i+1] + board[j:])\n                    next_hand = hand[0:i] + hand[i+1:]\n                    result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1)\n            lookup[tuple(board)][tuple(hand)] = result\n            return result\n\n        lookup = collections.defaultdict(dict)\n        board, hand = list(board), list(hand)\n        result = findMinStepHelper(board, hand, lookup)\n        return -1 if result == float(\"inf\") else result\n\n\n# Time:  O((b * h) * b * b! * h!)\n# Space: O(b * b! * h!)\nimport collections\n\n\n# greedy solution without proof (possibly incorrect)\nclass Solution_GREEDY_ACCEPT_BUT_NOT_PROVED(object):\n    def findMinStep(self, board, hand):\n        \"\"\"\n        :type board: str\n        :type hand: str\n        :rtype: int\n        \"\"\"\n        def shrink(s):  # Time: O(n), Space: O(n)\n            stack = []\n            start = 0\n            for i in xrange(len(s)+1):\n                if i == len(s) or s[i] != s[start]:\n                    if stack and stack[-1][0] == s[start]:\n                        stack[-1][1] += i - start\n                        if stack[-1][1] >= 3:\n                            stack.pop()\n                    elif s and i - start < 3:\n                        stack += [s[start], i - start],\n                    start = i\n            result = []\n            for p in stack:\n                result += [p[0]] * p[1]\n            return result\n\n        def findMinStepHelper2(board, hand, lookup):\n            result = float(\"inf\")\n            for i in xrange(len(hand)):\n                for j in xrange(len(board)+1):\n                    next_board = shrink(board[0:j] + hand[i:i+1] + board[j:])\n                    next_hand = hand[0:i] + hand[i+1:]\n                    result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1)\n            return result\n\n        def find(board, c, j):\n            for i in xrange(j, len(board)):\n                if board[i] == c:\n                    return i\n            return -1\n\n        def findMinStepHelper(board, hand, lookup):\n            if not board: return 0\n            if not hand: return float(\"inf\")\n            if tuple(hand) in lookup[tuple(board)]: return lookup[tuple(board)][tuple(hand)]\n\n            result = float(\"inf\")\n            for i in xrange(len(hand)):\n                j = 0\n                while j < len(board):\n                    k = find(board, hand[i], j)\n                    if k == -1:\n                        break\n\n                    if k < len(board) - 1 and board[k] == board[k+1]:\n                        next_board = shrink(board[0:k] + board[k+2:])\n                        next_hand = hand[0:i] + hand[i+1:]\n                        result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1)\n                        k += 1\n                    elif i > 0 and hand[i] == hand[i-1]:\n                        next_board = shrink(board[0:k] + board[k+1:])\n                        next_hand = hand[0:i-1] + hand[i+1:]\n                        result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 2)\n                    j = k+1\n\n            lookup[tuple(board)][tuple(hand)] = result\n            return result\n        \n        board, hand = list(board), list(hand)\n        hand.sort()\n        result = findMinStepHelper(board, hand, collections.defaultdict(dict))\n        if result == float(\"inf\"):\n            result = findMinStepHelper2(board, hand, collections.defaultdict(dict))\n        return -1 if result == float(\"inf\") else result\n\n\n# Time:  O(b * b! * h!)\n# Space: O(b * b! * h!)\n# if a ball can be only inserted beside a ball with same color,\n# we can do by this solution\nclass Solution_WRONG_GREEDY_AND_NOT_ACCEPT_NOW(object):\n    def findMinStep(self, board, hand):\n        \"\"\"\n        :type board: str\n        :type hand: str\n        :rtype: int\n        \"\"\"\n        def shrink(s):  # Time: O(n), Space: O(n)\n            stack = []\n            start = 0\n            for i in xrange(len(s)+1):\n                if i == len(s) or s[i] != s[start]:\n                    if stack and stack[-1][0] == s[start]:\n                        stack[-1][1] += i - start\n                        if stack[-1][1] >= 3:\n                            stack.pop()\n                    elif s and i - start < 3:\n                        stack += [s[start], i - start],\n                    start = i\n            result = []\n            for p in stack:\n                result += [p[0]] * p[1]\n            return result\n\n        def find(board, c, j):\n            for i in xrange(j, len(board)):\n                if board[i] == c:\n                    return i\n            return -1\n\n        def findMinStepHelper(board, hand, lookup):\n            if not board: return 0\n            if not hand: return float(\"inf\")\n            if tuple(hand) in lookup[tuple(board)]: return lookup[tuple(board)][tuple(hand)]\n\n            result = float(\"inf\")\n            for i in xrange(len(hand)):\n                j = 0\n                while j < len(board):\n                    k = find(board, hand[i], j)\n                    if k == -1:\n                        break\n\n                    if k < len(board) - 1 and board[k] == board[k+1]:\n                        next_board = shrink(board[0:k] + board[k+2:])\n                        next_hand = hand[0:i] + hand[i+1:]\n                        result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1)\n                        k += 1\n                    elif i > 0 and hand[i] == hand[i-1]:\n                        next_board = shrink(board[0:k] + board[k+1:])\n                        next_hand = hand[0:i-1] + hand[i+1:]\n                        result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 2)\n                    j = k+1\n\n            lookup[tuple(board)][tuple(hand)] = result\n            return result\n\n        lookup = collections.defaultdict(dict)\n        board, hand = list(board), list(hand)\n        hand.sort()\n        result = findMinStepHelper(board, hand, lookup)\n        return -1 if result == float(\"inf\") else result\n"
    }
]